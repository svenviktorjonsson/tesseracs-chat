=== Project Directory Structure ===
Root: C:\Users\viktor.jonsson\OneDrive - CellMax Technologies AB\Documents\Repositories\svenviktorjonsson\tesseracs-chat
Relevant files and folders (excluding specified patterns):

.
├── Readme.md
├── build.js
├── fetch_assets.py
├── package-lock.json
├── package.json
├── postcss.config.js
├── project_content.txt
├── pyproject.toml
├── tailwind.config.js
├── temp.js
├── temp.py
├── write_project_content_to_file.py
app/
├── __init__.py
├── auth.py
├── config.py
├── database.py
├── docker_utils.py
├── email_utils.py
├── llm.py
├── main.py
├── state.py
├── utils.py
├── static/
│   ├── _sidebar.html
│   ├── chat-session.html
│   ├── input.css
│   ├── login.html
│   ├── script.js
│   ├── session-choice.html
│   ├── js/
│   │   ├── app-ui.js


=== File Contents ===

=== Readme.md ===
Readme


=== build.js ===
--- CONTENT EXCLUDED (listed in exclude_files) ---


=== fetch_assets.py ===
import os
import requests
import sys

# --- Configuration ---
# Get the directory where the script is located
script_dir = os.path.dirname(os.path.abspath(__file__))
print(f"DEBUG: Script is running from directory: {script_dir}") # <-- Added Debug Print

# Define paths relative to the script's location
static_dir = os.path.join(script_dir, 'app', 'static')
assets_dir = os.path.join(static_dir, 'assets')
css_dir = os.path.join(assets_dir, 'css')
fonts_dir = os.path.join(assets_dir, 'fonts') # Define fonts dir for creation

# Print the calculated target directories for verification
print(f"DEBUG: Target static directory: {static_dir}")
print(f"DEBUG: Target assets directory: {assets_dir}")
print(f"DEBUG: Target CSS directory: {css_dir}")
print(f"DEBUG: Target fonts directory: {fonts_dir}") # <-- Added Debug Print

# List of CSS files to download
css_files_to_download = [
    {
        'name': 'katex.min.css',
        'url': 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css',
        'dest': os.path.join(css_dir, 'katex.min.css')
    },
    {
        'name': 'prism-tomorrow.min.css',
        'url': 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css',
        'dest': os.path.join(css_dir, 'prism-tomorrow.min.css')
    }
]

# --- Helper Functions ---
def ensure_dir_exists(dir_path):
    """Creates a directory if it doesn't exist."""
    if not os.path.exists(dir_path):
        print(f"Creating directory: {dir_path}")
        try:
            os.makedirs(dir_path, exist_ok=True)
        except OSError as e:
            print(f"Error creating directory {dir_path}: {e}", file=sys.stderr)
            sys.exit(1) # Exit if directory creation fails

def download_file(url, destination_path):
    """Downloads a file from a URL to a destination path."""
    print(f"Attempting to download {os.path.basename(destination_path)} to {destination_path} from {url}...") # <-- Added Debug Print
    try:
        response = requests.get(url, stream=True, timeout=30) # Added timeout
        response.raise_for_status() # Raise an exception for bad status codes (4xx or 5xx)

        with open(destination_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
        print(f"Successfully downloaded: {os.path.basename(destination_path)}")
        return True
    except requests.exceptions.RequestException as e:
        print(f"Error downloading {url}: {e}", file=sys.stderr)
        # Clean up partially downloaded file if it exists
        if os.path.exists(destination_path):
            try:
                os.remove(destination_path)
                print(f"Removed partially downloaded file: {os.path.basename(destination_path)}")
            except OSError as remove_error:
                print(f"Error removing partial file {destination_path}: {remove_error}", file=sys.stderr)
        return False
    except Exception as e:
        print(f"An unexpected error occurred during download of {url}: {e}", file=sys.stderr)
        return False


# --- Main Execution ---
def main():
    print("Starting Python asset fetching process...")

    # 1. Ensure directories exist
    print("Ensuring necessary directories exist...")
    ensure_dir_exists(static_dir)
    ensure_dir_exists(assets_dir)
    ensure_dir_exists(css_dir)
    ensure_dir_exists(fonts_dir) # Also create fonts dir
    print("Directory check complete.")

    # 2. Download CSS files
    print("\nDownloading CSS files...")
    success_count = 0
    failure_count = 0
    for file_info in css_files_to_download:
        # Print the destination path before downloading
        print(f"DEBUG: Calculated destination for {file_info['name']}: {file_info['dest']}") # <-- Added Debug Print
        if download_file(file_info['url'], file_info['dest']):
            success_count += 1
        else:
            failure_count += 1

    print(f"\nDownload summary: {success_count} succeeded, {failure_count} failed.")

    if failure_count > 0:
        print("\nOne or more downloads failed. Please check the errors above.", file=sys.stderr)
        sys.exit(1) # Exit with error code if any download failed
    else:
        print("\nPython asset fetching process completed successfully.")
        print("CSS files downloaded to:", css_dir)
        print("Ensure font files are placed in:", fonts_dir)

if __name__ == "__main__":
    main()


=== package-lock.json ===
--- CONTENT EXCLUDED (listed in exclude_files) ---


=== package.json ===
{
  "name": "tesseracs-chat",
  "version": "1.0.0",
  "description": "Readme",
  "main": "temp.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "node build.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/svenviktorjonsson/tesseracs-chat.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/svenviktorjonsson/tesseracs-chat/issues"
  },
  "homepage": "https://github.com/svenviktorjonsson/tesseracs-chat#readme",
  "devDependencies": {
    "autoprefixer": "^10.4.21",
    "esbuild": "^0.25.4",
    "esbuild-style-plugin": "^1.6.3",
    "postcss": "^8.5.3",
    "tailwindcss": "^3.4.17"
  },
  "dependencies": {
    "katex": "^0.16.22",
    "marked": "^15.0.11",
    "prismjs": "^1.29.0"
  }
}


=== postcss.config.js ===
// postcss.config.js
module.exports = {
  plugins: {
    'tailwindcss': {}, // Use 'tailwindcss' for v3
    'autoprefixer': {},
  },
}

=== project_content.txt ===


=== pyproject.toml ===
[tool.poetry]
name = "tesseracs-chat"
version = "1.0.0"
description = "Web chat interface for Ollama using FastAPI and LangChain"
authors = ["Viktor Jonsson <viktor.jonsson@tesseracs.com>"]
readme = "README.md" # Optional README
packages = [
    { include = "app" },
]

[tool.poetry.dependencies]
python = "^3.9" # Adjust Python version if needed
fastapi = "^0.110.0"
uvicorn = {extras = ["standard"], version = "^0.29.0"}

# Let Poetry resolve the latest compatible LangChain versions
# Using "*" allows any version, but be aware this might pull in breaking changes in the future.
langchain = "*"
langchain-ollama = "*"
langchain-core = "*"
langchain-community = "*"
langchain-text-splitters = "*"

# Other dependencies
websockets = "^12.0" # Required by FastAPI for WebSockets
python-dotenv = "^1.0.1" # For optional .env file
aiofiles = "^23.2.1" # For serving static files asynchronously
docker = "^7.1.0"
requests = "^2.32.3"
python-multipart = "^0.0.20"
fastapi-mail = "^1.4.2"
certifi = "^2025.4.26"
pydantic = "^2.11.4"
passlib = {extras = ["bcrypt"], version = "^1.7.4"}

[tool.poetry.scripts]
app = "app.main:start_server" # Command to run the app

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"



=== tailwind.config.js ===
/** @type {import('tailwindcss').Config} */
module.exports = {
    content: [
      "./app/static/**/*.html", // Scan HTML files in static
      "./app/static/**/*.js",   // Scan JS files in static
    ],
    theme: {
      extend: {},
    },
    plugins: [],
  }

=== temp.js ===
// --- DOM Elements ---
const chatHistory = document.getElementById('chat-history');
const chatForm = document.getElementById('chat-form');
const messageInput = document.getElementById('message-input');
const sendButton = document.getElementById('send-button');
const thinkCheckbox = document.getElementById('think-checkbox'); // Restored

// --- WebSocket & Client ID ---
let websocket;
const clientId = `web-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
let currentTurnId = 0; // Simple counter for unique IDs per turn

// --- State Machine Modes ---
const MODE_ANSWER = 'MODE_ANSWER';
const MODE_SEEKING_CODE_START_FENCE = 'MODE_SEEKING_CODE_START_FENCE'; // Looking for ```
const MODE_SEEKING_CODE_LANGUAGE = 'MODE_SEEKING_CODE_LANGUAGE';     // Reading language after ```
const MODE_INSIDE_CODE_BLOCK = 'MODE_INSIDE_CODE_BLOCK';        // Inside the code block
const MODE_SEEKING_CODE_END_FENCE = 'MODE_SEEKING_CODE_END_FENCE';   // Found potential closing ```

// --- State Variables ---
let currentProcessingMode = MODE_ANSWER;
let fenceBuffer = '';             // Buffer for detecting ``` fences
let langBuffer = '';              // Buffer for language string
let codeBuffer = '';              // Buffer for code content within a block
let currentCodeBlockLang = '';    // Detected language for the current block
let currentCodeBlockElement = null; // The <code> element being filled
let currentCodeBlockPreElement = null; // The <pre> element wrapping the code
let currentAiTurnContainer = null;  // The main container for the AI bubble + its code blocks
let currentAnswerElement = null;    // The div.ai-message bubble
let currentCodeBlocksArea = null; // The div below bubble holding code blocks
let codeBlockCounterThisTurn = 0; // Counter for code blocks within the *current* AI turn
let thinkingRequestedForCurrentTurn = false; // Restored
let isFirstContentChunkForTurn = true;

// --- Constants ---
const FENCE = '```';

// --- Helper Functions ---

function scrollToBottom() {
    // Adding a small delay can sometimes help ensure scrolling happens after render
    setTimeout(() => {
        chatHistory.scrollTo({ top: chatHistory.scrollHeight, behavior: 'smooth' });
    }, 50);
}

function addUserMessage(text) {
    const messageElement = document.createElement('div');
    messageElement.classList.add('message', 'user-message');
    messageElement.textContent = text;
    chatHistory.appendChild(messageElement);
    scrollToBottom();
}

function addSystemMessage(text) {
     const messageElement = document.createElement('div');
     messageElement.classList.add('system-message');
     messageElement.textContent = text;
     chatHistory.appendChild(messageElement);
     scrollToBottom();
}

function addErrorMessage(text) {
     console.error("[UI ERROR] ", text);
     const messageElement = document.createElement('div');
     messageElement.classList.add('error-message'); // Use error styling
     messageElement.textContent = `Error: ${text}`;
     if(currentAiTurnContainer) {
         currentAiTurnContainer.appendChild(messageElement); // Append error within the turn container
     } else {
         chatHistory.appendChild(messageElement); // Fallback if no turn container exists
     }
     scrollToBottom();
}

function setInputDisabledState(disabled) {
    messageInput.disabled = disabled;
    sendButton.disabled = disabled;
    if (thinkCheckbox) {
        thinkCheckbox.disabled = disabled;
    }
}

function finalizeTurnOnErrorOrClose() {
    console.log("[DEBUG] finalizeTurnOnErrorOrClose called.");
    if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK && currentCodeBlockElement) {
        console.warn("Stream ended unexpectedly inside a code block.");
        try {
            Prism.highlightElement(currentCodeBlockElement);
        } catch (e) { console.error("Prism highlighting error on incomplete block:", e); }
    }
    resetStreamingState();
    setInputDisabledState(true); // Disable input on error/close
}

function resetStreamingState() {
    console.log("[DEBUG] Resetting streaming state.");
    currentProcessingMode = MODE_ANSWER;
    fenceBuffer = '';
    langBuffer = '';
    codeBuffer = '';
    currentCodeBlockLang = '';
    currentCodeBlockElement = null;
    currentCodeBlockPreElement = null;
    // Note: Turn-specific elements (currentAiTurnContainer, etc.) are managed by setupNewAiTurn
}

function setupNewAiTurn() {
    currentTurnId++;
    codeBlockCounterThisTurn = 0; // Reset code block counter
    isFirstContentChunkForTurn = true; // <<< Reset the flag for the new turn

    currentAiTurnContainer = document.createElement('div');
    currentAiTurnContainer.classList.add('ai-turn-container');
    currentAiTurnContainer.dataset.turnId = currentTurnId;

    currentAnswerElement = document.createElement('div');
    currentAnswerElement.classList.add('message', 'ai-message');
    currentAiTurnContainer.appendChild(currentAnswerElement);

    currentCodeBlocksArea = document.createElement('div');
    currentCodeBlocksArea.classList.add('code-blocks-area');
    currentAiTurnContainer.appendChild(currentCodeBlocksArea);

    chatHistory.appendChild(currentAiTurnContainer);
}

function appendToAnswerBubble(text) {
    if (!currentAnswerElement) {
        console.error("Attempted to append to null answer bubble!");
        // Attempt recovery only if there's actual text content
        if (text.trim().length === 0) return; // Don't try to recover for whitespace only

        if (currentAiTurnContainer && !currentAiTurnContainer.querySelector('.ai-message')) {
             currentAnswerElement = document.createElement('div');
             currentAnswerElement.classList.add('message', 'ai-message');
             currentAiTurnContainer.insertBefore(currentAnswerElement, currentCodeBlocksArea);
        } else if (currentAiTurnContainer) {
             currentAnswerElement = currentAiTurnContainer.querySelector('.ai-message');
             if(!currentAnswerElement) {
                console.error("CRITICAL: Cannot find or create answer bubble in turn container.");
                return;
             }
        } else {
            console.error("CRITICAL: No turn container to recover answer bubble.");
            return;
        }
    }

    // <<< START: Added Leading Whitespace Trim Logic >>>
    let processedText = text;
    if (isFirstContentChunkForTurn) {
        processedText = text.trimStart(); // Remove leading whitespace ONLY for the first chunk
        // Only set flag to false if we actually processed non-empty text after trimming
        if (processedText.length > 0) {
             isFirstContentChunkForTurn = false;
        }
    }
    // <<< END: Added Leading Whitespace Trim Logic >>>

    // Append text content only if there is something left after trimming
    if (processedText.length > 0) {
        currentAnswerElement.appendChild(document.createTextNode(processedText));
    }
}


function appendCodeReference() {
    if (!currentAnswerElement) {
        console.error("Attempted to append code reference to null answer bubble!");
        return;
    }
    codeBlockCounterThisTurn++;
    const refSpan = document.createElement('span');
    refSpan.classList.add('code-reference');
    refSpan.textContent = `[Code ${codeBlockCounterThisTurn}]`;
    currentAnswerElement.appendChild(refSpan); // Append the span node
}

function createCodeBlockStructure(language) {
    if (!currentCodeBlocksArea) {
        console.error("Attempted to create code block in null area!");
        return;
    }

    const blockId = `code-block-turn${currentTurnId}-${codeBlockCounterThisTurn}`;
    // Normalize language: lowercase, trim, default 'plain', handle potential null/undefined
    const safeLanguage = (language || '').trim().toLowerCase() || 'plain';
    // Alias common variations
    const langAlias = {
        'python': 'python', 'py': 'python',
        'javascript': 'javascript', 'js': 'javascript',
        'html': 'markup', 'xml': 'markup', 'svg': 'markup', // Prism uses 'markup' for HTML/XML
        'css': 'css',
        'bash': 'bash', 'shell': 'bash',
        'java': 'java',
        'csharp': 'csharp', 'cs': 'csharp',
        'cpp': 'cpp', 'c++': 'cpp',
        'ruby': 'ruby', 'rb': 'ruby',
        'go': 'go',
        'php': 'php',
        'json': 'json',
        'yaml': 'yaml', 'yml': 'yaml',
        'sql': 'sql',
        'markdown': 'markdown', 'md': 'markdown'
    };
    const prismLang = langAlias[safeLanguage] || safeLanguage; // Use alias or original safe name
    const displayLang = safeLanguage; // Show the user what they typed (or 'plain')


    const container = document.createElement('div');
    container.classList.add('code-block-container');
    container.id = blockId;

    const header = document.createElement('div');
    header.classList.add('code-block-header');

    const title = document.createElement('span');
    title.textContent = `Code ${codeBlockCounterThisTurn} (${displayLang})`;

    const buttonsDiv = document.createElement('div');
    const toggleBtn = document.createElement('button');
    toggleBtn.classList.add('toggle-code-btn');
    toggleBtn.textContent = 'Show'; // Default text
    const copyBtn = document.createElement('button');
    copyBtn.classList.add('copy-code-btn');
    copyBtn.textContent = 'Copy';

    buttonsDiv.appendChild(toggleBtn);
    buttonsDiv.appendChild(copyBtn);

    // Append buttons first, then title
    header.appendChild(buttonsDiv);
    header.appendChild(title);

    // Create pre/code elements but store references locally for listeners
    const preElement = document.createElement('pre');
    const codeElement = document.createElement('code');
    codeElement.classList.add(`language-${prismLang}`);
    preElement.classList.add('hidden'); // Add hidden class by default

    // Assign references for streaming
    currentCodeBlockPreElement = preElement;
    currentCodeBlockElement = codeElement; // This global ref is used *during* streaming

    preElement.appendChild(codeElement);
    container.appendChild(header);
    container.appendChild(preElement);

    // --- Event Listeners ---

    toggleBtn.addEventListener('click', () => {
        // Find the pre element relative to the button clicked
        const containerDiv = toggleBtn.closest('.code-block-container');
        const preToToggle = containerDiv?.querySelector('pre');
        if (preToToggle) {
            const isHidden = preToToggle.classList.toggle('hidden');
            toggleBtn.textContent = isHidden ? 'Show' : 'Hide'; // Toggle text
        }
    });

    copyBtn.addEventListener('click', () => {
        // <<< START: Updated Copy Logic >>>
        // Find the specific container and code element relative to *this* button
        const containerDiv = copyBtn.closest('.code-block-container');
        const codeElementToCopy = containerDiv?.querySelector('pre > code');

        if (!codeElementToCopy) {
            console.error('Could not find code element to copy for button:', copyBtn);
            copyBtn.textContent = 'Error!';
             setTimeout(() => { copyBtn.textContent = 'Copy'; }, 1500);
            return; // Exit if element not found
        }

        const codeContent = codeElementToCopy.textContent;
        navigator.clipboard.writeText(codeContent).then(() => {
            copyBtn.textContent = 'Copied!';
            copyBtn.classList.add('copied'); // Add class for potential styling feedback
            setTimeout(() => {
                // Check if the text is still 'Copied!' before resetting
                // (prevents flicker if user clicks multiple times quickly)
                if (copyBtn.textContent === 'Copied!') {
                    copyBtn.textContent = 'Copy';
                    copyBtn.classList.remove('copied');
                }
            }, 1500); // Reset after 1.5 seconds
        }).catch(err => {
            console.error('Failed to copy code: ', err);
            copyBtn.textContent = 'Error!';
             // Remove copied class if it was somehow added
            copyBtn.classList.remove('copied');
            setTimeout(() => {
                 if (copyBtn.textContent === 'Error!') {
                    copyBtn.textContent = 'Copy';
                 }
            }, 1500); // Reset after 1.5 seconds
        });
        // <<< END: Updated Copy Logic >>>
    });

    currentCodeBlocksArea.appendChild(container);
}

function appendToCodeBlock(text) {
    if (currentCodeBlockElement) {
        // Append text content to the <code> element
         currentCodeBlockElement.appendChild(document.createTextNode(text));
    } else {
        console.error("Attempted to append to null code block element!");
    }
}

function finalizeCodeBlock() {
    if (currentCodeBlockElement) {
        try {
            // Highlight the completed block using Prism
            Prism.highlightElement(currentCodeBlockElement);
            console.log(`[DEBUG] Highlighted code block ${codeBlockCounterThisTurn} (lang: ${currentCodeBlockLang})`);
            // Optional: Add line numbers if plugin is active
            // if (currentCodeBlockPreElement.classList.contains('line-numbers')) {
            //     Prism.plugins.lineNumbers.resize(currentCodeBlockPreElement);
            // }
        } catch (e) {
            console.error(`Prism highlighting error for lang '${currentCodeBlockLang}':`, e);
            // Add a class indicating error?
             currentCodeBlockElement.classList.add('prism-highlight-error');
        }
    }
    // Reset code block specific state
    currentCodeBlockElement = null;
    currentCodeBlockPreElement = null;
    currentCodeBlockLang = '';
    codeBuffer = ''; // Clear code buffer
}

// --- WebSocket Connection ---
function connectWebSocket() {
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${window.location.host}/ws/${clientId}`;
    console.log(`[DEBUG] Attempting to connect to WebSocket: ${wsUrl}`);

    try {
        const ws = new WebSocket(wsUrl);

        ws.onopen = (event) => {
            console.log("[DEBUG] WebSocket connection opened");
            websocket = ws;
            setInputDisabledState(false); // Enable inputs
            addSystemMessage("Connected to the chat server.");
            // Add initial AI message
            setupNewAiTurn();
            appendToAnswerBubble("AI: Hello! How can I help you today?");
            resetStreamingState(); // Reset state machine after initial message

            if(messageInput.offsetParent !== null) messageInput.focus();
        };

        ws.onmessage = (event) => {
            let chunk = event.data;

            // --- Handle Control Messages First ---
            if (chunk === "<EOS>") {
                console.log("[DEBUG] Received <EOS>. Finalizing turn.");
                 // If ended inside a code block, finalize it
                 if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK) {
                    finalizeCodeBlock();
                } else if (currentProcessingMode === MODE_SEEKING_CODE_END_FENCE && fenceBuffer.length > 0) {
                    // Ended while seeking end fence, treat buffer as regular text
                    appendToAnswerBubble(fenceBuffer);
                 } else if (currentProcessingMode === MODE_SEEKING_CODE_LANGUAGE && langBuffer.length > 0) {
                     // Ended while seeking language, treat as regular text
                    appendToAnswerBubble(FENCE + langBuffer);
                 } else if (currentProcessingMode === MODE_SEEKING_CODE_START_FENCE && fenceBuffer.length > 0) {
                     // Ended while seeking start fence, treat as regular text
                    appendToAnswerBubble(fenceBuffer);
                 }

                resetStreamingState();
                setInputDisabledState(false); // Re-enable inputs
                if(messageInput.offsetParent !== null) messageInput.focus();
                scrollToBottom();
                return; // End processing for this message
            }
            if (chunk.startsWith("<ERROR>")) {
                const errorMessage = chunk.substring(7);
                console.error("[DEBUG] Received <ERROR>:", errorMessage);
                addErrorMessage(errorMessage);
                finalizeTurnOnErrorOrClose(); // Disables input
                scrollToBottom();
                return; // End processing for this message
            }

            // <<< --- START: Tag Filtering --- >>>
            // Remove <think> and </think> tags and any surrounding whitespace globally
            chunk = chunk.replace(/\s*<think>\s*/g, '').replace(/\s*<\/think>\s*/g, '');
            // If the chunk becomes empty after filtering, skip further processing for this chunk
            if (chunk.length === 0) {
                return;
            }
            // <<< --- END: Tag Filtering --- >>>


            // Ensure AI turn container exists (should be set up by setupNewAiTurn)
             if (!currentAiTurnContainer) {
                 console.error("CRITICAL: No AI turn container set up before message chunk received!");
                 // Attempt recovery only if chunk contains non-whitespace content after filtering
                 if (chunk.trim().length > 0) {
                    setupNewAiTurn();
                 } else {
                    return; // Don't set up turn for empty/whitespace-only chunks
                 }
            }

            // --- State Machine Processing ---
            let currentPos = 0;
            while (currentPos < chunk.length) {
                const char = chunk[currentPos];
                let incrementPos = true;

                switch (currentProcessingMode) {
                    case MODE_ANSWER:
                        if (char === FENCE[0]) {
                            fenceBuffer = char;
                            currentProcessingMode = MODE_SEEKING_CODE_START_FENCE;
                        } else {
                            appendToAnswerBubble(char);
                        }
                        break;

                    case MODE_SEEKING_CODE_START_FENCE:
                        if (char === FENCE[fenceBuffer.length]) {
                            fenceBuffer += char;
                            if (fenceBuffer === FENCE) {
                                console.log("[DEBUG] Found ``` start fence.");
                                fenceBuffer = '';
                                langBuffer = '';
                                currentProcessingMode = MODE_SEEKING_CODE_LANGUAGE;
                            }
                        } else {
                            appendToAnswerBubble(fenceBuffer + char);
                            fenceBuffer = '';
                            currentProcessingMode = MODE_ANSWER;
                        }
                        break;

                    case MODE_SEEKING_CODE_LANGUAGE:
                        if (char === '\n') {
                            console.log(`[DEBUG] Found language line: '${langBuffer}'`);
                            currentCodeBlockLang = langBuffer; // Keep raw lang buffer for createCodeBlockStructure
                            appendCodeReference();
                            createCodeBlockStructure(currentCodeBlockLang); // Handles normalization/aliasing
                            langBuffer = '';
                            codeBuffer = '';
                            currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                        } else if (langBuffer.length > 50) { // Prevent runaway language buffer
                             console.warn("Language line too long, assuming no language.");
                             appendToAnswerBubble(FENCE + langBuffer + char); // Treat as text
                             langBuffer = '';
                             fenceBuffer = '';
                             currentProcessingMode = MODE_ANSWER;
                        } else {
                            langBuffer += char;
                        }
                        break;

                    case MODE_INSIDE_CODE_BLOCK:
                        if (char === FENCE[0]) {
                            fenceBuffer = char;
                            currentProcessingMode = MODE_SEEKING_CODE_END_FENCE;
                        } else {
                            appendToCodeBlock(char);
                        }
                        break;

                    case MODE_SEEKING_CODE_END_FENCE:
                        if (char === FENCE[fenceBuffer.length]) {
                            fenceBuffer += char;
                            if (fenceBuffer === FENCE) {
                                console.log("[DEBUG] Found ``` end fence.");
                                // Check for immediate newline after fence, common pattern
                                if (currentPos + 1 < chunk.length && chunk[currentPos + 1] === '\n') {
                                     currentPos++; // Consume the newline
                                } else {
                                     // If next char is not newline, maybe check later chunks?
                                     // For simplicity, we'll just finalize here.
                                }
                                finalizeCodeBlock();
                                fenceBuffer = '';
                                currentProcessingMode = MODE_ANSWER;
                            }
                        } else {
                            appendToCodeBlock(fenceBuffer + char);
                            fenceBuffer = '';
                            currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                        }
                        break;

                    default:
                        console.error("Unknown processing mode:", currentProcessingMode);
                        currentProcessingMode = MODE_ANSWER;
                        incrementPos = false;
                }

                if (incrementPos) {
                    currentPos++;
                }
            } // end while loop over chunk

            scrollToBottom();
        }; // end onmessage

        ws.onerror = (event) => {
             console.error("WebSocket error:", event);
             addErrorMessage("WebSocket connection error. Please try refreshing the page.");
             finalizeTurnOnErrorOrClose();
        };

        ws.onclose = (event) => {
             console.log(`[DEBUG] WebSocket connection closed: Code=${event.code}, Reason='${event.reason}', WasClean=${event.wasClean}`);
             addSystemMessage(`Connection closed. ${event.reason ? event.reason : ''} (Code: ${event.code}). Attempting to reconnect...`);
             finalizeTurnOnErrorOrClose();
             websocket = undefined;
             const reconnectDelay = Math.min(1000 * (2 ** Math.min(8, event.code === 1000 ? 0 : 1)), 30000);
             console.log(`[DEBUG] Attempting reconnect in ${reconnectDelay}ms`);
             setTimeout(connectWebSocket, reconnectDelay);
        };

        console.log("[DEBUG] WebSocket object created and handlers assigned.");

    } catch (error) {
        console.error("[DEBUG] Error creating WebSocket:", error);
        addErrorMessage(`Failed to initialize WebSocket connection: ${error.message}. Check browser console.`);
        finalizeTurnOnErrorOrClose();
    }
}

if (chatForm) {
    chatForm.addEventListener('submit', (event) => {
        event.preventDefault(); // Prevent default form submission

        const userMessage = messageInput.value.trim(); // Get user text

        if (!userMessage) {
            return; // Do nothing if message is empty
        }

        // --- Check WebSocket State BEFORE Attempting Send ---
        if (!websocket || websocket.readyState !== WebSocket.OPEN) {
            console.warn("[Submit] WebSocket not ready or not defined. State:", websocket?.readyState);
            addErrorMessage("Not connected to the server. Please wait or refresh.");
            return; // Exit if not connected
        }

        // --- If WebSocket is OPEN, proceed ---
        try {
            // --- Step 1: Display User Message ---
            addUserMessage(userMessage); // Show user's raw message immediately

            // --- Step 2: Determine Thinking State & Prepare Message for Backend ---
            thinkingRequestedForCurrentTurn = thinkCheckbox ? thinkCheckbox.checked : false;
            console.log(`[Submit] Checkbox checked: ${thinkingRequestedForCurrentTurn}.`);

            let messageToSend = userMessage; // Default to the raw user message
            // Ensure NO_THINK_PREFIX is defined globally, e.g., const NO_THINK_PREFIX = "\\no_think";
            if (!thinkingRequestedForCurrentTurn) {
                messageToSend = NO_THINK_PREFIX + userMessage;
                console.log(`[Submit] Prepended '${NO_THINK_PREFIX}'. Prepared message: "${messageToSend.substring(0, 100)}..."`);
            } else {
                console.log(`[Submit] Prepared raw message (thinking requested): "${messageToSend.substring(0, 100)}..."`);
            }

            // --- Step 3: Setup UI for AI Response ---
            setupNewAiTurn(); // Uses thinkingRequestedForCurrentTurn for initial visibility

            // --- Step 4: Attempt to Send Message to WebSocket ---
            console.log(`[Submit] >>> About to call websocket.send(). State: ${websocket?.readyState}`); // Log state right before send

            websocket.send(messageToSend); // *** THE ACTUAL SEND CALL ***

            console.log("[Submit] <<< websocket.send() call completed (no immediate error thrown)."); // Log right after send

            // --- Step 5: Clear Input & Disable ---
            messageInput.value = '';          // Clear the input field
            setInputDisabledState(true); // Disable inputs while waiting for response
            console.log("[Submit] Input cleared and disabled.");

        } catch (sendError) {
            // --- Catch Errors During Send or Subsequent Steps ---
            console.error("[Submit] !!! ERROR during send attempt or post-send steps:", sendError);
            addErrorMessage(`Failed to send message: ${sendError.message}`);
            // Optionally re-enable input if send fails? Or leave disabled?
            // setInputDisabledState(false);
        }

    }); // End of submit handler
} else {
    // Handle case where the form element itself is missing
    console.error("CRITICAL ERROR: Could not find chat form element with ID 'chat-form'. Messages cannot be sent.");
    if (typeof addErrorMessage === 'function') {
        addErrorMessage("Initialization Error: Chat input form not found.");
    } else {
        alert("Initialization Error: Chat input form not found.");
    }
}

// --- Initial Setup ---
setInputDisabledState(true); // Disable inputs until connected
connectWebSocket(); // Start connection (will add initial AI message and enable inputs onopen)

=== temp.py ===
import os
import asyncio
import sys
import uvicorn
import webbrowser
import tempfile
import shutil
import json # Added for WebSocket message parsing/sending
import traceback # For detailed error logging
from pathlib import Path
from dotenv import load_dotenv
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Request, HTTPException
from fastapi.responses import HTMLResponse # JSONResponse no longer needed for run_code
from fastapi.staticfiles import StaticFiles
from fastapi.websockets import WebSocketState # Import WebSocketState
from pydantic import BaseModel # Keep for potential future HTTP models
import docker # Docker SDK
from docker.errors import DockerException, ImageNotFound, APIError, NotFound # Docker specific errors
from docker.models.containers import Container # For type hinting
from langchain_ollama.llms import OllamaLLM
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.output_parsers import StrOutputParser
from langchain.memory import ConversationBufferMemory
from langchain_core.runnables import RunnablePassthrough # RunnableLambda no longer needed here
from langchain_core.messages import HumanMessage, AIMessage

# --- Configuration ---
load_dotenv()
MODEL_ID = os.getenv("MODEL_ID", "qwen3")
OLLAMA_BASE_URL = os.getenv("OLLAMA_BASE_URL", "http://localhost:11434")
# NO_THINK_PREFIX is handled by frontend, backend receives prefixed message
NO_THINK_PREFIX = "\\no_think"

# --- Docker Configuration ---
SUPPORTED_LANGUAGES = {
    "python": {
        "image": "python:3.11-slim",
        "filename": "script.py",
        "command": ["python", "-u", "/app/script.py"] # Added -u for unbuffered output
    },
    "javascript": {
        "image": "node:18-alpine",
        "filename": "script.js",
        "command": ["node", "/app/script.js"]
    },
    # Add more languages here if needed
}
DOCKER_TIMEOUT_SECONDS = 30 # Increased timeout for potentially longer runs
DOCKER_MEM_LIMIT = "128m"

# --- FastAPI App Initialization ---
# Ensure the app object is created correctly
app = FastAPI(title="Ollama Web Chat")

# --- Docker Client Initialization ---
docker_client = None
try:
    docker_client = docker.from_env()
    docker_client.ping()
    print("Successfully connected to Docker daemon.")
except DockerException as e:
    print(f"CRITICAL WARNING: Could not connect to Docker daemon: {e}")
    print("Code execution via Docker will be unavailable.")
    docker_client = None

# --- Static Files Setup ---
# Determine the static files directory relative to this script's location
# This assumes main.py is either in the project root or inside an 'app' directory.
script_location = Path(__file__).parent
static_dir_in_app = script_location / "static"
static_dir_at_root = script_location.parent / "static" # If main.py is in 'app' dir

if static_dir_in_app.is_dir():
    static_dir = static_dir_in_app
    print(f"Found static directory at: {static_dir}")
elif script_location.name == "app" and static_dir_at_root.is_dir():
     # If script is in 'app' and 'static' is sibling to 'app'
     static_dir = static_dir_at_root
     print(f"Found static directory at: {static_dir}")
else:
    # Fallback check if script is in root and static is in root
    if (script_location.parent / "static").is_dir():
         static_dir = script_location.parent / "static"
         print(f"Found static directory at: {static_dir}")
    else:
        print(f"CRITICAL ERROR: Static directory not found near '{script_location}'. Looked for '{static_dir_in_app}' and '{static_dir_at_root}'. Exiting.")
        sys.exit(1)

# Mount static files - THIS MUST BE CORRECT FOR CSS/JS
app.mount("/static", StaticFiles(directory=str(static_dir)), name="static")
print(f"Mounted static directory '{static_dir}' at '/static'")


# --- LangChain Setup ---
try:
    model = OllamaLLM(model=MODEL_ID, base_url=OLLAMA_BASE_URL)
    print(f"Successfully initialized OllamaLLM: {MODEL_ID} at {OLLAMA_BASE_URL}")
except Exception as e:
    print(f"CRITICAL ERROR: OllamaLLM init failed: {e}"); sys.exit(1)

# --- Global State for WebSocket Connections and Running Containers ---
client_memory = {}
# Stores info about currently running code executions
# Format: { "code_block_id": {"container": Container, "stream_task": asyncio.Task, "client_id": str, "websocket": WebSocket, "stop_event": asyncio.Event} }
running_containers = {}
running_containers_lock = asyncio.Lock() # Lock for safe concurrent access

# --- Memory Management Functions (Unchanged) ---
def get_memory_for_client(client_id: str) -> ConversationBufferMemory:
    """Retrieves or creates memory for a specific client."""
    if client_id not in client_memory:
        client_memory[client_id] = ConversationBufferMemory(return_messages=True, memory_key="history")
        print(f"Initialized new memory for client: {client_id}")
    return client_memory[client_id]

def remove_memory_for_client(client_id: str):
    """Removes memory when a client disconnects."""
    if client_id in client_memory:
        del client_memory[client_id]
        print(f"Removed memory for client: {client_id}")

# --- LangChain Prompt and Chain Setup (Unchanged) ---
prompt = ChatPromptTemplate.from_messages([
    ("system", "You are a helpful AI assistant chatting in a web interface. Answer the user's questions concisely. Always use katex for math ($...$ or $$...$$). For a literal dollar sign use \\$. When providing code, use standard markdown code blocks (e.g., ```python ... ```)."),
    MessagesPlaceholder(variable_name="history"),
    ("human", "{input}")
])
output_parser = StrOutputParser()

# --- Helper Functions for WebSocket Code Execution (Unchanged from previous version) ---

async def send_ws_message(websocket: WebSocket, message_type: str, payload: dict):
    """Safely sends a JSON message over the WebSocket."""
    # Check state before sending
    if websocket.client_state != WebSocketState.CONNECTED:
         print(f"WebSocket not connected, cannot send {message_type} for {payload.get('code_block_id', 'N/A')}")
         return
    try:
        await websocket.send_json({"type": message_type, "payload": payload})
    except WebSocketDisconnect:
        print(f"WebSocket disconnected while trying to send {message_type} for {payload.get('code_block_id', 'N/A')}")
    except Exception as e:
        # Catch other potential errors like Runtime Error if connection closed during send
        print(f"Error sending WebSocket message ({message_type}) for {payload.get('code_block_id', 'N/A')}: {e}")
        # traceback.print_exc() # Optional: uncomment for more detail

# This function runs in a separate thread via run_in_executor
def sync_log_streamer(container: Container, websocket: WebSocket, code_block_id: str, loop: asyncio.AbstractEventLoop, stop_event: asyncio.Event):
    """
    Synchronously iterates through Docker logs and schedules sending messages
    back to the main asyncio loop. Runs in an executor thread.
    """
    try:
        # Note: follow=True keeps the stream open until container stops or stream is closed.
        log_stream = container.logs(stream=True, follow=True, stdout=True, stderr=True)
        print(f"[Thread-{code_block_id}] Starting log iteration for container {container.short_id}")

        for line_bytes in log_stream:
            if stop_event.is_set():
                print(f"[Thread-{code_block_id}] Stop event set, breaking log iteration.")
                break

            line_str = line_bytes.decode('utf-8', errors='replace')
            # Schedule the send_ws_message coroutine to run on the main event loop
            asyncio.run_coroutine_threadsafe(
                send_ws_message(websocket, "code_output", {
                    "code_block_id": code_block_id,
                    "stream": "stdout", # Sending all as stdout for simplicity, could try parsing later
                    "data": line_str
                }),
                loop # Pass the main event loop
            )

        print(f"[Thread-{code_block_id}] Finished log iteration for container {container.short_id}")

    except Exception as e:
        # Log error from the thread
        print(f"[Thread-{code_block_id}] Error during log streaming: {e}")
        # Don't print traceback here usually, as it might be expected on stop
        # traceback.print_exc()
        # Try to send an error message back to the client via the main loop
        asyncio.run_coroutine_threadsafe(
            send_ws_message(websocket, "code_output", {
                "code_block_id": code_block_id,
                "stream": "error",
                "data": f"\n[Error streaming logs from container: {str(e)}]"
            }),
            loop
        )

async def stream_docker_logs_via_executor(websocket: WebSocket, container: Container, code_block_id: str, stop_event: asyncio.Event):
    """
    Runs the synchronous log streamer function in an executor thread.
    """
    loop = asyncio.get_running_loop()
    print(f"Scheduling log streaming task in executor for {code_block_id}")
    # Run the sync function in the default executor
    await loop.run_in_executor(
        None, # Use default thread pool executor
        sync_log_streamer, # The function to run
        container, websocket, code_block_id, loop, stop_event # Arguments for the function
    )
    print(f"Executor task for log streaming finished for {code_block_id}")


async def run_code_in_docker_stream(websocket: WebSocket, client_id: str, code_block_id: str, language: str, code: str):
    """Runs code in Docker, streams output via WebSocket, and manages container lifecycle."""
    global docker_client, running_containers, running_containers_lock

    if not docker_client:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": "Docker service is unavailable on the server."
        })
        return

    lang_key = language.lower()
    lang_config = SUPPORTED_LANGUAGES.get(lang_key)
    if not lang_config:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": f"Language '{language}' not supported for execution."
        })
        return

    image_name = lang_config["image"]
    script_filename = lang_config["filename"]
    command = lang_config["command"]
    container_obj: Container | None = None
    stream_task: asyncio.Task | None = None
    tmpdir_obj = None # To hold the TemporaryDirectory object
    stop_event = asyncio.Event() # Event to signal cancellation to the streamer thread

    try:
        # Create temporary directory safely
        tmpdir_obj = tempfile.TemporaryDirectory()
        tmpdir = tmpdir_obj.name # Get the path string
        host_script_path = Path(tmpdir) / script_filename
        with open(host_script_path, "w", encoding="utf-8") as f:
            f.write(code)

        print(f"Attempting to run block {code_block_id} ({lang_key}) in Docker image {image_name}...")

        # Run the container detached
        container_obj = docker_client.containers.run(
            image=image_name,
            command=command,
            volumes={tmpdir: {'bind': '/app', 'mode': 'ro'}}, # Read-only mount
            working_dir='/app',
            mem_limit=DOCKER_MEM_LIMIT,
            stdout=True,
            stderr=True,
            detach=True, # Run in background
            # auto_remove=True, # Cannot auto-remove if we need to wait/get logs/stop
        )
        print(f"Container {container_obj.short_id} started for {code_block_id}")

        # Start the log streaming task using the executor helper
        stream_task = asyncio.create_task(
            stream_docker_logs_via_executor(websocket, container_obj, code_block_id, stop_event),
            name=f"log_stream_{code_block_id}" # Give the task a name for debugging
        )

        # Store container and task info BEFORE waiting
        async with running_containers_lock:
            if code_block_id in running_containers:
                 # This should ideally not happen if frontend disables button, but handle defensively
                 print(f"WARNING: Code block {code_block_id} was already running. Stopping previous run.")
                 # Call stop without await here, as we are inside the lock
                 # stop_docker_container needs to acquire the lock itself, so we schedule it
                 asyncio.create_task(stop_docker_container(code_block_id))


            running_containers[code_block_id] = {
                "container": container_obj,
                "stream_task": stream_task,
                "client_id": client_id,
                "websocket": websocket,
                "stop_event": stop_event # Store the stop event
            }

        # Wait for the container to finish execution or timeout
        print(f"Waiting for container {container_obj.short_id} ({code_block_id}) to finish...")
        loop = asyncio.get_running_loop()
        result = await loop.run_in_executor(
            None, # Use default executor
            lambda: container_obj.wait(timeout=DOCKER_TIMEOUT_SECONDS)
        )
        exit_code = result.get("StatusCode", -1)
        error_msg = result.get("Error", None)
        print(f"Container {container_obj.short_id} ({code_block_id}) finished. Result: {result}")

        # Ensure log streaming task is complete (it should be if container exited naturally)
        # Set stop event first to signal the thread, then wait/cancel task
        stop_event.set()
        try:
            # Wait briefly for the executor task to finish processing final logs
            await asyncio.wait_for(stream_task, timeout=5.0)
        except asyncio.TimeoutError:
            print(f"Warning: Log streaming task for {code_block_id} did not finish quickly after container exit.")
            # If it timed out, ensure it's cancelled (though setting stop_event should handle it)
            if not stream_task.done():
                stream_task.cancel()
        except asyncio.CancelledError:
             print(f"Log streaming task for {code_block_id} was cancelled (likely during stop).")
             pass # Already handled

        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id,
            "exit_code": exit_code,
            "error": error_msg # Send Docker-level error if any
        })

    except asyncio.TimeoutError: # Timeout from container_obj.wait()
        print(f"ERROR: Docker execution timed out for block {code_block_id} after {DOCKER_TIMEOUT_SECONDS}s.")
        await send_ws_message(websocket, "code_finished", {
             "code_block_id": code_block_id, "exit_code": -1,
             "error": f"Execution timed out after {DOCKER_TIMEOUT_SECONDS} seconds."
        })
        # Attempt to stop the timed-out container (this will also cancel the stream task via stop_docker_container)
        # Schedule stop_docker_container as it needs to acquire the lock
        asyncio.create_task(stop_docker_container(code_block_id))


    except ImageNotFound:
        error_msg = f"Server Error: Docker image '{image_name}' not found. Please pull it."
        print(f"ERROR for block {code_block_id}: {error_msg}")
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except APIError as e:
        error_msg = f"Server Error: Docker API error: {e}"
        print(f"ERROR for block {code_block_id}: {error_msg}")
        traceback.print_exc()
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except Exception as e:
        error_msg = f"Server Execution Error: {str(e)}"
        print(f"ERROR during Docker execution setup or wait for block {code_block_id}: {e}")
        traceback.print_exc()
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
        # Ensure stream task is cancelled if it was started
        if stream_task and not stream_task.done():
            print(f"Cancelling stream task for {code_block_id} due to setup/wait error.")
            stop_event.set() # Signal thread to stop
            stream_task.cancel()

    finally:
        # --- Final Cleanup ---
        # Remove from tracking dict if it hasn't been removed by stop_docker_container already
        async with running_containers_lock:
            if code_block_id in running_containers:
                print(f"Performing final cleanup check for {code_block_id}")
                task_to_cancel = running_containers[code_block_id]["stream_task"]
                stop_ev = running_containers[code_block_id]["stop_event"]
                if task_to_cancel and not task_to_cancel.done():
                     print(f"Final cleanup: Cancelling stream task for {code_block_id}")
                     stop_ev.set() # Signal thread
                     task_to_cancel.cancel()
                # Remove from tracking dict
                del running_containers[code_block_id]
                print(f"Removed {code_block_id} from running_containers during final cleanup")

        # Remove container if it exists and hasn't been removed by stop
        if container_obj:
            try:
                # Check if container still exists before removing
                await asyncio.get_running_loop().run_in_executor(None, container_obj.reload)
                print(f"Removing container {container_obj.short_id} ({code_block_id}) in final cleanup")
                # Need to run blocking remove in executor
                await asyncio.get_running_loop().run_in_executor(None, lambda: container_obj.remove(force=True))
            except NotFound:
                 print(f"Container {container_obj.short_id} already removed.")
                 pass # Already removed
            except Exception as rm_err:
                print(f"Error removing container {container_obj.short_id} in final cleanup: {rm_err}")

        # Clean up temporary directory
        if tmpdir_obj:
             try:
                  tmpdir_obj.cleanup()
             except Exception as cleanup_err:
                  print(f"Error cleaning up temp directory {tmpdir}: {cleanup_err}")


async def stop_docker_container(code_block_id: str):
    """Stops a running Docker container and cancels its log stream task."""
    global running_containers, running_containers_lock
    print(f"Attempting to stop execution for code block: {code_block_id}")
    loop = asyncio.get_running_loop()
    container_info = None
    container_obj = None
    stream_task = None
    websocket = None
    stop_event = None

    async with running_containers_lock:
        if code_block_id in running_containers:
            # Pop the entry to prevent others from trying to stop it simultaneously
            container_info = running_containers.pop(code_block_id)
            container_obj = container_info["container"]
            stream_task = container_info["stream_task"]
            websocket = container_info["websocket"] # Get websocket for final message
            stop_event = container_info["stop_event"]
            print(f"Found and removed running container {container_obj.short_id} for {code_block_id} from tracking.")
        else:
            print(f"Stop request for {code_block_id}, but it was not found in running_containers.")
            return # Nothing to stop

    # Perform actions outside the lock

    # 1. Signal the streaming thread to stop and cancel the task
    if stop_event:
        print(f"Setting stop event for {code_block_id}")
        stop_event.set()
    if stream_task and not stream_task.done():
        print(f"Cancelling stream task for {code_block_id}")
        stream_task.cancel()
        try:
            # Wait briefly for cancellation to be processed by the task
            await asyncio.wait_for(stream_task, timeout=1.0)
        except asyncio.TimeoutError:
            print(f"Stream task for {code_block_id} did not cancel quickly.")
        except asyncio.CancelledError:
            print(f"Stream task for {code_block_id} cancelled successfully.")
            pass # Expected

    # 2. Stop the container
    if container_obj:
        try:
            print(f"Stopping container {container_obj.short_id} ({code_block_id})...")
            # Stop needs to run in executor
            await loop.run_in_executor(None, lambda: container_obj.stop(timeout=5))
            print(f"Container {container_obj.short_id} stopped.")
        except Exception as stop_err:
            print(f"Error stopping container {container_obj.short_id}, attempting kill: {stop_err}")
            try:
                # Kill needs to run in executor
                await loop.run_in_executor(None, container_obj.kill)
                print(f"Container {container_obj.short_id} killed.")
            except Exception as kill_err:
                # Ignore kill error if container is already gone
                if "No such container" not in str(kill_err):
                     print(f"Error killing container {container_obj.short_id}: {kill_err}")

        # 3. Remove the container
        try:
            print(f"Removing container {container_obj.short_id} ({code_block_id}) after stop request.")
            # Remove needs to run in executor
            await loop.run_in_executor(None, lambda: container_obj.remove(force=True))
        except NotFound:
             pass # Already removed
        except Exception as rm_err:
            print(f"Error removing container {container_obj.short_id} after stop: {rm_err}")

    # 4. Send final message to client if websocket is still valid
    if websocket and websocket.client_state == WebSocketState.CONNECTED:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id,
            "exit_code": -1, # Indicate abnormal termination
            "error": "Execution stopped by user."
        })
    else:
         print(f"Cannot send stop confirmation for {code_block_id}, WebSocket reference lost or disconnected.")


async def cleanup_client_containers(client_id: str):
    """Stops and cleans up all running containers associated with a client ID."""
    global running_containers, running_containers_lock
    print(f"Cleaning up containers for disconnected client: {client_id}")
    containers_to_stop = []
    # Create a separate list to avoid modifying dict while iterating
    async with running_containers_lock:
         # Find code_block_ids associated with the client
         ids_for_client = [cb_id for cb_id, info in running_containers.items() if info["client_id"] == client_id]
         containers_to_stop.extend(ids_for_client)

    # Stop each container outside the lock to avoid holding it too long
    if containers_to_stop:
         print(f"Found containers to stop for client {client_id}: {containers_to_stop}")
         # Use asyncio.gather to stop them concurrently
         # Note: stop_docker_container already removes the entry from running_containers
         stop_tasks = [stop_docker_container(cb_id) for cb_id in containers_to_stop]
         results = await asyncio.gather(*stop_tasks, return_exceptions=True) # Log exceptions if any stop fails
         for i, result in enumerate(results):
              if isinstance(result, Exception):
                   print(f"Error during cleanup stop for {containers_to_stop[i]}: {result}")
         print(f"Finished cleanup for client {client_id}")
    else:
         print(f"No running containers found for client {client_id} during cleanup.")

# --- FastAPI Routes ---

# Root route to serve the main HTML page
@app.get("/", response_class=HTMLResponse)
async def get_chat_page(request: Request):
    """Serves the main chat HTML page."""
    html_file_path = static_dir / "index.html"
    if not html_file_path.is_file():
         print(f"ERROR: index.html not found at expected location: {html_file_path}")
         raise HTTPException(status_code=404, detail="index.html not found")
    try:
        with open(html_file_path, "r", encoding="utf-8") as f:
            html_content = f.read()
        return HTMLResponse(content=html_content)
    except Exception as e:
        print(f"ERROR reading index.html: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error reading index.html: {e}")


# --- WebSocket Endpoint ---
@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: str):
    """Handles WebSocket connections for chat and code execution."""
    await websocket.accept()
    print(f"WebSocket connection accepted for client: {client_id}")
    memory = get_memory_for_client(client_id)

    # Function to load history using this client's memory (Unchanged)
    def load_memory_for_current_client(_):
        loaded_vars = memory.load_memory_variables({})
        return loaded_vars.get("history", [])

    # Simple chain using the fixed global 'prompt' (Unchanged)
    chain = (
        RunnablePassthrough.assign(history=load_memory_for_current_client)
        | prompt
        | model
        | output_parser
    )
    print(f"LCEL Chain created for client: {client_id}")

    try:
        while True:
            # Check state before receiving
            if websocket.client_state != WebSocketState.CONNECTED:
                 print(f"WebSocket no longer connected for {client_id} before receive. Breaking loop.")
                 break

            received_data = await websocket.receive_text()

            # Check if it's a JSON command or regular chat input
            try:
                message_data = json.loads(received_data)
                message_type = message_data.get("type")
                payload = message_data.get("payload")

                if message_type and payload and isinstance(payload, dict):
                    # --- Handle JSON Commands ---
                    code_block_id = payload.get("code_block_id")
                    if not code_block_id:
                         print(f"Received JSON command without code_block_id: {message_data}")
                         continue

                    if message_type == "run_code":
                        language = payload.get("language")
                        code = payload.get("code")
                        if language and code is not None:
                             print(f"Received 'run_code' request for block {code_block_id} ({language}) from {client_id}")
                             # Start execution in background task
                             asyncio.create_task(
                                 run_code_in_docker_stream(websocket, client_id, code_block_id, language, code)
                             )
                        else:
                             print(f"Invalid 'run_code' payload received: {payload}")
                             await send_ws_message(websocket, "code_finished", {
                                  "code_block_id": code_block_id, "exit_code": -1,
                                  "error": "Invalid run_code request payload from client."
                             })

                    elif message_type == "stop_code":
                        print(f"Received 'stop_code' request for block {code_block_id} from {client_id}")
                        # Stop execution in background task
                        asyncio.create_task(
                             stop_docker_container(code_block_id)
                        )

                    else:
                        print(f"Received unknown JSON command type '{message_type}' from {client_id}")

                else:
                     # Treat as chat if JSON structure is invalid
                     print(f"Received invalid JSON structure from {client_id}, treating as chat: {received_data[:100]}...")
                     await handle_chat_message(chain, memory, websocket, client_id, received_data)

            except json.JSONDecodeError:
                # --- Handle Regular Chat Message ---
                # print(f"Handling text message from {client_id}: '{received_data[:50]}...'")
                await handle_chat_message(chain, memory, websocket, client_id, received_data)

    except WebSocketDisconnect:
        print(f"WebSocket disconnected during receive/process for client: {client_id}")
    except Exception as e:
        print(f"Unknown Error in WebSocket loop for client {client_id}: {e}")
        traceback.print_exc()
    finally:
        # --- Cleanup on Disconnect or Error ---
        print(f"Cleaning up resources for client: {client_id}")
        remove_memory_for_client(client_id)
        # Stop any running containers for this client
        await cleanup_client_containers(client_id)
        # Attempt to close websocket gracefully if it's not already closed
        if websocket.client_state == WebSocketState.CONNECTED:
            try:
                await websocket.close(code=1000) # Normal closure
                print(f"WebSocket closed gracefully for {client_id}")
            except Exception as close_exc:
                # Ignore errors if already closed or cannot close
                 print(f"Ignoring error during explicit WebSocket close for {client_id}: {close_exc}")
                 pass
        else:
             print(f"WebSocket already closed for {client_id} during cleanup.")


async def handle_chat_message(chain, memory, websocket: WebSocket, client_id: str, user_input: str):
     """Handles processing and streaming response for a regular chat message."""
     print(f"Handling chat message from {client_id}: '{user_input[:50]}...'")
     full_response = ""
     try:
         # Stream response using the chain
         async for chunk in chain.astream({"input": user_input}):
             # Check connection before sending each chunk
             if websocket.client_state != WebSocketState.CONNECTED:
                  print(f"WebSocket disconnected during chat stream for {client_id}. Aborting send.")
                  return # Stop sending if disconnected
             await websocket.send_text(chunk)
             full_response += chunk
     except Exception as chain_exc:
         error_msg = f"<ERROR>Error processing message: {chain_exc}"
         print(f"ERROR during chain execution for {client_id}: {chain_exc}")
         traceback.print_exc()
         # Try sending error message only if connected
         if websocket.client_state == WebSocketState.CONNECTED:
              await websocket.send_text(error_msg)
         # Don't save context if chain failed, but allow next message
         return

     # Send End Of Stream marker for chat message only if connected
     if websocket.client_state == WebSocketState.CONNECTED:
          await websocket.send_text("<EOS>")
          print(f"Finished streaming chat response to {client_id}")
          # Save context to memory
          # Note: user_input might contain the NO_THINK_PREFIX, which is fine for memory
          memory.save_context({"input": user_input}, {"output": full_response})
          print(f"Saved chat context to memory for client: {client_id}")
     else:
          print(f"WebSocket disconnected before sending <EOS> for {client_id}.")


# --- Function to run the server ---
def start_server():
    """Starts the Uvicorn server and opens the browser."""
    host = "127.0.0.1"
    port = 8001
    url = f"http://{host}:{port}"
    print(f"Starting server at {url}...")
    print(f"Using Ollama base URL: {OLLAMA_BASE_URL}")
    print(f"Using Model ID: {MODEL_ID}")
    print(f"Static files served from: {static_dir}")
    print(f"Supported execution languages: {list(SUPPORTED_LANGUAGES.keys())}")
    if not docker_client:
        print("WARNING: Docker client unavailable. Code execution will fail.")

    print(f"Attempting to open browser at {url}...")
    try:
        webbrowser.open(url)
    except Exception as browser_err:
        print(f"Warning: Could not automatically open browser: {browser_err}")
        print(f"Please navigate to {url} manually.")

    # --- Uvicorn Run ---
    # IMPORTANT: The target 'app.main:app' assumes this script (main.py)
    # is located inside a directory named 'app' relative to where you
    # run the uvicorn command OR that you run python like: python -m app.main
    # If main.py is at the project root, change the target to "main:app"
    uvicorn_target = "app.main:app"
    # Check if running directly (e.g., python main.py) vs module (python -m app.main)
    # A simple check: if the script's directory is named 'app'
    if Path(__file__).parent.name == "app":
         print(f"Running Uvicorn with target: '{uvicorn_target}' (assuming script is in 'app' directory)")
    else:
         # If not in 'app', assume it's at the root
         uvicorn_target = "main:app"
         print(f"Running Uvicorn with target: '{uvicorn_target}' (assuming script is at project root)")

    uvicorn.run(uvicorn_target, host=host, port=port, log_level="info", reload=True)

if __name__ == "__main__":
    # Add basic check for Docker client availability at startup
    if docker_client is None:
         print("\n---")
         print("WARNING: Docker is not running or accessible.")
         print("Code execution features will be disabled.")
         print("Please start Docker and restart this application for code execution.")
         print("---\n")
    start_server()



=== write_project_content_to_file.py ===
import os
import sys

# --- Configuration ---

# Set the starting directory (e.g., "." for current directory)
root = "."

# Extensions to include
extensions = ('.py', '.html', '.css', '.js', '.json', '.md', '.txt', '.yaml', '.yml', '.toml')

# Directories to completely exclude (will not be walked)
exclude_dirs = (
    '.git',
    '__pycache__',
    '.pytest_cache',
    'node_modules',
    'build',
    'old2',
    'testing-bundles', # Exclude this directory name wherever it appears
    '.venv',           # Common virtual environment folder
    'venv',
    'env',
    '.env',
    'dist',
    "assets"
)

# Files to list in the tree but exclude their *content*
exclude_files = (
    'package-lock.json',
    'yarn.lock',
    'katex.min.css',
    'katex.min.js',
    'build.js',
    'docker_utils.js',
    'llm.py',
    'input.css'
    # Add other large or irrelevant files by name here
)

# Output file name
output_filename = "project_content.txt"

# --- Script Logic ---

try:
    root = os.path.abspath(root)
    print(f"Starting directory: {root}")
    print(f"Output file: {output_filename}")
    print(f"Excluding directories: {exclude_dirs}")
    print(f"Excluding content of files: {exclude_files}")

    # Use a set for faster lookups
    exclude_dirs_set = set(exclude_dirs)
    exclude_files_set = set(exclude_files)

    with open(output_filename, "w", encoding="utf-8", errors="replace") as outfile:
        # === Add Directory Structure ===
        outfile.write("=== Project Directory Structure ===\n")
        outfile.write(f"Root: {root}\n")
        outfile.write("Relevant files and folders (excluding specified patterns):\n\n")

        structure_lines = []
        processed_dirs_for_structure = set()

        for current_root, dirs, files in os.walk(root, topdown=True):
            # Filter directories *in place* to prevent walking into excluded ones
            # Also exclude hidden directories starting with '.' unless root is hidden
            original_dirs = list(dirs) # Keep original for path checking if needed
            dirs[:] = [d for d in dirs if d not in exclude_dirs_set and not (d.startswith('.') and d != '.')]

            rel_path_from_start = os.path.relpath(current_root, root)

            # --- Skip processing if current path is inside an excluded directory ---
            # Check if any component of the relative path is in the exclusion list
            # Normalize path separators for consistent checking
            norm_rel_path = os.path.normpath(rel_path_from_start).replace(os.sep, '/')
            path_components = set(comp for comp in norm_rel_path.split('/') if comp and comp != '.')

            if any(comp in exclude_dirs_set or (comp.startswith('.') and comp != '.') for comp in path_components):
                 continue # Skip this directory entirely if any parent was excluded

            level = norm_rel_path.count('/') if norm_rel_path != '.' else 0

            # Add directory entry
            if rel_path_from_start == '.':
                 structure_lines.append(".\n")
            else:
                 indent = '│   ' * (level - 1) + '├── ' if level > 0 else ''
                 dir_name = os.path.basename(current_root)
                 # Check if this specific dir name should be excluded (e.g., if it's at the root)
                 if dir_name not in exclude_dirs_set and not (dir_name.startswith('.') and dir_name != '.'):
                     structure_lines.append(f"{indent}{dir_name}/\n")
                     processed_dirs_for_structure.add(norm_rel_path)


            # Add file entries for this directory
            file_indent = '│   ' * level + '├── '
            files.sort()
            for file in files:
                if file.endswith(extensions) and not file.startswith('.'):
                     structure_lines.append(f"{file_indent}{file}\n")

        # Write collected structure lines
        for line in structure_lines:
             outfile.write(line)

        outfile.write("\n\n=== File Contents ===\n\n")

        # === Add File Contents ===
        for current_root, dirs, files in os.walk(root, topdown=True):
            # Apply the same directory filtering as in the first walk
            dirs[:] = [d for d in dirs if d not in exclude_dirs_set and not (d.startswith('.') and d != '.')]

            rel_path_from_start = os.path.relpath(current_root, root)

            # --- Skip processing if current path is inside an excluded/hidden directory ---
            norm_rel_path = os.path.normpath(rel_path_from_start).replace(os.sep, '/')
            path_components = set(comp for comp in norm_rel_path.split('/') if comp and comp != '.')
            if any(comp in exclude_dirs_set or (comp.startswith('.') and comp != '.') for comp in path_components):
                 continue # Skip files in this directory

            files.sort()
            for file in files:
                 # Exclude hidden files and check extensions
                 if file.endswith(extensions) and not file.startswith('.'):
                     file_path = os.path.join(current_root, file)
                     relative_path = os.path.relpath(file_path, root)
                     display_path = relative_path.replace(os.sep, '/')

                     outfile.write(f"=== {display_path} ===\n")

                     # Check if the file *content* should be excluded
                     if file in exclude_files_set:
                         outfile.write("--- CONTENT EXCLUDED (listed in exclude_files) ---\n")
                     else:
                         try:
                             # Try reading with utf-8 first
                             with open(file_path, "r", encoding="utf-8") as infile:
                                 outfile.write(infile.read())
                         except UnicodeDecodeError:
                             # Fallback for non-utf8 files
                             try:
                                 with open(file_path, "r", encoding="latin-1") as infile:
                                     outfile.write(infile.read())
                                 outfile.write("\n--- (Warning: Read using latin-1 encoding) ---\n")
                             except Exception as inner_e:
                                 outfile.write(f"--- Error reading file (fallback failed): {inner_e} ---\n")
                         except Exception as e:
                             # Handle other potential file reading errors
                             outfile.write(f"--- Error reading file: {e} ---\n")

                     outfile.write("\n\n") # Add separation between file contents

    print(f"Successfully generated project content file: {output_filename}")

except FileNotFoundError:
    print(f"Error: Starting directory not found: {root}", file=sys.stderr)
except IOError as e:
    print(f"Error writing to output file {output_filename}: {e}", file=sys.stderr)
except Exception as e:
    print(f"An unexpected error occurred: {e}", file=sys.stderr)

=== app/__init__.py ===


=== app/auth.py ===
# app/auth.py
import datetime
import sqlite3
import traceback
from fastapi import Request, Response, HTTPException, Depends
from fastapi.security import APIKeyCookie
from pydantic import BaseModel
from passlib.context import CryptContext # Import CryptContext
from starlette.status import HTTP_401_UNAUTHORIZED
from typing import Optional, Dict, Any

# Assuming database utilities are in the same directory
# We still need generate_secure_token for session tokens, but hash_value is removed for passwords
from .database import get_db_connection, generate_secure_token, hash_value as hash_session_token # Rename hash_value import

# --- Passlib Configuration ---
# Use bcrypt, the recommended default. Schemes lists hashing algorithms.
# deprecated="auto" will automatically upgrade hashes if needed in the future.
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
# --- End Passlib Configuration ---

# Configuration for the session cookie
SESSION_COOKIE_NAME = "tesseracs_chat_session_token"
SESSION_DURATION_DAYS = 7

# Dependency for getting the session token from the cookie
cookie_scheme = APIKeyCookie(name=SESSION_COOKIE_NAME, auto_error=False)

# Pydantic model for the token response (used by /token endpoint)
class Token(BaseModel):
    access_token: str
    token_type: str
    user_id: Optional[int] = None
    user_name: Optional[str] = None
    user_email: Optional[str] = None

# --- Password Hashing Utilities ---
def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifies a plain password against a stored hash using passlib."""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Hashes a plain password using passlib."""
    return pwd_context.hash(password)
# --- End Password Hashing Utilities ---


async def create_user_session(response: Response, user_id: int) -> str:
    """
    Creates a new session token in the database for the given user_id,
    and sets the raw token value in an HTTPOnly cookie on the response object.
    (Uses hash_session_token for the session token itself, not passlib)
    """
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        session_token_raw = generate_secure_token(32)
        # Use the specific hash function for session tokens (e.g., SHA256)
        session_token_hashed = hash_session_token(session_token_raw)
        now_utc = datetime.datetime.now(datetime.timezone.utc)
        expires_at = now_utc + datetime.timedelta(days=SESSION_DURATION_DAYS)
        cursor.execute(
            "INSERT INTO auth_tokens (user_id, token_hash, token_type, expires_at) VALUES (?, ?, ?, ?)",
            (user_id, session_token_hashed, "session", expires_at.isoformat())
        )
        conn.commit()
        print(f"AUTH: Session token stored in DB for user_id: {user_id}")
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        print(f"AUTH ERROR: Storing session token failed: {db_err}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Could not create session due to a database error.")
    except Exception as e:
        if conn: conn.rollback()
        print(f"AUTH ERROR: Unexpected error storing session token: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Unexpected server error during session creation.")
    finally:
        if conn: conn.close()

    response.set_cookie(
        key=SESSION_COOKIE_NAME,
        value=session_token_raw,
        httponly=True,
        secure=False, # TODO: Set to True in production (HTTPS)
        samesite="lax",
        max_age=int(datetime.timedelta(days=SESSION_DURATION_DAYS).total_seconds()),
        path="/",
        domain=None
    )
    print(f"AUTH: Session cookie '{SESSION_COOKIE_NAME}' set in response for user_id: {user_id}.")
    return session_token_raw


async def get_current_user(
    request: Request,
    session_token_raw: Optional[str] = Depends(cookie_scheme)
) -> Optional[Dict[str, Any]]:
    """
    FastAPI Dependency: Retrieves the current authenticated user based on the
    session token found in the request's cookie.
    (Uses hash_session_token for the session token itself, not passlib)
    """
    token_to_verify = session_token_raw
    if not token_to_verify:
        token_to_verify = request.cookies.get(SESSION_COOKIE_NAME)
    if not token_to_verify:
        return None

    # Use the specific hash function for session tokens
    session_token_hashed = hash_session_token(token_to_verify)
    conn = None
    user_dict = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        now_utc_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        cursor.execute(
            """
            SELECT u.id, u.name, u.email, u.is_active
            FROM users u JOIN auth_tokens at ON u.id = at.user_id
            WHERE at.token_hash = ? AND at.token_type = 'session'
              AND at.expires_at > ? AND at.used_at IS NULL
            """,
            (session_token_hashed, now_utc_iso)
        )
        user_row = cursor.fetchone()
        if user_row:
            user_dict = dict(user_row)
            if not user_dict["is_active"]:
                print(f"AUTH get_current_user: User {user_dict.get('email')} found but is INACTIVE.")
                user_dict = None
    except sqlite3.Error as db_err:
        print(f"AUTH ERROR: Database error during session token verification: {db_err}")
        traceback.print_exc()
        user_dict = None
    except Exception as e:
        print(f"AUTH ERROR: Unexpected error during session token verification: {e}")
        traceback.print_exc()
        user_dict = None
    finally:
        if conn: conn.close()
    return user_dict


async def get_current_active_user(
    user: Optional[Dict[str, Any]] = Depends(get_current_user)
) -> Optional[Dict[str, Any]]:
    """FastAPI Dependency: Gets the current active user."""
    return user


async def get_user_by_session_token(session_token_raw: str) -> Optional[Dict[str, Any]]:
    """
    Authenticates a user based purely on a raw session token string.
    (Uses hash_session_token for the session token itself, not passlib)
    """
    if not session_token_raw:
        return None

    # Use the specific hash function for session tokens
    session_token_hashed = hash_session_token(session_token_raw)
    conn = None
    user_dict = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        now_utc = datetime.datetime.now(datetime.timezone.utc)
        now_utc_iso = now_utc.isoformat()
        cursor.execute(
            """
            SELECT u.id, u.name, u.email, u.is_active
            FROM users u JOIN auth_tokens at ON u.id = at.user_id
            WHERE at.token_hash = ? AND at.token_type = 'session'
              AND at.expires_at > ? AND at.used_at IS NULL
            """,
            (session_token_hashed, now_utc_iso)
        )
        user_row = cursor.fetchone()
        if user_row:
            user_dict = dict(user_row)
            if not user_dict["is_active"]:
                user_dict = None
    except sqlite3.Error as db_err:
        print(f"AUTH ERROR (get_user_by_session_token): Database error: {db_err}")
        traceback.print_exc()
        user_dict = None
    except Exception as e:
        print(f"AUTH ERROR (get_user_by_session_token): Unexpected error: {e}")
        traceback.print_exc()
        user_dict = None
    finally:
        if conn: conn.close()
    return user_dict


async def logout_user(response: Response, session_token_raw: Optional[str]):
    """
    Logs out the user by invalidating the session token in the database
    (if provided) and clearing the session cookie from the browser.
    (Uses hash_session_token for the session token itself, not passlib)
    """
    if session_token_raw:
        # Use the specific hash function for session tokens
        session_token_hashed = hash_session_token(session_token_raw)
        conn = None
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            now_utc_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            cursor.execute(
                """
                UPDATE auth_tokens SET used_at = ?, expires_at = ?
                WHERE token_hash = ? AND token_type = 'session'
                """,
                (now_utc_iso, now_utc_iso, session_token_hashed)
            )
            conn.commit()
            print(f"AUTH: Session token invalidated in DB for hash {session_token_hashed[:10]}.")
        except sqlite3.Error as db_err:
            if conn: conn.rollback()
            print(f"AUTH ERROR: Failed to invalidate session token in DB: {db_err}")
            traceback.print_exc()
        except Exception as e:
             if conn: conn.rollback()
             print(f"AUTH ERROR: Unexpected error invalidating session token: {e}")
             traceback.print_exc()
        finally:
            if conn: conn.close()

    response.delete_cookie(
        SESSION_COOKIE_NAME,
        httponly=True,
        secure=False, # TODO: Set to True in production (HTTPS)
        samesite="lax",
        path="/"
    )
    print(f"AUTH: Session cookie '{SESSION_COOKIE_NAME}' cleared from browser.")


=== app/config.py ===
# app/config.py
import os
import sys
from pathlib import Path
from dotenv import load_dotenv

# Load environment variables from a .env file if it exists
load_dotenv()

# --- LLM Configuration ---
MODEL_ID = os.getenv("MODEL_ID", "qwen3:8B")
OLLAMA_BASE_URL = os.getenv("OLLAMA_BASE_URL", "http://localhost:11434")
NO_THINK_PREFIX = "\\no_think"

# --- Docker Configuration ---
SUPPORTED_LANGUAGES = {
    "python": {
        "image": "python:3.11-slim",
        "filename": "script.py",
        "command": ["python", "-u", "/app/script.py"]
    },
    "javascript": {
        "image": "node:18-alpine",
        "filename": "script.js",
        "command": ["node", "/app/script.js"]
    },
    "cpp": {
        "image": "gcc:latest",
        "filename": "script.cpp",
        "command": ["sh", "-c", "g++ /app/script.cpp -o /app/output_executable && /app/output_executable"]
    },
    "csharp": {
        "image": "mcr.microsoft.com/dotnet/sdk:latest",
        "filename": "Script.cs",
        "command": [
            "sh", "-c",
            "cd /app && dotnet new console --force -o . > /dev/null && cp Script.cs Program.cs && rm Script.cs && dotnet run"
        ]
    },
    "typescript": {
        "image": "node:18-alpine",
        "filename": "script.ts",
        "command": ["sh", "-c", "tsc --module commonjs /app/script.ts && node /app/script.js"]
    },
    "java": {
        "image": "openjdk:17-jdk-slim",
        "filename": "Main.java",
        "command": ["sh", "-c", "javac /app/Main.java && java -cp /app Main"]
    },
    "go": {
        "image": "golang:1.21-alpine",
        "filename": "script.go",
        "command": ["go", "run", "/app/script.go"]
    },
    "rust": {
        "image": "rust:1-slim",
        "filename": "main.rs",
        "command": ["sh", "-c", "cd /app && rustc main.rs -o main_executable && ./main_executable"]
    }
}
DOCKER_TIMEOUT_SECONDS = int(os.getenv("DOCKER_TIMEOUT_SECONDS", 30))
DOCKER_MEM_LIMIT = os.getenv("DOCKER_MEM_LIMIT", "128m")

# --- Static Files Configuration ---
APP_DIR = Path(__file__).parent
PROJECT_ROOT = APP_DIR.parent
STATIC_DIR_IN_APP = APP_DIR / "static"
STATIC_DIR_AT_ROOT_LEVEL = PROJECT_ROOT / "static"
STATIC_DIR = None
if STATIC_DIR_IN_APP.is_dir(): STATIC_DIR = STATIC_DIR_IN_APP
elif STATIC_DIR_AT_ROOT_LEVEL.is_dir(): STATIC_DIR = STATIC_DIR_AT_ROOT_LEVEL
else:
    print(f"CRITICAL ERROR: Static directory not found. Looked in '{STATIC_DIR_IN_APP}' and '{STATIC_DIR_AT_ROOT_LEVEL}'. Exiting.")
    sys.exit(1)

# --- Email Configuration ---
MAIL_CONFIG = {
    "MAIL_USERNAME": os.getenv("MAIL_USERNAME"),
    "MAIL_PASSWORD": os.getenv("MAIL_PASSWORD"),
    "MAIL_FROM": os.getenv("MAIL_FROM"),
    "MAIL_PORT": int(os.getenv("MAIL_PORT", 465)), # Keep 465 from last attempt
    "MAIL_SERVER": os.getenv("MAIL_SERVER"),
    "MAIL_FROM_NAME": os.getenv("MAIL_FROM_NAME", "Tesseracs Chat"),
    "MAIL_STARTTLS": os.getenv("MAIL_STARTTLS", 'False').lower() in ('true', '1', 't'), # Keep False
    "MAIL_SSL_TLS": os.getenv("MAIL_SSL_TLS", 'True').lower() in ('true', '1', 't'),    # Keep True
    "USE_CREDENTIALS": True,
    # Read validation setting from env, default to True (secure)
    "VALIDATE_CERTS": os.getenv("MAIL_VALIDATE_CERTS", 'True').lower() in ('true', '1', 't')
}

if not all([MAIL_CONFIG["MAIL_USERNAME"], MAIL_CONFIG["MAIL_PASSWORD"], MAIL_CONFIG["MAIL_SERVER"]]):
    print("WARNING: Essential email configuration missing in .env file.")

# Print validation status being used for clarity
print(f"DEBUG config: Email certificate validation (VALIDATE_CERTS) is set to: {MAIL_CONFIG['VALIDATE_CERTS']}")



=== app/database.py ===
# app/database.py
import sqlite3
import os
from pathlib import Path
import hashlib # For password hashing (even if magic links are primary)
import secrets # For generating secure tokens
import datetime # For timestamps

# Determine the project root directory based on the location of this file
# Assuming this file is app/database.py
APP_DIR = Path(__file__).parent
PROJECT_ROOT = APP_DIR.parent
DATABASE_NAME = "tesseracs_chat.db"
DATABASE_PATH = PROJECT_ROOT / DATABASE_NAME

def get_db_connection():
    """Establishes a connection to the SQLite database."""
    # print(f"Attempting to connect to database at: {DATABASE_PATH}")
    conn = sqlite3.connect(DATABASE_PATH)
    conn.row_factory = sqlite3.Row # Access columns by name
    return conn

def init_db():
    """Initializes the database schema if it doesn't exist."""
    print(f"Initializing database schema at {DATABASE_PATH}...")
    conn = get_db_connection()
    cursor = conn.cursor()

    # Users Table
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        email TEXT UNIQUE NOT NULL,
        password_hash TEXT, 
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        is_active BOOLEAN DEFAULT TRUE NOT NULL 
    );
    """)
    print("Ensured 'users' table exists.")

    # Auth Tokens Table
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS auth_tokens (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        token_hash TEXT UNIQUE NOT NULL, 
        token_type TEXT NOT NULL CHECK(token_type IN ('magic_login', 'session', 'password_reset')),
        expires_at TIMESTAMP NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        used_at TIMESTAMP, 
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
    );
    """)
    print("Ensured 'auth_tokens' table exists.")

    # Sessions Table
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS sessions (
        id TEXT PRIMARY KEY, 
        host_user_id INTEGER NOT NULL, 
        name TEXT, 
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        last_accessed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        is_active BOOLEAN DEFAULT TRUE NOT NULL, 
        FOREIGN KEY (host_user_id) REFERENCES users (id) ON DELETE CASCADE
    );
    """)
    print("Ensured 'sessions' table exists.")

    # Session Participants Table
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS session_participants (
        session_id TEXT NOT NULL,
        user_id INTEGER NOT NULL,
        joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (session_id, user_id), 
        FOREIGN KEY (session_id) REFERENCES sessions (id) ON DELETE CASCADE,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
    );
    """)
    print("Ensured 'session_participants' table exists.")

    # Chat Messages Table
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS chat_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id TEXT NOT NULL,         
        user_id INTEGER,                 
        sender_name TEXT,                 
        sender_type TEXT NOT NULL CHECK(sender_type IN ('user', 'ai', 'system', 'anon_user')), 
        content TEXT NOT NULL,            
        client_id_temp TEXT,             
        turn_id INTEGER,                 
        thinking_content TEXT,           
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (session_id) REFERENCES sessions (id) ON DELETE CASCADE,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE SET NULL 
    );
    """)
    print("Ensured 'chat_messages' table exists.")

    # --- ADDED TABLE for Session Memory State ---
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS session_memory_state (
        session_id TEXT PRIMARY KEY,          -- Links directly to the session
        memory_state_json TEXT NOT NULL,      -- Stores the serialized memory state (e.g., as JSON)
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- When the memory was last saved
        FOREIGN KEY (session_id) REFERENCES sessions (id) ON DELETE CASCADE
    );
    """)
    print("Ensured 'session_memory_state' table exists.")
    # --- END OF ADDED TABLE ---

    # Add indexes for frequently queried columns for performance
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_users_email ON users (email);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_auth_tokens_token_hash ON auth_tokens (token_hash);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_auth_tokens_user_id ON auth_tokens (user_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_sessions_host_user_id ON sessions (host_user_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_session_participants_session_id ON session_participants (session_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_session_participants_user_id ON session_participants (user_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_chat_messages_session_id ON chat_messages (session_id);")
    # Add index for the new table's foreign key
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_session_memory_state_session_id ON session_memory_state (session_id);")
    print("Ensured indexes exist.")

    conn.commit()
    conn.close()
    print("Database initialization process complete.")

def hash_value(value: str) -> str:
    """Hashes a string value (e.g., password or token) using SHA256."""
    return hashlib.sha256(value.encode('utf-8')).hexdigest()

def generate_secure_token(length: int = 32) -> str:
    """Generates a cryptographically secure URL-safe token."""
    return secrets.token_urlsafe(length)

# You can run this file directly to initialize the database:
# python -m app.database
if __name__ == "__main__":
    print(f"Running database script directly. CWD: {Path.cwd()}")
    print(f"Project Root should be: {PROJECT_ROOT}")
    print(f"Database will be created/checked at: {DATABASE_PATH}")
    # Ensure the parent directory for the database exists
    DATABASE_PATH.parent.mkdir(parents=True, exist_ok=True)
    init_db()

=== app/docker_utils.py ===
# app/docker_utils.py

import asyncio
import tempfile
import shutil
import traceback
from pathlib import Path
import docker # Docker SDK for Python
from docker.errors import DockerException, ImageNotFound, APIError, NotFound # Docker specific errors
from docker.models.containers import Container # For type hinting container objects
from fastapi import WebSocket # For type hinting WebSockets

# Relative imports for modules within the 'app' package
from . import config
from . import state
from .utils import send_ws_message # Utility function for sending WebSocket messages

# --- Docker Client Initialization ---
# Attempt to initialize the Docker client from the environment settings.
# This typically connects to the Docker daemon running locally.
docker_client = None
try:
    # Get Docker client from environment variables (DOCKER_HOST, etc.)
    docker_client = docker.from_env()
    # Ping the Docker daemon to ensure connectivity
    docker_client.ping()
    print("Successfully connected to Docker daemon.")
except DockerException as e:
    # Handle exceptions if the Docker daemon is not reachable
    print(f"CRITICAL WARNING: Could not connect to Docker daemon: {e}")
    print("Code execution via Docker will be unavailable.")
    docker_client = None # Ensure client is None if connection failed

def get_docker_client():
    """
    Returns the initialized Docker client instance.
    Returns None if the client failed to initialize.
    """
    return docker_client

# --- Log Streaming Logic (Designed to Run in Executor Thread) ---

def sync_log_streamer(container: Container, websocket: WebSocket, code_block_id: str, loop: asyncio.AbstractEventLoop, stop_event: asyncio.Event):
    """
    Synchronously iterates through Docker container logs and schedules sending
    log lines back to the main asyncio event loop via WebSocket.
    This function is blocking and intended to be run in a separate thread using run_in_executor.

    Args:
        container: The Docker container object to stream logs from.
        websocket: The WebSocket connection to send log messages to.
        code_block_id: Identifier for the code block being executed.
        loop: The main asyncio event loop to schedule coroutines on.
        stop_event: An asyncio.Event used to signal when to stop streaming.
    """
    try:
        # Get a blocking generator for log lines (stdout and stderr)
        # follow=True keeps the stream open until the container stops or stop_event is set.
        log_stream = container.logs(stream=True, follow=True, stdout=True, stderr=True)
        print(f"[Thread-{code_block_id}] Starting log iteration for container {container.short_id}")

        # Iterate through the log stream line by line
        for line_bytes in log_stream:
            # Check if the stop event has been set (e.g., by user cancellation)
            if stop_event.is_set():
                print(f"[Thread-{code_block_id}] Stop event set, breaking log iteration.")
                break # Exit the loop if stop is requested

            # Decode bytes to string, replacing errors
            line_str = line_bytes.decode('utf-8', errors='replace')

            # Schedule the asynchronous send_ws_message function to run on the main event loop
            # This is crucial for thread safety when interacting with asyncio objects like WebSockets.
            asyncio.run_coroutine_threadsafe(
                send_ws_message(websocket, "code_output", {
                    "code_block_id": code_block_id,
                    "stream": "stdout", # Simplification: send both stdout/stderr as stdout type for now
                    "data": line_str
                }),
                loop # Pass the main event loop
            )

        print(f"[Thread-{code_block_id}] Finished log iteration for container {container.short_id}")

    except Exception as e:
        # Handle exceptions during log streaming (e.g., container removed unexpectedly)
        print(f"[Thread-{code_block_id}] Error during log streaming: {e}")
        # Schedule sending an error message back to the client via the main loop
        asyncio.run_coroutine_threadsafe(
            send_ws_message(websocket, "code_output", {
                "code_block_id": code_block_id,
                "stream": "error", # Indicate an error stream
                "data": f"\n[Error streaming logs from container: {str(e)}]"
            }),
            loop
        )

async def stream_docker_logs_via_executor(websocket: WebSocket, container: Container, code_block_id: str, stop_event: asyncio.Event):
    """
    Asynchronously runs the synchronous log streamer function (`sync_log_streamer`)
    in a separate thread using asyncio's default executor.

    Args:
        websocket: The WebSocket connection.
        container: The Docker container object.
        code_block_id: Identifier for the code block.
        stop_event: Event to signal stopping the stream.
    """
    loop = asyncio.get_running_loop()
    print(f"Scheduling log streaming task in executor for {code_block_id}")
    # Run the blocking sync_log_streamer function in the thread pool executor
    await loop.run_in_executor(
        None, # Use the default executor
        sync_log_streamer, # The function to run
        # Arguments to pass to sync_log_streamer:
        container, websocket, code_block_id, loop, stop_event
    )
    print(f"Executor task for log streaming finished for {code_block_id}")


# --- Docker Code Execution Core Function ---

async def run_code_in_docker_stream(websocket: WebSocket, client_id: str, code_block_id: str, language: str, code: str):
    """
    Handles the complete process of running user-provided code in a Docker container:
    1. Validates language and Docker availability.
    2. Creates a temporary directory and writes the code to a file.
    3. Starts the appropriate Docker container based on the language config.
    4. Starts a background task to stream container logs back via WebSocket.
    5. Waits for the container to finish or timeout.
    6. Sends a final status message (success, error, timeout) via WebSocket.
    7. Cleans up the container and temporary directory.

    Args:
        websocket: The client's WebSocket connection.
        client_id: The unique ID of the client.
        code_block_id: Identifier for the specific code block being run.
        language: The programming language of the code (e.g., "python", "c++").
        code: The actual code string provided by the user.
    """
    # Get the initialized Docker client instance
    local_docker_client = get_docker_client()

    # Check if Docker client is available
    if not local_docker_client:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": "Docker service is unavailable on the server."
        })
        return

    # Validate the requested language against the configuration
    lang_key = language.lower()
    lang_config = config.SUPPORTED_LANGUAGES.get(lang_key)
    if not lang_config:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": f"Language '{language}' not supported for execution."
        })
        return

    # Extract language-specific configuration
    image_name = lang_config["image"]
    script_filename = lang_config["filename"]
    command = lang_config["command"]

    # Initialize variables for container, task, temp dir, and stop event
    container_obj: Container | None = None
    stream_task: asyncio.Task | None = None
    tmpdir_obj = None # To hold the TemporaryDirectory object for proper cleanup
    stop_event = asyncio.Event() # Event to signal cancellation to the streamer thread

    try:
        # Create a temporary directory to store the script file
        # Using 'with' ensures cleanup even if errors occur later, but we need the path
        # outside the 'with', so we create it manually and clean up in 'finally'.
        tmpdir_obj = tempfile.TemporaryDirectory()
        tmpdir = tmpdir_obj.name # Get the path string
        host_script_path = Path(tmpdir) / script_filename

        # Write the user's code to the script file inside the temp directory
        with open(host_script_path, "w", encoding="utf-8") as f:
            f.write(code)

        print(f"Attempting to run block {code_block_id} ({lang_key}) in Docker image {image_name}...")

        # Run the Docker container
        # This might implicitly pull the image if not found locally
        container_obj = local_docker_client.containers.run(
            image=image_name,
            command=command, # Command defined in config.py
            # Mount the temporary directory read-write into /app inside the container
            # Changed mode from 'ro' to 'rw' to allow compilation output
            volumes={tmpdir: {'bind': '/app', 'mode': 'rw'}}, # <<< CHANGED HERE
            working_dir='/app', # Set working directory inside the container
            mem_limit=config.DOCKER_MEM_LIMIT, # Apply memory limit from config
            stdout=True, # Capture stdout
            stderr=True, # Capture stderr
            detach=True, # Run the container in the background
            # auto_remove=True, # Cannot auto-remove if we need logs/exit code/manual stop
        )
        print(f"Container {container_obj.short_id} started for {code_block_id}")

        # Create and start the background task for streaming logs
        stream_task = asyncio.create_task(
            stream_docker_logs_via_executor(websocket, container_obj, code_block_id, stop_event),
            name=f"log_stream_{code_block_id}" # Name the task for easier debugging
        )

        # Add the running container info to the global state dictionary (thread-safe)
        async with state.running_containers_lock:
            # Check if another execution for the same block ID is already running
            if code_block_id in state.running_containers:
                # This shouldn't happen if frontend disables button, but handle defensively
                print(f"WARNING: Code block {code_block_id} was already running. Stopping previous run.")
                # Schedule stop_docker_container; do not await inside the lock
                asyncio.create_task(stop_docker_container(code_block_id))

            # Store container details in the shared state dictionary
            state.running_containers[code_block_id] = {
                "container": container_obj,
                "stream_task": stream_task,
                "client_id": client_id,
                "websocket": websocket,
                "stop_event": stop_event # Store the stop event for cancellation
            }

        # Wait for the container to finish execution (blocking call run in executor)
        print(f"Waiting for container {container_obj.short_id} ({code_block_id}) to finish...")
        loop = asyncio.get_running_loop()
        # container.wait() is blocking, so run it in the executor
        result = await loop.run_in_executor(
            None, # Use default executor
            lambda: container_obj.wait(timeout=config.DOCKER_TIMEOUT_SECONDS) # Wait with timeout
        )
        # Extract exit code and potential error message from the result
        exit_code = result.get("StatusCode", -1) # Default to -1 if status code missing
        error_msg = result.get("Error", None) # Docker daemon error message
        print(f"Container {container_obj.short_id} ({code_block_id}) finished. Result: {result}")

        # --- Container Finished Normally or Errored ---
        # Signal the log streaming thread that it can stop
        stop_event.set()
        try:
            # Wait briefly for the log streaming task to finish processing final logs
            await asyncio.wait_for(stream_task, timeout=5.0)
        except asyncio.TimeoutError:
            print(f"Warning: Log streaming task for {code_block_id} did not finish quickly after container exit.")
            # Cancel the task if it's still running after the timeout
            if stream_task and not stream_task.done():
                stream_task.cancel()
        except asyncio.CancelledError:
            # Expected if the task was cancelled during stop_docker_container
             print(f"Log streaming task for {code_block_id} was cancelled (likely during stop).")

        # Send the final result message to the client
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id,
            "exit_code": exit_code,
            "error": error_msg # Send Docker-level error if any (e.g., OOMKilled)
        })

    except asyncio.TimeoutError: # Timeout triggered by container_obj.wait()
        # Handle the case where the container ran longer than DOCKER_TIMEOUT_SECONDS
        print(f"ERROR: Docker execution timed out for block {code_block_id} after {config.DOCKER_TIMEOUT_SECONDS}s.")
        await send_ws_message(websocket, "code_finished", {
             "code_block_id": code_block_id, "exit_code": -1,
             "error": f"Execution timed out after {config.DOCKER_TIMEOUT_SECONDS} seconds."
        })
        # Schedule the container stop process in the background
        asyncio.create_task(stop_docker_container(code_block_id))

    except ImageNotFound:
        # Handle case where the specified Docker image doesn't exist locally and couldn't be pulled
        error_msg = f"Server Error: Docker image '{image_name}' not found. Please ensure it's pulled or available."
        print(f"ERROR for block {code_block_id}: {error_msg}")
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except APIError as e:
        # Handle errors from the Docker daemon API
        error_msg = f"Server Error: Docker API error: {e}"
        print(f"ERROR for block {code_block_id}: {error_msg}")
        traceback.print_exc() # Print full traceback for server logs
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except Exception as e:
        # Catch any other unexpected errors during setup or execution
        error_msg = f"Server Execution Error: An unexpected error occurred." # Generic message for client
        print(f"ERROR during Docker execution setup or wait for block {code_block_id}: {e}")
        traceback.print_exc() # Print full traceback for server logs
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
        # Ensure stream task is cancelled if it was started before the error
        if stream_task and not stream_task.done():
            print(f"Cancelling stream task for {code_block_id} due to setup/wait error.")
            stop_event.set() # Signal thread to stop
            stream_task.cancel()

    finally:
        # --- Final Cleanup ---
        # This block executes whether the try block succeeded or failed

        # Remove container info from tracking dict if it hasn't been removed already
        async with state.running_containers_lock:
            if code_block_id in state.running_containers:
                print(f"Performing final cleanup check for {code_block_id}")
                # Retrieve task and event references before deleting the entry
                task_to_cancel = state.running_containers[code_block_id].get("stream_task")
                stop_ev = state.running_containers[code_block_id].get("stop_event")
                # Ensure task is stopped and cancelled if still running
                if task_to_cancel and not task_to_cancel.done():
                    print(f"Final cleanup: Cancelling stream task for {code_block_id}")
                    if stop_ev: stop_ev.set() # Signal thread
                    task_to_cancel.cancel()
                # Remove the entry from the tracking dictionary
                del state.running_containers[code_block_id]
                print(f"Removed {code_block_id} from running_containers during final cleanup")

        # Ensure the Docker container is removed
        if container_obj:
            try:
                # Need to run blocking Docker SDK calls in an executor thread
                loop = asyncio.get_running_loop()
                # Check if container still exists before trying to remove
                await loop.run_in_executor(None, container_obj.reload)
                print(f"Removing container {container_obj.short_id} ({code_block_id}) in final cleanup")
                # Force remove the container
                await loop.run_in_executor(None, lambda: container_obj.remove(force=True))
            except NotFound:
                # Container was already removed (e.g., by stop_docker_container)
                 print(f"Container {container_obj.short_id} already removed.")
            except Exception as rm_err:
                # Log error if removal fails for some other reason
                 print(f"Error removing container {container_obj.short_id} in final cleanup: {rm_err}")

        # Clean up the temporary directory
        if tmpdir_obj:
             try:
                 tmpdir_obj.cleanup() # Deletes the temporary directory and its contents
             except Exception as cleanup_err:
                 print(f"Error cleaning up temp directory {tmpdir_obj.name}: {cleanup_err}")


# --- Container Stopping Logic ---

async def stop_docker_container(code_block_id: str):
    """
    Stops a specific running Docker container identified by code_block_id.
    Handles cancelling the log stream task and removing the container.

    Args:
        code_block_id: The identifier of the code block whose container needs stopping.
    """
    print(f"Attempting to stop execution for code block: {code_block_id}")
    loop = asyncio.get_running_loop()
    container_info = None
    container_obj = None
    stream_task = None
    websocket = None
    stop_event = None

    # Safely access and remove the container info from the shared state
    async with state.running_containers_lock:
        if code_block_id in state.running_containers:
            # Pop the entry to prevent race conditions with other stop requests or cleanup
            container_info = state.running_containers.pop(code_block_id)
            container_obj = container_info.get("container")
            stream_task = container_info.get("stream_task")
            websocket = container_info.get("websocket") # Get websocket for final message
            stop_event = container_info.get("stop_event")
            print(f"Found and removed running container info for {code_block_id} from tracking.")
        else:
            # If not found, it might have finished or been stopped already
            print(f"Stop request for {code_block_id}, but it was not found in running_containers.")
            return # Nothing further to do

    # --- Perform actions outside the lock ---

    # 1. Signal the streaming thread to stop and cancel the asyncio task
    if stop_event:
        print(f"Setting stop event for {code_block_id}")
        stop_event.set()
    if stream_task and not stream_task.done():
        print(f"Cancelling stream task for {code_block_id}")
        stream_task.cancel()
        try:
            # Wait briefly for cancellation to be processed
            await asyncio.wait_for(stream_task, timeout=1.0)
        except asyncio.TimeoutError:
            print(f"Stream task for {code_block_id} did not cancel quickly.")
        except asyncio.CancelledError:
            print(f"Stream task for {code_block_id} cancelled successfully.")
            pass # Expected outcome

    # 2. Stop the Docker container (run blocking calls in executor)
    if container_obj:
        try:
            print(f"Stopping container {container_obj.short_id} ({code_block_id})...")
            # container.stop() is blocking
            await loop.run_in_executor(None, lambda: container_obj.stop(timeout=5))
            print(f"Container {container_obj.short_id} stopped.")
        except Exception as stop_err:
            # If stop fails (e.g., timeout), attempt to kill the container
            print(f"Error stopping container {container_obj.short_id}, attempting kill: {stop_err}")
            try:
                # container.kill() is blocking
                await loop.run_in_executor(None, container_obj.kill)
                print(f"Container {container_obj.short_id} killed.")
            except Exception as kill_err:
                # Ignore "No such container" error if already gone, log others
                 if "No such container" not in str(kill_err):
                     print(f"Error killing container {container_obj.short_id}: {kill_err}")

        # 3. Remove the Docker container (run blocking call in executor)
        try:
            print(f"Removing container {container_obj.short_id} ({code_block_id}) after stop request.")
            # container.remove() is blocking
            await loop.run_in_executor(None, lambda: container_obj.remove(force=True))
        except NotFound:
            pass # Container already removed
        except Exception as rm_err:
            print(f"Error removing container {container_obj.short_id} after stop: {rm_err}")

    # 4. Send final "stopped by user" message if WebSocket is still valid
    if websocket: # Check if websocket reference exists
         try:
             await send_ws_message(websocket, "code_finished", {
                 "code_block_id": code_block_id,
                 "exit_code": -1, # Indicate abnormal termination
                 "error": "Execution stopped by user."
             })
         except Exception as send_err:
              print(f"Error sending stop confirmation for {code_block_id}: {send_err}")
    else:
         print(f"Cannot send stop confirmation for {code_block_id}, WebSocket reference lost.")


# --- Client Disconnect Cleanup ---

async def cleanup_client_containers(client_id: str):
    """
    Stops and cleans up all running Docker containers associated with a specific client ID
    when that client disconnects.

    Args:
        client_id: The ID of the client that disconnected.
    """
    print(f"Cleaning up containers for disconnected client: {client_id}")
    containers_to_stop = []
    # Safely get a list of code_block_ids associated with the disconnected client
    async with state.running_containers_lock:
        # List comprehension to find matching client_id
        ids_for_client = [
            cb_id for cb_id, info in state.running_containers.items()
            if info.get("client_id") == client_id
        ]
        containers_to_stop.extend(ids_for_client)

    # Stop each container concurrently using asyncio.gather
    if containers_to_stop:
        print(f"Found containers to stop for client {client_id}: {containers_to_stop}")
        # Create a list of stop tasks
        stop_tasks = [stop_docker_container(cb_id) for cb_id in containers_to_stop]
        # Run tasks concurrently and gather results (including exceptions)
        results = await asyncio.gather(*stop_tasks, return_exceptions=True)
        # Log any errors that occurred during the cleanup stops
        for i, result in enumerate(results):
             if isinstance(result, Exception):
                 print(f"Error during cleanup stop for {containers_to_stop[i]}: {result}")
        print(f"Finished cleanup for client {client_id}")
    else:
        print(f"No running containers found for client {client_id} during cleanup.")



=== app/email_utils.py ===
# app/email_utils.py
from fastapi_mail import FastMail, MessageSchema, ConnectionConfig
from pathlib import Path
import traceback
from . import config # Import your config module

# Create the ConnectionConfig using settings from config.py
conf = ConnectionConfig(
    MAIL_USERNAME=config.MAIL_CONFIG.get("MAIL_USERNAME"),
    MAIL_PASSWORD=config.MAIL_CONFIG.get("MAIL_PASSWORD"),
    MAIL_FROM=config.MAIL_CONFIG.get("MAIL_FROM"),
    MAIL_PORT=config.MAIL_CONFIG.get("MAIL_PORT", 587),
    MAIL_SERVER=config.MAIL_CONFIG.get("MAIL_SERVER"),
    MAIL_FROM_NAME=config.MAIL_CONFIG.get("MAIL_FROM_NAME"),
    MAIL_STARTTLS=config.MAIL_CONFIG.get("MAIL_STARTTLS", True),
    MAIL_SSL_TLS=config.MAIL_CONFIG.get("MAIL_SSL_TLS", False),
    USE_CREDENTIALS=config.MAIL_CONFIG.get("USE_CREDENTIALS", True),
    VALIDATE_CERTS=config.MAIL_CONFIG.get("VALIDATE_CERTS", True)
)

# Initialize FastMail instance
fm = FastMail(conf)

async def send_registration_password_email(
    recipient_email: str,
    recipient_name: str,
    generated_password: str,
    login_url: str # URL to your login page
) -> bool:
    """
    Sends the auto-generated password to a new user using FastMail.
    """
    if not conf.MAIL_FROM or not conf.MAIL_SERVER: # Basic check
        print("EMAIL ERROR: Mail configuration (MAIL_FROM, MAIL_SERVER) is incomplete. Cannot send registration password email.")
        return False

    subject = "Welcome to Tesseracs Chat - Your Account Details"
    html_body = f"""
    <html>
    <head>
        <style>
            body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0; background-color: #f4f4f4; }}
            .email-container {{ width: 100%; max-width: 600px; margin: 20px auto; background-color: #ffffff; padding: 20px; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
            .header {{ text-align: center; padding-bottom: 20px; border-bottom: 1px solid #eee; }}
            .header h2 {{ color: #2563eb; margin: 0; }}
            .content p {{ margin: 15px 0; }}
            .content strong {{ color: #1d4ed8; }}
            .password-display {{
                background-color: #e9ecef;
                padding: 12px;
                border-radius: 4px;
                font-family: 'Courier New', Courier, monospace;
                font-size: 1.1em;
                text-align: center;
                margin: 20px 0;
                color: #000;
                border: 1px dashed #ccc;
            }}
            .login-button-container {{ text-align: center; margin: 25px 0; }}
            .login-button {{
                display: inline-block;
                background-color: #2563eb;
                color: white !important; /* Important for link inside button */
                padding: 12px 25px;
                text-decoration: none;
                border-radius: 5px;
                font-size: 16px;
                font-weight: bold;
                transition: background-color 0.3s ease;
            }}
            .login-button:hover {{ background-color: #1d4ed8; }}
            .footer {{ text-align: center; margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee; font-size: 0.9em; color: #777; }}
            .link {{ color: #2563eb; text-decoration: none; }}
            .link:hover {{ text-decoration: underline; }}
        </style>
    </head>
    <body>
        <div class="email-container">
            <div class="header">
                <h2>Welcome to Tesseracs Chat, {recipient_name}!</h2>
            </div>
            <div class="content">
                <p>Your account has been successfully created.</p>
                <p>Your email: <strong>{recipient_email}</strong></p>
                <p>Your temporary password is:</p>
                <div class="password-display">{generated_password}</div>
                <p>Please use this password to log in. You can log in here:</p>
                <div class="login-button-container">
                    <a href="{login_url}" class="login-button">Log In to Tesseracs Chat</a>
                </div>
                <p>If the button doesn't work, copy and paste this link into your browser:</p>
                <p><a href="{login_url}" class="link">{login_url}</a></p>
                <p>We recommend that you keep this password secure. If a password change feature becomes available in the future, consider using it.</p>
                <p>If you did not request this account, please ignore this email.</p>
            </div>
            <div class="footer">
                <p>Thanks,<br>The Tesseracs Chat Team</p>
                <p><small>This is an automated message. Please do not reply directly to this email.</small></p>
            </div>
        </div>
    </body>
    </html>
    """

    message = MessageSchema(
        subject=subject,
        recipients=[recipient_email],
        body=html_body,
        subtype="html"
    )

    try:
        print(f"EMAIL: Attempting to send registration password to {recipient_email} via {conf.MAIL_SERVER}:{conf.MAIL_PORT}")
        await fm.send_message(message)
        print(f"EMAIL: Registration password email successfully sent to {recipient_email}.")
        return True # Indicate success
    except Exception as e:
        print(f"EMAIL ERROR: Failed to send registration password email to {recipient_email}")
        print(f"EMAIL ERROR DETAILS: {type(e).__name__} - {e}")
        traceback.print_exc()
        return False # Indicate failure

async def send_password_reset_email(
    recipient_email: str,
    recipient_name: str,
    new_password: str,
    login_url: str
) -> bool:
    """
    Sends an email containing a newly generated password after a reset request.
    """
    if not conf.MAIL_FROM or not conf.MAIL_SERVER:
        print("EMAIL ERROR: Mail configuration (MAIL_FROM, MAIL_SERVER) is incomplete. Cannot send password reset email.")
        return False

    subject = "Your Tesseracs Chat Password Has Been Reset"
    # Use the same styling as the registration email for consistency
    html_body = f"""
    <html>
    <head>
        <style>
            body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0; background-color: #f4f4f4; }}
            .email-container {{ width: 100%; max-width: 600px; margin: 20px auto; background-color: #ffffff; padding: 20px; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
            .header {{ text-align: center; padding-bottom: 20px; border-bottom: 1px solid #eee; }}
            .header h2 {{ color: #2563eb; margin: 0; }}
            .content p {{ margin: 15px 0; }}
            .content strong {{ color: #1d4ed8; }}
            .password-display {{
                background-color: #e9ecef;
                padding: 12px;
                border-radius: 4px;
                font-family: 'Courier New', Courier, monospace;
                font-size: 1.1em;
                text-align: center;
                margin: 20px 0;
                color: #000;
                border: 1px dashed #ccc;
            }}
            .login-button-container {{ text-align: center; margin: 25px 0; }}
            .login-button {{
                display: inline-block;
                background-color: #2563eb;
                color: white !important;
                padding: 12px 25px;
                text-decoration: none;
                border-radius: 5px;
                font-size: 16px;
                font-weight: bold;
                transition: background-color 0.3s ease;
            }}
            .login-button:hover {{ background-color: #1d4ed8; }}
            .footer {{ text-align: center; margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee; font-size: 0.9em; color: #777; }}
            .link {{ color: #2563eb; text-decoration: none; }}
            .link:hover {{ text-decoration: underline; }}
        </style>
    </head>
    <body>
        <div class="email-container">
            <div class="header">
                <h2>Password Reset for Tesseracs Chat</h2>
            </div>
            <div class="content">
                <p>Hello {recipient_name},</p>
                <p>As requested, your password for Tesseracs Chat has been reset.</p>
                <p>Your email: <strong>{recipient_email}</strong></p>
                <p>Your new temporary password is:</p>
                <div class="password-display">{new_password}</div>
                <p>Please use this new password to log in. You can log in here:</p>
                <div class="login-button-container">
                    <a href="{login_url}" class="login-button">Log In to Tesseracs Chat</a>
                </div>
                <p>If the button doesn't work, copy and paste this link into your browser:</p>
                <p><a href="{login_url}" class="link">{login_url}</a></p>
                <p>If you did not request a password reset, please contact support or secure your account immediately.</p>
            </div>
            <div class="footer">
                <p>Thanks,<br>The Tesseracs Chat Team</p>
                <p><small>This is an automated message. Please do not reply directly to this email.</small></p>
            </div>
        </div>
    </body>
    </html>
    """

    message = MessageSchema(
        subject=subject,
        recipients=[recipient_email],
        body=html_body,
        subtype="html"
    )

    try:
        print(f"EMAIL: Attempting to send password reset to {recipient_email} via {conf.MAIL_SERVER}:{conf.MAIL_PORT}")
        await fm.send_message(message)
        print(f"EMAIL: Password reset email successfully sent to {recipient_email}.")
        return True
    except Exception as e:
        print(f"EMAIL ERROR: Failed to send password reset email to {recipient_email}")
        print(f"EMAIL ERROR DETAILS: {type(e).__name__} - {e}")
        traceback.print_exc()
        return False


=== app/llm.py ===
--- CONTENT EXCLUDED (listed in exclude_files) ---


=== app/main.py ===
# app/main.py

from pydantic import BaseModel, Field, EmailStr

import os
import sys
import uvicorn
import webbrowser
import traceback
from pathlib import Path
import asyncio
import json
import sqlite3
import uuid
from fastapi import (
    FastAPI,
    Request,
    HTTPException,
    WebSocket,
    WebSocketDisconnect,
    Form,
    Depends,
    Response as FastAPIResponse,
    Path as FastApiPath,
    Body,
    status
)
from fastapi.responses import HTMLResponse, FileResponse, RedirectResponse
from fastapi.security import OAuth2PasswordRequestForm
from fastapi.staticfiles import StaticFiles
from fastapi.websockets import WebSocketState
import datetime
from typing import Optional, Dict, Any, List

# Project local imports
from . import config
from . import state
from . import llm
from . import docker_utils
from . import utils
from . import database
from . import auth
from .auth import Token as AuthTokenResponse # Use renamed Token model
from . import email_utils

# --- FastAPI App Initialization ---
app = FastAPI(title="Tesseracs Chat")

# --- Pydantic Models ---
class SessionUpdateRequest(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)

class UserResponseModel(BaseModel): # For /api/me
    id: int
    name: str
    email: str

class EmailCheckRequest(BaseModel):
    email: EmailStr

class EmailCheckResponse(BaseModel):
    exists: bool
    user_name: Optional[str] = None

class RegistrationRequest(BaseModel):
    email: EmailStr
    name: str = Field(..., min_length=1, max_length=100)

class RegistrationResponse(BaseModel):
    message: str

# --- ADDED: Pydantic models for Forgot Password ---
class ForgotPasswordRequest(BaseModel):
    email: EmailStr

class ForgotPasswordResponse(BaseModel):
    message: str
# --- END ADDED ---

# --- Database Initialization on Startup ---
@app.on_event("startup")
async def startup_event():
    print("Application startup: Initializing database...")
    database.DATABASE_PATH.parent.mkdir(parents=True, exist_ok=True)
    database.init_db()
    print("Database initialization check complete.")
    if docker_utils.get_docker_client() is None:
        print("WARNING: Docker client unavailable during startup.")
    else:
        print("Docker client confirmed available at startup.")
    try:
        llm.get_model()
        print("LLM model connection checked successfully.")
    except Exception as e:
        print(f"CRITICAL ERROR during startup LLM check: {e}")


# --- Static Files Setup ---
if not config.STATIC_DIR or not config.STATIC_DIR.is_dir():
    sys.exit(f"CRITICAL ERROR: Base static directory invalid: {config.STATIC_DIR}")
dist_dir = config.STATIC_DIR / "dist"
if not dist_dir.is_dir():
    sys.exit(f"CRITICAL ERROR: Bundled assets dir not found: {dist_dir}. Run 'npm run build'.")
app.mount("/dist", StaticFiles(directory=dist_dir), name="dist_assets")
app.mount("/static", StaticFiles(directory=config.STATIC_DIR), name="static_pages")
print(f"Mounted bundled assets from '{dist_dir}' at '/dist'")
print(f"Mounted static pages directory '{config.STATIC_DIR}' at '/static'")


# --- Authentication & User Routes ---

@app.post("/token", response_model=AuthTokenResponse, tags=["Authentication"])
async def login_for_access_token(
    response: FastAPIResponse,
    form_data: OAuth2PasswordRequestForm = Depends()
):
    """Handles email/password login, sets session cookie."""
    email = form_data.username.lower().strip()
    password = form_data.password
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT id, name, email, password_hash, is_active FROM users WHERE email = ?", (email,))
        user_row = cursor.fetchone()
        if not user_row:
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect email or password.")

        user = dict(user_row)
        stored_password_hash = user.get("password_hash")
        if not stored_password_hash or not auth.verify_password(password, stored_password_hash):
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect email or password.")

        if not user["is_active"]:
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Account is inactive.")

        session_token_raw = await auth.create_user_session(response=response, user_id=user["id"])
        print(f"AUTH (/token): User '{email}' (ID: {user['id']}) logged in successfully.")
        return AuthTokenResponse(
            access_token=session_token_raw, token_type="bearer",
            user_id=user["id"], user_name=user["name"], user_email=user["email"]
        )
    except HTTPException as http_exc: raise http_exc
    except sqlite3.Error as db_err:
        print(f"API ERROR (/token): DB error for {email}: {db_err}"); traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error during login.")
    except Exception as e:
        print(f"API ERROR (/token): Unexpected error for {email}: {e}"); traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Unexpected server error during login.")
    finally:
        if conn: conn.close()


@app.post("/check_email", response_model=EmailCheckResponse, tags=["Authentication"])
async def check_email_exists(request_data: EmailCheckRequest):
    """Checks if an email exists in the database."""
    email_to_check = request_data.email.lower()
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT id, name FROM users WHERE email = ?", (email_to_check,))
        user_row = cursor.fetchone()
        if user_row:
            return EmailCheckResponse(exists=True, user_name=user_row["name"])
        else:
            return EmailCheckResponse(exists=False)
    except sqlite3.Error as db_err:
        print(f"API ERROR (/check_email): DB error for {email_to_check}: {db_err}"); traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error checking email.")
    except Exception as e:
        print(f"API ERROR (/check_email): Unexpected error for {email_to_check}: {e}"); traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Unexpected server error checking email.")
    finally:
        if conn: conn.close()


@app.post("/register", response_model=RegistrationResponse, tags=["Authentication"])
async def register_new_user(request_data: RegistrationRequest, request: Request):
    """Registers a new user, hashes password, emails generated password."""
    email = request_data.email.lower().strip()
    name = request_data.name.strip()
    if not name: raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Name cannot be empty.")
    conn = None
    try:
        conn = database.get_db_connection(); cursor = conn.cursor()
        cursor.execute("SELECT id FROM users WHERE email = ?", (email,))
        if cursor.fetchone(): raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Email already registered.")

        plain_password = database.generate_secure_token(12)
        hashed_password = auth.get_password_hash(plain_password) # Use passlib

        cursor.execute("INSERT INTO users (name, email, password_hash, is_active) VALUES (?, ?, ?, ?)", (name, email, hashed_password, True))
        user_id = cursor.lastrowid
        if not user_id: conn.rollback(); raise sqlite3.Error("Failed to get lastrowid.")

        base_url = str(request.base_url).rstrip('/'); login_page_url = f"{base_url}{request.url_for('get_login_page_route')}"
        email_sent = await email_utils.send_registration_password_email(
            recipient_email=email, recipient_name=name, generated_password=plain_password, login_url=login_page_url
        )
        if not email_sent:
            conn.commit(); print(f"User {email} created (ID: {user_id}), but password email FAILED.")
            raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail="Account created, but failed to send password email.")

        conn.commit(); print(f"New user registered: {email} (ID: {user_id}). Password email sent.")
        return RegistrationResponse(message="Account created! Temporary password sent to your email.")
    except HTTPException as http_exc:
        if conn: conn.rollback(); raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback(); print(f"API ERROR (/register): DB error for {email}: {db_err}"); traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error during registration.")
    except Exception as e:
        if conn: conn.rollback(); print(f"API ERROR (/register): Unexpected error for {email}: {e}"); traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Unexpected server error during registration.")
    finally:
        if conn: conn.close()

# --- ADDED: Forgot Password Endpoint ---
@app.post("/forgot_password", response_model=ForgotPasswordResponse, tags=["Authentication"])
async def handle_forgot_password(
    request_data: ForgotPasswordRequest,
    request: Request # To construct login URL for email
):
    """
    Handles a forgot password request. If the email exists, generates a new
    password, updates it in the database, and emails the new password to the user.
    """
    email = request_data.email.lower().strip()
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()

        # Find the user by email
        cursor.execute("SELECT id, name FROM users WHERE email = ? AND is_active = 1", (email,))
        user_row = cursor.fetchone()

        if not user_row:
            # IMPORTANT: Do not reveal if the email exists or not for security.
            # Send a generic success message regardless.
            print(f"AUTH (/forgot_password): Request received for non-existent or inactive email: {email}")
            return ForgotPasswordResponse(message="If an account with this email exists, a password reset email has been sent.")

        user = dict(user_row)
        user_id = user["id"]
        user_name = user["name"]

        # Generate a new random password
        new_plain_password = database.generate_secure_token(12)
        new_hashed_password = auth.get_password_hash(new_plain_password)

        # Update the user's password hash in the database
        cursor.execute("UPDATE users SET password_hash = ? WHERE id = ?", (new_hashed_password, user_id))
        if cursor.rowcount == 0:
            # Should not happen if we just found the user, but handle defensively
            conn.rollback()
            print(f"AUTH ERROR (/forgot_password): Failed to update password hash for user {user_id} ({email}).")
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to update password.")

        # Send the password reset email
        base_url = str(request.base_url).rstrip('/')
        login_page_url = f"{base_url}{request.url_for('get_login_page_route')}"
        email_sent = await email_utils.send_password_reset_email(
            recipient_email=email,
            recipient_name=user_name,
            new_password=new_plain_password, # Send the plain text new password
            login_url=login_page_url
        )

        if not email_sent:
            # If email fails, roll back the password change in the DB to avoid confusion.
            # The user's old password remains valid.
            conn.rollback()
            print(f"AUTH ERROR (/forgot_password): Password reset email FAILED to send for user {user_id} ({email}). DB changes rolled back.")
            raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail="Failed to send password reset email. Please try again.")

        # Commit the password change ONLY if the email was sent successfully
        conn.commit()
        print(f"AUTH (/forgot_password): Password reset successful for user {user_id} ({email}). New password email sent.")
        return ForgotPasswordResponse(message="If an account with this email exists, a password reset email has been sent.")

    except HTTPException as http_exc:
        # Don't rollback here if it's just a 404 simulated response
        if http_exc.status_code != status.HTTP_404_NOT_FOUND:
             if conn: conn.rollback()
        raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        print(f"API ERROR (/forgot_password): DB error for {email}: {db_err}"); traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error processing request.")
    except Exception as e:
        if conn: conn.rollback()
        print(f"API ERROR (/forgot_password): Unexpected error for {email}: {e}"); traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Unexpected server error processing request.")
    finally:
        if conn: conn.close()
# --- END ADDED ---


@app.get("/login", response_class=HTMLResponse, name="get_login_page_route", tags=["Pages"])
async def get_login_page_route(request: Request, user: Optional[Dict] = Depends(auth.get_current_user)):
    """Serves the login page or redirects if already logged in."""
    if user:
        return RedirectResponse(url=request.url_for("get_session_choice_page"), status_code=status.HTTP_302_FOUND)
    login_html_path = config.STATIC_DIR / "login.html"
    if not login_html_path.is_file(): raise HTTPException(status_code=404, detail="login.html not found.")
    return FileResponse(login_html_path)


@app.get("/logout", tags=["Authentication"])
async def logout_route(response: FastAPIResponse, session_token_value: Optional[str] = Depends(auth.cookie_scheme)):
    """Logs the user out by invalidating the session and clearing the cookie."""
    await auth.logout_user(response, session_token_value)
    return RedirectResponse(url="/login", status_code=status.HTTP_302_FOUND)


@app.get("/api/me", response_model=UserResponseModel, tags=["Users"])
async def get_current_user_details(user: Dict[str, Any] = Depends(auth.get_current_active_user)):
    """Gets details for the currently authenticated user."""
    if not user: raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")
    if not all(key in user for key in ["id", "name", "email"]):
        print(f"ERROR /api/me: User dict missing keys. User: {user}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="User data incomplete.")
    return UserResponseModel(id=user["id"], name=user["name"], email=user["email"])

# --- Main Application Routes (Protected) ---

@app.get("/", response_class=HTMLResponse, name="get_session_choice_page", tags=["Pages"])
async def get_session_choice_page(request: Request, user: Optional[Dict] = Depends(auth.get_current_active_user)):
    """Serves the session choice/dashboard page."""
    if not user:
        return RedirectResponse(url="/login", status_code=status.HTTP_302_FOUND)

    session_choice_html_path = config.STATIC_DIR / "session-choice.html"
    if not session_choice_html_path.is_file():
        raise HTTPException(status_code=404, detail="session-choice.html not found.")
    try:
        with open(session_choice_html_path, "r", encoding="utf-8") as f: html_content = f.read()
        # Consider passing user data via context if using a template engine
        # For simple replacement:
        html_content = html_content.replace("[User Name]", user.get("name", "User"))
        return HTMLResponse(content=html_content)
    except Exception as e:
        print(f"Error reading/serving session-choice.html: {e}"); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Error loading session choice page.")


@app.post("/sessions/create", status_code=status.HTTP_303_SEE_OTHER, tags=["Sessions"]) # Use 303 for POST-redirect-GET
async def create_new_session_route(
    request: Request,
    user: Dict[str, Any] = Depends(auth.get_current_active_user)
):
    """Creates a new chat session and redirects to it."""
    if not user: # Should be handled by Depends, but belt-and-suspenders
        raise HTTPException(status_code=401, detail="Not authenticated")

    new_session_id = str(uuid.uuid4())
    host_user_id = user["id"]
    conn = None
    default_session_name = ""

    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()

        # Insert session first
        cursor.execute(
            """INSERT INTO sessions (id, host_user_id, name, is_active) VALUES (?, ?, ?, ?)""",
            (new_session_id, host_user_id, None, True)
        )

        # Get creation timestamp to generate default name
        cursor.execute("SELECT created_at FROM sessions WHERE id = ?", (new_session_id,))
        session_row = cursor.fetchone()

        if not session_row or not session_row["created_at"]:
            default_session_name = f"Session ({new_session_id[:4]})"
            print(f"WARNING: Could not fetch created_at for session {new_session_id}. Using fallback name.")
        else:
            try:
                # Attempt to parse ISO format timestamp (adjust if your DB stores differently)
                created_at_str = session_row["created_at"].replace('Z', '+00:00') # Handle Z for UTC
                created_dt = datetime.datetime.fromisoformat(created_at_str)
                # Format timestamp for default name (adjust format as desired)
                default_session_name = created_dt.strftime("%b %d, %Y %I:%M %p")
            except (ValueError, TypeError) as fmt_err:
                print(f"WARNING: Error formatting timestamp '{session_row['created_at']}': {fmt_err}. Using fallback name.")
                default_session_name = f"Session ({new_session_id[:4]})"

        # Update session name with the generated default
        cursor.execute("UPDATE sessions SET name = ? WHERE id = ?", (default_session_name, new_session_id))

        # Add creator as participant
        cursor.execute(
            "INSERT INTO session_participants (session_id, user_id) VALUES (?, ?)",
            (new_session_id, host_user_id)
        )

        conn.commit()
        print(f"New session created: ID {new_session_id}, Name: '{default_session_name}', Hosted by User ID {host_user_id}")

    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        print(f"Database error creating session: {db_err}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Could not create new session due to a database error.")
    except Exception as e:
        if conn: conn.rollback()
        print(f"Unexpected error creating session: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Could not create new session due to a server error.")
    finally:
        if conn: conn.close()

    chat_url = request.url_for("get_chat_page_for_session", session_id=new_session_id)
    # Use 303 See Other for redirect after POST
    return RedirectResponse(url=str(chat_url), status_code=status.HTTP_303_SEE_OTHER)


@app.get("/chat/{session_id}", response_class=HTMLResponse, name="get_chat_page_for_session", tags=["Pages"])
async def get_chat_page_for_session(
    request: Request,
    session_id: str = FastApiPath(..., description="The ID of the chat session to load."),
    user: Optional[Dict] = Depends(auth.get_current_active_user)
):
    """Serves the chat page for a specific session after verifying access."""
    if not user:
        return RedirectResponse(url="/login", status_code=status.HTTP_302_FOUND)

    user_id = user['id']
    conn = None
    try:
        conn = database.get_db_connection(); cursor = conn.cursor()
        # Verify session exists and is active
        cursor.execute("SELECT id, name FROM sessions WHERE id = ? AND is_active = 1", (session_id,))
        session_row = cursor.fetchone()
        if not session_row:
            raise HTTPException(status_code=404, detail="Chat session not found or is inactive.")
        # Verify user is a participant
        cursor.execute("SELECT 1 FROM session_participants WHERE session_id = ? AND user_id = ?", (session_id, user_id))
        if not cursor.fetchone():
            raise HTTPException(status_code=403, detail="You do not have access to this chat session.")

        # Update last_accessed_at for the session
        current_time_utc_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        cursor.execute("UPDATE sessions SET last_accessed_at = ? WHERE id = ?", (current_time_utc_iso, session_id))
        conn.commit()

        print(f"User {user['email']} accessing chat for session: {session_id}. Last accessed updated.")
    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except Exception as e:
        if conn: conn.rollback()
        print(f"Error verifying session access or updating last_accessed_at: {e}"); traceback.print_exc();
        raise HTTPException(status_code=500, detail="Error verifying session access.")
    finally:
        if conn: conn.close()

    chat_html_path = config.STATIC_DIR / "chat-session.html"
    if not chat_html_path.is_file():
        raise HTTPException(status_code=404, detail="Chat interface file not found.")
    # Consider passing session_name or user_name to the template if needed
    return FileResponse(chat_html_path)


# --- WebSocket Handler ---
async def handle_chat_message(
    chain: Any, memory: Any, websocket: WebSocket, client_js_id: str,
    current_user: Dict, session_id: str, user_input: str
):
    """Handles processing a chat message and streaming the response."""
    user_name = current_user.get('name', 'User')
    user_db_id = current_user['id']
    full_response = ""
    thinking_content = None # Placeholder for potential future thinking extraction
    db_conn_user_msg = None

    # Save user message to DB
    try:
        db_conn_user_msg = database.get_db_connection()
        db_cursor_user_msg = db_conn_user_msg.cursor()
        db_cursor_user_msg.execute(
            """INSERT INTO chat_messages (session_id, user_id, sender_name, sender_type, content, client_id_temp)
               VALUES (?, ?, ?, ?, ?, ?)""",
            (session_id, user_db_id, user_name, 'user', user_input, client_js_id)
        )
        db_conn_user_msg.commit()
    except Exception as db_err:
        print(f"DB ERROR saving user message for session {session_id} (client {client_js_id}): {db_err}")
        if db_conn_user_msg: db_conn_user_msg.rollback()
    finally:
        if db_conn_user_msg: db_conn_user_msg.close()

    # Process message with LLM chain and stream response
    try:
        async for chunk_data in chain.astream({"input": user_input}):
            # Extract content and potentially thinking steps if your chain provides them
            # This part depends heavily on your specific LangChain setup
            if isinstance(chunk_data, dict):
                # Example: Check for specific keys if your chain yields dicts
                chunk_str = chunk_data.get("answer", "") # Or whatever key holds the main response
                # thinking_step = chunk_data.get("intermediate_steps", "") # Example
                # if thinking_step: appendRawTextToThinkingArea(thinking_step) # Send thinking via WS if needed
            else:
                chunk_str = str(chunk_data) # Assume simple string chunks

            if websocket.client_state != WebSocketState.CONNECTED:
                print(f"WS: WebSocket disconnected during LLM stream for session {session_id}. Aborting.")
                return
            await websocket.send_text(chunk_str)
            full_response += chunk_str
    except Exception as chain_exc:
        error_msg = f"<ERROR>LLM Error: Processing your message failed. Please try again. Details: {chain_exc}"
        print(f"LLM chain error for session {session_id} (client {client_js_id}): {chain_exc}")
        traceback.print_exc()
        if websocket.client_state == WebSocketState.CONNECTED:
            try: await websocket.send_text(error_msg)
            except Exception as send_err: print(f"WS ERROR: Could not send LLM error to client {client_js_id}: {send_err}")
        return # Stop processing on chain error

    # After successful streaming
    if websocket.client_state == WebSocketState.CONNECTED:
        try:
            await websocket.send_text("<EOS>") # Send End-Of-Stream marker

            # Save context to the in-memory object
            memory.save_context({"input": user_input}, {"output": full_response})
            print(f"WS: Context saved to in-memory object for session {session_id} (client {client_js_id}).")

            # Save memory state to database
            if state and hasattr(state, 'save_memory_state_to_db'):
                try: state.save_memory_state_to_db(session_id, memory)
                except Exception as save_mem_err: print(f"ERROR saving memory state to DB for session {session_id}: {save_mem_err}")
            else: print(f"Warning: state.save_memory_state_to_db function not found. Memory not persisted.")

            # Save AI message to DB (including thinking content if captured)
            db_conn_ai_msg = None
            try:
                db_conn_ai_msg = database.get_db_connection()
                db_cursor_ai_msg = db_conn_ai_msg.cursor()
                db_cursor_ai_msg.execute(
                    """INSERT INTO chat_messages (session_id, user_id, sender_name, sender_type, content, thinking_content, client_id_temp)
                       VALUES (?, ?, ?, ?, ?, ?, ?)""",
                    (session_id, None, "AI", 'ai', full_response, thinking_content, client_js_id) # Add thinking_content
                )
                db_conn_ai_msg.commit()
            except Exception as db_err:
                print(f"DB ERROR saving AI message for session {session_id} (client {client_js_id}): {db_err}")
                if db_conn_ai_msg: db_conn_ai_msg.rollback()
            finally:
                if db_conn_ai_msg: db_conn_ai_msg.close()

        except Exception as post_stream_err:
            print(f"CHAT ERROR: Post-stream processing for session {session_id} (client {client_js_id}): {post_stream_err}")
            traceback.print_exc()


@app.websocket("/ws/{session_id_ws}/{client_js_id}")
async def websocket_endpoint(
    websocket: WebSocket,
    session_id_ws: str = FastApiPath(..., title="Session ID", description="The ID of the chat session."),
    client_js_id: str = FastApiPath(..., title="Client JS ID", description="A unique ID generated by the client-side JavaScript.")
):
    """Handles WebSocket connections for chat sessions."""
    # Authenticate user via session cookie
    session_token_from_cookie = websocket.cookies.get(auth.SESSION_COOKIE_NAME)
    current_ws_user: Optional[Dict[str, Any]] = None
    if session_token_from_cookie:
        current_ws_user = await auth.get_user_by_session_token(session_token_from_cookie)

    ws_log_prefix_unauth = f"WS ({websocket.client.host}:{websocket.client.port}) session {session_id_ws}, client {client_js_id}:"
    if not current_ws_user:
        print(f"{ws_log_prefix_unauth} Authentication failed. Closing WebSocket.")
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return

    user_id = current_ws_user['id']
    user_email = current_ws_user.get('email', f'UserID_{user_id}')
    ws_log_prefix = f"WS (User: {user_email}, Session: {session_id_ws}, ClientJS: {client_js_id}):"
    print(f"{ws_log_prefix} User authenticated.")

    # Verify session existence and user participation
    conn_verify = None; is_participant = False
    try:
        conn_verify = database.get_db_connection(); cursor_verify = conn_verify.cursor()
        cursor_verify.execute("SELECT 1 FROM sessions WHERE id = ? AND is_active = 1", (session_id_ws,))
        if not cursor_verify.fetchone():
            print(f"{ws_log_prefix} Session not found or inactive. Closing.")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION); return
        cursor_verify.execute("SELECT 1 FROM session_participants WHERE session_id = ? AND user_id = ?", (session_id_ws, user_id))
        is_participant = cursor_verify.fetchone() is not None
        if not is_participant:
            print(f"{ws_log_prefix} User NOT participant. Closing.")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION); return
    except Exception as e:
        print(f"{ws_log_prefix} DB error verifying participation: {e}"); traceback.print_exc()
        await websocket.close(code=status.WS_1011_INTERNAL_ERROR); return
    finally:
        if conn_verify: conn_verify.close()

    print(f"{ws_log_prefix} User confirmed participant.")

    # Accept connection
    try:
        await websocket.accept()
        print(f"{ws_log_prefix} WebSocket connection accepted.")
    except Exception as accept_err:
        print(f"{ws_log_prefix} Error accepting WebSocket: {accept_err}"); return

    # Get or load conversation memory
    memory = state.get_memory_for_client(session_id_ws) # Handles DB loading

    # Define memory loading function for LangChain
    def load_memory_for_current_session(_ignored_input_map=None):
        memory_vars = memory.load_memory_variables({})
        history = memory_vars.get("history", [])
        # print(f"{ws_log_prefix} Loading memory: Found {len(history)} messages.") # Optional detailed log
        return history

    # Create LangChain processing chain
    chain: Any
    try:
        chain = llm.create_chain(load_memory_for_current_session)
        print(f"{ws_log_prefix} LLM chain created.")
    except Exception as chain_init_error:
        print(f"{ws_log_prefix} ERROR creating LCEL chain: {chain_init_error}"); traceback.print_exc()
        if websocket.client_state == WebSocketState.CONNECTED:
             await websocket.send_json({"type": "error", "payload": {"message": "Server error: Could not initialize chat."}})
        await websocket.close(code=status.WS_1011_INTERNAL_ERROR); return

    # Main loop for handling messages
    try:
        while True:
            if websocket.client_state != WebSocketState.CONNECTED:
                print(f"{ws_log_prefix} WebSocket no longer connected. Breaking loop.")
                break

            received_data = await websocket.receive_text()
            # print(f"{ws_log_prefix} Received data: {received_data[:100]}{'...' if len(received_data) > 100 else ''}") # Verbose

            try:
                message_data = json.loads(received_data)
                message_type = message_data.get("type")
                payload = message_data.get("payload")

                if message_type == "run_code" and payload and payload.get("code_block_id"):
                    language = payload.get("language"); code = payload.get("code"); code_block_id = payload.get("code_block_id")
                    print(f"{ws_log_prefix} Received 'run_code' for block {code_block_id}.")
                    if language and code is not None:
                        asyncio.create_task(docker_utils.run_code_in_docker_stream(websocket, client_js_id, code_block_id, language, code))
                    else:
                        print(f"{ws_log_prefix} Invalid 'run_code' payload for block {code_block_id}.")
                        await websocket.send_json({"type": "code_finished", "payload": {"code_block_id": payload.get("code_block_id","unknown"), "exit_code": -1, "error": "Invalid run_code payload."}})

                elif message_type == "stop_code" and payload and payload.get("code_block_id"):
                    code_block_id = payload.get("code_block_id")
                    print(f"{ws_log_prefix} Received 'stop_code' for block {code_block_id}.")
                    asyncio.create_task(docker_utils.stop_docker_container(code_block_id))

                else:
                    print(f"{ws_log_prefix} Received JSON, but unknown type '{message_type}'. Treating as chat.")
                    await handle_chat_message(chain, memory, websocket, client_js_id, current_ws_user, session_id_ws, received_data)

            except json.JSONDecodeError:
                # Treat as plain text chat message
                # print(f"{ws_log_prefix} Data not JSON, treating as chat message.") # Verbose
                await handle_chat_message(chain, memory, websocket, client_js_id, current_ws_user, session_id_ws, received_data)

            except Exception as handler_exc:
                print(f"{ws_log_prefix} ERROR handling received message: {handler_exc}"); traceback.print_exc()
                if websocket.client_state == WebSocketState.CONNECTED:
                     await websocket.send_json({"type": "error", "payload": {"message": "Server error processing your request."}})

    except WebSocketDisconnect:
        print(f"{ws_log_prefix} WebSocket disconnected by client.")
    except Exception as e:
        print(f"{ws_log_prefix} ERROR in WebSocket main loop: {e}"); traceback.print_exc()
        if websocket.client_state == WebSocketState.CONNECTED:
            try: await websocket.close(code=status.WS_1011_INTERNAL_ERROR)
            except Exception: pass
    finally:
        print(f"{ws_log_prefix} Cleaning up resources...")
        # Memory is NOT removed from global cache here for persistence
        await docker_utils.cleanup_client_containers(client_js_id) # Cleanup Docker containers
        if websocket.client_state == WebSocketState.CONNECTED:
            try: await websocket.close(code=status.WS_1000_NORMAL_CLOSURE)
            except Exception as final_close_err: print(f"{ws_log_prefix} Error during final WebSocket close: {final_close_err}")
        print(f"{ws_log_prefix} Cleanup complete.")


# --- API Routes for Sessions & Messages ---

@app.patch("/api/sessions/{session_id}", response_model=Dict[str, Any], tags=["Sessions"])
async def rename_session(
    session_id: str = FastApiPath(..., description="The ID of the session to rename."),
    update_data: SessionUpdateRequest = Body(...),
    user: Dict[str, Any] = Depends(auth.get_current_active_user)
):
    """Updates the name of a specific chat session."""
    if not user: raise HTTPException(status_code=401, detail="Not authenticated")
    user_id = user['id']; new_name = update_data.name.strip()
    if not new_name: raise HTTPException(status_code=400, detail="Session name cannot be empty.")
    conn = None
    try:
        conn = database.get_db_connection(); cursor = conn.cursor()
        # Verify user is participant in the active session
        cursor.execute(
            """SELECT s.id FROM sessions s JOIN session_participants sp ON s.id = sp.session_id
               WHERE s.id = ? AND sp.user_id = ? AND s.is_active = 1""",
            (session_id, user_id)
        )
        if not cursor.fetchone(): raise HTTPException(status_code=404, detail="Session not found or user lacks permission.")
        # Update the name
        cursor.execute("UPDATE sessions SET name = ? WHERE id = ?", (new_name, session_id))
        if cursor.rowcount == 0:
            conn.rollback(); raise HTTPException(status_code=404, detail="Session not found during update.")
        conn.commit()
        print(f"API: Renamed session {session_id} to '{new_name}' for user ID {user_id}")
        return {"id": session_id, "name": new_name, "message": "Session renamed successfully"}
    except sqlite3.Error as db_err:
        if conn: conn.rollback(); print(f"API ERROR (/api/sessions/{session_id} PATCH): DB error: {db_err}"); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Database error renaming session.")
    except HTTPException as http_exc: raise http_exc
    except Exception as e:
        if conn: conn.rollback(); print(f"API ERROR (/api/sessions/{session_id} PATCH): Unexpected error: {e}"); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Server error renaming session.")
    finally:
        if conn: conn.close()


@app.get("/api/sessions", response_model=List[Dict[str, Any]], tags=["Sessions"])
async def get_user_sessions(
    user: Dict[str, Any] = Depends(auth.get_current_active_user)
):
    """Fetches sessions the current user participates in, ordered by last active."""
    if not user: raise HTTPException(status_code=401, detail="Not authenticated")
    user_id = user['id']; sessions_list = []
    conn = None
    try:
        conn = database.get_db_connection(); cursor = conn.cursor()
        cursor.execute(
            """SELECT s.id, s.name, s.last_accessed_at AS last_active
               FROM sessions s JOIN session_participants sp ON s.id = sp.session_id
               WHERE sp.user_id = ? AND s.is_active = 1
               ORDER BY s.last_accessed_at DESC""",
            (user_id,)
        )
        rows = cursor.fetchall()
        for row in rows: sessions_list.append(dict(row))
        # print(f"API: Fetched {len(sessions_list)} sessions for user ID {user_id}") # Verbose
        return sessions_list
    except sqlite3.Error as db_err:
        print(f"API ERROR (/api/sessions): DB error for user {user_id}: {db_err}"); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Database error fetching sessions.")
    except Exception as e:
        print(f"API ERROR (/api/sessions): Unexpected error for user {user_id}: {e}"); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Server error fetching sessions.")
    finally:
        if conn: conn.close()


@app.get("/api/sessions/{session_id}/messages", response_model=List[Dict[str, Any]], tags=["Messages"])
async def get_chat_messages_for_session(
    session_id: str = FastApiPath(..., description="The ID of the session to fetch messages for."),
    user: Dict[str, Any] = Depends(auth.get_current_active_user)
):
    """Fetches all messages for a session the user participates in."""
    if not user: raise HTTPException(status_code=401, detail="Not authenticated")
    user_id = user['id']; messages_list = []
    conn = None
    try:
        conn = database.get_db_connection(); cursor = conn.cursor()
        # Verify session exists and user is participant
        cursor.execute("SELECT 1 FROM sessions WHERE id = ? AND is_active = 1", (session_id,))
        if not cursor.fetchone(): raise HTTPException(status_code=404, detail="Session not found or inactive.")
        cursor.execute("SELECT 1 FROM session_participants WHERE session_id = ? AND user_id = ?", (session_id, user_id))
        if not cursor.fetchone(): raise HTTPException(status_code=403, detail="Access denied to this session.")
        # Fetch messages
        cursor.execute(
            """SELECT id, session_id, user_id, sender_name, sender_type, content, client_id_temp, thinking_content, timestamp
               FROM chat_messages WHERE session_id = ? ORDER BY timestamp ASC""",
            (session_id,)
        )
        rows = cursor.fetchall()
        for row in rows: messages_list.append(dict(row))
        # print(f"API: Fetched {len(messages_list)} messages for session {session_id} for user ID {user_id}") # Verbose
        return messages_list
    except sqlite3.Error as db_err:
        print(f"API ERROR (/api/sessions/.../messages): DB error for user {user_id}, session {session_id}: {db_err}"); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Database error fetching messages.")
    except HTTPException as http_exc: raise http_exc
    except Exception as e:
        print(f"API ERROR (/api/sessions/.../messages): Unexpected error for user {user_id}, session {session_id}: {e}"); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Server error fetching messages.")
    finally:
        if conn: conn.close()


@app.delete("/api/sessions/{session_id}", status_code=status.HTTP_204_NO_CONTENT, tags=["Sessions"])
async def delete_session_route(
    session_id: str = FastApiPath(..., description="The ID of the session to delete."),
    user: Dict[str, Any] = Depends(auth.get_current_active_user)
):
    """Deletes a session if the user is the host."""
    if not user: raise HTTPException(status_code=401, detail="Not authenticated")
    user_id = user['id']; conn = None
    try:
        conn = database.get_db_connection(); cursor = conn.cursor()
        # Verify session exists, is active, and user is the host
        cursor.execute("SELECT host_user_id FROM sessions WHERE id = ? AND is_active = 1", (session_id,))
        session_row = cursor.fetchone()
        if not session_row: raise HTTPException(status_code=404, detail="Session not found or inactive.")
        if session_row["host_user_id"] != user_id: raise HTTPException(status_code=403, detail="Only the session host can delete it.")
        # Delete the session (cascades should handle participants, messages, memory)
        cursor.execute("DELETE FROM sessions WHERE id = ?", (session_id,))
        if cursor.rowcount == 0:
            conn.rollback(); raise HTTPException(status_code=404, detail="Session found but could not be deleted.")
        conn.commit()
        print(f"API: Deleted session {session_id} by host user ID {user_id}")
        return # Return None for 204 No Content status
    except sqlite3.Error as db_err:
        if conn: conn.rollback(); print(f"API ERROR (DELETE /api/sessions/{session_id}): DB error: {db_err}"); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Database error deleting session.")
    except HTTPException as http_exc:
        if conn: conn.rollback() # Rollback on permission errors etc. if transaction started
        raise http_exc
    except Exception as e:
        if conn: conn.rollback(); print(f"API ERROR (DELETE /api/sessions/{session_id}): Unexpected error: {e}"); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Server error deleting session.")
    finally:
        if conn: conn.close()


def start_server():
    """Configures and starts the Uvicorn server, attempting to open the browser."""
    host = os.getenv("HOST", "127.0.0.1")
    port = int(os.getenv("PORT", 8001))
    url = f"http://{host}:{port}"

    print("-" * 30)
    print(f"Tesseracs Chat Server Starting...")
    print(f"Access via: {url}/login")
    print(f"Using Config: Model='{config.MODEL_ID}', Ollama='{config.OLLAMA_BASE_URL}'")
    # Make sure dist_dir is defined or accessible if needed here, or remove this print
    # print(f"Static files from: {config.STATIC_DIR}, Bundles from: {dist_dir}") # dist_dir might not be in scope here
    print("-" * 30)

    # --- UNCOMMENTED THIS SECTION ---
    try:
        # Attempt to open the login page in the default web browser
        print(f"Attempting to open {url}/login in default browser...")
        webbrowser.open(f"{url}/login")
    except Exception as browser_err:
        # Log a warning if opening the browser fails, but continue starting the server
        print(f"Warning: Could not automatically open browser: {browser_err}")
    # --- END UNCOMMENTED SECTION ---

    # Start the Uvicorn server
    # reload=True is useful for development, consider removing for production
    uvicorn.run("app.main:app", host=host, port=port, log_level="info", reload=True)

if __name__ == "__main__":
    start_server()


=== app/state.py ===
# app/state.py

import asyncio
import json
import sqlite3
import datetime
from langchain.memory import ConversationBufferMemory
from langchain_core.messages import messages_from_dict, messages_to_dict
from typing import Dict, Any
from . import database

client_memory: Dict[str, ConversationBufferMemory] = {}
running_containers: Dict[str, Dict[str, Any]] = {}
running_containers_lock = asyncio.Lock()

def get_memory_for_client(session_id: str) -> ConversationBufferMemory:
    global client_memory
    if session_id in client_memory:
        return client_memory[session_id]

    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            "SELECT memory_state_json FROM session_memory_state WHERE session_id = ?",
            (session_id,)
        )
        row = cursor.fetchone()

        if row and row["memory_state_json"]:
            try:
                memory_data = json.loads(row["memory_state_json"])
                if isinstance(memory_data, list):
                    memory_instance = ConversationBufferMemory(
                        return_messages=True,
                        memory_key="history"
                    )
                    loaded_messages = messages_from_dict(memory_data)
                    memory_instance.chat_memory.messages = loaded_messages
                    client_memory[session_id] = memory_instance
                    return memory_instance
            except (json.JSONDecodeError, Exception):
                 pass
    except sqlite3.Error:
         pass
    finally:
        if conn:
            conn.close()

    new_memory = ConversationBufferMemory(return_messages=True, memory_key="history")
    client_memory[session_id] = new_memory
    return new_memory

def save_memory_state_to_db(session_id: str, memory: ConversationBufferMemory):
    if not memory:
        return

    conn = None
    try:
        messages = memory.chat_memory.messages
        memory_state_list = messages_to_dict(messages)
        memory_state_json = json.dumps(memory_state_list)
        current_time_utc = datetime.datetime.now(datetime.timezone.utc).isoformat()

        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            """
            INSERT OR REPLACE INTO session_memory_state
            (session_id, memory_state_json, updated_at)
            VALUES (?, ?, ?)
            """,
            (session_id, memory_state_json, current_time_utc)
        )
        conn.commit()
    except (json.JSONDecodeError, sqlite3.Error, Exception):
        if conn:
            conn.rollback()
    finally:
        if conn:
            conn.close()

def remove_memory_for_client(session_id: str):
    global client_memory
    if session_id in client_memory:
        del client_memory[session_id]

=== app/utils.py ===
# app/utils.py
import json
import traceback
from fastapi import WebSocket, WebSocketDisconnect
from fastapi.websockets import WebSocketState

async def send_ws_message(websocket: WebSocket, message_type: str, payload: dict):
    """Safely sends a JSON message over the WebSocket."""
    # Check state before sending (no change needed here)
    if websocket.client_state != WebSocketState.CONNECTED:
        print(f"[utils] WebSocket not connected, cannot send {message_type} for {payload.get('code_block_id', 'N/A')}")
        return
    try:
        await websocket.send_json({"type": message_type, "payload": payload})
    except WebSocketDisconnect:
        print(f"[utils] WebSocket disconnected while trying to send {message_type} for {payload.get('code_block_id', 'N/A')}")
    except Exception as e:
        # Catch other potential errors like Runtime Error if connection closed during send
        print(f"[utils] Error sending WebSocket message ({message_type}) for {payload.get('code_block_id', 'N/A')}: {e}")
        # traceback.print_exc() # Optional: uncomment for more detail

=== app/static/_sidebar.html ===
<div class="p-4 border-b border-gray-700 flex items-center justify-between">
    <h2 class="text-xl font-semibold text-white">Tesseracs</h2>
    <a href="/" title="Home" class="text-gray-400 hover:text-white">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path></svg>
    </a>
</div>

<nav class="flex-1 p-4 space-y-2 sidebar-scrollable">
    <form action="/sessions/create" method="POST" class="mb-4" id="new-chat-form-sidebar">
        <button type="submit" class="w-full flex items-center justify-center px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-md text-white font-medium transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
            New Chat
        </button>
    </form>

    <div class="text-sm text-gray-400 uppercase tracking-wider mb-2">Sessions</div>
    <ul id="session-list" class="space-y-1">
        <li class="px-3 py-1 text-gray-400 italic text-sm">Loading sessions...</li>
    </ul>

    <div class="mt-auto pt-4 border-t border-gray-700">
        <a href="#" id="settings-link-sidebar" class="flex items-center px-3 py-2 text-gray-300 hover:bg-gray-700 hover:text-white rounded-md text-sm">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826 3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
            Settings
        </a>
    </div>
</nav>

<div class="p-4 border-t border-gray-700">
    <a href="/logout" id="logout-link-sidebar" class="flex items-center justify-center w-full px-4 py-2 border border-gray-600 hover:bg-gray-700 rounded-md text-sm font-medium text-gray-300 hover:text-white transition duration-150 ease-in-out">
        Logout
    </a>
</div>

=== app/static/chat-session.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tesseracs Chat Session</title>
    <link rel="stylesheet" href="/dist/input.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        .sidebar-scrollable { overflow-y: auto; scrollbar-width: thin; scrollbar-color: #a0aec0 #edf2f7; }
        .sidebar-scrollable::-webkit-scrollbar { width: 6px; }
        .sidebar-scrollable::-webkit-scrollbar-track { background: #edf2f7; border-radius: 3px; }
        .sidebar-scrollable::-webkit-scrollbar-thumb { background-color: #a0aec0; border-radius: 3px; border: 1px solid #edf2f7; }
    </style>
</head>
<body class="font-sans bg-gray-100 text-gray-800">

    <div class="flex h-screen overflow-hidden">
        <aside id="sidebar-loader-target" class="w-64 bg-gray-800 text-gray-200 flex flex-col overflow-hidden">
        </aside>

        <main class="flex-1 flex flex-col overflow-hidden">
            <header class="bg-white border-b border-gray-200 p-4 shadow-sm">
                <h1 id="chat-session-title" class="text-lg font-semibold text-gray-800">Chat Session</h1>
            </header>
            <div id="chat-history" class="flex-1 overflow-y-auto p-4 space-y-4 bg-white shadow-inner m-4 rounded-lg">
            </div>
            <footer class="p-4 bg-gray-200 border-t border-gray-300">
                <form id="chat-form" class="flex items-center space-x-2">
                    <div class="think-checkbox-container flex items-center text-sm text-gray-600 mr-2">
                        <input type="checkbox" id="think-checkbox" class="mr-1 h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 cursor-pointer">
                        <label for="think-checkbox" class="cursor-pointer select-none">Think</label>
                    </div>
                    <input type="text" id="message-input" placeholder="Type your message..." autocomplete="off" required
                           class="flex-1 p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                    <button type="submit" id="send-button"
                            class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                        Send
                    </button>
                </form>
            </footer>
        </main>
    </div>

    <script type="module">
        import { loadSidebarHTML, populateSessionList } from '/static/js/app-ui.js';

        document.addEventListener('DOMContentLoaded', async () => {
            console.log("Chat Session Page: DOMContentLoaded. Attempting to load UI components.");
            const sidebarLoaded = await loadSidebarHTML('/static/_sidebar.html', 'sidebar-loader-target');
            if (sidebarLoaded) {
                // Use '/chat/' as the base URL for session links
                await populateSessionList('/api/sessions', 'session-list', '/chat/');
            } else {
                console.error("Chat Session Page: Sidebar loading failed, session list will not be populated by app-ui.js.");
            }
        });
    </script>
    <script src="/dist/script.js" defer></script>
</body>
</html>

=== app/static/input.css ===
--- CONTENT EXCLUDED (listed in exclude_files) ---


=== app/static/login.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Login - Tesseracs Chat</title>
    <link rel="stylesheet" href="/dist/input.css">
    <style>
        /* Simple class to hide elements */
        .hidden-field {
            display: none;
        }
        /* Style for the forgot password link */
        .forgot-password-link {
            display: block; /* Make it block to appear below the password field */
            text-align: right;
            font-size: 0.875rem; /* text-sm */
            color: #4b5563; /* text-gray-600 */
            text-decoration: none;
            /* Removed negative margin-top, added positive margin-top */
            margin-top: 0.5rem; /* Add some space above the link */
            margin-bottom: 1.25rem; /* Keep bottom margin for spacing below */
        }
        .forgot-password-link:hover {
            color: #1d4ed8; /* hover:text-blue-700 */
            text-decoration: underline;
        }
    </style>
</head>
<body class="flex flex-col justify-center items-center min-h-screen bg-gray-100 font-sans p-4">
    <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-md">
        <h1 class="text-center mb-6 text-2xl font-semibold text-gray-900">Tesseracs Chat</h1>

        <div id="message-area" class="p-3 rounded-md text-sm text-center mb-4" style="display: none;"></div>

        <form id="auth-form" class="mt-4">
            <div class="mb-5">
                <label for="email" class="block mb-2 text-sm font-medium text-gray-700">Email:</label>
                <input type="email" id="email" name="email" required autocomplete="email" class="block w-full py-2.5 px-3 border border-gray-300 rounded-md text-sm transition-colors duration-200 ease-in-out focus:border-blue-600 focus:ring-2 focus:ring-blue-300 focus:outline-none">
            </div>

            <div id="password-field-container" class="mb-5 hidden-field">
                <label for="password" class="block mb-2 text-sm font-medium text-gray-700">Password:</label>
                <input type="password" id="password" name="password" autocomplete="current-password" class="block w-full py-2.5 px-3 border border-gray-300 rounded-md text-sm transition-colors duration-200 ease-in-out focus:border-blue-600 focus:ring-2 focus:ring-blue-300 focus:outline-none">
                <a href="#" id="forgot-password-link" class="forgot-password-link">Forgot Password?</a>
            </div>

            <div id="name-field-container" class="mb-5 hidden-field">
                <label for="name" class="block mb-2 text-sm font-medium text-gray-700">Full Name:</label>
                <input type="text" id="name" name="name" autocomplete="name" class="block w-full py-2.5 px-3 border border-gray-300 rounded-md text-sm transition-colors duration-200 ease-in-out focus:border-blue-600 focus:ring-2 focus:ring-blue-300 focus:outline-none">
            </div>

            <button type="submit" id="submit-button" class="w-full py-3 bg-blue-600 text-white rounded-md text-sm font-medium cursor-pointer transition-colors duration-200 ease-in-out hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed">Continue</button>
        </form>

        <p id="form-instructions" class="text-xs text-center mt-6 text-gray-500">
            Enter your email to log in or create an account.
        </p>
    </div>

    <script>
        // --- DOM Element References ---
        const authForm = document.getElementById('auth-form');
        const emailInput = document.getElementById('email');
        const nameInput = document.getElementById('name');
        const passwordInput = document.getElementById('password');
        const nameFieldContainer = document.getElementById('name-field-container');
        const passwordFieldContainer = document.getElementById('password-field-container');
        const submitButton = document.getElementById('submit-button');
        const messageArea = document.getElementById('message-area');
        const formInstructions = document.getElementById('form-instructions');
        const forgotPasswordLink = document.getElementById('forgot-password-link');

        // --- State Management ---
        // Possible states: 'initial_email', 'login_password', 'register_name', 'forgot_password_prompt'
        let formState = 'initial_email';

        // --- UI Update Function ---
        function updateUIForState() {
            // Reset fields visibility and requirements first
            passwordFieldContainer.classList.add('hidden-field');
            nameFieldContainer.classList.add('hidden-field');
            passwordInput.required = false;
            nameInput.required = false;
            emailInput.readOnly = false; // Make email editable by default

            switch (formState) {
                case 'initial_email':
                    submitButton.textContent = 'Continue';
                    formInstructions.textContent = 'Enter your email to log in or create an account.';
                    break;
                case 'login_password':
                    passwordFieldContainer.classList.remove('hidden-field');
                    passwordInput.required = true;
                    emailInput.readOnly = true; // Prevent email change during login attempt
                    submitButton.textContent = 'Login';
                    formInstructions.textContent = 'Enter your password to log in.';
                    break;
                case 'register_name':
                    nameFieldContainer.classList.remove('hidden-field');
                    nameInput.required = true;
                    emailInput.readOnly = true; // Prevent email change during registration
                    submitButton.textContent = 'Create Account & Send Password';
                    formInstructions.textContent = 'This email is not registered. Enter your name to create an account. A password will be emailed to you.';
                    break;
                case 'forgot_password_prompt':
                    // Only email field is needed, others remain hidden
                    emailInput.readOnly = false; // Ensure email is editable
                    submitButton.textContent = 'Send Reset Email';
                    formInstructions.textContent = 'Enter your email address to receive a password reset.';
                    break;
            }
        }

        // --- Event Listeners ---

        // Forgot Password Link Click Handler
        forgotPasswordLink.addEventListener('click', (event) => {
            event.preventDefault(); // Prevent default link behavior
            console.log("Forgot Password link clicked.");
            formState = 'forgot_password_prompt';
            updateUIForState();
            // Clear any previous messages and focus email field
            messageArea.style.display = 'none';
            messageArea.textContent = '';
            emailInput.focus();
        });

        // Form Submission Handler (Handles all states)
        authForm.addEventListener('submit', async function(event) {
            event.preventDefault();
            messageArea.style.display = 'none'; // Hide previous messages on new submission
            messageArea.textContent = '';
            messageArea.className = 'p-3 rounded-md text-sm text-center mb-4'; // Reset message classes
            submitButton.disabled = true; // Disable button during processing

            const email = emailInput.value.trim().toLowerCase();

            // --- State: Initial Email Check ---
            if (formState === 'initial_email') {
                submitButton.textContent = 'Checking Email...';
                if (!email) {
                    showMessage('Please enter your email address.', 'error');
                    submitButton.disabled = false;
                    submitButton.textContent = 'Continue'; // Reset button text
                    return;
                }
                try {
                    const response = await fetch('/check_email', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ email: email })
                    });
                    const result = await response.json();
                    if (response.ok) {
                        formState = result.exists ? 'login_password' : 'register_name';
                        updateUIForState(); // Update UI based on new state
                    } else {
                        showMessage(result.detail || 'Error checking email.', 'error');
                        submitButton.textContent = 'Continue'; // Reset button text
                    }
                } catch (error) {
                    console.error('Email check error:', error);
                    showMessage('Network error checking email.', 'error');
                    submitButton.textContent = 'Continue'; // Reset button text
                } finally {
                    submitButton.disabled = false; // Re-enable button
                }
            }
            // --- State: Login with Password ---
            else if (formState === 'login_password') {
                submitButton.textContent = 'Logging In...';
                const password = passwordInput.value;
                if (!password) {
                    showMessage('Please enter your password.', 'error');
                    submitButton.disabled = false;
                    submitButton.textContent = 'Login';
                    return;
                }
                const formData = new FormData();
                formData.append('username', email); // Endpoint expects 'username'
                formData.append('password', password);
                try {
                    const response = await fetch('/token', { method: 'POST', body: formData });
                    const result = await response.json();
                    if (response.ok) {
                        showMessage('Login successful! Redirecting...', 'success');
                        // Redirect after a short delay to show message
                        setTimeout(() => { window.location.href = '/'; }, 1500);
                    } else {
                        showMessage(result.detail || 'Login failed. Check email or password.', 'error');
                        submitButton.textContent = 'Login'; // Reset button text
                        submitButton.disabled = false; // Re-enable button
                    }
                } catch (error) {
                    console.error('Login error:', error);
                    showMessage('Network error during login.', 'error');
                    submitButton.textContent = 'Login'; // Reset button text
                    submitButton.disabled = false; // Re-enable button
                }
                // Note: Button remains disabled on success until redirect
            }
            // --- State: Register New User ---
            else if (formState === 'register_name') {
                submitButton.textContent = 'Creating Account...';
                const name = nameInput.value.trim();
                if (!name) {
                    showMessage('Please enter your full name.', 'error');
                    submitButton.disabled = false;
                    submitButton.textContent = 'Create Account & Send Password';
                    return;
                }
                try {
                    const response = await fetch('/register', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ email: email, name: name })
                    });
                    const result = await response.json();
                    if (response.ok) {
                        showMessage(result.message || 'Account created! Password sent to your email.', 'success');
                        // Reset form to initial state after successful registration
                        authForm.reset(); // Clear all fields
                        formState = 'initial_email';
                        updateUIForState(); // Update UI back to initial state
                    } else {
                        showMessage(result.detail || 'Registration failed.', 'error');
                        submitButton.textContent = 'Create Account & Send Password'; // Reset button text
                    }
                } catch (error) {
                    console.error('Registration error:', error);
                    showMessage('Network error during registration.', 'error');
                    submitButton.textContent = 'Create Account & Send Password'; // Reset button text
                } finally {
                    submitButton.disabled = false; // Re-enable button
                }
            }
            // --- State: Forgot Password Request ---
            else if (formState === 'forgot_password_prompt') {
                submitButton.textContent = 'Sending Reset Email...';
                if (!email) {
                    showMessage('Please enter your email address.', 'error');
                    submitButton.disabled = false;
                    submitButton.textContent = 'Send Reset Email';
                    return;
                }
                try {
                    const response = await fetch('/forgot_password', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ email: email })
                    });
                    const result = await response.json();
                    if (response.ok) {
                         // Show the generic success message from the server
                        showMessage(result.message, 'success');
                        // Reset form to initial state
                        authForm.reset();
                        formState = 'initial_email';
                        updateUIForState();
                    } else {
                        // Handle potential server errors (5xx) or unexpected issues
                        showMessage(result.detail || 'Failed to process request.', 'error');
                        submitButton.textContent = 'Send Reset Email'; // Reset button text
                    }
                } catch (error) {
                    console.error('Forgot password error:', error);
                    showMessage('Network error sending reset email.', 'error');
                    submitButton.textContent = 'Send Reset Email'; // Reset button text
                } finally {
                    submitButton.disabled = false; // Re-enable button
                }
            }
        });

        // --- Helper Function to Display Messages ---
        function showMessage(message, type = 'info') {
            messageArea.textContent = message;
            // Reset classes first
            messageArea.className = 'p-3 rounded-md text-sm text-center mb-4 border';
            if (type === 'error') {
                messageArea.classList.add('text-red-700', 'bg-red-100', 'border-red-300');
            } else if (type === 'success') {
                messageArea.classList.add('text-green-700', 'bg-green-100', 'border-green-300');
            } else { // info
                messageArea.classList.add('text-blue-700', 'bg-blue-100', 'border-blue-300');
            }
            messageArea.style.display = 'block'; // Make sure it's visible
        }

        // --- Initial UI Setup on Page Load ---
        updateUIForState(); // Set initial UI based on default state ('initial_email')

    </script>
</body>
</html>


=== app/static/script.js ===
// --- JS Imports ---
import { marked } from 'marked';
import katex from 'katex';
import Prism from 'prismjs';

// --- Prism Components ---

import 'prismjs/components/prism-clike';
import 'prismjs/components/prism-python';
import 'prismjs/components/prism-javascript';
import 'prismjs/components/prism-css';
import 'prismjs/components/prism-bash';
import 'prismjs/components/prism-json';
import 'prismjs/components/prism-yaml';
import 'prismjs/components/prism-sql';
import 'prismjs/components/prism-java';
import 'prismjs/components/prism-csharp';
import 'prismjs/components/prism-go';
import 'prismjs/components/prism-rust';
import 'prismjs/components/prism-docker';
import 'prismjs/components/prism-typescript';
import 'prismjs/components/prism-c';
import 'prismjs/components/prism-cpp';
// import 'prismjs/components/prism-php'; // not working
// import 'prismjs/components/prism-ruby'; // not working
// --------------------------

// --- Constants and Variables ---
const chatHistory = document.getElementById('chat-history');
const chatForm = document.getElementById('chat-form');
const messageInput = document.getElementById('message-input');
const sendButton = document.getElementById('send-button');
const thinkCheckbox = document.getElementById('think-checkbox');

let websocket;
const clientId = `web-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
let currentTurnId = 0;

const MODE_ANSWER = 'MODE_ANSWER';
const MODE_SEEKING_CODE_LANGUAGE = 'MODE_SEEKING_CODE_LANGUAGE';
const MODE_INSIDE_CODE_BLOCK = 'MODE_INSIDE_CODE_BLOCK';
const MODE_KATEX_BUFFERING_INLINE = 'MODE_KATEX_BUFFERING_INLINE';
const MODE_KATEX_BUFFERING_DISPLAY = 'MODE_KATEX_BUFFERING_DISPLAY';
const MODE_MAYBE_START_DISPLAY_KATEX = 'MODE_MAYBE_START_DISPLAY_KATEX';
const MODE_SEEKING_TAG = 'MODE_SEEKING_TAG';
const MODE_INSIDE_THINK = 'MODE_INSIDE_THINK';
const MODE_MAYBE_END_THINK = 'MODE_MAYBE_END_THINK';
const NO_THINK_PREFIX = "\\no_think";
const MODE_SEEKING_CODE_START_FENCE = 'MODE_SEEKING_CODE_START_FENCE';
const MODE_SEEKING_CODE_END_FENCE = 'MODE_SEEKING_CODE_END_FENCE';

let currentProcessingMode = MODE_ANSWER;
let langBuffer = '';
let currentCodeBlockLang = ''; // Stores the language name (e.g., 'python')
let currentCodeBlockElement = null; // The <code> element
let currentCodeBlockPreElement = null; // The <pre> element wrapping the code
let katexBuffer = '';
let currentKatexMarkerId = null;
let thinkBuffer = '';
let tagBuffer = '';
let fenceBuffer = ''; // Added for fence detection
let currentAiTurnContainer = null;
let currentAnswerElement = null;
let currentThinkingArea = null;
let currentThinkingPreElement = null;
let currentCodeBlocksArea = null;
let codeBlockCounterThisTurn = 0;
let thinkingRequestedForCurrentTurn = false;
let accumulatedAnswerText = '';
let lastAppendedNode = null;
let hasThinkingContentArrivedThisTurn = false;
let firstAnswerTokenReceived = false;
var currentUserInfo = null

const FENCE = '```';
const THINK_START_TAG = '<think>';
const THINK_END_TAG = '</think>';
const KATEX_PLACEHOLDER_PREFIX = '%%KATEX_PLACEHOLDER_';
const KATEX_RENDERED_ATTR = 'data-katex-rendered';


/**
 * Extracts the session ID from the current URL path.
 * Assumes URL is like /chat/SESSION_ID/...
 * Returns the session ID string or null if not found or invalid.
 */
function getSessionIdFromPath() {
    const pathName = window.location.pathname; // Get the path part of the URL (e.g., "/chat/some-session-id")
    const pathParts = pathName.split('/');    // Split the path by "/"
                                            // For "/chat/some-session-id", pathParts will be ["", "chat", "some-session-id"]

    // Check if the path structure is as expected:
    // 1. pathParts.length >= 3 (e.g., "", "chat", "session_id")
    // 2. pathParts[1] is exactly "chat"
    if (pathParts.length >= 3 && pathParts[1] === 'chat') {
        const sessionId = pathParts[2]; // The session ID is the third part
        if (sessionId && sessionId.trim() !== "") { // Ensure it's not empty
            // console.log("Extracted session ID:", sessionId); // Keep for debugging if needed
            return sessionId;
        } else {
            console.error("Session ID extracted from path is empty or invalid.");
            return null;
        }
    }

    // console.log("Not on a chat page or session ID invalid:", pathName); // Keep for debugging if needed
    return null; // Return null if the path doesn't match the expected structure
}

// --- Utility Functions ---

function scrollToBottom(behavior = 'auto') {
    const isNearBottom = chatHistory.scrollHeight - chatHistory.scrollTop - chatHistory.clientHeight < 100;
    if (isNearBottom) {
        requestAnimationFrame(() => {
            chatHistory.scrollTo({ top: chatHistory.scrollHeight, behavior: behavior });
        });
    }
}

// --- Utility Functions --- 
// (debounce function is here)

function throttle(func, limit) {
    let lastFunc;
    let lastRan;
    return function throttledFunction(...args) {
      const context = this; // Capture the context
      if (!lastRan) {
        // If it hasn't run yet, run it immediately
        func.apply(context, args);
        lastRan = Date.now();
      } else {
        clearTimeout(lastFunc); // Clear any previously scheduled run
        // Schedule the next run after the limit has passed
        lastFunc = setTimeout(function() {
          // Check if enough time has passed since the last execution
          if ((Date.now() - lastRan) >= limit) {
            func.apply(context, args);
            lastRan = Date.now(); // Update the time it last ran
          }
        }, limit - (Date.now() - lastRan)); // Calculate remaining time needed
      }
    };
  }
  
  // (debouncedStreamHighlight definition will be replaced next)
  // (Rest of your utility functions)

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
};

function getCursorPosition(parentElement) {
    const selection = window.getSelection();
    if (selection.rangeCount === 0) return -1;

    const range = selection.getRangeAt(0);
    if (!parentElement.contains(range.startContainer)) {
        return -1;
    }

    const preSelectionRange = range.cloneRange();
    preSelectionRange.selectNodeContents(parentElement);
    try {
        preSelectionRange.setEnd(range.startContainer, range.startOffset);
    } catch (e) {
        console.error("Error setting preSelectionRange end:", e, "Range:", range);
        return -1;
    }
    return preSelectionRange.toString().length;
}

function setCursorPosition(parentElement, offset) {
    const selection = window.getSelection();
    if (!selection) return;

    const range = document.createRange();
    let charCount = 0;
    let foundStart = false;

    function findNodeAndOffset(node) {
        if (foundStart) return;

        if (node.nodeType === Node.TEXT_NODE) {
            const nextCharCount = charCount + node.length;
            if (!foundStart && offset >= charCount && offset <= nextCharCount) {
                try {
                    const offsetInNode = offset - charCount;
                    range.setStart(node, offsetInNode);
                    foundStart = true;
                } catch (e) {
                    console.error("Error setting range start:", e, "Node:", node, "Offset:", offsetInNode);
                }
            }
            charCount = nextCharCount;
        } else {
            for (let i = 0; i < node.childNodes.length; i++) {
                findNodeAndOffset(node.childNodes[i]);
                if (foundStart) break;
            }
        }
    }

    findNodeAndOffset(parentElement);

    if (foundStart) {
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
    } else {
        range.selectNodeContents(parentElement);
        range.collapse(false);
        selection.removeAllRanges();
        selection.addRange(range);
        console.warn(`Could not set cursor precisely at offset ${offset}. Placed at end.`);
    }
    parentElement.focus();
}

/**
 * Fetches the list of user sessions from the API and displays them in the sidebar.
 */
async function fetchAndDisplaySessions() {
    console.log("[fetchAndDisplaySessions] Function called."); // Log: Start of function

    const sessionListElement = document.getElementById('session-list');
    const chatSessionTitle = document.getElementById('chat-session-title');

    if (!sessionListElement) {
        console.log("[fetchAndDisplaySessions] Session list element (#session-list) not found. Exiting.");
        return;
    }

    console.log("[fetchAndDisplaySessions] Setting loading state.");
    sessionListElement.innerHTML = '<li class="px-3 py-1 text-gray-400 italic text-sm">Loading sessions...</li>';

    try {
        console.log("[fetchAndDisplaySessions] Making fetch request to /api/sessions...");
        const response = await fetch('/api/sessions');
        console.log(`[fetchAndDisplaySessions] Fetch response status: ${response.status}`); // Log: Response status

        if (!response.ok) {
            let errorDetail = `HTTP error ${response.status}`;
            try {
                const errorJson = await response.json();
                errorDetail = errorJson.detail || errorDetail;
            } catch (e) { /* Ignore */ }
            console.error(`[fetchAndDisplaySessions] Error fetching sessions: ${errorDetail}`);
            sessionListElement.innerHTML = `<li class="px-3 py-1 text-red-400 italic text-sm">Error loading sessions</li>`;
            return;
        }

        const sessions = await response.json();
        console.log("[fetchAndDisplaySessions] Received sessions:", sessions); // Log: The received data

        sessionListElement.innerHTML = ''; // Clear loading/error

        if (sessions.length === 0) {
            console.log("[fetchAndDisplaySessions] No sessions found. Displaying message.");
            sessionListElement.innerHTML = '<li class="px-3 py-1 text-gray-400 italic text-sm">No sessions yet</li>';
        } else {
            console.log(`[fetchAndDisplaySessions] Processing ${sessions.length} sessions...`);
            const activeSessionId = getSessionIdFromPath(); // Assumes getSessionIdFromPath() exists and works
            console.log(`[fetchAndDisplaySessions] Current active session ID from path: ${activeSessionId}`);

            sessions.forEach((session, index) => {
                // console.log(`[fetchAndDisplaySessions] Adding session ${index + 1}: ID=${session.id}, Name=${session.name}`); // Optional: Log each session
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = `/chat/${session.id}`;
                a.classList.add('block', 'px-3', 'py-2', 'rounded-md', 'text-sm', 'text-gray-300', 'hover:bg-gray-700', 'hover:text-white', 'truncate');

                if (session.id === activeSessionId) {
                    // console.log(`[fetchAndDisplaySessions] Highlighting active session: ${session.id}`);
                    a.classList.add('bg-gray-900', 'text-white');
                    a.setAttribute('aria-current', 'page');
                    if (chatSessionTitle) {
                        chatSessionTitle.textContent = session.name || `Chat Session ${session.id.substring(0, 4)}`;
                    }
                }

                a.textContent = session.name || `Session ${session.id.substring(0, 8)}`;
                a.title = session.name || `Session ${session.id}`;

                // Placeholder for Rename/Delete buttons
                // const iconsSpan = document.createElement('span');
                // iconsSpan.innerHTML = `...`;
                // a.appendChild(iconsSpan);

                li.appendChild(a);
                sessionListElement.appendChild(li);
            });
            console.log("[fetchAndDisplaySessions] Finished processing sessions.");
        }

    } catch (error) {
        console.error("[fetchAndDisplaySessions] Failed to fetch or display sessions:", error);
        sessionListElement.innerHTML = `<li class="px-3 py-1 text-red-400 italic text-sm">Error loading sessions</li>`;
    }
}

/**
 * Adds a user's message to the chat history UI.
 * Displays the current user's dynamic name and strips the NO_THINK_PREFIX 
 * from the displayed text if the user typed it.
 * Uses explicit window.currentUserInfo check.
 * @param {string} text - The raw text of the user's message as typed.
 */
function addUserMessage(text) {
    // Log the global variable directly at the start of the function call
    console.log(">>> addUserMessage called. window.currentUserInfo is:", window.currentUserInfo); 

    const messageElement = document.createElement('div');
    messageElement.classList.add('message', 'user-message', 'p-3', 'rounded-lg', 'max-w-xl', 'mb-2', 'break-words', 'flex', 'flex-col', 'bg-emerald-100', 'self-end', 'ml-auto');
    messageElement.setAttribute('data-sender', 'user');

    const senderElem = document.createElement('p');
    senderElem.classList.add('font-semibold', 'text-sm', 'mb-1', 'text-emerald-700');

    let userName = 'User'; // Default name
    console.log(">>> addUserMessage: Initial userName:", userName); 

    // --- MODIFIED: Explicitly check window.currentUserInfo ---
    if (typeof window.currentUserInfo === 'object' && window.currentUserInfo !== null && window.currentUserInfo.name) {
        console.log(">>> addUserMessage: Condition met. window.currentUserInfo.name is:", window.currentUserInfo.name); 
        userName = window.currentUserInfo.name; // Assign from the global object
        console.log(">>> addUserMessage: userName reassigned to:", userName); 
    } else {
        // Log details if the condition fails
        console.warn(`[addUserMessage] Condition failed. typeof window.currentUserInfo: ${typeof window.currentUserInfo}, window.currentUserInfo value: ${JSON.stringify(window.currentUserInfo)}, has name property: ${window.currentUserInfo ? window.currentUserInfo.hasOwnProperty('name') : 'N/A'}. Displaying default 'User'.`);
    }
    // --- END OF MODIFICATION ---

    console.log(`>>> Before setting textContent, userName is: '${userName}'`); 
    
    // escapeHTML should be defined globally
    senderElem.textContent = escapeHTML(userName); 
    
    console.log(`>>> After setting textContent, senderElem.textContent is: '${senderElem.textContent}'`); 

    messageElement.appendChild(senderElem);

    // --- Message Content ---
    const contentElem = document.createElement('div');
    contentElem.classList.add('text-gray-800', 'text-sm', 'message-content');
    let displayedText = text; 
    if (typeof NO_THINK_PREFIX === 'string' && NO_THINK_PREFIX.length > 0 && displayedText.startsWith(NO_THINK_PREFIX)) {
        displayedText = displayedText.substring(NO_THINK_PREFIX.length);
    }
    contentElem.textContent = displayedText;
    messageElement.appendChild(contentElem);

    // --- Timestamp ---
    const timestampElem = document.createElement('p');
    timestampElem.classList.add('text-xs', 'text-slate-500', 'mt-1', 'text-right');
    timestampElem.textContent = new Date().toLocaleString(); 
    messageElement.appendChild(timestampElem);
    
    if (chatHistory) { 
        chatHistory.appendChild(messageElement);
        setTimeout(() => scrollToBottom('smooth'), 50);
    } else {
        console.error("[addUserMessage] chatHistory element not found.");
    }
}





function addSystemMessage(text) {
   const messageElement = document.createElement('div');
   messageElement.classList.add('system-message');
   messageElement.textContent = text;
   chatHistory.appendChild(messageElement);
   setTimeout(() => scrollToBottom('smooth'), 50);
}

function addErrorMessage(text) {
   console.error("[UI ERROR] ", text);
   const messageElement = document.createElement('div');
   messageElement.classList.add('error-message');
   messageElement.textContent = `Error: ${text}`;
   if(currentAiTurnContainer) {
       const target = currentAnswerElement || currentCodeBlocksArea || currentAiTurnContainer;
       target.appendChild(messageElement);
   } else { chatHistory.appendChild(messageElement); }
   setTimeout(() => scrollToBottom('smooth'), 50);
}

function setInputDisabledState(disabled) {
    messageInput.disabled = disabled;
    sendButton.disabled = disabled;
    if (thinkCheckbox) {
        thinkCheckbox.disabled = disabled;
    }
}

/**
 * Sets up the DOM structure for a new turn from the AI, including thinking area,
 * answer bubble (with sender name), and code blocks area.
 */
function setupNewAiTurn() {
    currentTurnId++;
    codeBlockCounterThisTurn = 0;
    accumulatedAnswerText = '';
    lastAppendedNode = null;
    thinkBuffer = '';
    hasThinkingContentArrivedThisTurn = false;
    firstAnswerTokenReceived = false;

    currentAiTurnContainer = null;
    currentThinkingArea = null;
    currentThinkingPreElement = null;
    currentAnswerElement = null;
    currentCodeBlocksArea = null;

    console.log(`[setupNewAiTurn] Starting setup for Turn ID: ${currentTurnId}. thinkingRequestedForCurrentTurn is: ${thinkingRequestedForCurrentTurn}`);

    currentAiTurnContainer = document.createElement('div');
    currentAiTurnContainer.classList.add('ai-turn-container');
    currentAiTurnContainer.dataset.turnId = currentTurnId;

    // --- Thinking Area Setup (remains the same) ---
    currentThinkingArea = document.createElement('div');
    currentThinkingArea.classList.add('thinking-area');
    currentThinkingArea.dataset.turnId = currentTurnId;
    if (!thinkingRequestedForCurrentTurn) {
        currentThinkingArea.style.display = 'none';
    }
    const details = document.createElement('details');
    details.id = `thinking-details-${currentTurnId}`;
    const summary = document.createElement('summary');
    summary.classList.add('thinking-summary');
    const summaryTextSpan = document.createElement('span');
    summaryTextSpan.classList.add('text');
    summaryTextSpan.textContent = 'Show Thinking';
    const summaryDotsSpan = document.createElement('span');
    summaryDotsSpan.classList.add('dots');
    summary.appendChild(summaryTextSpan);
    summary.appendChild(summaryDotsSpan);
    currentThinkingPreElement = document.createElement('pre');
    details.appendChild(summary);
    details.appendChild(currentThinkingPreElement);
    currentThinkingArea.appendChild(details);
    currentAiTurnContainer.appendChild(currentThinkingArea);
    details.addEventListener('toggle', (event) => {
        const textSpan = event.target.querySelector('.thinking-summary .text');
        if (!textSpan) return;
        textSpan.textContent = event.target.open ? 'Hide Thinking' : 'Show Thinking';
    });
    // --- End Thinking Area Setup ---

    // --- Answer Element (AI Message Bubble) Setup ---
    currentAnswerElement = document.createElement('div');
    currentAnswerElement.classList.add('message', 'ai-message');
    // Add styling classes similar to historical AI messages for consistency
    currentAnswerElement.classList.add('p-3', 'rounded-lg', 'max-w-xl', 'mb-2', 'break-words', 'flex', 'flex-col', 'bg-sky-100', 'self-start', 'mr-auto');


    // **NEW**: Add Sender Name ("AI") to the live answer bubble
    const senderElem = document.createElement('p');
    senderElem.classList.add('font-semibold', 'text-sm', 'mb-1', 'text-sky-700');
    senderElem.textContent = 'AI'; // Or a dynamic AI name if available
    currentAnswerElement.appendChild(senderElem); // Prepend or append as preferred; prepending here

    // Div to hold the actual streaming content (will be populated by appendToAnswer/formatAnswerBubbleFinal)
    // This is effectively the 'message-content' part of the bubble.
    // We create a dedicated div for it so the sender name and timestamp can be siblings.
    const liveContentDiv = document.createElement('div');
    liveContentDiv.classList.add('text-gray-800', 'text-sm', 'message-content', 'live-ai-content-area'); // Added a specific class
    currentAnswerElement.appendChild(liveContentDiv);


    if (thinkingRequestedForCurrentTurn) {
        currentAnswerElement.style.display = 'none'; // Hide bubble if thinking is shown first
    } else {
        // Show answer bubble immediately with loading dots if no thinking display
        const loadingSpan = document.createElement('span');
        loadingSpan.classList.add('loading-dots');
        liveContentDiv.appendChild(loadingSpan); // Add loading dots to the content area
    }
    currentAiTurnContainer.appendChild(currentAnswerElement);

    // --- Code Blocks Area Setup (remains the same) ---
    currentCodeBlocksArea = document.createElement('div');
    currentCodeBlocksArea.classList.add('code-blocks-area');
    currentAiTurnContainer.appendChild(currentCodeBlocksArea);
    // --- End Code Blocks Area Setup ---

    chatHistory.appendChild(currentAiTurnContainer);
    console.log(`[setupNewAiTurn] Finished setup for Turn ID: ${currentTurnId}.`);
}

// You'll also need to adjust `appendToAnswer` and `formatAnswerBubbleFinal`
// to target the `liveContentDiv` within `currentAnswerElement` for the actual message content,
// instead of `currentAnswerElement` directly, to keep the sender name and future timestamp separate.

// Example adjustment for appendToAnswer (conceptual):
// Original: currentAnswerElement.appendChild(node);
// New: const targetContentArea = currentAnswerElement.querySelector('.live-ai-content-area');
//      if (targetContentArea) targetContentArea.appendChild(node); else currentAnswerElement.appendChild(node);
// Similar logic for text nodes and for formatAnswerBubbleFinal's innerHTML operations.


function appendRawTextToThinkingArea(text) {
    if (text && text.trim().length > 0) {
        // console.log(`[appendRawTextToThinkingArea] Received non-empty raw think text: "${text}" (length: ${text?.length})`);
    } else if (text !== null) {
        // console.log(`[appendRawTextToThinkingArea] Received empty or whitespace raw think text (length: ${text?.length})`);
    }

    // console.log(`[appendRawTextToThinkingArea] Checking condition: !thinkingRequestedForCurrentTurn is ${!thinkingRequestedForCurrentTurn} (value: ${thinkingRequestedForCurrentTurn})`);
    if (!thinkingRequestedForCurrentTurn) {
        // console.log("[appendRawTextToThinkingArea] Condition met (!thinkingRequested). Returning early. Should NOT display thinking.");
        return;
    }

    // console.log("[appendRawTextToThinkingArea] Proceeding because thinking was requested.");

    if (!currentThinkingArea || !currentThinkingPreElement || text.length === 0) {
        return;
    }

    if (!hasThinkingContentArrivedThisTurn) {
        if (currentThinkingArea.style.display === 'none') {
            // console.log("[appendRawTextToThinkingArea] First think chunk (and requested). Making area visible NOW. Display style was: " + currentThinkingArea.style.display);
            currentThinkingArea.style.display = '';
        }
        hasThinkingContentArrivedThisTurn = true;
    }

    try {
        currentThinkingPreElement.appendChild(document.createTextNode(text));
    } catch (appendError) {
         console.error("[appendRawTextToThinkingArea] Error appending text node:", appendError, "Pre Element:", currentThinkingPreElement, "Text:", text);
        return;
    }

    const detailsElement = currentThinkingPreElement.closest('details');
    if (detailsElement && detailsElement.open) {
         const isNearBottom = currentThinkingPreElement.scrollHeight - currentThinkingPreElement.scrollTop - currentThinkingPreElement.clientHeight < 50;
         if(isNearBottom) {
             requestAnimationFrame(() => { currentThinkingPreElement.scrollTop = currentThinkingPreElement.scrollHeight; });
         }
    }
}

function appendCodeReference() {
    if (!currentAnswerElement) {
        console.error("Attempted to append code reference to null answer bubble!");
        return;
    }
    if (codeBlockCounterThisTurn > 0) {
         const refSpan = document.createElement('span');
         refSpan.classList.add('code-reference');
         refSpan.textContent = `[Code ${codeBlockCounterThisTurn}]`;
         currentAnswerElement.appendChild(refSpan);
         lastAppendedNode = refSpan;
    } else {
        console.warn("appendCodeReference called but codeBlockCounterThisTurn is 0.");
    }
}

/**
 * Finalizes the AI answer bubble content with Markdown and KaTeX processing.
 * Targets the specific content div within the answer bubble.
 */
function formatAnswerBubbleFinal() {
    if (!currentAnswerElement) {
        console.warn("[formatAnswerBubbleFinal] Skipping: currentAnswerElement is null.");
        accumulatedAnswerText = ''; lastAppendedNode = null; firstAnswerTokenReceived = false; return;
    }

    // **MODIFIED**: Target the dedicated content area
    const targetContentArea = currentAnswerElement.querySelector('.live-ai-content-area');
    if (!targetContentArea) {
        console.error("[formatAnswerBubbleFinal] '.live-ai-content-area' not found. Cannot format content.");
        // Fallback: if somehow the structure is missing, try to use currentAnswerElement directly
        // but this will mix with sender name. This is mostly a safeguard.
        if (accumulatedAnswerText.trim().length > 0) {
             currentAnswerElement.innerHTML += marked.parse(accumulatedAnswerText, { mangle: false, headerIds: false, gfm: true, breaks: true, sanitize: false });
        }
        accumulatedAnswerText = ''; lastAppendedNode = null; firstAnswerTokenReceived = false; return;
    }
    
    // Original logic from formatAnswerBubbleFinal, but operating on `targetContentArea`

    // Ensure the main answer bubble is visible if it has content or accumulated text
    if (currentAnswerElement.style.display === 'none' && (targetContentArea.hasChildNodes() || accumulatedAnswerText.trim().length > 0)) {
        currentAnswerElement.style.display = ''; // Show the whole bubble
        const loadingDots = targetContentArea.querySelector('.loading-dots'); // Dots are inside targetContentArea
        if (loadingDots) loadingDots.remove();
    }

    const hasVisualContent = targetContentArea.hasChildNodes() && !targetContentArea.querySelector('.loading-dots');
    const hasAccumulatedContent = accumulatedAnswerText.trim().length > 0;

    if (!hasVisualContent && !hasAccumulatedContent) {
        const loadingDots = targetContentArea.querySelector('.loading-dots');
        if (loadingDots) loadingDots.remove();
        accumulatedAnswerText = '';
        lastAppendedNode = null;
        // firstAnswerTokenReceived should remain true if it was set, or handle as needed
        return;
    }

    try {
        const storedKatexNodes = {};
        let placeholderIndex = 0;
        let textForMarkdown = accumulatedAnswerText; // Start with accumulated text

        // Find KaTeX spans already rendered by the live streaming logic within targetContentArea
        const katexSpans = Array.from(targetContentArea.children).filter(el => el.matches(`span[${KATEX_RENDERED_ATTR}="true"]`));

        if (katexSpans.length > 0) {
            katexSpans.forEach((el) => {
                if (!el.parentNode) return; // Should be targetContentArea
                const placeholder = `${KATEX_PLACEHOLDER_PREFIX}${placeholderIndex++}`; // KATEX_PLACEHOLDER_PREFIX is global
                storedKatexNodes[placeholder] = el.cloneNode(true);
                try {
                    // Replace the KaTeX span with a text node placeholder
                    el.parentNode.replaceChild(document.createTextNode(placeholder), el);
                } catch (replaceError) {
                    console.error(`[formatAnswerBubbleFinal] Error replacing KaTeX node with placeholder ${placeholder}:`, replaceError, "Node:", el);
                    try { el.parentNode.removeChild(el); } catch (removeError) { console.error("Failed to remove problematic KaTeX node:", removeError); }
                }
            });
            // After replacement, the innerHTML of targetContentArea contains text and placeholders
            textForMarkdown = targetContentArea.innerHTML;
        } else {
             // If no KaTeX spans but there was visual content (e.g. just text nodes from appendToAnswer)
             // and also accumulated text, we should clear the visual DOM and use accumulated text.
            if (hasVisualContent && hasAccumulatedContent) {
                targetContentArea.innerHTML = ''; // Clear existing simple text nodes
            } else if (!hasAccumulatedContent && hasVisualContent) {
                // Only visual content (e.g. from appendToAnswer(null, node) where node was not KaTeX)
                // and no accumulated text. Use existing innerHTML.
                textForMarkdown = targetContentArea.innerHTML;
            }
            // If only accumulated text, textForMarkdown is already set.
        }
        
        if (textForMarkdown.trim().length === 0 && Object.keys(storedKatexNodes).length === 0) {
             // No text to parse and no KaTeX to reinsert.
        } else {
            // Parse the potentially modified innerHTML or accumulated text
            const markdownHtml = marked.parse(textForMarkdown, {
                mangle: false, headerIds: false, gfm: true, breaks: true, sanitize: false
            });
            targetContentArea.innerHTML = markdownHtml; // Set the parsed HTML into the content area
        }


        // Reinsert KaTeX nodes if any were stored
        if (Object.keys(storedKatexNodes).length > 0) {
            const walker = document.createTreeWalker(targetContentArea, NodeFilter.SHOW_TEXT);
            let node;
            const textNodesContainingPlaceholders = [];
            while (node = walker.nextNode()) {
                if (node.nodeValue && node.nodeValue.includes(KATEX_PLACEHOLDER_PREFIX)) {
                    textNodesContainingPlaceholders.push(node);
                }
            }

            textNodesContainingPlaceholders.forEach(textNode => {
                let currentNodeValue = textNode.nodeValue;
                let parent = textNode.parentNode;
                if (!parent) return; // Should be within targetContentArea

                const fragment = document.createDocumentFragment();
                let lastSplitEnd = 0;
                const placeholderScanRegex = new RegExp(`(${KATEX_PLACEHOLDER_PREFIX}\\d+)`, 'g');
                let placeholderMatch;

                while((placeholderMatch = placeholderScanRegex.exec(currentNodeValue)) !== null) {
                    const placeholder = placeholderMatch[1];
                    const matchIndex = placeholderMatch.index;
                    if (matchIndex > lastSplitEnd) {
                        fragment.appendChild(document.createTextNode(currentNodeValue.substring(lastSplitEnd, matchIndex)));
                    }
                    if (storedKatexNodes[placeholder]) {
                        fragment.appendChild(storedKatexNodes[placeholder].cloneNode(true));
                    } else {
                        fragment.appendChild(document.createTextNode(placeholder)); // Fallback
                    }
                    lastSplitEnd = placeholderScanRegex.lastIndex;
                }
                if (lastSplitEnd < currentNodeValue.length) {
                    fragment.appendChild(document.createTextNode(currentNodeValue.substring(lastSplitEnd)));
                }
                parent.replaceChild(fragment, textNode);
            });
        }
    } catch (error) {
        console.error("Error during final Markdown/KaTeX formatting in live AI bubble:", error);
        addErrorMessage("Failed to perform final message formatting for AI response.");
        if (targetContentArea && accumulatedAnswerText.trim().length > 0) {
            targetContentArea.textContent = accumulatedAnswerText; // Fallback to raw accumulated text
        }
    }
    accumulatedAnswerText = ''; // Clear after processing
    lastAppendedNode = null; // Reset for the next stream
    // firstAnswerTokenReceived remains true.
}


function resetStreamingState() {
    // console.log("[DEBUG] Resetting streaming state.");
    currentProcessingMode = MODE_ANSWER;
    langBuffer = ''; currentCodeBlockLang = '';
    currentCodeBlockElement = null; currentCodeBlockPreElement = null;
    katexBuffer = ''; currentKatexMarkerId = null;
    thinkBuffer = ''; tagBuffer = ''; fenceBuffer = ''; // Reset fenceBuffer
    lastAppendedNode = null;
    thinkingRequestedForCurrentTurn = false;
}

function renderAndReplaceKatex(isDisplay, markerId) {

    if (!currentAnswerElement || !markerId || katexBuffer === null || katexBuffer === undefined) {
        console.error("[KaTeX Replace Marker] Error: Invalid state (element, markerId, or buffer). MarkerID:", markerId, "Buffer:", katexBuffer);
        if (markerId && currentAnswerElement) {
             try {
                 const strayMarker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);
                 if (strayMarker?.parentNode) strayMarker.parentNode.removeChild(strayMarker);
             } catch (e) { console.error("Error cleaning stray marker:", e); }
        }
        katexBuffer = '';
        return false;
    }

    const trimmedKatexBuffer = katexBuffer.trim();

    try {
        const stringToRender = trimmedKatexBuffer.length > 0 ? trimmedKatexBuffer : " ";
        const katexHtml = katex.renderToString(stringToRender, {
            displayMode: isDisplay,
            throwOnError: false,
            output: "html",
            strict: false
        });

        if (katexHtml.includes('katex-error') && trimmedKatexBuffer.length > 0) {
            console.warn(`[KaTeX Replace Marker] KaTeX reported a rendering error for buffer: "${trimmedKatexBuffer}". Marker ID: ${markerId}. Raw text will remain.`);
             try {
                 const marker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);
                 if (marker?.parentNode) marker.parentNode.removeChild(marker);
                 else console.warn("Couldn't find marker to clean up after render error.");
             } catch (cleanupError) { console.error("Error during marker cleanup after render error:", cleanupError); }
            katexBuffer = '';
            return false;
        }

        const startMarker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);

        if (!startMarker) {
            console.error(`[KaTeX Replace Marker] Error: Cannot find start marker span with ID: ${markerId}. Aborting replacement. Content might be inconsistent.`);
            katexBuffer = '';
            return false;
        }

        if (!startMarker.parentNode) {
             console.error(`[KaTeX Replace Marker] Error: Start marker span with ID ${markerId} found but has no parent (already removed?). Aborting.`);
             katexBuffer = '';
             return false;
        }

        const parent = startMarker.parentNode;
        let nodesToRemove = [];
        let currentNode = startMarker.nextSibling;

        while (currentNode) {
            nodesToRemove.push(currentNode);
            if (nodesToRemove.length > 1000) {
                console.error("[KaTeX Replace Marker] Error: Excessive node collection limit reached (1000). Aborting replacement.");
                 try { parent.removeChild(startMarker); } catch(e){}
                 katexBuffer = '';
                 return false;
            }
            currentNode = currentNode.nextSibling;
        }

        const katexSpan = document.createElement('span');
        katexSpan.setAttribute(KATEX_RENDERED_ATTR, 'true');
        katexSpan.innerHTML = katexHtml;

        parent.insertBefore(katexSpan, startMarker);
        parent.removeChild(startMarker);

        nodesToRemove.forEach(node => {
            if (node.parentNode === parent) {
                parent.removeChild(node);
            } else {
                console.warn("[KaTeX Replace Marker] Node parent changed or node removed unexpectedly during collection, skipping removal:", node);
            }
        });

        appendToAnswer(null, katexSpan);
        katexBuffer = '';
        return true;

    } catch (error) {
        console.error("[KaTeX Replace Marker] General error during marker-based replacement:", error);
        try {
            const marker = currentAnswerElement?.querySelector(`span[data-katex-start-id="${markerId}"]`);
            if (marker?.parentNode) marker.parentNode.removeChild(marker);
        } catch (cleanupError) { console.error("Error during marker cleanup after general error:", cleanupError); }
        katexBuffer = '';
        return false;
    }
}

function finalizeTurnOnErrorOrClose() {
    console.log("[DEBUG] finalizeTurnOnErrorOrClose called.");
    if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK && currentCodeBlockElement) {
        console.warn("Stream ended unexpectedly inside code block. Finalizing highlight.");
        try { finalizeCodeBlock(true); } catch (e) { console.error("Prism highlight error on close:", e); }
    }
    if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE ||
        currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY ||
        currentProcessingMode === MODE_MAYBE_START_DISPLAY_KATEX) {
        console.warn("Stream ended unexpectedly inside KaTeX block. Processing raw text.");
        if (currentKatexMarkerId) {
            renderAndReplaceKatex(currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY, currentKatexMarkerId);
            currentKatexMarkerId = null;
        }
    }
     if (currentProcessingMode === MODE_INSIDE_THINK || currentProcessingMode === MODE_MAYBE_END_THINK || currentProcessingMode === MODE_SEEKING_TAG) {
         console.warn("Stream ended unexpectedly inside/seeking Think tags. Finishing think buffer:", thinkBuffer);
         if (currentThinkingArea && currentThinkingArea.style.display !== 'none' && currentThinkingPreElement) {
              appendRawTextToThinkingArea("\n--- (Stream ended unexpectedly during thinking) ---");
         }
     }

    formatAnswerBubbleFinal();
    resetStreamingState();
    setInputDisabledState(true);
}

/**
 * Creates the DOM structure for a new, live code block being streamed.
 * Hides the run button for unsupported languages.
 * @param {string} language - The language specified after the opening ``` fence.
 */
function createCodeBlockStructure(language) {
    if (!currentCodeBlocksArea) {
        console.error("createCodeBlockStructure: Code blocks area is null!");
        return;
    }
    codeBlockCounterThisTurn++;
    const currentCodeNumber = codeBlockCounterThisTurn;
    const blockId = `code-block-turn${currentTurnId}-${currentCodeNumber}`;
    const safeLanguage = (language || '').trim().toLowerCase() || 'plaintext';

    // Language aliases and Prism language determination (as before)
    const langAlias = { /* ... keep your existing aliases ... */
        'python': 'python', 'py': 'python', 'javascript': 'javascript', 'js': 'javascript',
        'html': 'markup', 'xml': 'markup', 'svg': 'markup', 'css': 'css', 'bash': 'bash',
        'sh': 'bash', 'shell': 'bash', 'json': 'json', 'yaml': 'yaml', 'yml': 'yaml',
        'markdown': 'markdown', 'md': 'markdown', 'sql': 'sql', 'java': 'java', 'c': 'c',
        'cpp': 'cpp', 'c++': 'cpp', 'csharp': 'csharp', 'cs': 'csharp', 'go': 'go',
        'rust': 'rust', 'php': 'php', 'ruby': 'ruby', 'rb': 'ruby',
        'dockerfile': 'docker', 'docker': 'docker', 'typescript': 'typescript', 'ts': 'typescript',
        'plaintext': 'plain', 'text': 'plain',
    };
    const prismLang = langAlias[safeLanguage] || safeLanguage;
    const displayLang = safeLanguage; // Use the cleaned-up language name for checks/display
    currentCodeBlockLang = prismLang; // Store the Prism language used

    // --- ADD: List of languages supported by the backend Docker execution ---
    const supportedExecutionLanguages = [
        "python", "javascript", "cpp", "csharp", "typescript", "java", "go", "rust"
        // Add or remove languages based on your config.py SUPPORTED_LANGUAGES keys
    ];
    const isLanguageSupported = supportedExecutionLanguages.includes(displayLang);
    // --- END OF ADD ---

    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;

    const container = document.createElement('div');
    container.classList.add('code-block-container');
    container.id = blockId;
    container.dataset.language = displayLang; // Store the display language

    const codeHeader = document.createElement('div');
    codeHeader.classList.add('code-block-header');

    const codeButtonsDiv = document.createElement('div');
    codeButtonsDiv.classList.add('code-block-buttons');

    // Create buttons (as before)
    const runStopBtn = document.createElement('button');
    runStopBtn.classList.add('run-code-btn', 'code-action-btn');
    runStopBtn.dataset.status = 'idle';
    runStopBtn.innerHTML = playIconSvg;
    runStopBtn.title = 'Run Code';
    runStopBtn.addEventListener('click', handleRunStopCodeClick);

    const toggleCodeBtn = document.createElement('button');
    toggleCodeBtn.classList.add('toggle-code-btn', 'code-action-btn');
    toggleCodeBtn.textContent = 'Hide';
    toggleCodeBtn.title = 'Show/Hide Code';

    const copyCodeBtn = document.createElement('button');
    copyCodeBtn.classList.add('copy-code-btn', 'code-action-btn');
    copyCodeBtn.textContent = 'Copy';
    copyCodeBtn.title = 'Copy Code';

    // --- ADD: Conditionally hide run button ---
    if (!isLanguageSupported) {
        runStopBtn.style.display = 'none'; // Hide the button entirely
        runStopBtn.title = `Run Code (language '${displayLang}' not supported for execution)`; // Update title even if hidden
        console.log(`Hiding run button for unsupported language: ${displayLang}`); // Optional log
    }
    // --- END OF ADD ---

    // Add buttons to their container (run button is added even if hidden, simplifies layout logic)
    codeButtonsDiv.appendChild(runStopBtn);
    codeButtonsDiv.appendChild(toggleCodeBtn);
    codeButtonsDiv.appendChild(copyCodeBtn);

    // Code block title (as before)
    const codeTitle = document.createElement('span');
    codeTitle.classList.add('code-block-title');
    codeTitle.textContent = `Code ${currentCodeNumber} (${displayLang})`;
    codeTitle.style.flexGrow = '1';
    codeTitle.style.textAlign = 'left';

    // Assemble header (as before)
    codeHeader.appendChild(codeButtonsDiv);
    codeHeader.appendChild(codeTitle);

    // Create pre/code elements (as before)
    const preElement = document.createElement('pre');
    preElement.classList.add('manual');
    const codeElement = document.createElement('code');
    codeElement.className = `language-${prismLang}`;
    codeElement.setAttribute('contenteditable', 'true'); // Live code is editable
    codeElement.setAttribute('spellcheck', 'false');

    // Assign to global state variables for streaming (as before)
    currentCodeBlockPreElement = preElement;
    currentCodeBlockElement = codeElement;

    // Create output area structure (as before)
    const outputHeader = document.createElement('div');
    outputHeader.classList.add('code-output-header');
    outputHeader.style.display = 'none';
    // ... (rest of output header setup: buttons, title, status span) ...
    const outputButtonsDiv = document.createElement('div');
    outputButtonsDiv.classList.add('code-block-buttons');
    const placeholderSpan = document.createElement('span');
    placeholderSpan.classList.add('output-header-button-placeholder');
    outputButtonsDiv.appendChild(placeholderSpan);
    const toggleOutputBtn = document.createElement('button');
    toggleOutputBtn.classList.add('toggle-output-btn', 'code-action-btn');
    toggleOutputBtn.textContent = 'Hide';
    toggleOutputBtn.title = 'Show/Hide Output';
    const copyOutputBtn = document.createElement('button');
    copyOutputBtn.classList.add('copy-output-btn', 'code-action-btn');
    copyOutputBtn.textContent = 'Copy';
    copyOutputBtn.title = 'Copy Output';
    outputButtonsDiv.appendChild(toggleOutputBtn);
    outputButtonsDiv.appendChild(copyOutputBtn);
    const outputTitle = document.createElement('span');
    outputTitle.classList.add('output-header-title');
    outputTitle.textContent = `Output Code ${currentCodeNumber}`;
    const codeStatusSpan = document.createElement('span');
    codeStatusSpan.classList.add('code-status-span');
    codeStatusSpan.textContent = 'Idle';
    outputHeader.appendChild(outputButtonsDiv);
    outputHeader.appendChild(outputTitle);
    outputHeader.appendChild(codeStatusSpan);

    const outputConsoleDiv = document.createElement('div');
    outputConsoleDiv.classList.add('code-output-console');
    outputConsoleDiv.style.display = 'none';
    const outputPre = document.createElement('pre');
    outputConsoleDiv.appendChild(outputPre);

    // Assemble the full block (as before)
    preElement.appendChild(codeElement);
    container.appendChild(codeHeader);
    container.appendChild(preElement);
    container.appendChild(outputHeader);
    container.appendChild(outputConsoleDiv);

    // Add event listeners (as before)
    // Toggle code listener
    toggleCodeBtn.addEventListener('click', () => {
        const isHidden = preElement.classList.toggle('hidden');
        toggleCodeBtn.textContent = isHidden ? 'Show' : 'Hide';
    });
    // Copy code listener
    copyCodeBtn.addEventListener('click', async () => {
        if (!codeElement) return;
        try {
            await navigator.clipboard.writeText(codeElement.textContent || '');
            copyCodeBtn.textContent = 'Copied!';
            copyCodeBtn.classList.add('copied');
            setTimeout(() => { copyCodeBtn.textContent = 'Copy'; copyCodeBtn.classList.remove('copied'); }, 1500);
        } catch (err) {
            console.error('Failed to copy code: ', err);
            copyCodeBtn.textContent = 'Error';
            setTimeout(() => { copyCodeBtn.textContent = 'Copy'; }, 1500);
        }
    });
    // Run button listener is already attached above
    // Debounced highlight listener for editable code (as before)
    const debouncedHighlight = debounce(() => {
        const savedPosition = getCursorPosition(codeElement);
        if (savedPosition === -1) { console.warn("Could not save cursor position or cursor not in element. Highlight may cause cursor jump."); }
        try {
            const currentText = codeElement.textContent;
            codeElement.innerHTML = ''; 
            codeElement.textContent = currentText; 
            Prism.highlightElement(codeElement);
            if (savedPosition !== -1) { setCursorPosition(codeElement, savedPosition); }
        } catch (e) {
            console.error("Error during debounced highlighting:", e);
            if (savedPosition !== -1) { setCursorPosition(codeElement, savedPosition); }
        }
    }, 500);
    codeElement.addEventListener('input', debouncedHighlight);
    codeElement.addEventListener('paste', (e) => { setTimeout(debouncedHighlight, 100); });
    // Output area listeners (as before)
    toggleOutputBtn.addEventListener('click', () => {
        const isHidden = outputConsoleDiv.classList.toggle('hidden');
        toggleOutputBtn.textContent = isHidden ? 'Show' : 'Hide';
    });
    copyOutputBtn.addEventListener('click', async () => {
        if (!outputPre) return;
        try {
            await navigator.clipboard.writeText(outputPre.textContent || '');
            copyOutputBtn.textContent = 'Copied!';
            copyOutputBtn.classList.add('copied');
            setTimeout(() => { copyOutputBtn.textContent = 'Copy'; copyOutputBtn.classList.remove('copied'); }, 1500);
        } catch (err) {
            console.error('Failed to copy output: ', err);
            copyOutputBtn.textContent = 'Error';
            setTimeout(() => { copyOutputBtn.textContent = 'Copy'; }, 1500);
        }
    });

    // Append to DOM and reset state (as before)
    currentCodeBlocksArea.appendChild(container);
    lastAppendedNode = null; // Reset last appended node for main answer bubble
}

async function handleRunStopCodeClick(event) {
    const button = event.currentTarget;
    const container = button.closest('.code-block-container');
    if (!container) return;

    const codeBlockId = container.id;
    const language = container.dataset.language;
    const codeElement = container.querySelector('code');
    const outputHeader = container.querySelector('.code-output-header');
    const outputConsoleDiv = container.querySelector('.code-output-console');
    const outputPre = outputConsoleDiv ? outputConsoleDiv.querySelector('pre') : null;
    const statusSpan = outputHeader ? outputHeader.querySelector('.code-status-span') : null;

    if (!language || !codeElement || !outputHeader || !outputConsoleDiv || !outputPre || !statusSpan) {
        console.error(`Missing elements for code block ${codeBlockId}`);
        addErrorMessage(`Cannot run code block ${codeBlockId}: Internal UI error.`);
        return;
    }

    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;
    const stopIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><rect width="100" height="100" rx="15"/></svg>`;
    const stoppingIconSvg = `<svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: block;"><path d="M12 2V6M12 18V22M6 12H2M22 12H18M19.0711 4.92893L16.2426 7.75736M7.75736 16.2426L4.92893 19.0711M19.0711 19.0711L16.2426 16.2426M7.75736 7.75736L4.92893 4.92893" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;

    const code = codeElement.textContent || '';
    const currentStatus = button.dataset.status;

    if (!websocket || websocket.readyState !== WebSocket.OPEN) {
        console.warn("WebSocket not open. Cannot run/stop code.");
        statusSpan.textContent = 'Error: Disconnected';
        statusSpan.className = 'code-status-span error';
        outputHeader.style.display = 'flex';
        addErrorMessage("Cannot run/stop code: Not connected to server.");
        return;
    }

    if (currentStatus === 'idle') {
        console.log(`Requesting run for block ${codeBlockId} (${language})`);
        button.dataset.status = 'running';
        button.innerHTML = stopIconSvg;
        button.title = 'Stop Execution';

        outputPre.innerHTML = '';
        outputHeader.style.display = 'flex';
        outputConsoleDiv.style.display = 'block';
        outputConsoleDiv.classList.remove('hidden');
        const toggleOutputBtn = outputHeader.querySelector('.toggle-output-btn');
        if (toggleOutputBtn) toggleOutputBtn.textContent = 'Hide';

        statusSpan.textContent = 'Running...';
        statusSpan.className = 'code-status-span running';

        websocket.send(JSON.stringify({
            type: 'run_code',
            payload: { code_block_id: codeBlockId, language: language, code: code }
        }));

    } else if (currentStatus === 'running') {
        console.log(`Requesting stop for block ${codeBlockId}`);
        button.dataset.status = 'stopping';
        button.innerHTML = stoppingIconSvg;
        button.title = 'Stopping...';
        button.disabled = true;

        statusSpan.textContent = 'Stopping...';
        statusSpan.className = 'code-status-span stopping';

        websocket.send(JSON.stringify({
            type: 'stop_code',
            payload: { code_block_id: codeBlockId }
        }));
    } else if (currentStatus === 'stopping') {
        console.log(`Already stopping block ${codeBlockId}`);
    }
}

function addCodeOutput(outputPreElement, streamType, text) {
    if (!outputPreElement || !text) return;

    const span = document.createElement('span');
    span.classList.add(streamType === 'stderr' ? 'stderr-output' : 'stdout-output');
    span.textContent = text;
    outputPreElement.appendChild(span);
    outputPreElement.scrollTop = outputPreElement.scrollHeight;
}

/**
 * Appends text content to the currently active code block element 
 * and triggers debounced syntax highlighting.
 * @param {string} text - The text chunk to append.
 */
function appendToCodeBlock(text) {
    // Ensure we have a target code element to append to
    if (currentCodeBlockElement) {
        // Append the raw text node to the <code> element
        currentCodeBlockElement.appendChild(document.createTextNode(text));
        
        // Auto-scroll the code block's <pre> container if it's visible
        // currentCodeBlockPreElement is the parent <pre> element
        if(currentCodeBlockPreElement && !currentCodeBlockPreElement.classList.contains('hidden')) {
            // Check if the scroll position is near the bottom
            const isNearCodeBottom = currentCodeBlockPreElement.scrollHeight - currentCodeBlockPreElement.scrollTop - currentCodeBlockPreElement.clientHeight < 50; // Threshold of 50px
            if(isNearCodeBottom) {
                // Use requestAnimationFrame for smoother scrolling after the DOM update
                requestAnimationFrame(() => { 
                    // Check again inside animation frame as state might change rapidly
                    if(currentCodeBlockPreElement) { 
                       currentCodeBlockPreElement.scrollTop = currentCodeBlockPreElement.scrollHeight; 
                    }
                });
            }
        }

        // --- THIS IS THE SPECIFIC CHANGE FOR THIS STEP ---
        // Trigger the debounced highlighter every time text is appended
        throttledStreamHighlight()
        // --- END OF SPECIFIC CHANGE ---

    } else {
        // Log an error if we try to append but no code block is active
        console.error("Attempted to append to null code block element!");
    }
}

/**
 * Appends text or a DOM node to the current AI's answer area.
 * Targets the specific content div within the answer bubble.
 * @param {string | null} text - Text to append.
 * @param {Node | null} node - DOM node to append.
 */
function appendToAnswer(text = null, node = null) {
    if (!currentAnswerElement) {
        console.error("[appendToAnswer] currentAnswerElement is null. Cannot append.");
        return;
    }

    // **MODIFIED**: Target the dedicated content area within the AI message bubble
    const targetContentArea = currentAnswerElement.querySelector('.live-ai-content-area');
    if (!targetContentArea) {
        console.error("[appendToAnswer] '.live-ai-content-area' not found in currentAnswerElement. Appending to currentAnswerElement directly as fallback.");
        // Fallback to old behavior if somehow the structure is missing, though this shouldn't happen with the updated setupNewAiTurn
        const fallbackTarget = currentAnswerElement; 
        
        // Logic from original appendToAnswer, but using fallbackTarget
        let isMeaningfulContentFallback = (text && text.trim().length > 0) ||
                                   (node && node.nodeType !== Node.COMMENT_NODE && (!node.textContent || node.textContent.trim().length > 0));

        if (!firstAnswerTokenReceived && isMeaningfulContentFallback) {
            if (fallbackTarget.style.display === 'none') {
                fallbackTarget.style.display = '';
            }
            const loadingDotsFallback = fallbackTarget.querySelector('.loading-dots');
            if (loadingDotsFallback) {
                loadingDotsFallback.remove();
            }
            firstAnswerTokenReceived = true;
        }

        if (node) {
            if (!node.classList || !node.classList.contains('loading-dots')) {
                fallbackTarget.appendChild(node);
                lastAppendedNode = node; // Keep track of last appended node relative to its parent
            }
        } else if (text !== null && text.length > 0) {
            accumulatedAnswerText += text; // Still accumulate globally for formatAnswerBubbleFinal
            if (lastAppendedNode && lastAppendedNode.nodeType === Node.TEXT_NODE && lastAppendedNode.parentNode === fallbackTarget) {
                lastAppendedNode.nodeValue += text;
            } else {
                const textNode = document.createTextNode(text);
                fallbackTarget.appendChild(textNode);
                lastAppendedNode = textNode;
            }
        }
        return; // End of fallback logic
    }


    // --- Main logic using targetContentArea ---
    let isMeaningfulContent = (text && text.trim().length > 0) ||
                              (node && node.nodeType !== Node.COMMENT_NODE && (!node.textContent || node.textContent.trim().length > 0));

    if (!firstAnswerTokenReceived && isMeaningfulContent) {
        // This logic primarily handles making the *overall* currentAnswerElement visible
        // if it was hidden (e.g., due to thinkingRequestedForCurrentTurn).
        // The loading dots are inside targetContentArea.
        if (currentAnswerElement.style.display === 'none') {
            currentAnswerElement.style.display = ''; // Show the whole bubble
        }
        const loadingDots = targetContentArea.querySelector('.loading-dots');
        if (loadingDots) {
            loadingDots.remove();
        }
        firstAnswerTokenReceived = true;
    }

    if (node) {
        // Don't append loading dots if they are the node (they are handled above)
        if (!node.classList || !node.classList.contains('loading-dots')) {
            targetContentArea.appendChild(node);
            // lastAppendedNode should refer to nodes within targetContentArea for text concatenation logic
            lastAppendedNode = (targetContentArea.contains(node)) ? node : null;
        }
    } else if (text !== null && text.length > 0) {
        accumulatedAnswerText += text; // Global accumulation for final formatting
        // Smart text node concatenation within targetContentArea
        if (lastAppendedNode && lastAppendedNode.nodeType === Node.TEXT_NODE && lastAppendedNode.parentNode === targetContentArea) {
            lastAppendedNode.nodeValue += text;
        } else {
            const textNode = document.createTextNode(text);
            targetContentArea.appendChild(textNode);
            lastAppendedNode = textNode;
        }
    }
}


/**
 * Finalizes the currently active code block, performing a final, 
 * non-debounced syntax highlight to ensure completeness.
 * Resets code block streaming state variables.
 * @param {boolean} isTruncated - Indicates if the stream ended unexpectedly (e.g., via EOS).
 */
function finalizeCodeBlock(isTruncated = false) {
    // Check if there is an active code block element being processed
    if (currentCodeBlockElement) {
        const blockContainer = currentCodeBlockElement.closest('.code-block-container');
        const blockId = blockContainer ? blockContainer.id : 'unknown';
        const langClass = currentCodeBlockElement.className; // e.g., "language-python"
        
        // Log the finalization attempt
        console.log(`[finalizeCodeBlock] Finalizing highlight for block ${blockId} (lang class: ${langClass}). Stream truncated: ${isTruncated}`);

        try {
            // Normalizing the text nodes within the <code> element can sometimes help 
            // Prism handle unusual spacing or fragmented text nodes correctly.
            currentCodeBlockElement.normalize(); 
            
            // --- THIS IS THE SPECIFIC CHANGE FOR THIS STEP ---
            // Perform an immediate, final highlight on the entire code block element.
            // This ensures the complete code is highlighted, catching any parts potentially 
            // missed by the last debounced call if the stream ended abruptly.
            if (typeof Prism !== 'undefined' && typeof Prism.highlightElement === 'function') {
                Prism.highlightElement(currentCodeBlockElement);
                console.log(`[finalizeCodeBlock] Final highlighting applied successfully for ${blockId}.`);
            } else {
                 console.warn(`[finalizeCodeBlock] Prism.js or highlightElement not available for final highlight on block ${blockId}.`);
            }
            // --- END OF SPECIFIC CHANGE ---

            // Optional: Cancel any pending debounced highlight call.
            // This requires your debounce implementation to have a .cancel() method.
            // If it doesn't, you can omit this block.
            // if (debouncedStreamHighlight && typeof debouncedStreamHighlight.cancel === 'function') {
            //     console.log(`[finalizeCodeBlock] Cancelling pending debounced highlight for block ${blockId}.`);
            //     debouncedStreamHighlight.cancel();
            // }

        } catch (e) {
            // Log any errors during the final highlighting process
            console.error(`Prism highlight error on finalizeCodeBlock (lang '${currentCodeBlockLang}', block ${blockId}):`, e);
        }
    } else {
         // Log a warning if this function is called when no code block is active
         console.warn("[finalizeCodeBlock] Called but currentCodeBlockElement is null.");
    }
    
    // Reset the global state variables related to the code block stream AFTER processing.
    currentCodeBlockElement = null;    // Reference to the <code> element
    currentCodeBlockPreElement = null; // Reference to the parent <pre> element
    currentCodeBlockLang = '';         // Language identifier (e.g., 'python')
    // fenceBuffer should also be reset if it's tracked globally and related
    // fenceBuffer = ''; 
}


function resetAllCodeButtonsOnErrorOrClose() {
    console.log("Resetting all code run/stop buttons and statuses due to connection issue.");
    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;

    document.querySelectorAll('.code-block-container').forEach(container => {
        const button = container.querySelector('.run-code-btn');
        const outputHeader = container.querySelector('.code-output-header');
        const statusSpan = outputHeader ? outputHeader.querySelector('.code-status-span') : null;

        if (button && button.dataset.status !== 'idle') {
            button.dataset.status = 'idle';
            button.innerHTML = playIconSvg;
            button.title = 'Run Code';
            button.disabled = false;
        }
        if (statusSpan) {
             if (!statusSpan.classList.contains('idle') && !statusSpan.classList.contains('success')) {
                 if (outputHeader) outputHeader.style.display = 'flex';
                 statusSpan.textContent = 'Error: Disconnected';
                 statusSpan.className = 'code-status-span error';
             }
        }
    });
}

function connectWebSocket() {

    let sessionId = null;
    const pathParts = window.location.pathname.split('/');
    // Example: /chat/ef7a41e6-2ba7-4882-b9bb-91c03edb25ac
    // pathParts would be ["", "chat", "ef7a41e6-2ba7-4882-b9bb-91c03edb25ac"]
    if (pathParts.length >= 3 && pathParts[1] === 'chat') {
        sessionId = pathParts[2]; // This should be the session_id
        if (!sessionId || sessionId.trim() === "") {
             console.error("Session ID extracted from path is empty.");
             sessionId = null; // Treat empty ID as invalid
        }
    }

    if (!sessionId) {
        console.error("Could not extract valid session ID from URL path:", window.location.pathname);
        // Use your existing addErrorMessage function if available
        if (typeof addErrorMessage === 'function') {
             addErrorMessage("Cannot connect to chat: Invalid session ID in URL.");
        } else {
             alert("Cannot connect to chat: Invalid session ID in URL.");
        }
        // Use your existing setInputDisabledState function if available
        if (typeof setInputDisabledState === 'function') {
             setInputDisabledState(true);
        }
        return; // Stop connection attempt
    }
    // --- END: Added logic to get session ID from URL path ---

    // Use your existing global clientId variable
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    // Construct the URL with the extracted sessionId and existing clientId
    const wsUrl = `${wsProtocol}//${window.location.host}/ws/${sessionId}/${clientId}`; // Corrected URL format

    console.log(`[DEBUG] Attempting to connect to WebSocket: ${wsUrl}`);

    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`; // Keep this if used elsewhere, otherwise remove

    try {
        // Use the corrected wsUrl
        const ws = new WebSocket(wsUrl);
        console.log('connectWebSocket: Creating WebSocket object...');

        ws.onopen = (event) => {
            console.log("[DEBUG] WebSocket connection opened. ws object:", ws);
            websocket = ws; // Assign to your global websocket variable

            // Check for your actual helper functions
            if (typeof addSystemMessage !== 'function' || typeof setupNewAiTurn !== 'function' || typeof appendToAnswer !== 'function' || typeof formatAnswerBubbleFinal !== 'function' || typeof resetStreamingState !== 'function' || typeof setInputDisabledState !== 'function') {
                console.error("CRITICAL ERROR: One or more required helper functions are not defined when ws.onopen is called. Check script order.");
                alert("Chat initialization failed. Please refresh the page. (Error: Helpers undefined)");
                if (typeof setInputDisabledState === 'function') setInputDisabledState(true);
                return;
            }

            if (typeof setInputDisabledState === 'function') setInputDisabledState(false);
            if (typeof addSystemMessage === 'function') addSystemMessage("Connected to the chat server.");

            // thinkingRequestedForCurrentTurn = false; // Assuming this is a global/accessible variable
            // setupNewAiTurn(); // Your existing function
            // const welcomeMessage = "Hello! How can I help you today?";
            // appendToAnswer(welcomeMessage); // Your existing function
            // formatAnswerBubbleFinal(); // Your existing function
            // console.log("[DEBUG ws.onopen] Resetting state after welcome message.");
            // resetStreamingState(); // Your existing function

            if(messageInput && messageInput.offsetParent !== null) messageInput.focus();
        };

        ws.onmessage = (event) => {
            // This is the full onmessage logic from your provided script
            let isJsonMessage = false;
            let messageData = null;
            try {
                if (typeof event.data === 'string' && event.data.startsWith('{')) {
                    messageData = JSON.parse(event.data);
                    if (messageData && messageData.type && messageData.payload && messageData.payload.code_block_id) {
                        isJsonMessage = true;
                    }
                }
            } catch (e) {
                isJsonMessage = false;
            }

            if (isJsonMessage) {
                // console.log("%c[ws.onmessage] Code Execution JSON received:", "color: blue;", messageData);
                const { type, payload } = messageData;
                const { code_block_id } = payload;
                const container = document.getElementById(code_block_id);

                if (!container) {
                    console.warn(`Received message for unknown code block ID: ${code_block_id}`, payload);
                    return;
                }

                const outputHeader = container.querySelector('.code-output-header');
                const outputConsoleDiv = container.querySelector('.code-output-console');
                const outputPre = outputConsoleDiv ? outputConsoleDiv.querySelector('pre') : null;
                const runStopBtn = container.querySelector('.run-code-btn');
                const statusSpan = outputHeader ? outputHeader.querySelector('.code-status-span') : null;

                if (!outputHeader || !outputPre || !runStopBtn || !statusSpan) {
                        console.error(`Missing elements for code block ${code_block_id}. Cannot process message.`);
                        return;
                }

                switch (type) {
                    case 'code_output':
                        const { stream, data } = payload;
                        if (outputHeader.style.display === 'none') {
                            // console.log(`Showing output header for ${code_block_id} on first output.`);
                            outputHeader.style.display = 'flex';
                        }
                        if (outputConsoleDiv.style.display === 'none') {
                            // console.log(`Showing output console for ${code_block_id} on first output.`);
                            outputConsoleDiv.style.display = 'block';
                            outputConsoleDiv.classList.remove('hidden');
                                const toggleOutputBtn = outputHeader.querySelector('.toggle-output-btn');
                                if (toggleOutputBtn) toggleOutputBtn.textContent = 'Hide';
                        }
                        if (runStopBtn.dataset.status === 'idle'){
                                const stopIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><rect width="100" height="100" rx="15"/></svg>`;
                                console.warn(`Received code output for ${code_block_id} while button was idle. Forcing state to running.`);
                                runStopBtn.dataset.status = 'running';
                                runStopBtn.innerHTML = stopIconSvg;
                                runStopBtn.title = 'Stop Execution';
                                runStopBtn.disabled = false;
                                statusSpan.textContent = 'Running...';
                                statusSpan.className = 'code-status-span running';
                        }
                        addCodeOutput(outputPre, stream, data); // Your existing function
                        break;

                    case 'code_finished':
                        if (outputHeader.style.display === 'none') {
                            // console.log(`Showing output header for ${code_block_id} on finish.`);
                            outputHeader.style.display = 'flex';
                        }
                            if (outputConsoleDiv.style.display === 'none') {
                            // console.log(`Showing output console for ${code_block_id} on finish.`);
                            outputConsoleDiv.style.display = 'block';
                            outputConsoleDiv.classList.remove('hidden');
                                const toggleOutputBtn = outputHeader.querySelector('.toggle-output-btn');
                                if (toggleOutputBtn) toggleOutputBtn.textContent = 'Hide';
                        }

                        const { exit_code, error } = payload;
                        let finishMessage = '';
                        let statusClass = '';

                        if (error) {
                            if (error === "Execution stopped by user.") {
                                finishMessage = 'Stopped'; statusClass = 'stopped';
                            } else if (error.startsWith("Execution timed out")) {
                                    finishMessage = 'Timeout'; statusClass = 'error';
                            } else {
                                    finishMessage = `Error (${exit_code !== undefined ? exit_code : 'N/A'})`; statusClass = 'error';
                                    console.error(`Execution error for ${code_block_id}:`, error);
                            }
                        } else {
                            finishMessage = `Finished (Exit: ${exit_code})`;
                            statusClass = exit_code === 0 ? 'success' : 'error';
                        }

                        statusSpan.textContent = finishMessage;
                        statusSpan.className = `code-status-span ${statusClass}`;

                        runStopBtn.dataset.status = 'idle';
                        // Use the playIconSvg defined earlier or redefine it if needed
                        runStopBtn.innerHTML = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;
                        runStopBtn.title = 'Run Code';
                        runStopBtn.disabled = false;
                        break;

                    default:
                        console.warn(`Received unknown code execution message type: ${type}`, payload);
                }

            } else {
                // console.log("%c[ws.onmessage] RAW chat data received:", "color: magenta;", event.data);
                let chunk = event.data;
                const currentTurnIdForMsg = currentTurnId; // Assuming currentTurnId is global/accessible

                // Inside your connectWebSocket -> ws.onmessage -> else (raw chat data) -> if (chunk === "<EOS>") block:

                if (chunk === "<EOS>") {
                    const currentTurnIdForMsg = currentTurnId; // Capture currentTurnId for logging context
                    console.log(`%c[ws.onmessage] Turn ${currentTurnIdForMsg}: Received <EOS>. Finalizing turn.`, 'color: green; font-weight: bold;');

                    // Handle cases where EOS is received unexpectedly in the middle of processing
                    if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly inside a code block. Appending any fence buffer and finalizing code block.`);
                        if (fenceBuffer && fenceBuffer.length > 0) {
                            appendToCodeBlock(fenceBuffer); // Append any partial fence characters
                        }
                        try {
                            finalizeCodeBlock(true); // true indicates truncation
                        } catch (e) {
                            console.error(`Error finalizing code block on EOS for Turn ${currentTurnIdForMsg}:`, e);
                        }
                    } else if (currentProcessingMode === MODE_SEEKING_CODE_END_FENCE) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly while seeking code end fence. Treating fence buffer '${fenceBuffer}' as part of the code.`);
                        appendToCodeBlock(fenceBuffer); // Treat buffered fence characters as code content
                        try {
                            finalizeCodeBlock(true); // true indicates truncation
                        } catch (e) {
                            console.error(`Error finalizing code block on EOS (seeking end fence) for Turn ${currentTurnIdForMsg}:`, e);
                        }
                    } else if (currentProcessingMode === MODE_SEEKING_CODE_LANGUAGE && langBuffer && langBuffer.length > 0) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly while seeking code language. Treating '${FENCE}${langBuffer}' as plain text.`);
                        appendToAnswer(FENCE + langBuffer); // Append the incomplete fence and language buffer as text
                    } else if (currentProcessingMode === MODE_SEEKING_CODE_START_FENCE && fenceBuffer && fenceBuffer.length > 0) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly while seeking code start fence. Treating '${fenceBuffer}' as plain text.`);
                        appendToAnswer(fenceBuffer); // Append the incomplete fence buffer as text
                    } else if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE || currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly inside a KaTeX block. Attempting to render buffered content: "${katexBuffer}"`);
                        if (currentKatexMarkerId) {
                            renderAndReplaceKatex(currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY, currentKatexMarkerId);
                            currentKatexMarkerId = null; // Reset marker ID
                        } else {
                             // If no marker, append raw buffer as text to avoid losing it
                            appendToAnswer((currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY ? "$$" : "$") + katexBuffer);
                        }
                    } else if (currentProcessingMode === MODE_MAYBE_START_DISPLAY_KATEX) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly after a '$'. Treating as plain text.`);
                        appendToAnswer('$'); // Append the single dollar sign
                    } else if (currentProcessingMode === MODE_INSIDE_THINK || currentProcessingMode === MODE_MAYBE_END_THINK || currentProcessingMode === MODE_SEEKING_TAG) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly while in mode '${currentProcessingMode}'. Buffered tag: "${tagBuffer}", Buffered think: "${thinkBuffer}"`);
                        if (thinkingRequestedForCurrentTurn && currentThinkingArea && currentThinkingPreElement) {
                            if (tagBuffer) appendRawTextToThinkingArea(tagBuffer); // Append any partial tag
                            // thinkBuffer should have already been appended incrementally by appendRawTextToThinkingArea
                            appendRawTextToThinkingArea("\n--- (End of stream during thinking process) ---");
                        } else if (tagBuffer) { // If not in thinking mode but had a tag buffer
                            appendToAnswer(tagBuffer);
                        }
                    }
                    // Any other modes might just proceed to formatAnswerBubbleFinal with existing accumulatedAnswerText

                    formatAnswerBubbleFinal(); // Process and finalize the main answer content

                    // Add Timestamp to the live AI answer bubble
                    if (currentAnswerElement) {
                        const timestampElem = document.createElement('p');
                        timestampElem.classList.add('text-xs', 'text-slate-500', 'mt-1', 'text-left'); // Consistent styling
                        timestampElem.textContent = new Date().toLocaleString(); // Time when EOS is received
                        currentAnswerElement.appendChild(timestampElem); // Append to the main bubble, after content div
                    }

                    resetStreamingState(); // Reset all streaming state variables for the next turn
                    
                    // Re-enable input fields
                    if (typeof setInputDisabledState === 'function') {
                        setInputDisabledState(false);
                    }
                    
                    // Focus on the message input if it's visible
                    if (messageInput && messageInput.offsetParent !== null) {
                        messageInput.focus();
                    }
                    
                    // Scroll to the bottom of the chat history
                    setTimeout(() => scrollToBottom('smooth'), 50); 
                    
                    return; // Important to exit after handling EOS
                }

                if (chunk.startsWith("<ERROR>")) {
                    const errorMessage = chunk.substring(7);
                    console.error(`[ws.onmessage] Turn ${currentTurnIdForMsg}: Received <ERROR>:`, errorMessage);
                    if (typeof addErrorMessage === 'function') addErrorMessage(errorMessage);
                    finalizeTurnOnErrorOrClose(); // Your existing function
                    resetAllCodeButtonsOnErrorOrClose(); // Your existing function
                    setTimeout(() => scrollToBottom('smooth'), 50);
                    return;
                }

                if (chunk.length === 0) {
                        return;
                }

                if (!currentAiTurnContainer) { // Assuming global/accessible
                    if (chunk.trim().length > 0) {
                        console.warn(`%c[ws.onmessage] Turn ${currentTurnIdForMsg}: First non-empty chat chunk received, but turn container not set up? Forcing setup.`, 'color: red; font-weight: bold;');
                        setupNewAiTurn(); // Your existing function
                    } else {
                        return;
                    }
                }

                // Your existing complex state machine logic to process the chunk
                let currentPos = 0;
                while (currentPos < chunk.length) {
                    const char = chunk[currentPos];
                    let incrementPos = true;
                    let previousMode = currentProcessingMode; // Assuming global/accessible

                    if (char === '\\' && currentPos + 1 < chunk.length) {
                        const nextChar = chunk[currentPos + 1];
                        const escapableChars = '$`*\\<>';
                        if (escapableChars.includes(nextChar)) {
                            if (currentProcessingMode === MODE_INSIDE_THINK) { appendRawTextToThinkingArea(nextChar); }
                            else if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE || currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY) { katexBuffer += nextChar; appendToAnswer(nextChar); } // Assuming katexBuffer is global/accessible
                            else if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK) { appendToCodeBlock(nextChar); } // Your existing function
                            else { appendToAnswer(nextChar); } // Your existing function
                            currentPos += 2;
                            incrementPos = false;
                            continue;
                        }
                    }

                    switch (currentProcessingMode) { // Assuming global/accessible
                        case MODE_ANSWER:
                            if (char === FENCE[0]) {
                                if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                katexBuffer = ''; currentKatexMarkerId = null;
                                fenceBuffer = char; // Assuming fenceBuffer is global/accessible
                                currentProcessingMode = MODE_SEEKING_CODE_START_FENCE;
                            } else if (char === '$') {
                                if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                currentProcessingMode = MODE_MAYBE_START_DISPLAY_KATEX;
                            } else if (char === '<') {
                                    if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                tagBuffer = char; // Assuming tagBuffer is global/accessible
                                currentProcessingMode = MODE_SEEKING_TAG;
                            } else {
                                if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                appendToAnswer(char);
                            }
                            break;
                        // ... include all your other cases from the state machine ...
                        case MODE_SEEKING_CODE_START_FENCE:
                            if (char === FENCE[fenceBuffer.length]) {
                                fenceBuffer += char;
                                if (fenceBuffer === FENCE) {
                                    fenceBuffer = ''; langBuffer = ''; // Assuming langBuffer is global/accessible
                                    currentProcessingMode = MODE_SEEKING_CODE_LANGUAGE;
                                }
                            } else {
                                appendToAnswer(fenceBuffer);
                                fenceBuffer = '';
                                currentProcessingMode = MODE_ANSWER;
                                incrementPos = false;
                            }
                            break;
                        case MODE_SEEKING_CODE_LANGUAGE:
                                if (char === '\n') {
                                    currentCodeBlockLang = langBuffer.trim(); // Assuming global/accessible
                                    createCodeBlockStructure(currentCodeBlockLang); // Your existing function
                                    appendCodeReference(); // Your existing function
                                    langBuffer = '';
                                    currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                                } else if (langBuffer.length > 50) {
                                    console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: Code language line too long. Treating as text.`);
                                    appendToAnswer(FENCE + langBuffer + char);
                                    langBuffer = ''; fenceBuffer = '';
                                    currentProcessingMode = MODE_ANSWER;
                                } else {
                                    langBuffer += char;
                                }
                                break;
                        case MODE_INSIDE_CODE_BLOCK:
                            if (char === FENCE[0]) {
                                fenceBuffer = char;
                                currentProcessingMode = MODE_SEEKING_CODE_END_FENCE;
                            } else {
                                appendToCodeBlock(char);
                            }
                            break;
                        case MODE_SEEKING_CODE_END_FENCE:
                            if (char === FENCE[fenceBuffer.length]) {
                                fenceBuffer += char;
                                if (fenceBuffer === FENCE) {
                                    finalizeCodeBlock(); // Your existing function
                                    fenceBuffer = '';
                                    currentProcessingMode = MODE_ANSWER;
                                    lastAppendedNode = null; // Assuming global/accessible
                                    if (currentPos + 1 < chunk.length && chunk[currentPos + 1] === '\n') {
                                        currentPos++;
                                        incrementPos = true;
                                    }
                                }
                            } else {
                                appendToCodeBlock(fenceBuffer);
                                fenceBuffer = '';
                                currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                                incrementPos = false;
                            }
                            break;
                        case MODE_MAYBE_START_DISPLAY_KATEX:
                            if (char === '$') {
                                currentKatexMarkerId = `katex-marker-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
                                const startMarkerDisp = document.createElement('span');
                                startMarkerDisp.setAttribute('data-katex-start-id', currentKatexMarkerId);
                                startMarkerDisp.style.display = 'none';
                                appendToAnswer(null, startMarkerDisp);
                                appendToAnswer('$$');
                                currentProcessingMode = MODE_KATEX_BUFFERING_DISPLAY;
                                katexBuffer = '';
                            } else {
                                currentKatexMarkerId = `katex-marker-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
                                const startMarkerInline = document.createElement('span');
                                startMarkerInline.setAttribute('data-katex-start-id', currentKatexMarkerId);
                                startMarkerInline.style.display = 'none';
                                appendToAnswer(null, startMarkerInline);
                                appendToAnswer('$');
                                appendToAnswer(char);
                                currentProcessingMode = MODE_KATEX_BUFFERING_INLINE;
                                katexBuffer = char;
                            }
                            break;
                        case MODE_KATEX_BUFFERING_INLINE:
                            if (char === '$') {
                                appendToAnswer('$');
                                if (currentKatexMarkerId) { renderAndReplaceKatex(false, currentKatexMarkerId); currentKatexMarkerId = null; }
                                else { console.error(`Attempted end inline KaTeX Turn ${currentTurnIdForMsg} no marker ID!`); }
                                currentProcessingMode = MODE_ANSWER;
                            } else { katexBuffer += char; appendToAnswer(char); }
                            break;
                        case MODE_KATEX_BUFFERING_DISPLAY:
                                if (char === '$' && currentPos + 1 < chunk.length && chunk[currentPos + 1] === '$') {
                                    appendToAnswer('$$');
                                    if (currentKatexMarkerId) { renderAndReplaceKatex(true, currentKatexMarkerId); currentKatexMarkerId = null; }
                                    else { console.error(`Attempted end display KaTeX Turn ${currentTurnIdForMsg} no marker ID!`); }
                                    currentProcessingMode = MODE_ANSWER; currentPos++;
                                } else { katexBuffer += char; appendToAnswer(char); }
                                break;
                        case MODE_SEEKING_TAG:
                            tagBuffer += char;
                            const lowerTag = tagBuffer.toLowerCase();
                            if (lowerTag === THINK_START_TAG) {
                                thinkBuffer = ''; currentProcessingMode = MODE_INSIDE_THINK; tagBuffer = ''; lastAppendedNode = null; // Assuming thinkBuffer is global/accessible
                            } else if (THINK_START_TAG.startsWith(lowerTag)) { /* Keep buffering */ }
                            else {
                                appendToAnswer(tagBuffer); currentProcessingMode = MODE_ANSWER; tagBuffer = ''; incrementPos = false;
                            }
                            if (tagBuffer.length > 20) {
                                    console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: Tag buffer excessive, treating as text: ${tagBuffer}`);
                                    appendToAnswer(tagBuffer); currentProcessingMode = MODE_ANSWER; tagBuffer = ''; incrementPos = false;
                            }
                            break;
                        case MODE_INSIDE_THINK:
                                if (char === '<') {
                                    tagBuffer = char; currentProcessingMode = MODE_MAYBE_END_THINK;
                                } else { appendRawTextToThinkingArea(char); } // Your existing function
                                break;
                        case MODE_MAYBE_END_THINK:
                                tagBuffer += char;
                                const lowerEndTag = tagBuffer.toLowerCase();
                                if (lowerEndTag === THINK_END_TAG) {
                                    thinkBuffer = ''; tagBuffer = ''; currentProcessingMode = MODE_ANSWER; lastAppendedNode = null;
                                } else if (THINK_END_TAG.startsWith(lowerEndTag)) { /* Keep buffering */ }
                                else {
                                    appendRawTextToThinkingArea(tagBuffer);
                                    currentProcessingMode = MODE_INSIDE_THINK; tagBuffer = ''; incrementPos = false;
                                }
                                if (tagBuffer.length > 20) {
                                        console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: End tag buffer excessive, treating as think text: ${tagBuffer}`);
                                        appendRawTextToThinkingArea(tagBuffer); currentProcessingMode = MODE_INSIDE_THINK; tagBuffer = ''; incrementPos = false;
                                }
                                break;
                        default:
                            console.error(`Unknown processing mode: ${currentProcessingMode} in Turn ${currentTurnIdForMsg}`);
                            appendToAnswer(char);
                            currentProcessingMode = MODE_ANSWER;
                    }

                    if (incrementPos) { currentPos++; }
                }
                scrollToBottom(); // Your existing function
            }
        };

        ws.onerror = (event) => {
            // This is the full onerror logic from your provided script
            console.error("WebSocket error observed:", event);
            if (typeof addErrorMessage === 'function') addErrorMessage("WebSocket connection error. Please check the server or try refreshing. See console for details.");
            if (typeof finalizeTurnOnErrorOrClose === 'function') finalizeTurnOnErrorOrClose();
            if (typeof resetAllCodeButtonsOnErrorOrClose === 'function') resetAllCodeButtonsOnErrorOrClose();
            if (typeof setInputDisabledState === 'function') setInputDisabledState(true);
        };

        ws.onclose = (event) => {
            // This is the full onclose logic from your provided script
            console.log("WebSocket connection closed.", event);
            if (typeof addSystemMessage === 'function') addSystemMessage(`Connection closed: ${event.reason || 'Normal closure'} (Code: ${event.code})`);
            if (typeof finalizeTurnOnErrorOrClose === 'function') finalizeTurnOnErrorOrClose();
            if (typeof resetAllCodeButtonsOnErrorOrClose === 'function') resetAllCodeButtonsOnErrorOrClose();
            if (event.code !== 1000 && event.code !== 1005) {
                console.log("Unexpected WebSocket closure. Attempting to reconnect WebSocket in 3 seconds...");
                if (typeof addSystemMessage === 'function') addSystemMessage("Attempting to reconnect...");
                if (typeof setInputDisabledState === 'function') setInputDisabledState(true);
                setTimeout(() => { websocket = null; if (typeof resetStreamingState === 'function') resetStreamingState(); currentAiTurnContainer = null; connectWebSocket(); }, 3000); // Assuming currentAiTurnContainer is global/accessible
            } else { if (typeof setInputDisabledState === 'function') setInputDisabledState(true); }
        };
        // -----------------------------------------------------------------------------------------

        console.log("[DEBUG] WebSocket object created and handlers assigned.");

    } catch (error) {
        console.error("[DEBUG] CRITICAL Error creating WebSocket object:", error);
        if (typeof addErrorMessage === 'function') { addErrorMessage(`WebSocket Creation Error: ${error.message}. Please check server and refresh.`); }
        else { alert(`WebSocket Creation Error: ${error.message}. Please check server and refresh.`); }
        if (typeof setInputDisabledState === 'function') setInputDisabledState(true);
    }
}

// --- Utility Functions --- 
// (debounce function)
// (throttle function defined above)

// Throttled function for highlighting the streaming code block
let throttledStreamHighlight = throttle(() => {
    // Optional: Keep logs to verify throttling
    console.log(">>> throttledStreamHighlight: Attempting highlight..."); 
    console.log(`>>> throttledStreamHighlight: currentProcessingMode = ${currentProcessingMode}`);
    console.log(">>> throttledStreamHighlight: currentCodeBlockElement =", currentCodeBlockElement);

    if (currentCodeBlockElement && currentProcessingMode === MODE_INSIDE_CODE_BLOCK) {
        console.log(">>> throttledStreamHighlight: Conditions met."); 
        try {
            if (typeof Prism !== 'undefined' && typeof Prism.highlightElement === 'function') {
                console.log(">>> throttledStreamHighlight: Calling Prism.highlightElement..."); 
                Prism.highlightElement(currentCodeBlockElement);
                console.log(">>> throttledStreamHighlight: Prism.highlightElement call completed."); 
            } else {
                console.warn(">>> throttledStreamHighlight: Prism.js or highlightElement not available!");
            }
        } catch (e) {
            console.error(">>> throttledStreamHighlight: Error during highlight:", e, currentCodeBlockElement);
        }
    } else {
         console.log(">>> throttledStreamHighlight: Conditions NOT met. Skipping highlight."); 
    }
// Throttle limit in milliseconds (e.g., run at most once every 250ms)
}, 250); // Adjust limit as needed (e.g., 200-500ms) 

// --- End Utility Functions ---

let debouncedStreamHighlight = debounce(() => {
    // --- ADDED LOGGING ---
    console.log(">>> debouncedStreamHighlight: Fired!"); 
    console.log(`>>> debouncedStreamHighlight: currentProcessingMode = ${currentProcessingMode}`);
    console.log(">>> debouncedStreamHighlight: currentCodeBlockElement =", currentCodeBlockElement);
    // --- END OF ADDED LOGGING ---

    // Check if we are currently inside a code block being streamed
    if (currentCodeBlockElement && currentProcessingMode === MODE_INSIDE_CODE_BLOCK) {
        console.log(">>> debouncedStreamHighlight: Conditions met. Attempting highlight."); // Log attempt
        try {
            // Check if Prism and highlightElement are available
            if (typeof Prism !== 'undefined' && typeof Prism.highlightElement === 'function') {
                console.log(">>> debouncedStreamHighlight: Prism.highlightElement found. Calling..."); // Log before call
                Prism.highlightElement(currentCodeBlockElement);
                console.log(">>> debouncedStreamHighlight: Prism.highlightElement call completed."); // Log after call
            } else {
                console.warn(">>> debouncedStreamHighlight: Prism.js or Prism.highlightElement not available!");
            }
        } catch (e) {
            console.error(">>> debouncedStreamHighlight: Error during highlight:", e, currentCodeBlockElement);
        }
    } else {
         console.log(">>> debouncedStreamHighlight: Conditions NOT met. Skipping highlight."); 
    }
}, 300); // Keep your debounce delay (e.g., 300ms)

// Helper function to escape HTML to prevent XSS where markdown is not intended.
function escapeHTML(str) {
    if (str === null || str === undefined) return '';
    return str.toString()
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}

/**
 * Renders a single message object (from history) into the chat history UI.
 * Handles user, system, and AI messages, including complex rendering for AI messages
 * (thinking area, code blocks, KaTeX, and Markdown).
 * Strips NO_THINK_PREFIX from historical user messages.
 * @param {object} msg - The message object from the database.
 * @param {HTMLElement} chatHistoryDiv - The main chat history container element.
 * @param {boolean} isHistory - Flag indicating if the message is from loaded history.
 */
function renderSingleMessage(msg, chatHistoryDiv, isHistory = false) {
    // Ensure essential parameters and libraries are available
    if (!chatHistoryDiv || !msg) {
        console.warn("[RenderMessage] Missing chatHistoryDiv or message object. Message:", msg);
        return;
    }
    if (typeof marked === 'undefined') {
        console.error("[RenderMessage] marked.js library is not loaded. Cannot render markdown content.");
        const plainTextDiv = document.createElement('div');
        plainTextDiv.classList.add('message-item', 'p-3', 'rounded-lg', 'max-w-xl', 'mb-2', 'break-words', 'bg-red-100', 'text-red-700');
        plainTextDiv.textContent = `Error: Markdown library not found. Raw content: ${msg.content || 'N/A'}`;
        chatHistoryDiv.appendChild(plainTextDiv);
        return;
    }
    if (typeof katex === 'undefined') {
        console.warn("[RenderMessage] KaTeX library not found. Math expressions may not render correctly.");
    }


    const senderType = msg.sender_type;
    let originalMessageContent = msg.content || ''; // Raw content from DB
    // Use sender_name from DB if available, otherwise determine default based on type
    const senderName = msg.sender_name || (senderType === 'ai' ? 'AI' : (senderType === 'user' ? 'User' : 'System'));
    const timestamp = msg.timestamp;
    const historicalThinkingContent = msg.thinking_content; // For AI messages

    const KATEX_PLACEHOLDER_PREFIX_HISTORICAL = '%%HISTORICAL_KATEX_PLACEHOLDER_';

    // --- Handle User and System Messages (Simpler Rendering) ---
    if (senderType === 'user' || senderType === 'system') {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message-item', 'p-3', 'rounded-lg', 'max-w-xl', 'mb-2', 'break-words', 'flex', 'flex-col');
        messageDiv.setAttribute('data-sender', senderType);
        if (msg.id) { messageDiv.setAttribute('data-message-id', String(msg.id)); }
        if (msg.client_id_temp && isHistory) { messageDiv.setAttribute('data-client-id-temp', msg.client_id_temp); }

        if (senderType === 'user') {
            messageDiv.classList.add('bg-emerald-100', 'self-end', 'ml-auto');
        } else { // System message
            messageDiv.classList.add('bg-slate-200', 'self-center', 'mx-auto', 'text-xs', 'italic');
        }

        const senderElem = document.createElement('p');
        senderElem.classList.add('font-semibold', 'text-sm', 'mb-1');
        if (senderType === 'user') senderElem.classList.add('text-emerald-700');
        else senderElem.classList.add('text-slate-600');
        // Use the senderName determined earlier (from DB or default)
        senderElem.textContent = escapeHTML(senderName); // escapeHTML should be defined
        messageDiv.appendChild(senderElem);

        const contentElem = document.createElement('div');
        contentElem.classList.add('text-gray-800', 'text-sm', 'message-content');

        // --- ADDED: Strip NO_THINK_PREFIX for historical user messages ---
        let displayedContent = originalMessageContent;
        if (senderType === 'user' && typeof NO_THINK_PREFIX === 'string' && NO_THINK_PREFIX.length > 0 && displayedContent.startsWith(NO_THINK_PREFIX)) {
            displayedContent = displayedContent.substring(NO_THINK_PREFIX.length);
            // console.log(`[RenderMessage] Stripped NO_THINK_PREFIX from historical user message ID: ${msg.id}`); // Optional log
        }
        // --- END OF ADDED CHANGE ---

        // For user/system, content is parsed as Markdown (after potential prefix stripping for user)
        contentElem.innerHTML = marked.parse(displayedContent);
        messageDiv.appendChild(contentElem);

        if (timestamp) {
            const timestampElem = document.createElement('p');
            timestampElem.classList.add('text-xs', 'text-slate-500', 'mt-1');
            if (senderType === 'user') timestampElem.classList.add('text-right');
            else timestampElem.classList.add('text-center');
            try {
                timestampElem.textContent = new Date(timestamp).toLocaleString();
            } catch (e) {
                timestampElem.textContent = String(timestamp); // Fallback for invalid date
            }
            messageDiv.appendChild(timestampElem);
        }
        chatHistoryDiv.appendChild(messageDiv);

    // --- Handle AI Messages (Complex Rendering - Assumed Correct from Previous Steps) ---
    } else if (senderType === 'ai') {
        // ... (Keep the complex AI message rendering logic from the previous version) ...
        // ... (This includes thinking area, code block extraction/rendering, KaTeX processing) ...
        
        // For brevity, the full AI rendering logic is omitted here, but it should be the
        // same as the one in the previous complete 'renderSingleMessage' function.
        // Ensure the following steps are performed on originalMessageContent:
        // 1. Extract code blocks, render them using createHistoricalCodeBlockDisplay, replace with placeholders.
        // 2. Extract KaTeX, render using katex.renderToString, replace with placeholders.
        // 3. Parse the remaining content with marked.parse().
        // 4. Reinsert the rendered KaTeX HTML.
        // 5. Assemble the full ai-turn-container with thinking, answer bubble, and code blocks area.

        // --- Start of AI Message Rendering Logic (Copied from previous complete version) ---
        const turnIdSuffix = msg.id ? String(msg.id) : `hist-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
        const aiTurnContainer = document.createElement('div');
        aiTurnContainer.classList.add('ai-turn-container');
        aiTurnContainer.setAttribute('data-sender', 'ai');
        if (msg.id) { aiTurnContainer.setAttribute('data-message-id', String(msg.id)); }
        if (msg.client_id_temp && isHistory) { aiTurnContainer.setAttribute('data-client-id-temp', msg.client_id_temp); }
        aiTurnContainer.dataset.turnId = `historical-${turnIdSuffix}`;

        // --- 1. Thinking Area Setup ---
        const thinkingArea = document.createElement('div');
        thinkingArea.classList.add('thinking-area');
        thinkingArea.dataset.turnId = `historical-${turnIdSuffix}`; 
        const details = document.createElement('details');
        details.id = `thinking-details-historical-${turnIdSuffix}`;
        const summary = document.createElement('summary');
        summary.classList.add('thinking-summary');
        const summaryTextSpan = document.createElement('span');
        summaryTextSpan.classList.add('text');
        summaryTextSpan.textContent = 'Show Thinking';
        const summaryDotsSpan = document.createElement('span'); 
        summaryDotsSpan.classList.add('dots');
        summary.appendChild(summaryTextSpan);
        summary.appendChild(summaryDotsSpan);
        const thinkingPreElement = document.createElement('pre');
        if (historicalThinkingContent && historicalThinkingContent.trim() !== "") {
            thinkingPreElement.textContent = historicalThinkingContent;
        } else {
            thinkingPreElement.textContent = '(No historical thinking data available for this AI message)';
            thinkingArea.style.display = 'none'; 
        }
        details.appendChild(summary);
        details.appendChild(thinkingPreElement);
        thinkingArea.appendChild(details);
        aiTurnContainer.appendChild(thinkingArea);
        details.addEventListener('toggle', (event) => {
            const textSpan = event.target.querySelector('.thinking-summary .text');
            if (!textSpan) return;
            textSpan.textContent = event.target.open ? 'Hide Thinking' : 'Show Thinking';
        });

        // --- Main Answer Bubble & Code Blocks Area ---
        const answerElement = document.createElement('div');
        answerElement.classList.add('message', 'ai-message', 'p-3', 'rounded-lg', 'max-w-xl', 'mb-2', 'break-words', 'flex', 'flex-col', 'bg-sky-100', 'self-start', 'mr-auto');
        const codeBlocksArea = document.createElement('div');
        codeBlocksArea.classList.add('code-blocks-area');
        let contentForProcessing = originalMessageContent;

        // --- 2. Extract and Render Code Blocks ---
        let historicalCodeBlockCounter = 0;
        const codeBlockRegex = /```(\w*)\n([\s\S]*?)\n```/g; 
        let matchCode;
        const extractedCodeBlocks = [];
        let tempContentForCodeExtraction = contentForProcessing;
        let contentAfterCodeExtraction = "";
        let lastCodeMatchEndIndex = 0;
        while ((matchCode = codeBlockRegex.exec(tempContentForCodeExtraction)) !== null) {
            historicalCodeBlockCounter++;
            const language = matchCode[1] || 'plaintext'; 
            const code = matchCode[2];
            const placeholder = `%%HISTORICAL_CODE_BLOCK_${historicalCodeBlockCounter}%%`;
            extractedCodeBlocks.push({ language, code, placeholder, index: historicalCodeBlockCounter });
            contentAfterCodeExtraction += tempContentForCodeExtraction.substring(lastCodeMatchEndIndex, matchCode.index);
            contentAfterCodeExtraction += placeholder;
            lastCodeMatchEndIndex = codeBlockRegex.lastIndex; 
        }
        contentAfterCodeExtraction += tempContentForCodeExtraction.substring(lastCodeMatchEndIndex);
        contentForProcessing = contentAfterCodeExtraction; 
        extractedCodeBlocks.forEach(block => {
            if (typeof createHistoricalCodeBlockDisplay === 'function') {
                createHistoricalCodeBlockDisplay(block.language, block.code, turnIdSuffix, block.index, codeBlocksArea);
            } else {
                console.warn('createHistoricalCodeBlockDisplay function is not defined. Cannot render historical code block fully.');
                 const fallbackDiv = document.createElement('div'); 
                 fallbackDiv.textContent = `[Code ${block.index} (${block.language}) - Full display unavailable]`;
                 codeBlocksArea.appendChild(fallbackDiv);
            }
            const referenceText = ` [Code ${block.index}] `;
            contentForProcessing = contentForProcessing.replace(block.placeholder, referenceText);
        });

        // --- 3. Pre-process for KaTeX ---
        const storedHistoricalKatex = {}; 
        let katexPlaceholderIndex = 0;
        const katexRegexGlobal = /(?<!\\)\$\$([\s\S]+?)(?<!\\)\$\$|(?<!\\)\$((?:\\\$|[^$])+?)(?<!\\)\$/g;
        let textForMarkdownParsing = contentForProcessing.replace(katexRegexGlobal, (match, displayContent, inlineContent) => {
            const isDisplayMode = !!displayContent; 
            const katexString = displayContent || inlineContent;
            const cleanedKatexString = katexString.replace(/\\([$])/g, '$1');
            let katexHtml = '';
            if (typeof katex !== 'undefined' && typeof katex.renderToString === 'function') {
                try {
                    katexHtml = katex.renderToString(cleanedKatexString, {
                        displayMode: isDisplayMode, throwOnError: false, output: "html", strict: false 
                    });
                } catch (e) {
                    console.error("Error rendering historical KaTeX:", e, "Original string:", match);
                    katexHtml = `<span class="katex-error" title="${escapeHTML(e.toString())}">${escapeHTML(match)}</span>`;
                }
            } else {
                return match; 
            }
            const placeholderId = `${KATEX_PLACEHOLDER_PREFIX_HISTORICAL}${katexPlaceholderIndex++}`;
            storedHistoricalKatex[placeholderId] = katexHtml; 
            return placeholderId; 
        });

        // --- 4. Markdown Parsing ---
        const senderElemAI = document.createElement('p'); // Use different var name to avoid conflict
        senderElemAI.classList.add('font-semibold', 'text-sm', 'mb-1', 'text-sky-700');
        senderElemAI.textContent = escapeHTML(senderName); // Use senderName which is 'AI' here
        answerElement.appendChild(senderElemAI);
        const contentElemAI = document.createElement('div'); // Use different var name
        contentElemAI.classList.add('text-gray-800', 'text-sm', 'message-content');
        contentElemAI.innerHTML = marked.parse(textForMarkdownParsing); 
        answerElement.appendChild(contentElemAI);

        // --- 5. KaTeX Post-processing ---
        if (Object.keys(storedHistoricalKatex).length > 0) {
            const walker = document.createTreeWalker(contentElemAI, NodeFilter.SHOW_TEXT, null, false);
            let node;
            const textNodesToModify = []; 
            while (node = walker.nextNode()) {
                if (node.nodeValue && node.nodeValue.includes(KATEX_PLACEHOLDER_PREFIX_HISTORICAL)) {
                    textNodesToModify.push(node);
                }
            }
            textNodesToModify.forEach(textNode => {
                let currentTextValue = textNode.nodeValue;
                const parent = textNode.parentNode;
                if (!parent) return;
                const fragment = document.createDocumentFragment(); 
                let lastSplitEnd = 0;
                const placeholderScanRegex = new RegExp(`(${KATEX_PLACEHOLDER_PREFIX_HISTORICAL}\\d+)`, 'g');
                let placeholderMatch;
                while((placeholderMatch = placeholderScanRegex.exec(currentTextValue)) !== null) {
                    const placeholderId = placeholderMatch[1]; 
                    const matchStartIndex = placeholderMatch.index;
                    if (matchStartIndex > lastSplitEnd) {
                        fragment.appendChild(document.createTextNode(currentTextValue.substring(lastSplitEnd, matchStartIndex)));
                    }
                    if (storedHistoricalKatex[placeholderId]) {
                        const katexWrapperSpan = document.createElement('span');
                        katexWrapperSpan.innerHTML = storedHistoricalKatex[placeholderId];
                        if (katexWrapperSpan.childNodes.length === 1 && katexWrapperSpan.firstChild.nodeType === Node.ELEMENT_NODE) {
                             fragment.appendChild(katexWrapperSpan.firstChild);
                        } else {
                             fragment.appendChild(katexWrapperSpan);
                        }
                    } else {
                        fragment.appendChild(document.createTextNode(placeholderId));
                    }
                    lastSplitEnd = placeholderScanRegex.lastIndex; 
                }
                if (lastSplitEnd < currentTextValue.length) {
                    fragment.appendChild(document.createTextNode(currentTextValue.substring(lastSplitEnd)));
                }
                parent.replaceChild(fragment, textNode);
            });
        }

        // --- Timestamp and Final Assembly ---
        if (timestamp) {
            const timestampElemAI = document.createElement('p'); // Use different var name
            timestampElemAI.classList.add('text-xs', 'text-slate-500', 'mt-1', 'text-left');
            try {
                timestampElemAI.textContent = new Date(timestamp).toLocaleString();
            } catch (e) {
                timestampElemAI.textContent = String(timestamp);
            }
            answerElement.appendChild(timestampElemAI);
        }
        aiTurnContainer.appendChild(answerElement); 
        aiTurnContainer.appendChild(codeBlocksArea);  
        chatHistoryDiv.appendChild(aiTurnContainer); 
        // --- End of AI Message Rendering Logic ---
    }
}




/**
 * Fetches chat history for the current session and displays it.
 * @param {string} sessionId - The ID of the current chat session.
 */
async function loadAndDisplayChatHistory(sessionId) {
    const chatHistoryDiv = document.getElementById('chat-history');
    if (!chatHistoryDiv) {
        console.error("Chat history container 'chat-history' not found.");
        return;
    }

    // Update chat session title - assuming it's available via an API or could be fetched.
    // For now, we'll set a generic one or rely on existing logic if it sets the title.
    // const chatSessionTitleElement = document.getElementById('chat-session-title');
    // if (chatSessionTitleElement) chatSessionTitleElement.textContent = `Chat: ${sessionId.substring(0,8)}...`;


    chatHistoryDiv.innerHTML = '<p class="text-center text-gray-500 p-4">Loading history...</p>'; 

    try {
        const response = await fetch(`/api/sessions/${sessionId}/messages`);
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ detail: "Failed to load chat history." }));
            console.error(`Error fetching chat history for session ${sessionId}:`, response.status, errorData.detail);
            chatHistoryDiv.innerHTML = `<p class="text-center text-red-500 p-4">Error loading history: ${escapeHTML(errorData.detail || response.statusText)}</p>`;
            return;
        }

        const messages = await response.json();
        chatHistoryDiv.innerHTML = ''; // Clear loading indicator

        if (messages.length === 0) {
            chatHistoryDiv.innerHTML = '<p class="text-center text-gray-500 p-4">No messages in this session yet. Start chatting!</p>';
        } else {
            messages.forEach(msg => {
                // Use the new renderSingleMessage function
                renderSingleMessage(msg, chatHistoryDiv, true);
            });
            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight; 
        }
        console.log(`Successfully loaded ${messages.length} messages for session ${sessionId}.`);

    } catch (error) {
        console.error(`Failed to fetch or display chat history for session ${sessionId}:`, error);
        chatHistoryDiv.innerHTML = `<p class="text-center text-red-500 p-4">An unexpected error occurred while loading history. Check console.</p>`;
    }
}



/**
 * Creates and appends a display structure for a historical code block,
 * making the code editable, re-highlighting on input, and hiding the
 * run button for unsupported languages.
 * @param {string} language - The language of the code.
 * @param {string} codeContent - The actual code string.
 * @param {string} turnIdSuffix - A unique suffix for element IDs within this historical turn.
 * @param {number} codeBlockIndex - The 1-based index of this code block within the AI turn.
 * @param {HTMLElement} codeBlocksAreaElement - The parent DOM element to append this code block to.
 */
function createHistoricalCodeBlockDisplay(language, codeContent, turnIdSuffix, codeBlockIndex, codeBlocksAreaElement) {
    // Ensure the target area for code blocks exists
    if (!codeBlocksAreaElement) {
        console.error("createHistoricalCodeBlockDisplay: Code blocks area element is null! Cannot append code block.");
        return;
    }

    const blockId = `historical-code-block-turn${turnIdSuffix}-${codeBlockIndex}`;
    const safeLanguage = (language || '').trim().toLowerCase() || 'plaintext';

    // Language aliases and Prism language determination (as before)
    const langAlias = { /* ... keep your existing aliases ... */
        'python': 'python', 'py': 'python', 'javascript': 'javascript', 'js': 'javascript',
        'html': 'markup', 'xml': 'markup', 'svg': 'markup', 'css': 'css', 'bash': 'bash',
        'sh': 'bash', 'shell': 'bash', 'json': 'json', 'yaml': 'yaml', 'yml': 'yaml',
        'markdown': 'markdown', 'md': 'markdown', 'sql': 'sql', 'java': 'java', 'c': 'c',
        'cpp': 'cpp', 'c++': 'cpp', 'csharp': 'csharp', 'cs': 'csharp', 'go': 'go',
        'rust': 'rust', 'php': 'php', 'ruby': 'ruby', 'rb': 'ruby',
        'dockerfile': 'docker', 'docker': 'docker', 'typescript': 'typescript', 'ts': 'typescript',
        'plaintext': 'plain', 'text': 'plain',
     };
    const prismLang = langAlias[safeLanguage] || safeLanguage;
    const displayLang = safeLanguage; // Use the cleaned-up language name for checks/display

    // --- ADD: List of languages supported by the backend Docker execution ---
    // Make sure this list matches the one in createCodeBlockStructure
    const supportedExecutionLanguages = [
        "python", "javascript", "cpp", "csharp", "typescript", "java", "go", "rust"
        // Add or remove languages based on your config.py SUPPORTED_LANGUAGES keys
    ];
    const isLanguageSupported = supportedExecutionLanguages.includes(displayLang);
    // --- END OF ADD ---


    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;

    const container = document.createElement('div');
    container.classList.add('code-block-container', 'historical-code-block');
    container.id = blockId;
    container.dataset.language = displayLang;

    const codeHeader = document.createElement('div');
    codeHeader.classList.add('code-block-header');

    const codeButtonsDiv = document.createElement('div');
    codeButtonsDiv.classList.add('code-block-buttons');

    // Create buttons (as before)
    const runStopBtn = document.createElement('button');
    runStopBtn.classList.add('run-code-btn', 'code-action-btn');
    runStopBtn.innerHTML = playIconSvg;
    runStopBtn.title = 'Run Code';
    runStopBtn.dataset.status = 'idle';
    runStopBtn.addEventListener('click', handleRunStopCodeClick);

    const toggleCodeBtn = document.createElement('button');
    toggleCodeBtn.classList.add('toggle-code-btn', 'code-action-btn');
    toggleCodeBtn.textContent = 'Hide';
    toggleCodeBtn.title = 'Show/Hide Code';

    const copyCodeBtn = document.createElement('button');
    copyCodeBtn.classList.add('copy-code-btn', 'code-action-btn');
    copyCodeBtn.textContent = 'Copy';
    copyCodeBtn.title = 'Copy Code';

    // --- ADD: Conditionally hide run button ---
    if (!isLanguageSupported) {
        runStopBtn.style.display = 'none'; // Hide the button entirely
        runStopBtn.title = `Run Code (language '${displayLang}' not supported for execution)`; // Update title
    }
    // --- END OF ADD ---

    // Add buttons to their container
    codeButtonsDiv.appendChild(runStopBtn);
    codeButtonsDiv.appendChild(toggleCodeBtn);
    codeButtonsDiv.appendChild(copyCodeBtn);

    // Code block title (as before)
    const codeTitle = document.createElement('span');
    codeTitle.classList.add('code-block-title');
    codeTitle.textContent = `Code ${codeBlockIndex} (${displayLang})`;
    codeTitle.style.flexGrow = '1';
    codeTitle.style.textAlign = 'left';

    // Assemble header (as before)
    codeHeader.appendChild(codeButtonsDiv);
    codeHeader.appendChild(codeTitle);

    // Create pre/code elements (as before)
    const preElement = document.createElement('pre');
    preElement.classList.add('manual');
    const codeElement = document.createElement('code');
    codeElement.className = `language-${prismLang}`;
    codeElement.setAttribute('contenteditable', 'true'); // Historical code editable
    codeElement.setAttribute('spellcheck', 'false');
    codeElement.textContent = codeContent;

    // Assemble code display area (as before)
    preElement.appendChild(codeElement);
    container.appendChild(codeHeader);
    container.appendChild(preElement);

    // Create output area structure (as before)
    const outputHeader = document.createElement('div');
    outputHeader.classList.add('code-output-header');
    outputHeader.style.display = 'none';
    // ... (rest of output header setup: buttons, title, status span) ...
    const outputButtonsDiv = document.createElement('div');
    outputButtonsDiv.classList.add('code-block-buttons');
    const placeholderSpan = document.createElement('span');
    placeholderSpan.classList.add('output-header-button-placeholder');
    outputButtonsDiv.appendChild(placeholderSpan);
    const toggleOutputBtn = document.createElement('button');
    toggleOutputBtn.classList.add('toggle-output-btn', 'code-action-btn');
    toggleOutputBtn.textContent = 'Hide';
    toggleOutputBtn.title = 'Show/Hide Output';
    const copyOutputBtn = document.createElement('button');
    copyOutputBtn.classList.add('copy-output-btn', 'code-action-btn');
    copyOutputBtn.textContent = 'Copy';
    copyOutputBtn.title = 'Copy Output';
    outputButtonsDiv.appendChild(toggleOutputBtn);
    outputButtonsDiv.appendChild(copyOutputBtn);
    const outputTitle = document.createElement('span');
    outputTitle.classList.add('output-header-title');
    outputTitle.textContent = `Output Code ${codeBlockIndex}`;
    const codeStatusSpan = document.createElement('span');
    codeStatusSpan.classList.add('code-status-span');
    codeStatusSpan.textContent = 'Idle';
    outputHeader.appendChild(outputButtonsDiv);
    outputHeader.appendChild(outputTitle);
    outputHeader.appendChild(codeStatusSpan);

    const outputConsoleDiv = document.createElement('div');
    outputConsoleDiv.classList.add('code-output-console');
    outputConsoleDiv.style.display = 'none';
    const outputPre = document.createElement('pre');
    outputConsoleDiv.appendChild(outputPre);

    // Append output area to container (as before)
    container.appendChild(outputHeader);
    container.appendChild(outputConsoleDiv);

    // Add event listeners (as before)
    // Toggle code listener
    toggleCodeBtn.addEventListener('click', () => {
        const isHidden = preElement.classList.toggle('hidden');
        toggleCodeBtn.textContent = isHidden ? 'Show' : 'Hide';
    });
    // Copy code listener
    copyCodeBtn.addEventListener('click', async () => {
        try {
            await navigator.clipboard.writeText(codeElement.textContent || '');
            copyCodeBtn.textContent = 'Copied!';
            copyCodeBtn.classList.add('copied');
            setTimeout(() => { copyCodeBtn.textContent = 'Copy'; copyCodeBtn.classList.remove('copied'); }, 1500);
        } catch (err) {
            console.error('Failed to copy historical code: ', err);
            copyCodeBtn.textContent = 'Error';
            setTimeout(() => { copyCodeBtn.textContent = 'Copy'; }, 1500);
        }
    });
    // Run button listener is already attached above
    // Debounced highlight listener for editable historical code (as before)
    const debouncedHistoricalHighlight = debounce(() => {
        const savedPosition = getCursorPosition(codeElement);
        if (savedPosition === -1) { console.warn(`Could not save cursor position for historical block ${blockId}. Highlight may cause cursor jump.`); }
        try {
            const currentText = codeElement.textContent;
            codeElement.innerHTML = ''; 
            codeElement.textContent = currentText; 
            Prism.highlightElement(codeElement); 
            if (savedPosition !== -1) { setCursorPosition(codeElement, savedPosition); }
        } catch (e) {
            console.error(`Error during debounced highlighting for historical block ${blockId}:`, e);
            if (savedPosition !== -1) { setCursorPosition(codeElement, savedPosition); }
        }
    }, 500); 
    codeElement.addEventListener('input', debouncedHistoricalHighlight);
    codeElement.addEventListener('paste', (e) => { setTimeout(debouncedHistoricalHighlight, 100); });
    // Output area listeners (as before)
    toggleOutputBtn.addEventListener('click', () => {
        const isHidden = outputConsoleDiv.classList.toggle('hidden');
        toggleOutputBtn.textContent = isHidden ? 'Show' : 'Hide';
    });
    copyOutputBtn.addEventListener('click', async () => {
        if (!outputPre) return;
        try {
            await navigator.clipboard.writeText(outputPre.textContent || '');
            copyOutputBtn.textContent = 'Copied!';
            copyOutputBtn.classList.add('copied');
            setTimeout(() => { copyOutputBtn.textContent = 'Copy'; copyOutputBtn.classList.remove('copied'); }, 1500);
        } catch (err) {
            console.error('Failed to copy historical output: ', err);
            copyOutputBtn.textContent = 'Error';
            setTimeout(() => { copyOutputBtn.textContent = 'Copy'; }, 1500);
        }
    });

    // Apply initial Prism highlighting (as before)
    if (typeof Prism !== 'undefined' && typeof Prism.highlightElement === 'function') {
        try {
            Prism.highlightElement(codeElement);
        } catch (e) {
            console.error(`Prism highlight error on initial historical code block (lang '${prismLang}', ID: ${blockId}):`, e, codeElement);
        }
    } else {
        console.warn("Prism.js or Prism.highlightElement not available. Historical code will not be highlighted.");
    }

    // Append the fully constructed code block to the designated area
    codeBlocksAreaElement.appendChild(container);
}


// At the top of your script.js (or in a shared scope)
var currentUserInfo = null; // Declare globally, initialize to null

/**
 * Fetches the current authenticated user's details from the /api/me endpoint
 * and populates the global currentUserInfo object. Includes detailed logging.
 */
async function initializeCurrentUser() {
    console.log(">>> initializeCurrentUser: Starting fetch..."); // Log start
    try {
        const response = await fetch('/api/me'); // Call the FastAPI endpoint
        console.log(">>> initializeCurrentUser: Fetch response status:", response.status); // Log status

        if (response.ok) {
            const userData = await response.json();
            console.log(">>> initializeCurrentUser: Received userData from /api/me:", userData); // <-- Log the received data

            // Check if received data has the expected 'name' property
            if (userData && userData.name) {
                window.currentUserInfo = { // Assign to the global variable
                    name: userData.name,
                    email: userData.email,
                    id: userData.id
                };
                console.log(">>> initializeCurrentUser: Assigned to window.currentUserInfo:", window.currentUserInfo); // <-- Log after assignment
            } else {
                console.error(">>> initializeCurrentUser: Received userData is missing 'name' property.", userData);
                window.currentUserInfo = null; // Set to null if data is incomplete
            }
            
        } else if (response.status === 401) { // Unauthorized
            console.warn(">>> initializeCurrentUser: User not authenticated (401).");
            window.currentUserInfo = null; 
        } else {
            console.error(">>> initializeCurrentUser: Failed fetch. Status:", response.status);
            window.currentUserInfo = null;
        }
    } catch (error) {
        console.error(">>> initializeCurrentUser: Error during fetch:", error);
        window.currentUserInfo = null; 
    }
    console.log(">>> initializeCurrentUser: Finished."); // Log end
}

// --- REVISED DOMContentLoaded Event Listener ---
document.addEventListener('DOMContentLoaded', async () => {
    console.log("[DOMContentLoaded] Event fired.");

    // --- 1. Initialize Current User Information FIRST ---
    await initializeCurrentUser(); 
    console.log("[DOMContentLoaded] After initializeCurrentUser awaited. currentUserInfo:", window.currentUserInfo);

    // --- 2. Get DOM Element References ---
    const chatHistory = document.getElementById('chat-history');
    const chatForm = document.getElementById('chat-form');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const thinkCheckbox = document.getElementById('think-checkbox');
    const listElementCheck = document.getElementById('session-list'); 

    // --- 3. Initial UI State & Library Configuration ---
    if (typeof setInputDisabledState === 'function') {
        setInputDisabledState(true); 
    } else {
        console.error("setInputDisabledState function is not defined.");
        if (messageInput) messageInput.disabled = true;
        if (sendButton) sendButton.disabled = true;
        if (thinkCheckbox) thinkCheckbox.disabled = true;
    }

    if (typeof marked !== 'undefined' && typeof marked.setOptions === 'function') {
        marked.setOptions({
            gfm: true, breaks: true, sanitize: false, smartLists: true, smartypants: false,
        });
        console.log("marked.js configured.");
    } else {
        console.warn("[DOMContentLoaded] marked.js or marked.setOptions is not available.");
    }

    // --- 4. Attach Chat Form Submit Event Listener ---
    if (chatForm && messageInput) { 
        console.log("Attaching submit listener to chat form:", chatForm);

        chatForm.addEventListener('submit', (event) => {
            event.preventDefault(); 
            console.log('Chat form submit event intercepted.');
            const userMessage = messageInput.value.trim();
            console.log('User message input:', userMessage);
            if (!userMessage) { 
                console.log('Empty message, returning.');
                return; 
            }
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                console.warn("[Submit] WebSocket not ready. State:", websocket?.readyState);
                if (typeof addErrorMessage === 'function') addErrorMessage("Not connected to the server.");
                return;
            }
            try {
                if (typeof addUserMessage === 'function') {
                     console.log('Calling addUserMessage with raw input:', userMessage);
                     addUserMessage(userMessage); 
                } else {
                     console.error('addUserMessage function not found!');
                }
                thinkingRequestedForCurrentTurn = thinkCheckbox ? thinkCheckbox.checked : false;
                console.log('Thinking requested for next turn:', thinkingRequestedForCurrentTurn);
                let messageToSend = userMessage;
                if (!thinkingRequestedForCurrentTurn && typeof NO_THINK_PREFIX === 'string') {
                    messageToSend = NO_THINK_PREFIX + userMessage;
                    console.log('Adding NO_THINK_PREFIX for sending.');
                } 
                if (typeof setupNewAiTurn === 'function') {
                     console.log('Calling setupNewAiTurn.');
                     setupNewAiTurn();
                } else {
                     console.error('setupNewAiTurn function not found!');
                }
                console.log('Sending message via WebSocket:', messageToSend);
                websocket.send(messageToSend);
                messageInput.value = ''; 
                if (typeof setInputDisabledState === 'function') {
                     console.log('Disabling input while AI responds.');
                     setInputDisabledState(true);
                } else {
                     console.error('setInputDisabledState function not found!');
                }
            } catch (sendError) {
                console.error("[Submit] ERROR during message submission process:", sendError);
                if (typeof addErrorMessage === 'function') addErrorMessage(`Failed to send message: ${sendError.message}`);
            }
        });
    } else {
        if (window.location.pathname.includes("/chat/")) {
            console.error("CRITICAL ERROR: Chat form or message input not found.");
            if (typeof addErrorMessage === 'function') addErrorMessage("Initialization Error: Chat input components missing.");
        }
    }

    // --- 5. Session List, History Loading, and WebSocket Connection ---
    if (listElementCheck) {
         console.log("#session-list element found.");
         // if (typeof fetchAndDisplaySessions === 'function') { fetchAndDisplaySessions(); }
    }

    const currentSessionId = (typeof getSessionIdFromPath === 'function') ? getSessionIdFromPath() : null;

    if (currentSessionId) {
        console.log(`[DOMContentLoaded] Initializing for session ID: ${currentSessionId}.`);
        if (typeof loadAndDisplayChatHistory === 'function') {
            console.log(`Calling loadAndDisplayChatHistory for session: ${currentSessionId}`);
            await loadAndDisplayChatHistory(currentSessionId); 
            console.log("loadAndDisplayChatHistory finished.");
        } else {
            console.error('[DOMContentLoaded] loadAndDisplayChatHistory function not defined!');
            if (typeof addErrorMessage === 'function') addErrorMessage("Error: Cannot load chat history.");
        }
        if (typeof connectWebSocket === 'function') {
            console.log("Attempting WebSocket connection.");
            connectWebSocket(); 
        } else {
            console.error('[DOMContentLoaded] connectWebSocket function not defined!');
            if (typeof addErrorMessage === 'function') addErrorMessage("Error: Cannot connect to chat server.");
        }
    } else {
        console.log("[DOMContentLoaded] Not on a specific chat page.");
        if (typeof setInputDisabledState === 'function') {
            setInputDisabledState(true);
        }
    }
    console.log("[DOMContentLoaded] Setup complete.");
}); // End of DOMContentLoaded listener

console.log("[Script] End of script file reached. DOMContentLoaded listener attached.");


=== app/static/session-choice.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to Tesseracs Chat</title>
    <link rel="stylesheet" href="/dist/input.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        .sidebar-scrollable { overflow-y: auto; scrollbar-width: thin; scrollbar-color: #a0aec0 #edf2f7; }
        .sidebar-scrollable::-webkit-scrollbar { width: 6px; }
        .sidebar-scrollable::-webkit-scrollbar-track { background: #edf2f7; border-radius: 3px; }
        .sidebar-scrollable::-webkit-scrollbar-thumb { background-color: #a0aec0; border-radius: 3px; border: 1px solid #edf2f7; }
    </style>
</head>
<body class="font-sans bg-gray-100 text-gray-800">

    <div class="flex h-screen overflow-hidden">
        <aside id="sidebar-loader-target" class="w-64 bg-gray-800 text-gray-200 flex flex-col overflow-hidden">
            </aside>

        <main id="session-choice-content" class="flex-1 flex flex-col p-6 overflow-y-auto items-center justify-center">
            <div class="bg-white p-8 rounded-lg shadow-xl text-center max-w-lg">
                <h1 class="text-3xl font-bold text-gray-800 mb-4">Welcome to Tesseracs Chat!</h1>
                <p class="text-gray-600 mb-6">
                    Select an existing session from the sidebar to continue your conversations,
                    or click "New Chat" in the sidebar to start a fresh one.
                </p>
                <p class="text-gray-500 text-sm">
                    Engage in dynamic chat sessions, powered by advanced AI. Your discussions are saved and can be revisited anytime.
                </p>
            </div>
            <div class="mt-10 text-center">
                <h2 class="text-xl font-semibold text-gray-700 mb-3">About Tesseracs</h2>
                <p class="text-gray-600">
                    Tesseracs Chat is designed for seamless and intelligent conversations. <br/>
                    Manage your chat sessions efficiently and collaborate with AI.
                </p>
            </div>
        </main>
    </div>

    <script type="module">
        import { loadSidebarHTML, populateSessionList } from '/static/js/app-ui.js';

        document.addEventListener('DOMContentLoaded', async () => {
            console.log("Session Choice Page (Welcome Page): DOMContentLoaded. Attempting to load UI components.");
            
            const sidebarLoaded = await loadSidebarHTML('/static/_sidebar.html', 'sidebar-loader-target');
            
            if (sidebarLoaded) {
                // Use '/chat/' as the base URL, so links become /chat/SESSION_ID
                await populateSessionList('/api/sessions', 'session-list', '/chat/');
            } else {
                console.error("Session Choice Page: Sidebar loading failed, session list will not be populated by app-ui.js.");
            }
        });
    </script>
</body>
</html>

=== app/static/js/app-ui.js ===
// static/js/app-ui.js

export async function loadSidebarHTML(sidebarHtmlPath = '_sidebar.html', targetElementId = 'sidebar-loader-target') {
    const sidebarTarget = document.getElementById(targetElementId);
    if (!sidebarTarget) {
        console.error(`Sidebar target element with ID '${targetElementId}' not found.`);
        return false;
    }
    try {
        const response = await fetch(sidebarHtmlPath);
        if (!response.ok) {
            console.error(`Failed to fetch sidebar HTML from ${sidebarHtmlPath}. Status: ${response.status}`);
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const sidebarHTML = await response.text();
        sidebarTarget.innerHTML = sidebarHTML;
        console.log(`Sidebar HTML successfully loaded from ${sidebarHtmlPath} into #${targetElementId}`);
        return true;
    } catch (error) {
        console.error('Could not load sidebar:', error);
        sidebarTarget.innerHTML = '<p class="p-4 text-red-400">Error loading sidebar content.</p>';
        return false;
    }
}

async function handleDeleteSession(sessionId, sessionName, apiEndpoint, listElementId, chatPageBaseUrl) {
    if (!window.confirm(`Are you sure you want to delete the session "${sessionName}"? This action cannot be undone.`)) {
        return;
    }

    console.log(`Attempting to delete session: ${sessionId}`);
    try {
        const response = await fetch(`/api/sessions/${sessionId}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ detail: "Failed to delete session. Server error." }));
            console.error(`Failed to delete session ${sessionId}. Status: ${response.status}`, errorData);
            alert(`Error deleting session: ${errorData.detail || response.statusText}`);
            return;
        }

        console.log(`Session ${sessionId} successfully deleted from server.`);
        
        const currentPath = window.location.pathname;
        // Ensure chatPageBaseUrl ends with a slash if not already
        const base = chatPageBaseUrl.endsWith('/') ? chatPageBaseUrl : chatPageBaseUrl + '/';
        const deletedSessionPath = `${base}${sessionId}`;

        if (currentPath === deletedSessionPath || currentPath === `${deletedSessionPath}/`) {
            window.location.href = '/'; 
        } else {
            await populateSessionList(apiEndpoint, listElementId, chatPageBaseUrl);
        }

    } catch (error) {
        console.error('Error during delete session request:', error);
        alert('An error occurred while trying to delete the session. Please check the console.');
    }
}

export async function populateSessionList(apiEndpoint = '/api/sessions', listElementId = 'session-list', chatPageBaseUrl = '/chat/') {
    const sessionListElement = document.getElementById(listElementId);
    if (!sessionListElement) {
        console.error(`Session list element with ID '${listElementId}' not found.`);
        return;
    }
    sessionListElement.innerHTML = '<li class="px-3 py-1 text-gray-400 italic text-sm">Loading sessions...</li>';

    try {
        console.log(`Workspaceing sessions from: ${apiEndpoint}`);
        const response = await fetch(apiEndpoint);

        if (!response.ok) {
            const errorText = await response.text();
            console.error(`Failed to fetch sessions from ${apiEndpoint}. Status: ${response.status}. Response: ${errorText}`);
            throw new Error(`HTTP error! status: ${response.status}. Message: ${errorText}`);
        }
        const sessions = await response.json();
        if (!Array.isArray(sessions)) {
            console.error(`Data from ${apiEndpoint} is not an array:`, sessions);
            throw new Error(`Expected an array of sessions from ${apiEndpoint}, but received other type.`);
        }

        if (sessions.length === 0) {
            sessionListElement.innerHTML = '<li class="px-3 py-1 text-gray-400 text-sm">No active sessions found.</li>';
        } else {
            sessionListElement.innerHTML = '';
            sessions.forEach(session => {
                if (!session.id || !session.name) {
                    console.warn('Session object is missing id or name:', session);
                    return;
                }

                const listItem = document.createElement('li');
                listItem.className = 'flex items-center justify-between pr-2 group hover:bg-gray-750 rounded-md'; // Added group and hover effect for item

                const link = document.createElement('a');
                const base = chatPageBaseUrl.endsWith('/') ? chatPageBaseUrl : chatPageBaseUrl + '/';
                link.href = `${base}${session.id}`; 
                
                link.className = 'block pl-3 pr-1 py-2 text-gray-300 group-hover:text-white rounded-l-md text-sm truncate flex-grow';
                
                let lastActiveDisplay = "Never";
                if (session.last_active) {
                    try {
                        lastActiveDisplay = new Date(session.last_active).toLocaleString();
                    } catch (e) {
                        console.warn("Could not parse last_active date:", session.last_active);
                        lastActiveDisplay = session.last_active; // show raw if parsing fails
                    }
                }
                link.title = `${session.name}\nLast active: ${lastActiveDisplay}`;
                link.textContent = session.name;
                
                const currentPath = window.location.pathname;
                if (currentPath === link.pathname) { 
                    link.classList.add('bg-gray-700', 'text-white', 'font-semibold');
                    listItem.classList.add('bg-gray-700'); // Also highlight the whole li item
                }


                const deleteButton = document.createElement('button');
                deleteButton.innerHTML = '&#x2715;'; 
                deleteButton.className = 'ml-2 p-1 text-gray-500 hover:text-red-400 focus:outline-none rounded-full hover:bg-gray-600 transition-colors duration-150 ease-in-out text-xs opacity-0 group-hover:opacity-100 focus:opacity-100 flex-shrink-0'; 
                deleteButton.title = `Delete session: ${session.name}`;
                
                deleteButton.onclick = (event) => {
                    event.stopPropagation(); // Prevent triggering link navigation
                    handleDeleteSession(session.id, session.name, apiEndpoint, listElementId, base);
                };

                listItem.appendChild(link);
                listItem.appendChild(deleteButton);
                sessionListElement.appendChild(listItem);
            });
        }
        console.log(`Session list successfully populated from ${apiEndpoint} with ${sessions.length} sessions.`);

    } catch (error) {
        console.error('Error populating session list:', error);
        sessionListElement.innerHTML = `<li class="px-3 py-1 text-red-400 text-sm">Could not load sessions. Error: ${error.message}</li>`;
    }
}

