=== Project Directory Structure ===
Root: C:\Users\viktor.jonsson\OneDrive - CellMax Technologies AB\Documents\Repositories\svenviktorjonsson\tesseracs-chat
Relevant files and folders (excluding specified patterns):

.
├── Readme.md
├── fetch_assets.py
├── generate_secret_key.py
├── package.json
├── postcss.config.js
├── project_content.txt
├── pyproject.toml
├── tailwind.config.js
├── write_project_content_to_file.py
├── app/
│   ├── __init__.py
│   ├── auth.py
│   ├── config.py
│   ├── database.py
│   ├── docker_utils.py
│   ├── email_utils.py
│   ├── encryption_utils.py
│   ├── main.py
│   ├── models.py
│   ├── state.py
│   ├── temp.py
│   ├── utils.py
│   ├── static/
│   │   ├── _sidebar.html
│   │   ├── chat-session.html
│   │   ├── login.html
│   │   ├── script.js
│   │   ├── session-choice.html
│   │   ├── settings.html
│   │   ├── email_templates/
│   │   │   ├── password_reset_email.html
│   │   │   ├── registration_email.html
│   │   ├── js/
│   │   │   ├── app-ui.js
│   │   │   ├── settings.js
│   │   │   ├── temp.js


=== File Contents ===

=== Readme.md ===
Readme


=== fetch_assets.py ===
import os
import requests
import sys

# --- Configuration ---
# Get the directory where the script is located
script_dir = os.path.dirname(os.path.abspath(__file__))
print(f"DEBUG: Script is running from directory: {script_dir}") # <-- Added Debug Print

# Define paths relative to the script's location
static_dir = os.path.join(script_dir, 'app', 'static')
assets_dir = os.path.join(static_dir, 'assets')
css_dir = os.path.join(assets_dir, 'css')
fonts_dir = os.path.join(assets_dir, 'fonts') # Define fonts dir for creation

# Print the calculated target directories for verification
print(f"DEBUG: Target static directory: {static_dir}")
print(f"DEBUG: Target assets directory: {assets_dir}")
print(f"DEBUG: Target CSS directory: {css_dir}")
print(f"DEBUG: Target fonts directory: {fonts_dir}") # <-- Added Debug Print

# List of CSS files to download
css_files_to_download = [
    {
        'name': 'katex.min.css',
        'url': 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css',
        'dest': os.path.join(css_dir, 'katex.min.css')
    },
    {
        'name': 'prism-tomorrow.min.css',
        'url': 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css',
        'dest': os.path.join(css_dir, 'prism-tomorrow.min.css')
    }
]

# --- Helper Functions ---
def ensure_dir_exists(dir_path):
    """Creates a directory if it doesn't exist."""
    if not os.path.exists(dir_path):
        print(f"Creating directory: {dir_path}")
        try:
            os.makedirs(dir_path, exist_ok=True)
        except OSError as e:
            print(f"Error creating directory {dir_path}: {e}", file=sys.stderr)
            sys.exit(1) # Exit if directory creation fails

def download_file(url, destination_path):
    """Downloads a file from a URL to a destination path."""
    print(f"Attempting to download {os.path.basename(destination_path)} to {destination_path} from {url}...") # <-- Added Debug Print
    try:
        response = requests.get(url, stream=True, timeout=30) # Added timeout
        response.raise_for_status() # Raise an exception for bad status codes (4xx or 5xx)

        with open(destination_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
        print(f"Successfully downloaded: {os.path.basename(destination_path)}")
        return True
    except requests.exceptions.RequestException as e:
        print(f"Error downloading {url}: {e}", file=sys.stderr)
        # Clean up partially downloaded file if it exists
        if os.path.exists(destination_path):
            try:
                os.remove(destination_path)
                print(f"Removed partially downloaded file: {os.path.basename(destination_path)}")
            except OSError as remove_error:
                print(f"Error removing partial file {destination_path}: {remove_error}", file=sys.stderr)
        return False
    except Exception as e:
        print(f"An unexpected error occurred during download of {url}: {e}", file=sys.stderr)
        return False


# --- Main Execution ---
def main():
    print("Starting Python asset fetching process...")

    # 1. Ensure directories exist
    print("Ensuring necessary directories exist...")
    ensure_dir_exists(static_dir)
    ensure_dir_exists(assets_dir)
    ensure_dir_exists(css_dir)
    ensure_dir_exists(fonts_dir) # Also create fonts dir
    print("Directory check complete.")

    # 2. Download CSS files
    print("\nDownloading CSS files...")
    success_count = 0
    failure_count = 0
    for file_info in css_files_to_download:
        # Print the destination path before downloading
        print(f"DEBUG: Calculated destination for {file_info['name']}: {file_info['dest']}") # <-- Added Debug Print
        if download_file(file_info['url'], file_info['dest']):
            success_count += 1
        else:
            failure_count += 1

    print(f"\nDownload summary: {success_count} succeeded, {failure_count} failed.")

    if failure_count > 0:
        print("\nOne or more downloads failed. Please check the errors above.", file=sys.stderr)
        sys.exit(1) # Exit with error code if any download failed
    else:
        print("\nPython asset fetching process completed successfully.")
        print("CSS files downloaded to:", css_dir)
        print("Ensure font files are placed in:", fonts_dir)

if __name__ == "__main__":
    main()


=== generate_secret_key.py ===
import secrets
key = secrets.token_urlsafe(32)  # Generates a 32-byte random string, URL-safe
print(key)

=== package.json ===
{
  "name": "tesseracs-chat",
  "version": "1.0.0",
  "description": "Readme",
  "main": "temp.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "node build.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/svenviktorjonsson/tesseracs-chat.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/svenviktorjonsson/tesseracs-chat/issues"
  },
  "homepage": "https://github.com/svenviktorjonsson/tesseracs-chat#readme",
  "devDependencies": {
    "autoprefixer": "^10.4.21",
    "esbuild": "^0.25.4",
    "esbuild-style-plugin": "^1.6.3",
    "postcss": "^8.5.3",
    "tailwindcss": "^3.4.17"
  },
  "dependencies": {
    "katex": "^0.16.22",
    "marked": "^15.0.11",
    "prismjs": "^1.29.0"
  }
}


=== postcss.config.js ===
// postcss.config.js
module.exports = {
  plugins: {
    'tailwindcss': {}, // Use 'tailwindcss' for v3
    'autoprefixer': {},
  },
}

=== project_content.txt ===


=== pyproject.toml ===
[tool.poetry]
name = "tesseracs-chat"
version = "1.0.1"
description = "Web chat interface for Ollama using FastAPI and LangChain"
authors = ["Viktor Jonsson <viktor.jonsson@tesseracs.com>"]
readme = "README.md" # Optional README
packages = [
    { include = "app" },
]

[tool.poetry.dependencies]
python = "^3.9" # Adjust Python version if needed
fastapi = "^0.110.0"
uvicorn = {extras = ["standard"], version = "^0.29.0"}

# Let Poetry resolve the latest compatible LangChain versions
# Using "*" allows any version, but be aware this might pull in breaking changes in the future.
langchain = "*"
langchain-ollama = "*"
langchain-core = "*"
langchain-community = "*"
langchain-text-splitters = "*"

# Other dependencies
websockets = "^12.0" # Required by FastAPI for WebSockets
python-dotenv = "^1.0.1" # For optional .env file
aiofiles = "^23.2.1" # For serving static files asynchronously
docker = "^7.1.0"
requests = "^2.32.3"
python-multipart = "^0.0.20"
fastapi-mail = "^1.4.2"
certifi = "^2025.4.26"
pydantic = "^2.11.4"
langchain-openai = "^0.3.16"
langchain-anthropic = "^0.3.13"
langchain-google-genai = "^2.1.4"
cryptography = ">=43.0,<44.0"
passlib = {extras = ["bcrypt"], version = "^1.7.4"}
bcrypt = "==4.0.1"
fastapi-csrf-protect = "^1.0.3"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"



=== tailwind.config.js ===
/** @type {import('tailwindcss').Config} */
module.exports = {
    content: [
      "./app/static/**/*.html", // Scan HTML files in static
      "./app/static/**/*.js",   // Scan JS files in static
    ],
    theme: {
      extend: {},
    },
    plugins: [],
  }

=== write_project_content_to_file.py ===
import os
import sys

# --- Configuration ---

# Set the starting directory (e.g., "." for current directory)
root = "."


import os

# --- Configuration ---

# !!! CHANGE THIS VARIABLE TO THE DESIRED STARTING DIRECTORY !!!
# Example: root = "/path/to/your/project" or root = "src"
root = fr"./"

# Extensions to include
extensions = ('.py', '.html', '.css', '.js', '.json', '.md', '.txt', '.yaml', '.yml', '.toml')

# Directories to completely exclude (will not be walked)
exclude_dirs = (
    '.git',
    '__pycache__',
    '.pytest_cache',
    'node_modules',
    'build',
    'old2',
    'testing-bundles', # Exclude this directory name wherever it appears
    '.venv',           # Common virtual environment folder
    'venv',
    'env',
    '.env',
    'dist',
    "assets"
)

# Files to list in the tree but exclude their *content*
exclude_exact_filenames = (
    'package-lock.json',
    'yarn.lock',
    'katex.min.css',
    'katex.min.js',
    'build.js',
    'docker_utils.js',
    'llm.py',
    'input.css'
    # Add other large or irrelevant files by name here
)

# Files to exclude from the tree and content if their name contains any of these strings
exclude_filename_patterns = ('lock',)

# Specific files to list in the tree but exclude their *content* from the output
exclude_files = (
    'session.json',
    'cm_logo.ico',
)

# Output file name
output_filename = "project_content.txt"

# --- Script Logic ---

# Normalize the root path and make it absolute for reliable comparisons
root = os.path.abspath(root)

print(f"Starting directory: {root}")
print(f"Output file: {output_filename}")

# The instructions to be added at the end of the file
llm_instructions = """
=== LLM Instructions ===
Now please just read the project and the rules for writing code and just wait for instructions.

Here are the rules:
1. DONT write comments, placeholders or docstrings if not explicitely told.
2. Write functions with the correct initial indentation so that if the function is indented so is your code that you write.
3. DO NOT USE NON-TERMINATED SPACES. MAKE SURE TO FOLLOW THIS! ITS SUPER IMPORTANT AND YOU SEEM TO BREAK IT, PLEASE!!!
4. For changes that require multiple replacements please tell me what to replace with what instead of rewriting large portions of text. You can use vscode valid regexp for instance.
5. For small functions less than 100 lines of code please rewrite the full function. For larger functions please only write complete control statements if/while/case.
6. Never omit/change working logic if not explicitely statet that it should be removed/change
7. DONT use the CANVAS TOOL where code is written in artifacts.
8. Write only functions that are new seperately from functions that needs updates.
9. Make sure to write what has been change where to place/what to replace for each code snippet.
"""


try:
    # Using "w" mode ensures the file is overwritten if it exists
    with open(output_filename, "w", encoding="utf-8") as outfile:
        # === Add Directory Structure ===
        outfile.write("=== Project Directory Structure ===\n")
        outfile.write(f"Root: {root}\n")
        outfile.write("Relevant files and folders (excluding specified patterns):\n\n")

        start_level = root.count(os.sep)
        for current_root, dirs, files in os.walk(root, topdown=True):
            dirs[:] = [d for d in dirs if d not in exclude_dirs and not d.startswith('.')]
            rel_path_from_start = os.path.relpath(current_root, root)
            level = current_root.count(os.sep) - start_level

            if rel_path_from_start != '.':
                path_components = os.path.normpath(rel_path_from_start).split(os.sep)
                if any(comp in exclude_dirs or comp.startswith('.') for comp in path_components):
                    continue

                indent = '│   ' * (level - 1) + '├── ' if level > 0 else ''
                outfile.write(f"{indent}{os.path.basename(current_root)}/\n")
            else:
                outfile.write(".\n")

            file_indent = '│   ' * level + '├── '
            files.sort()
            for file in files:
                # Apply all file exclusion rules
                if (file.endswith(extensions) and
                    not file.startswith('.') and
                    file not in exclude_exact_filenames and
                    not any(p in file for p in exclude_filename_patterns)):
                        outfile.write(f"{file_indent}{file}\n")

        outfile.write("\n\n=== File Contents ===\n\n")

        # === Add File Contents ===
        for current_root, dirs, files in os.walk(root, topdown=True):
            dirs[:] = [d for d in dirs if d not in exclude_dirs and not d.startswith('.')]
            rel_path_from_start = os.path.relpath(current_root, root)
            if rel_path_from_start != '.':
                path_components = os.path.normpath(rel_path_from_start).split(os.sep)
                if any(comp in exclude_dirs or comp.startswith('.') for comp in path_components):
                    continue

            files.sort()
            for file in files:
                # Apply all file exclusion rules again for content processing
                if (file.endswith(extensions) and
                    not file.startswith('.') and
                    file not in exclude_exact_filenames and
                    not any(p in file for p in exclude_filename_patterns)):
                        file_path = os.path.join(current_root, file)
                        relative_path = os.path.relpath(file_path, root)
                        display_path = relative_path.replace(os.sep, '/')
                        outfile.write(f"=== {display_path} ===\n")

                        if file in exclude_files:
                            outfile.write("--- CONTENT EXCLUDED (listed in exclude_files) ---\n")
                        else:
                            try:
                                try:
                                    with open(file_path, "r", encoding="utf-8") as infile:
                                        outfile.write(infile.read())
                                except UnicodeDecodeError:
                                    try:
                                        with open(file_path, "r", encoding="latin-1") as infile:
                                            outfile.write(infile.read())
                                        outfile.write("\n--- (Warning: Read using latin-1 encoding) ---\n")
                                    except Exception as inner_e:
                                        outfile.write(f"--- Error reading file (fallback failed): {inner_e} ---\n")
                            except Exception as e:
                                outfile.write(f"--- Error reading file: {e} ---\n")
                        outfile.write("\n\n")

        # === Add LLM Instructions at the end of the file ===
        outfile.write(llm_instructions)

    print("Successfully generated project content file.")

except Exception as e:
    print(f"An error occurred: {e}")

=== app/__init__.py ===


=== app/auth.py ===
# app/auth.py
import os
import secrets
import sqlite3
import traceback # Added from earlier version
from datetime import datetime, timedelta, timezone
from typing import Optional, Dict, Any

from fastapi import Depends, HTTPException, status, Response, Request # Added Request
from fastapi.security import APIKeyCookie, OAuth2PasswordBearer # Added APIKeyCookie

from passlib.context import CryptContext

# Assuming your project structure allows these relative imports
from . import models # For type hinting if needed (e.g., User model for return types)
from . import config
# Import necessary functions from database.py
from .database import get_db_connection, generate_secure_token, hash_value as hash_session_token

# Password Hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# --- Constants ---
SESSION_COOKIE_NAME = "tesseracs_session_token"
SESSION_DURATION_DAYS = 7 # From earlier version

# OAuth2 scheme for API endpoints (if you use Bearer tokens for some APIs)
# This is for FastAPI's dependency injection to get token from Authorization header
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/token") # tokenUrl points to your login endpoint

# Dependency for getting the session token from the cookie
cookie_scheme = APIKeyCookie(name=SESSION_COOKIE_NAME, auto_error=False)


# --- Password Utilities ---
def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifies a plain password against a stored hash using passlib."""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Hashes a plain password using passlib (for user passwords)."""
    return pwd_context.hash(password)

# --- User Authentication (Database Interaction for login) ---
def authenticate_user_from_db(
    conn: sqlite3.Connection, email: str, password: str
) -> Optional[Dict[str, Any]]:
    """
    Authenticates a user by fetching from DB and verifying password.
    This is typically called by the /token login route.

    Args:
        conn: Active SQLite database connection (passed from the route).
        email: User's email.
        password: User's plain text password.

    Returns:
        A dictionary containing user details if successful, otherwise None.
    """
    if not conn:
        print("ERROR (auth.authenticate_user_from_db): Database connection is None.")
        return None
    
    try:
        cursor = conn.cursor()
        # Ensure email is normalized (e.g., lowercased) for lookup
        normalized_email = email.lower().strip()
        cursor.execute(
            "SELECT id, name, email, password_hash, is_active FROM users WHERE email = ?",
            (normalized_email,)
        )
        user_row = cursor.fetchone()

        if not user_row:
            print(f"DEBUG (auth.authenticate_user_from_db): User not found for email: {normalized_email}")
            return None 

        user_data = dict(user_row)
        stored_password_hash = user_data.get("password_hash")

        if not stored_password_hash or not verify_password(password, stored_password_hash):
            print(f"DEBUG (auth.authenticate_user_from_db): Password verification failed for email: {normalized_email}")
            return None

        # Return relevant user details, excluding the password hash
        return {
            "id": user_data["id"],
            "name": user_data["name"],
            "email": user_data["email"],
            "is_active": user_data["is_active"],
        }
    except sqlite3.Error as e:
        print(f"ERROR (auth.authenticate_user_from_db): Database error - {e}")
        traceback.print_exc()
        return None
    except Exception as e: # Catch any other unexpected errors
        print(f"ERROR (auth.authenticate_user_from_db): Unexpected error - {e}")
        traceback.print_exc()
        return None


# --- Session Token Management (Database-backed sessions) ---
async def create_user_session(response: Response, user_id: int) -> str:
    """
    Creates a new session token, stores its HASH in the database,
    and sets the RAW token as an HttpOnly cookie in the response.
    Uses `hash_session_token` (from database.py) for session tokens.
    """
    session_token_raw = generate_secure_token(32) # Generate a new raw token
    # Use the specific hash function for session tokens (e.g., SHA256 from database.py)
    session_token_hashed = hash_session_token(session_token_raw) 
    
    expires_delta = timedelta(days=SESSION_DURATION_DAYS)
    expires_at = datetime.now(timezone.utc) + expires_delta
    
    conn = None
    try:
        conn = get_db_connection() # Get a new connection
        cursor = conn.cursor()
        cursor.execute(
            """INSERT INTO auth_tokens (user_id, token_hash, token_type, created_at, expires_at)
               VALUES (?, ?, ?, datetime('now', 'utc'), ?)""",
            (user_id, session_token_hashed, 'session', expires_at.isoformat())
        )
        conn.commit()
        
        response.set_cookie(
            key=SESSION_COOKIE_NAME,
            value=session_token_raw, # Set the RAW token in the cookie
            httponly=True,
            max_age=int(expires_delta.total_seconds()),
            expires=expires_at,
            samesite="Lax",
            secure=config.BASE_URL.startswith("https://"), # Secure cookie if served over HTTPS
            path="/"
        )
        print(f"AUTH: Session cookie '{SESSION_COOKIE_NAME}' set for user_id {user_id}. Expires: {expires_at.isoformat()}")
        return session_token_raw # Return the raw token (e.g., for /token response model)
        
    except sqlite3.Error as e:
        print(f"ERROR (auth.create_user_session): Database error - {e}")
        traceback.print_exc()
        if conn: conn.rollback()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Could not create user session due to a database issue.")
    except Exception as e:
        print(f"ERROR (auth.create_user_session): Unexpected error - {e}")
        traceback.print_exc()
        if conn: conn.rollback()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Could not create user session due to an unexpected server error.")
    finally:
        if conn:
            conn.close()

async def get_user_by_session_token_internal(token_raw: Optional[str]) -> Optional[Dict[str, Any]]:
    """
    Internal helper: Retrieves user details based on a RAW session token.
    Hashes the raw token and verifies it against hashed tokens in the database.
    Uses `hash_session_token` (from database.py).
    """
    if not token_raw:
        return None
    
    session_token_hashed = hash_session_token(token_raw) # Hash the raw token for DB lookup
    conn = None
    try:
        conn = get_db_connection() # Get a new connection
        cursor = conn.cursor()
        now_utc_iso = datetime.now(timezone.utc).isoformat()
        
        cursor.execute(
            """SELECT u.id, u.name, u.email, u.is_active
               FROM users u JOIN auth_tokens at ON u.id = at.user_id
               WHERE at.token_hash = ? AND at.token_type = 'session' 
               AND at.expires_at > ? AND at.used_at IS NULL
            """, (session_token_hashed, now_utc_iso)
        )
        user_row = cursor.fetchone()

        if user_row:
            user_data = dict(user_row)
            return {
                "id": user_data["id"],
                "name": user_data["name"],
                "email": user_data["email"],
                "is_active": user_data["is_active"]
            }
        return None
        
    except sqlite3.Error as e:
        print(f"ERROR (auth.get_user_by_session_token_internal): Database error - {e}")
        traceback.print_exc()
        return None
    except Exception as e:
        print(f"ERROR (auth.get_user_by_session_token_internal): Unexpected error - {e}")
        traceback.print_exc()
        return None
    finally:
        if conn:
            conn.close()

# This `get_current_user` is for cookie-based authentication (Optional user)
async def get_current_user(
    session_token_raw: Optional[str] = Depends(cookie_scheme)
) -> Optional[Dict[str, Any]]:
    """
    FastAPI Dependency: Retrieves the current authenticated user based on the
    session token from the cookie. Returns user dict or None if not authenticated/active.
    Does not raise HTTPException, allowing routes to handle optional authentication.
    """
    if not session_token_raw:
        return None
    
    user = await get_user_by_session_token_internal(session_token_raw)
    if user and user.get("is_active"):
        return user
    return None


# This `get_current_active_user` is for cookie-based authentication (Required active user)
async def get_current_active_user(
    session_token_raw: Optional[str] = Depends(cookie_scheme)
) -> Dict[str, Any]:
    """
    FastAPI Dependency: Retrieves the current authenticated AND active user.
    Raises HTTPException if not authenticated or user is inactive.
    This is typically used for routes that require a logged-in, active user.
    """
    if not session_token_raw:
        # This case might be hit if cookie_scheme's auto_error=False and cookie is missing
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated (no session cookie)",
            headers={"WWW-Authenticate": "Session"}, 
        )
    
    user = await get_user_by_session_token_internal(session_token_raw)
    
    if not user:
        # Consider how to handle invalid cookie (e.g., if main.py should clear it on redirect)
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired session token",
            headers={"WWW-Authenticate": "Session"},
        )
    if not user.get("is_active"):
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="User account is inactive")
    
    return user


# This `get_current_user_bearer` is a placeholder for API Bearer token authentication
# It uses oauth2_scheme, which looks for "Authorization: Bearer <token>" header.
async def get_current_user_bearer(token: str = Depends(oauth2_scheme)) -> Optional[Dict[str, Any]]:
    """
    Dependency to get the current user from a Bearer token (for API calls).
    This is an example if you were using JWTs or other Bearer tokens.
    It's kept separate from cookie-based session authentication.
    """
    if not token:
        return None
    # In a real scenario, you would:
    # 1. Decode the JWT token (if it's a JWT).
    # 2. Validate its signature, issuer, audience, expiry.
    # 3. Extract user identifier (e.g., user_id or sub) from token claims.
    # 4. Fetch user from database based on that identifier.
    # For now, this is a placeholder and returns None.
    print(f"DEBUG (auth.get_current_user_bearer): Received Bearer token: {token[:15]}...")
    # Example: user_id = my_jwt_decode_function(token).get("sub")
    # user = await fetch_user_from_db_by_id(user_id)
    # return user
    return None # Replace with actual Bearer token validation and user lookup


async def logout_user(response: Response, session_token_raw: Optional[str]):
    """
    Logs out the user by invalidating their session token in the database
    (if provided) and clearing the session cookie from the browser.
    Uses `hash_session_token` for session tokens.
    """
    if session_token_raw:
        session_token_hashed = hash_session_token(session_token_raw)
        conn = None
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            now_utc_iso = datetime.now(timezone.utc).isoformat()
            # Mark the specific token as used by setting used_at and making it expire immediately
            cursor.execute(
                """UPDATE auth_tokens 
                   SET used_at = ?, expires_at = ?
                   WHERE token_hash = ? AND token_type = 'session'""",
                (now_utc_iso, now_utc_iso, session_token_hashed)
            )
            conn.commit()
            print(f"AUTH: Session token (hash starting {session_token_hashed[:10]}...) marked as used/expired in DB for logout.")
        except sqlite3.Error as e:
            print(f"ERROR (auth.logout_user): Database error invalidating token - {e}")
            traceback.print_exc()
            if conn: conn.rollback()
            # Proceed with cookie deletion even if DB update fails
        except Exception as e:
            print(f"ERROR (auth.logout_user): Unexpected error invalidating token - {e}")
            traceback.print_exc()
            if conn: conn.rollback()
        finally:
            if conn:
                conn.close()

    # Always attempt to delete the cookie from the browser
    response.delete_cookie(
        SESSION_COOKIE_NAME,
        httponly=True,
        secure=config.BASE_URL.startswith("https://"), # Match secure attribute used when setting
        samesite="Lax", # Match samesite attribute
        path="/"
    )
    print(f"AUTH: Session cookie '{SESSION_COOKIE_NAME}' cleared from browser response.")


=== app/config.py ===
# app/config.py
import os
import sys
from pathlib import Path
from dotenv import load_dotenv
from typing import Optional, List, Dict, Any

# Load environment variables from a .env file if it exists
load_dotenv()

# --- Application Base URL ---
BASE_URL = os.getenv("BASE_URL", "http://localhost:8001")

CSRF_PROTECT_SECRET_KEY = os.getenv("CSRF_PROTECT_SECRET_KEY")

DEBUG_MODE = os.getenv("DEBUG_MODE", "False").lower() in ('true', '1', 't', 'yes')
DATABASE_PATH = Path(os.getenv("DATABASE_PATH","./tesseracs_chat.db")) # Corrected typo from DATABSE_PATH
# --- Secret Key for Encryption ---
APP_SECRET_KEY = os.getenv("APP_SECRET_KEY")
if not APP_SECRET_KEY:
    print("CRITICAL WARNING: APP_SECRET_KEY is not set in the environment. "
          "User-specific API keys will not be securely stored. This is a major security risk. "
          "Please set this environment variable to a strong, random string. "
          "For development, the application will proceed, but encryption will be disabled if this key is missing.")
elif len(APP_SECRET_KEY) < 32:
    print(f"WARNING: APP_SECRET_KEY is set but may not be strong enough (length: {len(APP_SECRET_KEY)}). "
          "Ensure it's a Fernet-compatible key (32 url-safe base64-encoded bytes).")


# --- LLM Configuration ---

ENV_DEFAULT_OLLAMA_MODEL_ID = os.getenv("DEFAULT_OLLAMA_MODEL_ID", "qwen3:8B")
ENV_DEFAULT_OLLAMA_MODEL_DISPLAY_NAME = os.getenv("DEFAULT_OLLAMA_MODEL_DISPLAY_NAME", "Qwen3 8B (Local Default)")
ENV_DEFAULT_OLLAMA_MODEL_CONTEXT_WINDOW = int(os.getenv("DEFAULT_OLLAMA_MODEL_CONTEXT_WINDOW", 32768))

LLM_PROVIDERS: Dict[str, Dict[str, Any]] = {
    "ollama_local": {
        "display_name": "Ollama (Local)",
        "type": "ollama",
        "base_url_env_var": "OLLAMA_BASE_URL",
        "api_key_env_var": None, # Ollama does not use API keys in this manner
        "available_models": [
            {
                "model_id": ENV_DEFAULT_OLLAMA_MODEL_ID,
                "display_name": ENV_DEFAULT_OLLAMA_MODEL_DISPLAY_NAME,
                "context_window": ENV_DEFAULT_OLLAMA_MODEL_CONTEXT_WINDOW
            },
        ],
    },
    "google_gemini": {
        "display_name": "Google Gemini",
        "type": "google_genai",
        "base_url_env_var": None, # Google SDK handles the endpoint
        "api_key_env_var": "GOOGLE_API_KEY", # User's original: None, changed to GOOGLE_API_KEY to align with get_provider_config usage
        "available_models": [
            {
                "model_id": "gemini-2.5-pro-preview-05-06", # User's original model ID
                "display_name": "Gemini 2.5 Pro", 
                "context_window": 1048576 
            },
            {
                "model_id": "gemini-2.5-flash-preview-04-17", # User's original model ID
                "display_name": "Gemini 2.5 Flash", 
                "context_window": 1048576 
            }

        ],
    },
    "anthropic_claude": {
        "display_name": "Anthropic Claude",
        "type": "anthropic",
        "base_url_env_var": None, # Anthropic SDK handles the endpoint
        "api_key_env_var": "ANTHROPIC_API_KEY", # User's original: None, changed to ANTHROPIC_API_KEY
        "available_models": [
            {
                "model_id": "claude-3-7-sonnet-20250219", # User's original model ID
                "display_name": "Claude 3.7 Sonnet", 
                "context_window": 200000 
            }
        ],
    },
    "openai_compatible_server": {
        "display_name": "OpenAI-Compatible API",
        "type": "openai_compatible",
        "base_url_env_var": "OPENAI_COMPATIBLE_BASE_URL",
        "api_key_env_var": "OPENAI_COMPATIBLE_API_KEY", # User's original: None, changed to OPENAI_COMPATIBLE_API_KEY
        "available_models": [
            {
                "model_id": "o4-mini", # User's original model ID
                "display_name": "o4 mini (OpenAI Compatible)",
                "context_window": 128000
            }
        ],
    },
}

# --- Default LLM Selection ---
DEFAULT_LLM_PROVIDER_ID: str = os.getenv("DEFAULT_LLM_PROVIDER_ID", "ollama_local") # User's original default
# Logic to set DEFAULT_LLM_MODEL_ID based on DEFAULT_LLM_PROVIDER_ID and its available models
_default_provider_config_for_model_fallback = LLM_PROVIDERS.get(DEFAULT_LLM_PROVIDER_ID, {})
_default_provider_models_for_fallback = _default_provider_config_for_model_fallback.get("available_models", [])
_default_model_id_env_candidate = os.getenv("DEFAULT_LLM_MODEL_ID")

if _default_model_id_env_candidate and any(m["model_id"] == _default_model_id_env_candidate for m in _default_provider_models_for_fallback):
    DEFAULT_LLM_MODEL_ID: str = _default_model_id_env_candidate
elif _default_provider_models_for_fallback:
    DEFAULT_LLM_MODEL_ID: str = _default_provider_models_for_fallback[0]["model_id"]
else:
    DEFAULT_LLM_MODEL_ID: str = "qwen3:8B" # Fallback to user's original hardcoded default if provider/models not found
    if DEFAULT_LLM_PROVIDER_ID == "ollama_local":
        DEFAULT_LLM_MODEL_ID = ENV_DEFAULT_OLLAMA_MODEL_ID # Ensure it uses the ollama default if provider is ollama
    print(f"WARNING: Could not determine a valid DEFAULT_LLM_MODEL_ID for provider '{DEFAULT_LLM_PROVIDER_ID}' from its 'available_models'. Using '{DEFAULT_LLM_MODEL_ID}'.")


# --- Provider Characteristics ---
# ADDED THESE AS THEY WERE MISSING AND CAUSING AttributeErrors
PROVIDERS_TYPICALLY_USING_API_KEYS = {
    "google_gemini",
    "anthropic_claude",
    "openai_compatible_server"
    # Add "openai" here if you add a direct OpenAI provider definition
}

PROVIDERS_ALLOWING_USER_KEYS_EVEN_IF_SYSTEM_CONFIGURED = {
    "google_gemini",                # User might want to use their own project quota/key
    "anthropic_claude",             # User might want to use their own key
    "openai_compatible_server"      # For this type, user often provides key and base_url
}


# --- Helper function to get a provider's configuration ---
def get_provider_config(provider_id: str) -> Optional[Dict[str, Any]]:
    provider_info_template = LLM_PROVIDERS.get(provider_id)
    if not provider_info_template:
        return None

    runtime_config = provider_info_template.copy()

    base_url_env_name = provider_info_template.get("base_url_env_var")
    resolved_base_url = None # Initialize
    if base_url_env_name:
        resolved_base_url = os.getenv(base_url_env_name)
    
    # Specific handling for Ollama's common OLLAMA_BASE_URL if its own provider-specific env var isn't set
    if provider_info_template.get("type") == "ollama" and not resolved_base_url:
        resolved_base_url = os.getenv("OLLAMA_BASE_URL", "http://localhost:11434")
    
    runtime_config["base_url"] = resolved_base_url if resolved_base_url else provider_info_template.get("base_url") # Fallback to static base_url in template if any

    # This key in runtime_config is what main.py's list_llm_providers expects
    runtime_config["api_key_env_var_name"] = provider_info_template.get("api_key_env_var")

    if "available_models" not in runtime_config or not isinstance(runtime_config["available_models"], list):
        runtime_config["available_models"] = []
    return runtime_config

# --- Ollama Base URL (General fallback if not specified per provider) ---
OLLAMA_BASE_URL = os.getenv("OLLAMA_BASE_URL", "http://localhost:11434")

# --- Chat Behavior Prefixes ---
NO_THINK_PREFIX = "\\no_think"
THINK_PREFIX = "\\think"

# --- Docker Configuration ---
SUPPORTED_LANGUAGES = {
    "python": {"image": "python:3.11-slim", "filename": "script.py", "command": ["python", "-u", "/app/script.py"]},
    "javascript": {"image": "node:18-alpine", "filename": "script.js", "command": ["node", "/app/script.js"]},
    "cpp": {"image": "gcc:latest", "filename": "script.cpp", "command": ["sh", "-c", "g++ /app/script.cpp -o /app/output_executable && /app/output_executable"]},
    "csharp": {"image": "mcr.microsoft.com/dotnet/sdk:latest", "filename": "Script.cs", "command": ["sh", "-c", "cd /app && dotnet new console --force -o . > /dev/null && cp Script.cs Program.cs && rm Script.cs && dotnet run"]},
    "typescript": {"image": "node:18-alpine", "filename": "script.ts", "command": ["sh", "-c", "npm install -g typescript > /dev/null 2>&1 && tsc --module commonjs /app/script.ts && node /app/script.js"]},
    "java": {"image": "openjdk:17-jdk-slim", "filename": "Main.java", "command": ["sh", "-c", "javac /app/Main.java && java -cp /app Main"]},
    "go": {"image": "golang:1.21-alpine", "filename": "script.go", "command": ["go", "run", "/app/script.go"]},
    "rust": {"image": "rust:1-slim", "filename": "main.rs", "command": ["sh", "-c", "cd /app && rustc main.rs -o main_executable && ./main_executable"]}
}
DOCKER_TIMEOUT_SECONDS = int(os.getenv("DOCKER_TIMEOUT_SECONDS", 30))
DOCKER_MEM_LIMIT = os.getenv("DOCKER_MEM_LIMIT", "128m")

# --- Static Files Configuration ---
APP_DIR = Path(__file__).resolve().parent 
PROJECT_ROOT = APP_DIR.parent
STATIC_DIR_IN_APP = APP_DIR / "static"
STATIC_DIR_AT_ROOT_LEVEL = PROJECT_ROOT / "static"
STATIC_DIR: Optional[Path] = None 

if STATIC_DIR_IN_APP.is_dir():
    STATIC_DIR = STATIC_DIR_IN_APP
elif STATIC_DIR_AT_ROOT_LEVEL.is_dir() and (PROJECT_ROOT / "pyproject.toml").exists(): 
    STATIC_DIR = STATIC_DIR_AT_ROOT_LEVEL
else:
    current_working_dir = Path.cwd()
    if (current_working_dir / "app" / "static").is_dir(): 
        STATIC_DIR = current_working_dir / "app" / "static"
    elif (current_working_dir / "static").is_dir(): 
        STATIC_DIR = current_working_dir / "static"
    
    if not STATIC_DIR or not STATIC_DIR.is_dir(): 
        print(f"CRITICAL ERROR: Static directory not found. Checked standard locations relative to {APP_DIR}, {PROJECT_ROOT}, and {current_working_dir}. Application may not serve frontend assets.")
        # sys.exit(1) # Consider if exiting is appropriate or just log error

# --- Email Configuration ---
MAIL_CONFIG = {
    "MAIL_USERNAME": os.getenv("MAIL_USERNAME"),
    "MAIL_PASSWORD": os.getenv("MAIL_PASSWORD"),
    "MAIL_FROM": os.getenv("MAIL_FROM"),
    "MAIL_PORT": int(os.getenv("MAIL_PORT", 465)),
    "MAIL_SERVER": os.getenv("MAIL_SERVER"),
    "MAIL_FROM_NAME": os.getenv("MAIL_FROM_NAME", "Tesseracs Chat"),
    "MAIL_STARTTLS": os.getenv("MAIL_STARTTLS", 'False').lower() in ('true', '1', 't', 'yes'),
    "MAIL_SSL_TLS": os.getenv("MAIL_SSL_TLS", 'True').lower() in ('true', '1', 't', 'yes'),
    "USE_CREDENTIALS": True,
    "VALIDATE_CERTS": os.getenv("MAIL_VALIDATE_CERTS", 'True').lower() in ('true', '1', 't', 'yes')
}

if not all([MAIL_CONFIG["MAIL_USERNAME"], MAIL_CONFIG["MAIL_PASSWORD"], MAIL_CONFIG["MAIL_SERVER"], MAIL_CONFIG["MAIL_FROM"]]):
    print("WARNING: Essential email configuration (USERNAME, PASSWORD, SERVER, FROM) missing in .env file. Email functionalities will likely fail.")

# --- Rate Limiting Configuration ---
FORGOT_PASSWORD_ATTEMPT_LIMIT = int(os.getenv("FORGOT_PASSWORD_ATTEMPT_LIMIT", 3)) # User's original
FORGOT_PASSWORD_ATTEMPT_WINDOW_HOURS = int(os.getenv("FORGOT_PASSWORD_ATTEMPT_WINDOW_HOURS", 24)) # User's original

# --- Debug Logging for Configuration ---
print(f"DEBUG config: Application DEBUG_MODE: {DEBUG_MODE}")
print(f"DEBUG config: Application BASE_URL is set to: {BASE_URL}")
if STATIC_DIR:
    print(f"DEBUG config: Static files directory resolved to: {STATIC_DIR.resolve()}")
else:
     print("DEBUG config: Static files directory NOT RESOLVED.")
print(f"DEBUG config: Email VALIDATE_CERTS: {MAIL_CONFIG['VALIDATE_CERTS']}, SSL_TLS: {MAIL_CONFIG['MAIL_SSL_TLS']}, STARTTLS: {MAIL_CONFIG['MAIL_STARTTLS']}")
print(f"DEBUG config: Default LLM Provider ID (system default): {DEFAULT_LLM_PROVIDER_ID}")
print(f"DEBUG config: Default LLM Model ID (system default): {DEFAULT_LLM_MODEL_ID}")

default_provider_runtime_details = get_provider_config(DEFAULT_LLM_PROVIDER_ID)
if default_provider_runtime_details:
    print(f"DEBUG config: Default Provider Type: {default_provider_runtime_details.get('type')}")
    print(f"DEBUG config: Default Provider Resolved Base URL: {default_provider_runtime_details.get('base_url')}")
    print(f"DEBUG config: Default Provider API Key Env Var Name (from LLM_PROVIDERS 'api_key_env_var'): {default_provider_runtime_details.get('api_key_env_var_name')}")
else:
    print(f"WARNING config: Default LLM Provider '{DEFAULT_LLM_PROVIDER_ID}' could not be resolved by get_provider_config.")

if not CSRF_PROTECT_SECRET_KEY:
     print("WARNING config: CSRF_PROTECT_SECRET_KEY is not set in environment. main.py will use a fallback (insecure for production).")


=== app/database.py ===
# app/database.py
import sqlite3
import os
from pathlib import Path
import hashlib # For password hashing
import secrets # For generating secure tokens
import datetime # For timestamps

# Determine the project root directory based on the location of this file
# Assuming this file is app/database.py
APP_DIR = Path(__file__).parent
PROJECT_ROOT = APP_DIR.parent
DATABASE_NAME = "tesseracs_chat.db" # Name of the SQLite database file
DATABASE_PATH = PROJECT_ROOT / DATABASE_NAME # Full path to the database file

def get_db_connection():
    """
    Establishes a connection to the SQLite database.
    Enables row_factory for column access by name and foreign key constraints.
    """
    # print(f"Attempting to connect to database at: {DATABASE_PATH}") # Uncomment for debugging path issues
    conn = sqlite3.connect(DATABASE_PATH)
    conn.row_factory = sqlite3.Row # Allows accessing columns by name (e.g., row['email'])
    conn.execute("PRAGMA foreign_keys = ON;") # Enforce foreign key constraints for this connection
    return conn

def init_db():
    """
    Initializes the database schema.
    Creates tables if they don't exist and attempts to add missing columns
    to existing tables to support schema evolution.
    """
    print(f"Initializing database schema at {DATABASE_PATH}...")
    conn = get_db_connection()
    cursor = conn.cursor()

    # --- Users Table ---
    # Defines user accounts, their credentials, and LLM preferences.
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        email TEXT UNIQUE NOT NULL,
        password_hash TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- Added for tracking updates
        is_active BOOLEAN DEFAULT TRUE NOT NULL,
        selected_llm_provider_id TEXT,      -- User's chosen LLM provider ID
        selected_llm_model_id TEXT,         -- User's chosen LLM model ID for the selected provider
        user_llm_api_key_encrypted TEXT,    -- User's encrypted API key (if they provide their own)
        selected_llm_base_url TEXT          -- User's custom base URL for compatible LLM providers (e.g., OpenAI-compatible servers)
    );
    """)
    print("Ensured 'users' table exists.")

    # Add new columns to 'users' table if they don't exist (for existing databases)
    user_table_columns_to_add = {
        "selected_llm_provider_id": "TEXT",
        "selected_llm_model_id": "TEXT",
        "user_llm_api_key_encrypted": "TEXT",
        "selected_llm_base_url": "TEXT",
        "updated_at": "TIMESTAMP DEFAULT CURRENT_TIMESTAMP" # Ensure updated_at can be added
    }
    cursor.execute("PRAGMA table_info(users)")
    existing_user_columns = [col[1] for col in cursor.fetchall()]

    for col_name, col_definition in user_table_columns_to_add.items():
        if col_name not in existing_user_columns:
            try:
                cursor.execute(f"ALTER TABLE users ADD COLUMN {col_name} {col_definition}")
                print(f"Added '{col_name}' column to 'users' table.")
            except sqlite3.OperationalError as e:
                print(f"Could not add column '{col_name}' to 'users' table: {e}. It might already exist or there's a schema issue.")

    # --- Auth Tokens Table ---
    # Stores various authentication tokens (e.g., session tokens, password reset tokens).
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS auth_tokens (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,                   -- Foreign key to the users table
        token_hash TEXT UNIQUE NOT NULL,            -- Hashed value of the token
        token_type TEXT NOT NULL CHECK(token_type IN ('magic_login', 'session', 'password_reset')), -- Type of token
        expires_at TIMESTAMP NOT NULL,              -- Expiration timestamp for the token
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- When the token was created
        used_at TIMESTAMP,                          -- When the token was used (if applicable, e.g., for one-time tokens)
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE -- If a user is deleted, their tokens are also deleted
    );
    """)
    print("Ensured 'auth_tokens' table exists.")

    # --- Sessions Table ---
    # Represents individual chat sessions.
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS sessions (
        id TEXT PRIMARY KEY,                        -- Unique ID for the session (e.g., UUID)
        host_user_id INTEGER NOT NULL,              -- User who created/hosts the session
        name TEXT,                                  -- User-defined or auto-generated name for the session
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- When the session was created
        last_accessed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- When the session was last accessed or had activity
        is_active BOOLEAN DEFAULT TRUE NOT NULL,    -- Whether the session is currently active or soft-deleted
        FOREIGN KEY (host_user_id) REFERENCES users (id) ON DELETE CASCADE -- If host user is deleted, their sessions are deleted
    );
    """)
    print("Ensured 'sessions' table exists.")

    # --- Session Participants Table ---
    # Manages which users are part of which sessions (for multi-user scenarios, or just the host).
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS session_participants (
        session_id TEXT NOT NULL,                   -- Foreign key to the sessions table
        user_id INTEGER NOT NULL,                   -- Foreign key to the users table
        joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- When the user joined the session
        PRIMARY KEY (session_id, user_id),          -- Composite primary key
        FOREIGN KEY (session_id) REFERENCES sessions (id) ON DELETE CASCADE, -- If session is deleted, participation records are deleted
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE      -- If user is deleted, their participation records are deleted
    );
    """)
    print("Ensured 'session_participants' table exists.")

    # --- Chat Messages Table ---
    # Stores all messages within chat sessions.
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS chat_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id TEXT NOT NULL,                   -- Foreign key to the sessions table
        user_id INTEGER,                            -- Foreign key to users table (NULL if AI/system message)
        sender_name TEXT,                           -- Display name of the sender (e.g., user's name, "AI")
        sender_type TEXT NOT NULL CHECK(sender_type IN ('user', 'ai', 'system', 'anon_user')), -- Type of sender
        content TEXT NOT NULL,                      -- The actual message content
        client_id_temp TEXT,                        -- Optional temporary ID from client for optimistic UI updates
        turn_id INTEGER,                            -- Groups related user and AI messages in a conversational turn
        thinking_content TEXT,                      -- Stores AI's "thinking" process or intermediate thoughts
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- When the message was recorded
        model_provider_id TEXT,                     -- For AI messages: which LLM provider was used
        model_id TEXT,                              -- For AI messages: which specific LLM model was used
        FOREIGN KEY (session_id) REFERENCES sessions (id) ON DELETE CASCADE, -- If session is deleted, its messages are deleted
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE SET NULL    -- If user is deleted, messages remain but user_id becomes NULL
    );
    """)
    print("Ensured 'chat_messages' table exists.")

    # Add new columns to 'chat_messages' if they don't exist
    chat_messages_columns_to_add = {
        "model_provider_id": "TEXT",
        "model_id": "TEXT"
    }
    cursor.execute("PRAGMA table_info(chat_messages)")
    existing_chat_columns = [col[1] for col in cursor.fetchall()]

    for col_name, col_type in chat_messages_columns_to_add.items():
        if col_name not in existing_chat_columns:
            try:
                cursor.execute(f"ALTER TABLE chat_messages ADD COLUMN {col_name} {col_type}")
                print(f"Added '{col_name}' column to 'chat_messages' table.")
            except sqlite3.OperationalError as e:
                print(f"Could not add column '{col_name}' to 'chat_messages' table: {e}. It might already exist.")

    # --- Session Memory State Table ---
    # Stores serialized conversation memory for LLMs, allowing sessions to be resumed with context.
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS session_memory_state (
        session_id TEXT PRIMARY KEY,                -- Foreign key to the sessions table
        memory_state_json TEXT NOT NULL,            -- Serialized memory state (e.g., JSON string)
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- When this memory state was last updated
        FOREIGN KEY (session_id) REFERENCES sessions (id) ON DELETE CASCADE -- If session is deleted, its memory state is deleted
    );
    """)
    print("Ensured 'session_memory_state' table exists.")

    # --- Password Reset Attempts Table ---
    # Logs attempts to reset passwords, useful for rate limiting and security auditing.
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS password_reset_attempts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        email TEXT NOT NULL,                        -- Email for which the reset was attempted
        ip_address TEXT,                            -- Optional: IP address of the requester
        attempted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP -- Timestamp of the reset attempt
    );
    """)
    print("Ensured 'password_reset_attempts' table exists.")

    # --- Indexes for Performance ---
    # These indexes help speed up common queries.
    print("Ensuring database indexes exist...")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_users_email ON users (email);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_auth_tokens_token_hash ON auth_tokens (token_hash);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_auth_tokens_user_id ON auth_tokens (user_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_sessions_host_user_id ON sessions (host_user_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_session_participants_session_id ON session_participants (session_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_session_participants_user_id ON session_participants (user_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_chat_messages_session_id ON chat_messages (session_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_chat_messages_timestamp ON chat_messages (timestamp);") # For ordering messages
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_session_memory_state_session_id ON session_memory_state (session_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_password_reset_attempts_email_time ON password_reset_attempts (email, attempted_at);")
    print("Ensured all indexes exist.")

    conn.commit() # Save all schema changes
    conn.close()
    print("Database initialization process complete.")

# --- Utility Functions ---

def hash_value(value: str) -> str:
    """
    Hashes a string value (e.g., for storing tokens securely) using SHA256.
    """
    return hashlib.sha256(value.encode('utf-8')).hexdigest()

def generate_secure_token(length: int = 32) -> str:
    """
    Generates a cryptographically secure, URL-safe text string.
    Useful for session tokens, password reset tokens, etc.
    """
    return secrets.token_urlsafe(length)

# This allows the script to be run directly to initialize the database
# e.g., `python -m app.database` from the project root directory.
if __name__ == "__main__":
    print(f"Running database script directly. Current Working Directory: {Path.cwd()}")
    print(f"Project Root (expected): {PROJECT_ROOT}")
    print(f"Database will be created/checked at: {DATABASE_PATH}")
    
    # Ensure the parent directory for the database file exists before trying to create/connect to it
    DATABASE_PATH.parent.mkdir(parents=True, exist_ok=True)
    
    init_db()

=== app/docker_utils.py ===
# app/docker_utils.py

import asyncio
import tempfile
import shutil
import traceback
from pathlib import Path
import docker # Docker SDK for Python
from docker.errors import DockerException, ImageNotFound, APIError, NotFound # Docker specific errors
from docker.models.containers import Container # For type hinting container objects
from fastapi import WebSocket # For type hinting WebSockets

# Relative imports for modules within the 'app' package
from . import config
from . import state
from .utils import send_ws_message # Utility function for sending WebSocket messages

# --- Docker Client Initialization ---
# Attempt to initialize the Docker client from the environment settings.
# This typically connects to the Docker daemon running locally.
docker_client = None
try:
    # Get Docker client from environment variables (DOCKER_HOST, etc.)
    docker_client = docker.from_env()
    # Ping the Docker daemon to ensure connectivity
    docker_client.ping()
    print("Successfully connected to Docker daemon.")
except DockerException as e:
    # Handle exceptions if the Docker daemon is not reachable
    print(f"CRITICAL WARNING: Could not connect to Docker daemon: {e}")
    print("Code execution via Docker will be unavailable.")
    docker_client = None # Ensure client is None if connection failed

def get_docker_client():
    """
    Returns the initialized Docker client instance.
    Returns None if the client failed to initialize.
    """
    return docker_client

# --- Log Streaming Logic (Designed to Run in Executor Thread) ---

def sync_log_streamer(container: Container, websocket: WebSocket, code_block_id: str, loop: asyncio.AbstractEventLoop, stop_event: asyncio.Event):
    """
    Synchronously iterates through Docker container logs and schedules sending
    log lines back to the main asyncio event loop via WebSocket.
    This function is blocking and intended to be run in a separate thread using run_in_executor.

    Args:
        container: The Docker container object to stream logs from.
        websocket: The WebSocket connection to send log messages to.
        code_block_id: Identifier for the code block being executed.
        loop: The main asyncio event loop to schedule coroutines on.
        stop_event: An asyncio.Event used to signal when to stop streaming.
    """
    try:
        # Get a blocking generator for log lines (stdout and stderr)
        # follow=True keeps the stream open until the container stops or stop_event is set.
        log_stream = container.logs(stream=True, follow=True, stdout=True, stderr=True)
        print(f"[Thread-{code_block_id}] Starting log iteration for container {container.short_id}")

        # Iterate through the log stream line by line
        for line_bytes in log_stream:
            # Check if the stop event has been set (e.g., by user cancellation)
            if stop_event.is_set():
                print(f"[Thread-{code_block_id}] Stop event set, breaking log iteration.")
                break # Exit the loop if stop is requested

            # Decode bytes to string, replacing errors
            line_str = line_bytes.decode('utf-8', errors='replace')

            # Schedule the asynchronous send_ws_message function to run on the main event loop
            # This is crucial for thread safety when interacting with asyncio objects like WebSockets.
            asyncio.run_coroutine_threadsafe(
                send_ws_message(websocket, "code_output", {
                    "code_block_id": code_block_id,
                    "stream": "stdout", # Simplification: send both stdout/stderr as stdout type for now
                    "data": line_str
                }),
                loop # Pass the main event loop
            )

        print(f"[Thread-{code_block_id}] Finished log iteration for container {container.short_id}")

    except Exception as e:
        # Handle exceptions during log streaming (e.g., container removed unexpectedly)
        print(f"[Thread-{code_block_id}] Error during log streaming: {e}")
        # Schedule sending an error message back to the client via the main loop
        asyncio.run_coroutine_threadsafe(
            send_ws_message(websocket, "code_output", {
                "code_block_id": code_block_id,
                "stream": "error", # Indicate an error stream
                "data": f"\n[Error streaming logs from container: {str(e)}]"
            }),
            loop
        )

async def stream_docker_logs_via_executor(websocket: WebSocket, container: Container, code_block_id: str, stop_event: asyncio.Event):
    """
    Asynchronously runs the synchronous log streamer function (`sync_log_streamer`)
    in a separate thread using asyncio's default executor.

    Args:
        websocket: The WebSocket connection.
        container: The Docker container object.
        code_block_id: Identifier for the code block.
        stop_event: Event to signal stopping the stream.
    """
    loop = asyncio.get_running_loop()
    print(f"Scheduling log streaming task in executor for {code_block_id}")
    # Run the blocking sync_log_streamer function in the thread pool executor
    await loop.run_in_executor(
        None, # Use the default executor
        sync_log_streamer, # The function to run
        # Arguments to pass to sync_log_streamer:
        container, websocket, code_block_id, loop, stop_event
    )
    print(f"Executor task for log streaming finished for {code_block_id}")


# --- Docker Code Execution Core Function ---

async def run_code_in_docker_stream(websocket: WebSocket, client_id: str, code_block_id: str, language: str, code: str):
    """
    Handles the complete process of running user-provided code in a Docker container:
    1. Validates language and Docker availability.
    2. Creates a temporary directory and writes the code to a file.
    3. Starts the appropriate Docker container based on the language config.
    4. Starts a background task to stream container logs back via WebSocket.
    5. Waits for the container to finish or timeout.
    6. Sends a final status message (success, error, timeout) via WebSocket.
    7. Cleans up the container and temporary directory.

    Args:
        websocket: The client's WebSocket connection.
        client_id: The unique ID of the client.
        code_block_id: Identifier for the specific code block being run.
        language: The programming language of the code (e.g., "python", "c++").
        code: The actual code string provided by the user.
    """
    # Get the initialized Docker client instance
    local_docker_client = get_docker_client()

    # Check if Docker client is available
    if not local_docker_client:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": "Docker service is unavailable on the server."
        })
        return

    # Validate the requested language against the configuration
    lang_key = language.lower()
    lang_config = config.SUPPORTED_LANGUAGES.get(lang_key)
    if not lang_config:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": f"Language '{language}' not supported for execution."
        })
        return

    # Extract language-specific configuration
    image_name = lang_config["image"]
    script_filename = lang_config["filename"]
    command = lang_config["command"]

    # Initialize variables for container, task, temp dir, and stop event
    container_obj: Container | None = None
    stream_task: asyncio.Task | None = None
    tmpdir_obj = None # To hold the TemporaryDirectory object for proper cleanup
    stop_event = asyncio.Event() # Event to signal cancellation to the streamer thread

    try:
        # Create a temporary directory to store the script file
        # Using 'with' ensures cleanup even if errors occur later, but we need the path
        # outside the 'with', so we create it manually and clean up in 'finally'.
        tmpdir_obj = tempfile.TemporaryDirectory()
        tmpdir = tmpdir_obj.name # Get the path string
        host_script_path = Path(tmpdir) / script_filename

        # Write the user's code to the script file inside the temp directory
        with open(host_script_path, "w", encoding="utf-8") as f:
            f.write(code)

        print(f"Attempting to run block {code_block_id} ({lang_key}) in Docker image {image_name}...")

        # Run the Docker container
        # This might implicitly pull the image if not found locally
        container_obj = local_docker_client.containers.run(
            image=image_name,
            command=command, # Command defined in config.py
            # Mount the temporary directory read-write into /app inside the container
            # Changed mode from 'ro' to 'rw' to allow compilation output
            volumes={tmpdir: {'bind': '/app', 'mode': 'rw'}}, # <<< CHANGED HERE
            working_dir='/app', # Set working directory inside the container
            mem_limit=config.DOCKER_MEM_LIMIT, # Apply memory limit from config
            stdout=True, # Capture stdout
            stderr=True, # Capture stderr
            detach=True, # Run the container in the background
            # auto_remove=True, # Cannot auto-remove if we need logs/exit code/manual stop
        )
        print(f"Container {container_obj.short_id} started for {code_block_id}")

        # Create and start the background task for streaming logs
        stream_task = asyncio.create_task(
            stream_docker_logs_via_executor(websocket, container_obj, code_block_id, stop_event),
            name=f"log_stream_{code_block_id}" # Name the task for easier debugging
        )

        # Add the running container info to the global state dictionary (thread-safe)
        async with state.running_containers_lock:
            # Check if another execution for the same block ID is already running
            if code_block_id in state.running_containers:
                # This shouldn't happen if frontend disables button, but handle defensively
                print(f"WARNING: Code block {code_block_id} was already running. Stopping previous run.")
                # Schedule stop_docker_container; do not await inside the lock
                asyncio.create_task(stop_docker_container(code_block_id))

            # Store container details in the shared state dictionary
            state.running_containers[code_block_id] = {
                "container": container_obj,
                "stream_task": stream_task,
                "client_id": client_id,
                "websocket": websocket,
                "stop_event": stop_event # Store the stop event for cancellation
            }

        # Wait for the container to finish execution (blocking call run in executor)
        print(f"Waiting for container {container_obj.short_id} ({code_block_id}) to finish...")
        loop = asyncio.get_running_loop()
        # container.wait() is blocking, so run it in the executor
        result = await loop.run_in_executor(
            None, # Use default executor
            lambda: container_obj.wait(timeout=config.DOCKER_TIMEOUT_SECONDS) # Wait with timeout
        )
        # Extract exit code and potential error message from the result
        exit_code = result.get("StatusCode", -1) # Default to -1 if status code missing
        error_msg = result.get("Error", None) # Docker daemon error message
        print(f"Container {container_obj.short_id} ({code_block_id}) finished. Result: {result}")

        # --- Container Finished Normally or Errored ---
        # Signal the log streaming thread that it can stop
        stop_event.set()
        try:
            # Wait briefly for the log streaming task to finish processing final logs
            await asyncio.wait_for(stream_task, timeout=5.0)
        except asyncio.TimeoutError:
            print(f"Warning: Log streaming task for {code_block_id} did not finish quickly after container exit.")
            # Cancel the task if it's still running after the timeout
            if stream_task and not stream_task.done():
                stream_task.cancel()
        except asyncio.CancelledError:
            # Expected if the task was cancelled during stop_docker_container
             print(f"Log streaming task for {code_block_id} was cancelled (likely during stop).")

        # Send the final result message to the client
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id,
            "exit_code": exit_code,
            "error": error_msg # Send Docker-level error if any (e.g., OOMKilled)
        })

    except asyncio.TimeoutError: # Timeout triggered by container_obj.wait()
        # Handle the case where the container ran longer than DOCKER_TIMEOUT_SECONDS
        print(f"ERROR: Docker execution timed out for block {code_block_id} after {config.DOCKER_TIMEOUT_SECONDS}s.")
        await send_ws_message(websocket, "code_finished", {
             "code_block_id": code_block_id, "exit_code": -1,
             "error": f"Execution timed out after {config.DOCKER_TIMEOUT_SECONDS} seconds."
        })
        # Schedule the container stop process in the background
        asyncio.create_task(stop_docker_container(code_block_id))

    except ImageNotFound:
        # Handle case where the specified Docker image doesn't exist locally and couldn't be pulled
        error_msg = f"Server Error: Docker image '{image_name}' not found. Please ensure it's pulled or available."
        print(f"ERROR for block {code_block_id}: {error_msg}")
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except APIError as e:
        # Handle errors from the Docker daemon API
        error_msg = f"Server Error: Docker API error: {e}"
        print(f"ERROR for block {code_block_id}: {error_msg}")
        traceback.print_exc() # Print full traceback for server logs
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except Exception as e:
        # Catch any other unexpected errors during setup or execution
        error_msg = f"Server Execution Error: An unexpected error occurred." # Generic message for client
        print(f"ERROR during Docker execution setup or wait for block {code_block_id}: {e}")
        traceback.print_exc() # Print full traceback for server logs
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
        # Ensure stream task is cancelled if it was started before the error
        if stream_task and not stream_task.done():
            print(f"Cancelling stream task for {code_block_id} due to setup/wait error.")
            stop_event.set() # Signal thread to stop
            stream_task.cancel()

    finally:
        # --- Final Cleanup ---
        # This block executes whether the try block succeeded or failed

        # Remove container info from tracking dict if it hasn't been removed already
        async with state.running_containers_lock:
            if code_block_id in state.running_containers:
                print(f"Performing final cleanup check for {code_block_id}")
                # Retrieve task and event references before deleting the entry
                task_to_cancel = state.running_containers[code_block_id].get("stream_task")
                stop_ev = state.running_containers[code_block_id].get("stop_event")
                # Ensure task is stopped and cancelled if still running
                if task_to_cancel and not task_to_cancel.done():
                    print(f"Final cleanup: Cancelling stream task for {code_block_id}")
                    if stop_ev: stop_ev.set() # Signal thread
                    task_to_cancel.cancel()
                # Remove the entry from the tracking dictionary
                del state.running_containers[code_block_id]
                print(f"Removed {code_block_id} from running_containers during final cleanup")

        # Ensure the Docker container is removed
        if container_obj:
            try:
                # Need to run blocking Docker SDK calls in an executor thread
                loop = asyncio.get_running_loop()
                # Check if container still exists before trying to remove
                await loop.run_in_executor(None, container_obj.reload)
                print(f"Removing container {container_obj.short_id} ({code_block_id}) in final cleanup")
                # Force remove the container
                await loop.run_in_executor(None, lambda: container_obj.remove(force=True))
            except NotFound:
                # Container was already removed (e.g., by stop_docker_container)
                 print(f"Container {container_obj.short_id} already removed.")
            except Exception as rm_err:
                # Log error if removal fails for some other reason
                 print(f"Error removing container {container_obj.short_id} in final cleanup: {rm_err}")

        # Clean up the temporary directory
        if tmpdir_obj:
             try:
                 tmpdir_obj.cleanup() # Deletes the temporary directory and its contents
             except Exception as cleanup_err:
                 print(f"Error cleaning up temp directory {tmpdir_obj.name}: {cleanup_err}")


# --- Container Stopping Logic ---

async def stop_docker_container(code_block_id: str):
    """
    Stops a specific running Docker container identified by code_block_id.
    Handles cancelling the log stream task and removing the container.

    Args:
        code_block_id: The identifier of the code block whose container needs stopping.
    """
    print(f"Attempting to stop execution for code block: {code_block_id}")
    loop = asyncio.get_running_loop()
    container_info = None
    container_obj = None
    stream_task = None
    websocket = None
    stop_event = None

    # Safely access and remove the container info from the shared state
    async with state.running_containers_lock:
        if code_block_id in state.running_containers:
            # Pop the entry to prevent race conditions with other stop requests or cleanup
            container_info = state.running_containers.pop(code_block_id)
            container_obj = container_info.get("container")
            stream_task = container_info.get("stream_task")
            websocket = container_info.get("websocket") # Get websocket for final message
            stop_event = container_info.get("stop_event")
            print(f"Found and removed running container info for {code_block_id} from tracking.")
        else:
            # If not found, it might have finished or been stopped already
            print(f"Stop request for {code_block_id}, but it was not found in running_containers.")
            return # Nothing further to do

    # --- Perform actions outside the lock ---

    # 1. Signal the streaming thread to stop and cancel the asyncio task
    if stop_event:
        print(f"Setting stop event for {code_block_id}")
        stop_event.set()
    if stream_task and not stream_task.done():
        print(f"Cancelling stream task for {code_block_id}")
        stream_task.cancel()
        try:
            # Wait briefly for cancellation to be processed
            await asyncio.wait_for(stream_task, timeout=1.0)
        except asyncio.TimeoutError:
            print(f"Stream task for {code_block_id} did not cancel quickly.")
        except asyncio.CancelledError:
            print(f"Stream task for {code_block_id} cancelled successfully.")
            pass # Expected outcome

    # 2. Stop the Docker container (run blocking calls in executor)
    if container_obj:
        try:
            print(f"Stopping container {container_obj.short_id} ({code_block_id})...")
            # container.stop() is blocking
            await loop.run_in_executor(None, lambda: container_obj.stop(timeout=5))
            print(f"Container {container_obj.short_id} stopped.")
        except Exception as stop_err:
            # If stop fails (e.g., timeout), attempt to kill the container
            print(f"Error stopping container {container_obj.short_id}, attempting kill: {stop_err}")
            try:
                # container.kill() is blocking
                await loop.run_in_executor(None, container_obj.kill)
                print(f"Container {container_obj.short_id} killed.")
            except Exception as kill_err:
                # Ignore "No such container" error if already gone, log others
                 if "No such container" not in str(kill_err):
                     print(f"Error killing container {container_obj.short_id}: {kill_err}")

        # 3. Remove the Docker container (run blocking call in executor)
        try:
            print(f"Removing container {container_obj.short_id} ({code_block_id}) after stop request.")
            # container.remove() is blocking
            await loop.run_in_executor(None, lambda: container_obj.remove(force=True))
        except NotFound:
            pass # Container already removed
        except Exception as rm_err:
            print(f"Error removing container {container_obj.short_id} after stop: {rm_err}")

    # 4. Send final "stopped by user" message if WebSocket is still valid
    if websocket: # Check if websocket reference exists
         try:
             await send_ws_message(websocket, "code_finished", {
                 "code_block_id": code_block_id,
                 "exit_code": -1, # Indicate abnormal termination
                 "error": "Execution stopped by user."
             })
         except Exception as send_err:
              print(f"Error sending stop confirmation for {code_block_id}: {send_err}")
    else:
         print(f"Cannot send stop confirmation for {code_block_id}, WebSocket reference lost.")


# --- Client Disconnect Cleanup ---

async def cleanup_client_containers(client_id: str):
    """
    Stops and cleans up all running Docker containers associated with a specific client ID
    when that client disconnects.

    Args:
        client_id: The ID of the client that disconnected.
    """
    print(f"Cleaning up containers for disconnected client: {client_id}")
    containers_to_stop = []
    # Safely get a list of code_block_ids associated with the disconnected client
    async with state.running_containers_lock:
        # List comprehension to find matching client_id
        ids_for_client = [
            cb_id for cb_id, info in state.running_containers.items()
            if info.get("client_id") == client_id
        ]
        containers_to_stop.extend(ids_for_client)

    # Stop each container concurrently using asyncio.gather
    if containers_to_stop:
        print(f"Found containers to stop for client {client_id}: {containers_to_stop}")
        # Create a list of stop tasks
        stop_tasks = [stop_docker_container(cb_id) for cb_id in containers_to_stop]
        # Run tasks concurrently and gather results (including exceptions)
        results = await asyncio.gather(*stop_tasks, return_exceptions=True)
        # Log any errors that occurred during the cleanup stops
        for i, result in enumerate(results):
             if isinstance(result, Exception):
                 print(f"Error during cleanup stop for {containers_to_stop[i]}: {result}")
        print(f"Finished cleanup for client {client_id}")
    else:
        print(f"No running containers found for client {client_id} during cleanup.")



=== app/email_utils.py ===
# app/email_utils.py
from fastapi_mail import FastMail, MessageSchema, ConnectionConfig
from pathlib import Path
import traceback
from . import config # Import your config module

# --- Email Configuration ---
# Create the ConnectionConfig using settings from config.py
# This configuration is used to connect to the email server.
conf = ConnectionConfig(
    MAIL_USERNAME=config.MAIL_CONFIG.get("MAIL_USERNAME"),
    MAIL_PASSWORD=config.MAIL_CONFIG.get("MAIL_PASSWORD"),
    MAIL_FROM=config.MAIL_CONFIG.get("MAIL_FROM"),
    MAIL_PORT=config.MAIL_CONFIG.get("MAIL_PORT", 587), # Default to 587 if not in config
    MAIL_SERVER=config.MAIL_CONFIG.get("MAIL_SERVER"),
    MAIL_FROM_NAME=config.MAIL_CONFIG.get("MAIL_FROM_NAME"),
    MAIL_STARTTLS=config.MAIL_CONFIG.get("MAIL_STARTTLS", True), # Default to True
    MAIL_SSL_TLS=config.MAIL_CONFIG.get("MAIL_SSL_TLS", False),   # Default to False
    USE_CREDENTIALS=config.MAIL_CONFIG.get("USE_CREDENTIALS", True),
    VALIDATE_CERTS=config.MAIL_CONFIG.get("VALIDATE_CERTS", True) # Default to True
)

# Initialize FastMail instance with the configuration
fm = FastMail(conf)

# Define the base path for email templates
# config.APP_DIR should point to the 'app' directory.
EMAIL_TEMPLATES_DIR = config.APP_DIR / "static" / "email_templates"

async def send_registration_password_email(
    recipient_email: str,
    recipient_name: str,
    generated_password: str,
    login_url: str
) -> bool:
    """
    Sends the generated password to a new user using an HTML template.
    The password sent is the user's actual password.
    """
    # Basic check for essential mail server configuration
    if not conf.MAIL_FROM or not conf.MAIL_SERVER:
        print("EMAIL ERROR: Mail configuration (MAIL_FROM, MAIL_SERVER) is incomplete. Cannot send registration password email.")
        return False

    template_path = EMAIL_TEMPLATES_DIR / "registration_email.html"
    subject = "Welcome to Tesseracs Chat - Your Account Details"

    try:
        # Read the HTML template from file
        with open(template_path, "r", encoding="utf-8") as f:
            html_template = f.read()

        # Replace placeholders in the template
        # Ensure all placeholders match those in the HTML template
        html_body = html_template.replace("{{ recipient_name }}", recipient_name)
        html_body = html_body.replace("{{ email }}", recipient_email) # Changed from {{ recipient_email }} for consistency
        html_body = html_body.replace("{{ password }}", generated_password)
        html_body = html_body.replace("{{ login_url }}", login_url)

    except FileNotFoundError:
        print(f"EMAIL ERROR: Registration email template not found at {template_path}")
        return False
    except Exception as e:
        print(f"EMAIL ERROR: Failed to read or process registration email template: {e}")
        traceback.print_exc()
        return False

    # Create the email message schema
    message = MessageSchema(
        subject=subject,
        recipients=[recipient_email],
        body=html_body,
        subtype="html"
    )

    try:
        # Attempt to send the email
        print(f"EMAIL: Attempting to send registration password to {recipient_email} via {conf.MAIL_SERVER}:{conf.MAIL_PORT}")
        await fm.send_message(message)
        print(f"EMAIL: Registration password email successfully sent to {recipient_email}.")
        return True  # Indicate success
    except Exception as e:
        # Log any errors during email sending
        print(f"EMAIL ERROR: Failed to send registration password email to {recipient_email}")
        print(f"EMAIL ERROR DETAILS: {type(e).__name__} - {e}")
        traceback.print_exc()
        return False # Indicate failure

async def send_password_reset_email(
    recipient_email: str,
    recipient_name: str,
    new_password: str,
    login_url: str
) -> bool:
    """
    Sends an email containing a newly generated password after a reset request,
    using an HTML template.
    """
    # Basic check for essential mail server configuration
    if not conf.MAIL_FROM or not conf.MAIL_SERVER:
        print("EMAIL ERROR: Mail configuration (MAIL_FROM, MAIL_SERVER) is incomplete. Cannot send password reset email.")
        return False

    template_path = EMAIL_TEMPLATES_DIR / "password_reset_email.html"
    subject = "Your Tesseracs Chat Password Has Been Reset"

    try:
        # Read the HTML template from file
        with open(template_path, "r", encoding="utf-8") as f:
            html_template = f.read()

        # Replace placeholders in the template
        # Ensure all placeholders match those in the HTML template
        html_body = html_template.replace("{{ recipient_name }}", recipient_name)
        html_body = html_body.replace("{{ email }}", recipient_email) # Changed from {{ recipient_email }} for consistency
        html_body = html_body.replace("{{ password }}", new_password)
        html_body = html_body.replace("{{ login_url }}", login_url)

    except FileNotFoundError:
        print(f"EMAIL ERROR: Password reset email template not found at {template_path}")
        return False
    except Exception as e:
        print(f"EMAIL ERROR: Failed to read or process password reset email template: {e}")
        traceback.print_exc()
        return False

    # Create the email message schema
    message = MessageSchema(
        subject=subject,
        recipients=[recipient_email],
        body=html_body,
        subtype="html"
    )

    try:
        # Attempt to send the email
        print(f"EMAIL: Attempting to send password reset to {recipient_email} via {conf.MAIL_SERVER}:{conf.MAIL_PORT}")
        await fm.send_message(message)
        print(f"EMAIL: Password reset email successfully sent to {recipient_email}.")
        return True # Indicate success
    except Exception as e:
        # Log any errors during email sending
        print(f"EMAIL ERROR: Failed to send password reset email to {recipient_email}")
        print(f"EMAIL ERROR DETAILS: {type(e).__name__} - {e}")
        traceback.print_exc()
        return False # Indicate failure


=== app/encryption_utils.py ===
# app/encryption_utils.py
import os
from cryptography.fernet import Fernet, InvalidToken
# Import config from the current package
from . import config 
from typing import Optional

# Global variable to hold the Fernet instance, initialized once
_fernet_instance: Optional[Fernet] = None

def _get_fernet() -> Fernet:
    """
    Initializes and returns the Fernet instance for encryption/decryption.
    Raises ValueError if APP_SECRET_KEY is not configured or invalid.
    """
    global _fernet_instance
    if _fernet_instance is None:
        if not config.APP_SECRET_KEY:
            print("CRITICAL ERROR: APP_SECRET_KEY is not configured in the environment. "
                  "Cannot perform encryption/decryption of sensitive data.")
            raise ValueError("APP_SECRET_KEY is not configured. Encryption services are unavailable.")
        
        try:
            # APP_SECRET_KEY must be a URL-safe base64-encoded 32-byte key.
            key_bytes = config.APP_SECRET_KEY.encode('utf-8')
            _fernet_instance = Fernet(key_bytes)
            print("Fernet encryption service initialized successfully.")
        except Exception as e:
            # This can happen if the key is not correctly formatted (e.g., wrong length, not base64)
            print(f"CRITICAL ERROR: Failed to initialize Fernet with APP_SECRET_KEY: {e}. "
                  "Ensure APP_SECRET_KEY is a valid Fernet key (URL-safe base64 encoded 32-byte key). "
                  "You can generate one using: python -c \"from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())\"")
            raise ValueError(f"Invalid APP_SECRET_KEY format for Fernet encryption: {e}") from e
            
    return _fernet_instance

def encrypt_data(data: str) -> Optional[str]:
    """
    Encrypts a string using the configured Fernet instance.

    Args:
        data: The string data to encrypt.

    Returns:
        The encrypted string, or None if encryption fails or data is empty.
    """
    if not data:
        return None # Do not encrypt empty strings, return None or empty as per policy
    
    try:
        fernet_cipher = _get_fernet()
        encrypted_bytes = fernet_cipher.encrypt(data.encode('utf-8'))
        return encrypted_bytes.decode('utf-8') # Store the encrypted data as a string
    except ValueError as ve: # Raised by _get_fernet if APP_SECRET_KEY is not set/invalid
        print(f"Encryption failed due to configuration issue: {ve}")
        # Depending on policy, you might re-raise or return a specific error indicator.
        # For now, returning None as the operation could not be completed.
        return None
    except Exception as e:
        print(f"Error during data encryption: {e}")
        # import traceback
        # traceback.print_exc() # Uncomment for detailed stack trace during development
        return None

def decrypt_data(encrypted_data: str) -> Optional[str]:
    """
    Decrypts a string using the configured Fernet instance.

    Args:
        encrypted_data: The encrypted string data.

    Returns:
        The decrypted string, or None if decryption fails (e.g., invalid token, key mismatch, or data corruption)
        or if the input is empty.
    """
    if not encrypted_data:
        return None
    
    try:
        fernet_cipher = _get_fernet()
        decrypted_bytes = fernet_cipher.decrypt(encrypted_data.encode('utf-8'))
        return decrypted_bytes.decode('utf-8')
    except InvalidToken:
        # This is a common error if the token is tampered with, the key is wrong,
        # or the data is not valid Fernet-encrypted data.
        print("Error during data decryption: Invalid token. Data might be corrupted or key mismatch.")
        return None
    except ValueError as ve: # Raised by _get_fernet if APP_SECRET_KEY is not set/invalid
        print(f"Decryption failed due to configuration issue: {ve}")
        return None
    except Exception as e:
        print(f"An unexpected error occurred during data decryption: {e}")
        # import traceback
        # traceback.print_exc() # Uncomment for detailed stack trace during development
        return None

# Example usage (for testing purposes, typically not run directly like this in production)
if __name__ == '__main__':
    # This block will only run if the script is executed directly.
    # It requires APP_SECRET_KEY to be set in the environment or .env file.
    print("Running encryption_utils.py for testing...")
    if not config.APP_SECRET_KEY:
        print("Skipping tests: APP_SECRET_KEY is not set in environment.")
    else:
        try:
            # Ensure Fernet can be initialized
            _get_fernet() 
            print("Fernet instance obtained successfully for testing.")

            original_text = "This is a super secret API key!"
            print(f"Original text: '{original_text}'")

            encrypted = encrypt_data(original_text)
            if encrypted:
                print(f"Encrypted text: '{encrypted}'")
                
                decrypted = decrypt_data(encrypted)
                if decrypted:
                    print(f"Decrypted text: '{decrypted}'")
                    assert original_text == decrypted, "Decryption did not match original!"
                    print("Encryption and decryption test successful!")
                else:
                    print("Decryption FAILED.")
            else:
                print("Encryption FAILED.")
            
            print("\nTesting with empty string:")
            encrypted_empty = encrypt_data("")
            print(f"Encrypting empty string: {encrypted_empty}")
            decrypted_empty_from_none = decrypt_data(None) # type: ignore
            print(f"Decrypting None: {decrypted_empty_from_none}")

            print("\nTesting decryption of invalid token:")
            invalid_decryption = decrypt_data("this_is_not_a_valid_fernet_token")
            print(f"Decrypting invalid token: {invalid_decryption}")

        except ValueError as e:
            print(f"Test failed due to ValueError (likely APP_SECRET_KEY issue): {e}")
        except Exception as e:
            print(f"An unexpected error occurred during testing: {e}")



=== app/main.py ===
# In app/main.py

# Ensure your imports at the top of app/main.py look like this:
import os
import sys
import traceback
from pathlib import Path
import asyncio
import json
import sqlite3
import uuid
from urllib.parse import urlparse
import datetime
from typing import Optional, Dict, Any, List, Union # Ensure List and Union are here if used elsewhere

from fastapi import (
    FastAPI,
    Request,
    HTTPException,
    WebSocket,
    WebSocketDisconnect,
    Form,
    Depends,
    Response as FastAPIResponse, # This is an alias, not the Response class itself for type hinting
    Path as FastApiPath,
    Body,
    status
)
from fastapi.responses import (
    HTMLResponse,
    RedirectResponse,
    JSONResponse,
    FileResponse,
    Response  # *** ADDED Response here ***
)
from fastapi.security import OAuth2PasswordRequestForm
from fastapi.staticfiles import StaticFiles
from fastapi.websockets import WebSocketState

from pydantic import HttpUrl

from fastapi_csrf_protect import CsrfProtect
from fastapi_csrf_protect.exceptions import CsrfProtectError

# Assuming your local modules are imported like this:
from . import config
from . import state
from . import llm
from . import docker_utils
from . import utils
from . import database
from . import auth
from . import email_utils
from . import models
from . import encryption_utils

app = FastAPI(title="Tesseracs Chat CSRF Example")

# CSRF Configuration Loader
@CsrfProtect.load_config
def get_csrf_config():
    loaded_secret_from_config = getattr(config, 'CSRF_PROTECT_SECRET_KEY', None)
    final_csrf_secret = None
    # IMPORTANT: This default fallback secret is INSECURE for production.
    # It MUST be overridden by a strong, unique secret in your environment/config.
    default_fallback_secret = "a_very_secure_fallback_secret_key_must_be_at_least_32_bytes_long_0123456789"

    if isinstance(loaded_secret_from_config, str) and len(loaded_secret_from_config) >= 32:
        final_csrf_secret = loaded_secret_from_config
        print(f"DEBUG CSRF: Using configured CSRF_PROTECT_SECRET_KEY (first 5 chars): '{final_csrf_secret[:5]}...'.")
    else:
        if loaded_secret_from_config is None:
            print("WARNING CSRF: CSRF_PROTECT_SECRET_KEY not found in config. Using a placeholder DEMO secret key. THIS IS INSECURE FOR PRODUCTION.")
        elif not isinstance(loaded_secret_from_config, str):
            print(f"CRITICAL CSRF ERROR: CSRF_PROTECT_SECRET_KEY from config is not a string (type: {type(loaded_secret_from_config).__name__}). Using placeholder. THIS IS INSECURE FOR PRODUCTION.")
        elif len(loaded_secret_from_config) < 32:
            print(f"WARNING CSRF: CSRF_PROTECT_SECRET_KEY from config is too short (length: {len(loaded_secret_from_config)}, requires >=32). Using placeholder. THIS IS INSECURE FOR PRODUCTION.")
        final_csrf_secret = default_fallback_secret
        print(f"WARNING CSRF: Using placeholder DEMO secret key (first 5 chars): '{final_csrf_secret[:5]}...'. Ensure CSRF_PROTECT_SECRET_KEY is correctly set and is at least 32 bytes long in your production environment/config.")
    
    print("CSRF CONFIG: Using list-based configuration to explicitly set all parameters.")
    return [
        ("secret_key", final_csrf_secret),
        ("cookie_key", "fastapi-csrf-token"),      # Name of the CSRF token cookie
        ("header_name", "X-CSRF-Token"),          # Name of the CSRF token header for AJAX
        ("httponly", True),                      # CSRF cookie should be HttpOnly
    ]

# CSRF Exception Handler
@app.exception_handler(CsrfProtectError)
async def csrf_protect_exception_handler(request: Request, exc: CsrfProtectError):
    print(f"---- CSRF EXCEPTION HANDLER: Caught CsrfProtectError ----")
    print(f"---- CSRF EXCEPTION HANDLER: Request URL: {request.url}")
    print(f"---- CSRF EXCEPTION HANDLER: Request Method: {request.method}")
    print(f"---- CSRF EXCEPTION HANDLER: Exception message: {exc.message}") 
    print(f"---- CSRF EXCEPTION HANDLER: Exception status code: {exc.status_code}")
    relevant_headers = {
        "content-type": request.headers.get("content-type"),
        "x-csrf-token": request.headers.get("x-csrf-token"), 
        "referer": request.headers.get("referer"),
    }
    print(f"---- CSRF EXCEPTION HANDLER: Relevant Request Headers: {relevant_headers}")
    try:
        form_data = await request.form()
        print(f"---- CSRF EXCEPTION HANDLER: Form Data at time of exception: {dict(form_data)}")
    except Exception as e_form_log:
        print(f"---- CSRF EXCEPTION HANDLER: Could not log form data at time of exception: {e_form_log}")

    return JSONResponse(
        status_code=exc.status_code, 
        content={"detail": exc.message if exc.message else "CSRF Validation Failed"}
    )
# Helper function to serve HTML files with CSRF token injection for JavaScript
async def serve_html_with_csrf(
    file_path: Path,
    request: Request,
    csrf_protect: CsrfProtect,
    replacements: Optional[Dict[str, str]] = None
) -> HTMLResponse:
    if not file_path.is_file():
        print(f"---- SERVER LOG: HTML SERVER - CRITICAL ERROR: HTML file not found at '{file_path}'")
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Resource {file_path.name} not found.")

    html_content_original = ""
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            html_content_original = f.read()
        print(f"---- SERVER LOG: HTML SERVER - '{file_path.name}' content (length: {len(html_content_original)}) read successfully.")
    except Exception as e:
        print(f"---- SERVER LOG: HTML SERVER - ERROR reading '{file_path.name}': {e}")
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Error loading content for {file_path.name}.")

    _raw_token_csrf, signed_token_for_cookie = csrf_protect.generate_csrf_tokens()
    if not _raw_token_csrf or not signed_token_for_cookie:
        print(f"---- SERVER LOG: HTML SERVER ('{file_path.name}') - CRITICAL ERROR: Failed to generate CSRF tokens.")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="CSRF token generation failed on server.")

    print(f"---- SERVER LOG: HTML SERVER ('{file_path.name}') - Raw CSRF token generated for JS: '{_raw_token_csrf[:10]}...'")

    html_content_processed = html_content_original
    
    # Standard CSRF token replacement for JavaScript variable `window.csrfTokenRaw`
    csrf_placeholder = "%%CSRF_TOKEN_RAW%%"
    if csrf_placeholder in html_content_processed:
        html_content_processed = html_content_processed.replace(csrf_placeholder, _raw_token_csrf)
        if csrf_placeholder in html_content_processed: # Check if replacement failed
             print(f"---- SERVER LOG: HTML SERVER ('{file_path.name}') - CRITICAL FAILURE: Placeholder '{csrf_placeholder}' replacement had no effect. Token: '{_raw_token_csrf}'.")
        else:
            print(f"---- SERVER LOG: HTML SERVER ('{file_path.name}') - SUCCESS: Placeholder '{csrf_placeholder}' replaced for JS.")
    else:
        print(f"---- SERVER LOG: HTML SERVER ('{file_path.name}') - INFO: Placeholder '{csrf_placeholder}' NOT FOUND in HTML. Token not directly injected for 'window.csrfTokenRaw'.")

    # Apply additional dynamic replacements if any
    if replacements:
        for key, value in replacements.items():
            if key in html_content_processed:
                html_content_processed = html_content_processed.replace(key, str(value)) # Ensure value is string
                print(f"---- SERVER LOG: HTML SERVER ('{file_path.name}') - Replaced placeholder '{key}'.")
            else:
                print(f"---- SERVER LOG: HTML SERVER ('{file_path.name}') - INFO: Additional placeholder '{key}' not found.")

    response = HTMLResponse(content=html_content_processed)
    try:
        csrf_protect.set_csrf_cookie(response=response, csrf_signed_token=signed_token_for_cookie)
        print(f"---- SERVER LOG: HTML SERVER ('{file_path.name}') - CSRF cookie set in response.")
    except Exception as e:
        print(f"---- SERVER LOG: HTML SERVER ('{file_path.name}') - ERROR during CSRF cookie setting: {e}")
        traceback.print_exc()
        # Not raising HTTPException here as content is ready, but cookie setting failed. Client might still work if old cookie is valid.

    return response

# --- Authentication & Page Routes ---

@app.get("/login", response_class=HTMLResponse, name="get_login_page_route", tags=["Pages"])
async def get_login_page_route(
    request: Request,
    # CRITICAL: This route MUST use `auth.get_current_user` for OPTIONAL authentication.
    # This allows unauthenticated users (like new users) to access the login page.
    # `auth.get_current_user` returns the user dict if authenticated, or None otherwise,
    # and importantly, it does NOT raise an HTTPException if the user is not authenticated.
    user: Optional[Dict[str, Any]] = Depends(auth.get_current_user), 
    csrf_protect: CsrfProtect = Depends() # Ensure CsrfProtect is correctly imported
) -> Response: # MODIFIED: Changed return type hint to Response
    """
    Serves the login page.
    If the user is already authenticated, it redirects them to the session choice page.
    Otherwise, it displays the login form.
    """
    print("---- SERVER LOG: GET /login - Route entered ----")
    
    # Log the state of the user object obtained from the optional dependency.
    # For a new, unauthenticated user, 'user' should be None here.
    if user is None:
        print("---- SERVER LOG: GET /login - `auth.get_current_user` returned None (User is not authenticated). This is expected for new users.")
    else:
        print(f"---- SERVER LOG: GET /login - `auth.get_current_user` returned a user object. Email: '{user.get('email')}'.")

    if user:
        # User is already authenticated (auth.get_current_user returned user data).
        # Redirect them away from the login page.
        print(f"---- SERVER LOG: GET /login - User '{user.get('email')}' already authenticated. Redirecting to session choice page...")
        try:
            # Ensure you have a route named 'get_session_choice_page'
            # This name should match the 'name' parameter in the @app.get("/") decorator for your session choice page.
            session_choice_url = request.url_for("get_session_choice_page")
        except Exception as e:
            # Fallback if the named route isn't found (should not happen in a well-configured app)
            print(f"---- SERVER LOG: GET /login - CRITICAL ERROR: Could not find route named 'get_session_choice_page'. Defaulting to '/'. Error: {e}")
            session_choice_url = "/" 
        return RedirectResponse(url=str(session_choice_url), status_code=status.HTTP_302_FOUND)

    # If 'user' is None, the user is not authenticated. Proceed to show the login page.
    print("---- SERVER LOG: GET /login - Proceeding to serve login page for unauthenticated user.")
    
    # Ensure config.STATIC_DIR is correctly defined and points to your static files directory
    if not config.STATIC_DIR or not (config.STATIC_DIR / "login.html").is_file():
        print(f"---- SERVER LOG: GET /login - CRITICAL ERROR: login.html not found at {config.STATIC_DIR / 'login.html' if config.STATIC_DIR else 'configured STATIC_DIR'}.")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Login page resource is missing on the server.")
        
    login_html_path = config.STATIC_DIR / "login.html"
    
    # Assuming serve_html_with_csrf is your helper function to read HTML, inject CSRF, and set cookies
    # serve_html_with_csrf should return an HTMLResponse
    html_response_content = await serve_html_with_csrf(login_html_path, request, csrf_protect)
    return html_response_content # This is already an HTMLResponse



@app.get("/", response_class=HTMLResponse, name="get_session_choice_page", tags=["Pages"])
async def get_session_choice_page_route( # Renamed function to avoid conflict if you had another
    request: Request,
    # Use the OPTIONAL user dependency here
    user: Optional[Dict[str, Any]] = Depends(auth.get_current_user),
    csrf_protect: CsrfProtect = Depends()
) -> Response: # Can return HTMLResponse or RedirectResponse
    """
    Serves the session choice page if the user is authenticated.
    If the user is not authenticated, redirects them to the login page.
    """
    print("---- SERVER LOG: GET / (get_session_choice_page) - Route entered ----")

    if user is None:
        # User is not authenticated, redirect to the login page.
        print("---- SERVER LOG: GET / (get_session_choice_page) - User not authenticated. Redirecting to /login.")
        try:
            login_url = request.url_for("get_login_page_route")
        except Exception as e:
            print(f"---- SERVER LOG: GET / (get_session_choice_page) - CRITICAL ERROR: Could not find route named 'get_login_page_route'. Defaulting to '/login'. Error: {e}")
            login_url = "/login" # Fallback
        return RedirectResponse(url=str(login_url), status_code=status.HTTP_302_FOUND)

    # User is authenticated, proceed to show the session choice page.
    print(f"---- SERVER LOG: GET / (get_session_choice_page) - User '{user.get('email')}' authenticated. Serving session-choice page.")
    
    if not config.STATIC_DIR or not (config.STATIC_DIR / "session-choice.html").is_file():
        print(f"---- SERVER LOG: GET / (get_session_choice_page) - CRITICAL ERROR: session-choice.html not found.")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Session choice page resource is missing.")
        
    session_choice_html_path = config.STATIC_DIR / "session-choice.html"
    replacements = {"[User Name]": user.get("name", "User")} # Ensure this placeholder exists in session-choice.html
    
    # Assuming serve_html_with_csrf is your helper function
    return await serve_html_with_csrf(session_choice_html_path, request, csrf_protect, replacements=replacements)

@app.get("/chat/{session_id}", response_class=HTMLResponse, name="get_chat_page_for_session", tags=["Pages"])
async def get_chat_page_for_session(
    request: Request,
    session_id: str = FastApiPath(..., description="The ID of the chat session to load."),
    user: Dict[str, Any] = Depends(auth.get_current_active_user), # Ensure this is the correct auth dependency
    csrf_protect: CsrfProtect = Depends()
):
    print(f"---- SERVER LOG: GET /chat/{session_id} - Route entered ----")
    if not user: # Should be handled by Depends
        print(f"---- SERVER LOG: GET /chat/{session_id} - No active user, redirecting to login.")
        # Ensure get_login_page_route is correctly named if you use url_for
        login_url = request.url_for("get_login_page_route") if "get_login_page_route" in request.app.router.routes else "/login"
        return RedirectResponse(url=str(login_url), status_code=status.HTTP_302_FOUND)

    user_id = user['id']
    session_name_for_html = "Chat Session" # Default name
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        
        # Fetch session details
        cursor.execute("SELECT id, name FROM sessions WHERE id = ? AND is_active = 1", (session_id,))
        session_row = cursor.fetchone()
        
        if not session_row:
            print(f"---- SERVER LOG: GET /chat/{session_id} - Session not found or inactive.")
            raise HTTPException(status_code=404, detail="Chat session not found or is inactive.")
        
        session_name_for_html = session_row["name"] # This is your "May 16, 2025..." string

        # Verify user has access to this session
        cursor.execute("SELECT 1 FROM session_participants WHERE session_id = ? AND user_id = ?", (session_id, user_id))
        if not cursor.fetchone():
            print(f"---- SERVER LOG: GET /chat/{session_id} - User {user_id} lacks access.")
            raise HTTPException(status_code=403, detail="You do not have access to this chat session.")

        # Update last_accessed_at for the session
        current_time_utc_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        cursor.execute("UPDATE sessions SET last_accessed_at = ? WHERE id = ?", (current_time_utc_iso, session_id))
        conn.commit()
        print(f"---- SERVER LOG: GET /chat/{session_id} - Access granted for user {user_id}. Session last_accessed_at updated.")

    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc() # It's good to have traceback for unexpected errors
        raise HTTPException(status_code=500, detail="Error verifying session access for chat page.")
    finally:
        if conn: conn.close()

    chat_html_path = config.STATIC_DIR / "chat-session.html"
    if not chat_html_path.is_file():
        print(f"---- SERVER LOG: GET /chat/{session_id} - CRITICAL ERROR: chat-session.html not found at {chat_html_path}")
        raise HTTPException(status_code=500, detail="Chat page resource is missing on the server.")

    # *** CORRECTED REPLACEMENTS ***
    # Define a specific placeholder that you will use in your chat-session.html
    # For example, let's use "%%SESSION_NAME_PLACEHOLDER%%"
    replacements = {
        "%%SESSION_NAME_PLACEHOLDER%%": utils.escape_html(session_name_for_html)
    }
    
    return await serve_html_with_csrf(chat_html_path, request, csrf_protect, replacements=replacements)


@app.get("/settings", response_class=HTMLResponse, name="get_settings_page", tags=["Pages"])
async def get_settings_page(
    request: Request,
    user: Dict[str, Any] = Depends(auth.get_current_active_user),
    csrf_protect: CsrfProtect = Depends()
):
    print("---- SERVER LOG: GET /settings - Route entered ----")
    if not user: # Should be caught by Depends(auth.get_current_active_user)
        print("---- SERVER LOG: GET /settings - No active user, redirecting to login (unexpected).")
        login_url = request.url_for("get_login_page_route")
        return RedirectResponse(url=str(login_url), status_code=status.HTTP_302_FOUND)

    settings_html_path = config.STATIC_DIR / "settings.html"
    # Add any specific replacements for settings.html if needed
    # e.g. replacements = {"": utils.escape_html(user.get("email", ""))}
    return await serve_html_with_csrf(settings_html_path, request, csrf_protect) # Add replacements if any

@app.post("/check_email", response_model=models.EmailCheckResponse, tags=["Authentication"])
async def check_email_exists_route(
    request: Request,
    request_data: models.EmailCheckRequest,
    csrf_protect: CsrfProtect = Depends()
):
    print(f"---- SERVER LOG: POST /check_email - Route entered for email: {request_data.email} ----")
    # CSRF token is expected in the X-CSRF-Token header for AJAX by default
    await csrf_protect.validate_csrf(request)
    print(f"---- SERVER LOG: POST /check_email - CSRF validation PASSED for email: {request_data.email} ----")

    email_to_check = request_data.email.lower().strip()
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM users WHERE email = ? AND is_active = 1", (email_to_check,))
        user_row = cursor.fetchone()
        if user_row:
            user_name = user_row["name"]
            return models.EmailCheckResponse(exists=True, user_name=user_name)
        else:
            return models.EmailCheckResponse(exists=False, user_name=None)
    except sqlite3.Error as e:
        print(f"---- SERVER LOG: POST /check_email - Database error: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error checking email.")
    except Exception as e:
        print(f"---- SERVER LOG: POST /check_email - Unexpected error: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Unexpected error checking email.")
    finally:
        if conn: conn.close()

@app.post("/token", response_model=models.Token, tags=["Authentication"])
async def login_for_access_token(
    request: Request,
    response: FastAPIResponse,
    form_data: OAuth2PasswordRequestForm = Depends(),
    csrf_protect: CsrfProtect = Depends()
):
    print("---- SERVER LOG: POST /token - Route entered ----")
    # For form submissions, fastapi-csrf-protect checks the form field "csrf_token" by default.
    await csrf_protect.validate_csrf(request)
    print("---- SERVER LOG: POST /token - CSRF validation PASSED ----")

    email = form_data.username.lower().strip()
    password = form_data.password
    conn = None
    print(f"---- SERVER LOG: POST /token - Attempting login for email: {email}")
    try:
        conn = database.get_db_connection()
        user_dict = auth.authenticate_user_from_db(conn, email, password) # Refactored to auth module potentially
        if not user_dict: # Covers user not found or password mismatch
            print(f"---- SERVER LOG: POST /token - Authentication failed for email: {email}")
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect email or password.")
        
        if not user_dict["is_active"]:
            print(f"---- SERVER LOG: POST /token - Login FAILED: Account inactive for email: {email}")
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Account is inactive.")
        
        print(f"---- SERVER LOG: POST /token - Login SUCCESSFUL for user ID: {user_dict['id']}. Creating session...")
        session_token_raw = await auth.create_user_session(response=response, user_id=user_dict["id"]) # Sets session cookie
        
        # After successful login, new CSRF tokens should be set on the response for the new authenticated context.
        _raw_token_new, signed_token_for_cookie_new = csrf_protect.generate_csrf_tokens()
        csrf_protect.set_csrf_cookie(response=response, csrf_signed_token=signed_token_for_cookie_new)
        print(f"---- SERVER LOG: POST /token - New CSRF cookie set in response. Raw part of new token: {_raw_token_new[:10]}...")
        
        return models.Token(
            access_token=session_token_raw, 
            token_type="bearer", # This is for API access, session cookie is for browser
            user_id=user_dict["id"], 
            user_name=user_dict["name"], 
            user_email=user_dict["email"]
            # The client JS after login will typically redirect or refresh,
            # and the new page served via serve_html_with_csrf will get its %%CSRF_TOKEN_RAW%%
        )
    except HTTPException as http_exc:
        raise http_exc # Re-raise known HTTP exceptions
    except sqlite3.Error as db_err:
        print(f"---- SERVER LOG: POST /token - Database error for {email}: {db_err}")
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error during login process.")
    except Exception as e:
        print(f"---- SERVER LOG: POST /token - Unexpected server error during login for {email}: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Unexpected server error during login.")
    finally:
        if conn: conn.close()

@app.post("/sessions/create", status_code=status.HTTP_303_SEE_OTHER, tags=["Sessions"])
async def create_new_session_route(
    request: Request, 
    user: Dict[str, Any] = Depends(auth.get_current_active_user),
    csrf_protect: CsrfProtect = Depends()
):
    print("---- SERVER LOG: POST /sessions/create - Route entered ----")

    # Let CsrfProtect handle reading the form data internally.
    # With csrf_form_field_name explicitly set in config, it should prioritize this.
    try:
        await csrf_protect.validate_csrf(request)
        print("---- SERVER LOG: POST /sessions/create - CSRF validation PASSED ----")
    except CsrfProtectError as e_csrf: 
        print(f"---- SERVER LOG: POST /sessions/create - CSRF validation FAILED (CsrfProtectError). Message: {e_csrf.message}")
        raise 
    except Exception as e_csrf_val: 
        print(f"---- SERVER LOG: POST /sessions/create - CSRF validation FAILED (Unexpected Exception). Error type: {type(e_csrf_val).__name__}, Message: {e_csrf_val}")
        traceback.print_exc() 
        raise 

    if not user: 
        print("---- SERVER LOG: POST /sessions/create - User not authenticated (should have been caught by Depends).")
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated for session creation.")

    new_session_id = str(uuid.uuid4())
    host_user_id = user["id"]
    conn = None
    default_session_name = ""
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute(
            """INSERT INTO sessions (id, host_user_id, name, is_active, created_at, last_accessed_at) 
               VALUES (?, ?, ?, ?, datetime('now', 'utc'), datetime('now', 'utc'))""",
            (new_session_id, host_user_id, None, True) 
        )
        cursor.execute("SELECT created_at FROM sessions WHERE id = ?", (new_session_id,))
        session_row = cursor.fetchone()
        
        if not session_row or not session_row["created_at"]:
            default_session_name = f"Session ({new_session_id[:4]})"
            print(f"---- SERVER LOG: POST /sessions/create - Warning: Could not retrieve created_at for session {new_session_id}. Using fallback name: {default_session_name}")
        else:
            try:
                created_at_str = session_row["created_at"]
                if isinstance(created_at_str, str):
                     created_at_str = created_at_str.replace('Z', '+00:00') 
                created_dt = datetime.datetime.fromisoformat(created_at_str)
                if created_dt.tzinfo is None: 
                    created_dt = created_dt.replace(tzinfo=datetime.timezone.utc)
                default_session_name = created_dt.strftime("%b %d, %Y %I:%M %p UTC")
            except (ValueError, TypeError) as parse_err:
                print(f"---- SERVER LOG: POST /sessions/create - Error parsing created_at '{session_row['created_at']}': {parse_err}. Using fallback name.")
                default_session_name = f"Session ({new_session_id[:4]})"
        
        cursor.execute("UPDATE sessions SET name = ? WHERE id = ?", (default_session_name, new_session_id))
        
        cursor.execute(
            "INSERT INTO session_participants (session_id, user_id) VALUES (?, ?)",
            (new_session_id, host_user_id)
        )
        conn.commit()
        print(f"---- SERVER LOG: POST /sessions/create - New session '{new_session_id}' ('{default_session_name}') created by user '{host_user_id}'.")
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error: Could not create new session.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Server error: Could not create new session.")
    finally:
        if conn: conn.close()
    
    try:
        chat_url = request.url_for("get_chat_page_for_session", session_id=new_session_id)
    except Exception as url_for_err:
        print(f"---- SERVER LOG: POST /sessions/create - Error generating URL for 'get_chat_page_for_session': {url_for_err}. Defaulting redirect.")
        chat_url = f"/chat/{new_session_id}" 

    response = RedirectResponse(url=str(chat_url), status_code=status.HTTP_303_SEE_OTHER)
    return response




@app.post("/register", response_model=models.RegistrationResponse, tags=["Authentication"])
async def register_new_user(
    request_data: models.RegistrationRequest,
    request: Request,
    csrf_protect: CsrfProtect = Depends()
):
    print(f"---- SERVER LOG: POST /register - Attempting registration for email: {request_data.email} ----")
    await csrf_protect.validate_csrf(request) # Expects X-CSRF-Token for JSON request
    print(f"---- SERVER LOG: POST /register - CSRF validation PASSED for email: {request_data.email} ----")

    email = request_data.email.lower().strip()
    name = request_data.name.strip()

    if not name:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Name cannot be empty.")
    if not utils.is_valid_email(email): # Assuming utils.is_valid_email exists
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid email format.")

    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT id FROM users WHERE email = ?", (email,))
        if cursor.fetchone():
            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="This email address is already registered.")
        
        plain_password = database.generate_secure_token(12) # Or from config.PASSWORD_LENGTH
        hashed_password = auth.get_password_hash(plain_password)
        
        cursor.execute(
            "INSERT INTO users (name, email, password_hash, is_active, created_at, updated_at) VALUES (?, ?, ?, ?, datetime('now'), datetime('now'))",
            (name, email, hashed_password, True) # is_active usually True on registration
        )
        user_id = cursor.lastrowid
        if not user_id: # Should not happen if insert is successful and table has autoincrement PK
            conn.rollback()
            print(f"---- SERVER LOG: POST /register - CRITICAL: Failed to get lastrowid after user insertion for {email}.")
            raise sqlite3.Error("User insertion failed to return an ID.")

        login_url_from_fastapi = str(request.url_for('get_login_page_route'))
        # Construct a robust login_page_url
        parsed_base_url = urlparse(config.BASE_URL)
        parsed_login_route_url = urlparse(login_url_from_fastapi)
        login_page_url = parsed_base_url._replace(path=parsed_login_route_url.path, query=parsed_login_route_url.query, fragment=parsed_login_route_url.fragment).geturl()
        
        email_sent = await email_utils.send_registration_password_email(
            recipient_email=email, recipient_name=name, generated_password=plain_password, login_url=login_page_url
        )
        
        if not email_sent:
            # Account is created, but email failed. This is a critical issue for user experience.
            # Log this error clearly.
            # Commit user creation but inform about email failure.
            conn.commit() # Commit the user anway
            print(f"---- SERVER LOG: POST /register - User '{email}' registered (ID: {user_id}), BUT FAILED to send password email.")
            raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail="Account created, but there was an issue sending your password email. Please try the 'Forgot Password' option or contact support.")
        
        conn.commit()
        print(f"---- SERVER LOG: POST /register - User '{email}' (ID: {user_id}) registered successfully. Password email sent.")
        return models.RegistrationResponse(message="Account created successfully! Your password has been sent to your email address.")

    except HTTPException as http_exc: # Re-raise known HTTP exceptions
        if conn: conn.rollback() # Ensure rollback on handled errors too
        raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="A database error occurred during registration.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred during registration.")
    finally:
        if conn: conn.close()

@app.post("/forgot_password", response_model=models.ForgotPasswordResponse, tags=["Authentication"])
async def handle_forgot_password(
    request_data: models.ForgotPasswordRequest,
    request: Request,
    csrf_protect: CsrfProtect = Depends()
):
    print(f"---- SERVER LOG: POST /forgot_password - Request for email: {request_data.email} ----")
    await csrf_protect.validate_csrf(request) # Expects X-CSRF-Token for JSON
    print(f"---- SERVER LOG: POST /forgot_password - CSRF validation PASSED for email: {request_data.email} ----")

    email = request_data.email.lower().strip()
    if not utils.is_valid_email(email): # Assuming utils.is_valid_email
        # Still return generic message to prevent email enumeration
        return models.ForgotPasswordResponse(message="If an account with this email exists and is active, a password reset email has been sent.")

    client_ip = request.client.host if request.client else "unknown_ip"
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()

        # Always log the attempt for auditing and rate limiting analysis
        cursor.execute(
            "INSERT INTO password_reset_attempts (email, ip_address, attempted_at) VALUES (?, ?, datetime('now'))",
            (email, client_ip)
        )
        # Don't commit yet, commit at the end of successful operations or before returning generic message

        # Rate limiting check (after logging the current attempt)
        time_window_start = datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(hours=config.FORGOT_PASSWORD_ATTEMPT_WINDOW_HOURS)
        cursor.execute(
            "SELECT COUNT(*) FROM password_reset_attempts WHERE email = ? AND attempted_at >= ?",
            (email, time_window_start.isoformat())
        )
        attempt_count_row = cursor.fetchone()
        recent_attempts = attempt_count_row[0] if attempt_count_row else 0

        if recent_attempts > config.FORGOT_PASSWORD_ATTEMPT_LIMIT: # Use > because current attempt is already logged
            conn.commit() # Commit the logged attempt
            print(f"---- SERVER LOG: POST /forgot_password - Rate limit exceeded for {email}. Attempts: {recent_attempts}.")
            return models.ForgotPasswordResponse(message="If an account with this email exists and is active, a password reset email has been sent.")

        cursor.execute("SELECT id, name FROM users WHERE email = ? AND is_active = 1", (email,))
        user_row = cursor.fetchone()

        if not user_row:
            conn.commit() # Commit the logged attempt
            print(f"---- SERVER LOG: POST /forgot_password - No active user found for {email}.")
            return models.ForgotPasswordResponse(message="If an account with this email exists and is active, a password reset email has been sent.")

        user_dict = dict(user_row)
        user_id = user_dict["id"]
        user_name = user_dict["name"]

        new_plain_password = database.generate_secure_token(12)
        new_hashed_password = auth.get_password_hash(new_plain_password)

        cursor.execute("UPDATE users SET password_hash = ?, updated_at = datetime('now') WHERE id = ?", (new_hashed_password, user_id))
        if cursor.rowcount == 0: # Should not happen if user_row was found
            conn.rollback() # Rollback the attempt log as well if this fails
            print(f"---- SERVER LOG: POST /forgot_password - ERROR: Failed to update password hash for user {email} (ID: {user_id}) though user was found.")
            # Return generic message, but this is a server issue.
            return models.ForgotPasswordResponse(message="If an account with this email exists and is active, a password reset email has been sent.")

        login_url_from_fastapi = str(request.url_for('get_login_page_route'))
        parsed_base_url = urlparse(config.BASE_URL)
        parsed_login_route_url = urlparse(login_url_from_fastapi)
        login_page_url = parsed_base_url._replace(path=parsed_login_route_url.path, query=parsed_login_route_url.query, fragment=parsed_login_route_url.fragment).geturl()
        
        email_sent = await email_utils.send_password_reset_email(
            recipient_email=email, recipient_name=user_name, new_password=new_plain_password, login_url=login_page_url
        )

        if not email_sent:
            conn.rollback() # Rollback password change AND the attempt log if email fails critically
            print(f"---- SERVER LOG: POST /forgot_password - Password for {email} was reset in DB, but email sending FAILED. Transaction rolled back.")
            # Still return generic message to the user.
            return models.ForgotPasswordResponse(message="If an account with this email exists and is active, a password reset email has been sent.")
            # Server-side, this might be a 502 error if you want to be more explicit about failure.

        conn.commit() # Commit password change and the successful attempt log
        print(f"---- SERVER LOG: POST /forgot_password - Password reset email successfully sent for user {email} (ID: {user_id}).")
        return models.ForgotPasswordResponse(message="If an account with this email exists and is active, a password reset email has been sent.")

    except sqlite3.Error as db_err:
        if conn: conn.rollback() # Rollback any partial changes
        traceback.print_exc()
        print(f"---- SERVER LOG: POST /forgot_password - Database error for {email}: {db_err}")
        # Return generic message to prevent leaking information
        return models.ForgotPasswordResponse(message="An error occurred while processing your request. Please try again.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        print(f"---- SERVER LOG: POST /forgot_password - Unexpected error for {email}: {e}")
        return models.ForgotPasswordResponse(message="An unexpected error occurred. Please try again.")
    finally:
        if conn: conn.close()


# --- User Account Management API Routes (/api/me/*) ---
# These routes can be called by client-side JavaScript using fetch (likely with Bearer token)
# OR from a settings page form (potentially with session cookie + CSRF token).
# The `auth.get_current_active_user` dependency handles Bearer token auth primarily.
# We add `csrf_protect` and a check to enforce CSRF if not a Bearer call.

async def _ensure_csrf_for_cookie_auth(request: Request, csrf_protect: CsrfProtect):
    """Helper to validate CSRF if the request is not using Bearer token auth."""
    auth_header = request.headers.get("authorization")
    is_bearer_auth = auth_header and auth_header.lower().startswith("bearer ")
    if not is_bearer_auth:
        print(f"---- CSRF CHECK: Path '{request.url.path}' is not Bearer auth, validating CSRF token.")
        await csrf_protect.validate_csrf(request)
        print(f"---- CSRF CHECK: Path '{request.url.path}' CSRF token validated for cookie-based request.")
    else:
        print(f"---- CSRF CHECK: Path '{request.url.path}' is Bearer auth, skipping CSRF token validation.")


@app.put("/api/me/llm-settings", response_model=models.UserLLMSettingsResponse, tags=["User Account Management", "LLM Configuration"])
async def update_user_llm_settings(
    request: Request,
    settings_update: models.UserLLMSettingsUpdateRequest,
    current_user: Dict[str, Any] = Depends(auth.get_current_active_user), # Handles Bearer token
    csrf_protect: CsrfProtect = Depends() # For CSRF validation if not Bearer
):
    await _ensure_csrf_for_cookie_auth(request, csrf_protect)
    user_id = current_user["id"]
    conn = None

    # Validate provider and model IDs against config
    if settings_update.selected_llm_provider_id:
        provider_config_info = config.LLM_PROVIDERS.get(settings_update.selected_llm_provider_id)
        if not provider_config_info:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"Invalid provider ID: {settings_update.selected_llm_provider_id}")
        
        available_models_for_provider = provider_config_info.get("available_models", [])
        if settings_update.selected_llm_model_id:
            model_found = any(
                model.get("model_id") == settings_update.selected_llm_model_id
                for model in available_models_for_provider
            )
            if not model_found:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Model ID '{settings_update.selected_llm_model_id}' not found or not valid for provider '{settings_update.selected_llm_provider_id}'."
                )
        elif available_models_for_provider: # Provider has models, but none selected in update
             # If a provider is selected that has defined models, a model must also be selected.
             # If the user intends to clear the model, they should also clear the provider or select a provider with no predefined models.
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"A model ID must be selected for provider '{settings_update.selected_llm_provider_id}'.")

    encrypted_api_key_to_store: Optional[str] = None
    if settings_update.user_llm_api_key is not None: # Field is present in the request
        if settings_update.user_llm_api_key == "": # User explicitly wants to clear the key
            encrypted_api_key_to_store = None
        else:
            if not config.APP_SECRET_KEY:
                print("CRITICAL ERROR: APP_SECRET_KEY is not set. Cannot encrypt user API key.")
                raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Server configuration error: API key encryption service is unavailable.")
            encrypted_api_key_to_store = encryption_utils.encrypt_data(settings_update.user_llm_api_key)
            if not encrypted_api_key_to_store: # Should only happen if encryption fails unexpectedly
                raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to secure API key.")
    
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            "SELECT selected_llm_provider_id, selected_llm_model_id, user_llm_api_key_encrypted, selected_llm_base_url FROM users WHERE id = ?",
            (user_id,)
        )
        current_db_settings = cursor.fetchone()
        if not current_db_settings: # Should not happen for an active authenticated user
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User settings record not found.")

        # Determine final values: if a field is in settings_update, use it; otherwise, keep DB value.
        final_provider_id = settings_update.selected_llm_provider_id if settings_update.selected_llm_provider_id is not None else current_db_settings["selected_llm_provider_id"]
        final_model_id = settings_update.selected_llm_model_id if settings_update.selected_llm_model_id is not None else current_db_settings["selected_llm_model_id"]
        
        if settings_update.user_llm_api_key is not None: # API key was part of the update request
            final_api_key_encrypted = encrypted_api_key_to_store
        else: # API key was not in the update request, keep existing
            final_api_key_encrypted = current_db_settings["user_llm_api_key_encrypted"]

        final_base_url_str: Optional[str] = None
        if settings_update.selected_llm_base_url is not None: # Base URL was part of the update
            if not settings_update.selected_llm_base_url: # Explicitly empty (e.g., empty string from form)
                final_base_url_str = None
            else:
                final_base_url_str = str(settings_update.selected_llm_base_url) # Convert HttpUrl to string
        else: # Base URL not in update, keep existing
            final_base_url_str = current_db_settings["selected_llm_base_url"]

        # Logic to clear dependent fields if provider is cleared or fundamentally changed
        if final_provider_id is None:
            final_model_id = None
            final_api_key_encrypted = None # Clearing provider implies clearing user-specific key for it
            final_base_url_str = None    # Clearing provider implies clearing user-specific base URL
        elif final_provider_id != current_db_settings["selected_llm_provider_id"]:
            # If provider changed, re-evaluate if existing API key/base URL are still relevant
            # For simplicity here, if provider changes, and user didn't explicitly send new key/URL,
            # we might clear them if the new provider type suggests it (e.g. ollama often doesn't need user key).
            # This logic can be more nuanced based on provider types.
            new_provider_config_details = config.get_provider_config(final_provider_id)
            if new_provider_config_details and new_provider_config_details.get("type") == "ollama":
                if settings_update.user_llm_api_key is None: # If user didn't send a new key for ollama
                    final_api_key_encrypted = None
                if settings_update.selected_llm_base_url is None: # If user didn't send a new base_url for ollama
                    final_base_url_str = None # Default to system config for ollama base URL unless user specifies
        
        # Ensure model is compatible with provider
        if final_provider_id and final_model_id:
            prov_info = config.LLM_PROVIDERS.get(final_provider_id)
            if not prov_info or not any(m.get("model_id") == final_model_id for m in prov_info.get("available_models", [])):
                # This case implies an inconsistency, possibly model was valid for old provider but not new one
                # Or user cleared model without clearing provider that requires one.
                # Safest might be to clear model if it's not valid for the final_provider_id
                final_model_id = None 
                # If the provider requires a model, this state (provider set, model None) might be an issue later.
                # The initial validation should catch "provider selected, model required but not provided".

        cursor.execute(
            """UPDATE users SET
                selected_llm_provider_id = ?,
                selected_llm_model_id = ?,
                user_llm_api_key_encrypted = ?,
                selected_llm_base_url = ?,
                updated_at = datetime('now')
                WHERE id = ?""",
            (final_provider_id, final_model_id, final_api_key_encrypted, final_base_url_str, user_id)
        )
        conn.commit()

        has_user_api_key_after_update = False
        if final_api_key_encrypted and config.APP_SECRET_KEY:
            try:
                decrypted_check = encryption_utils.decrypt_data(final_api_key_encrypted)
                has_user_api_key_after_update = bool(decrypted_check and decrypted_check.strip())
            except Exception:
                has_user_api_key_after_update = False 
                print(f"WARNING: User {user_id} LLM settings update - could not decrypt stored API key for verification.")
        elif final_api_key_encrypted and not config.APP_SECRET_KEY:
            has_user_api_key_after_update = True # Assume it's present but unverified
            print(f"WARNING: User {user_id} LLM settings update - APP_SECRET_KEY not set, cannot verify has_user_api_key status accurately.")
        
        updated_base_url_obj: Optional[HttpUrl] = None
        if final_base_url_str:
            try:
                updated_base_url_obj = HttpUrl(final_base_url_str)
            except ValueError:
                print(f"WARNING: User {user_id} LLM settings - stored base_url '{final_base_url_str}' is invalid.")
                pass # Keep it None
        
        return models.UserLLMSettingsResponse(
            selected_llm_provider_id=final_provider_id,
            selected_llm_model_id=final_model_id,
            has_user_api_key=has_user_api_key_after_update,
            selected_llm_base_url=updated_base_url_obj
        )
    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error occurred while updating LLM settings.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred while updating LLM settings.")
    finally:
        if conn: conn.close()

@app.post("/api/me/regenerate-password", response_model=models.RegeneratePasswordResponse, tags=["User Account Management"])
async def regenerate_user_password(
    request: Request,
    payload: models.RegeneratePasswordRequest = Body(...),
    current_user: Dict[str, Any] = Depends(auth.get_current_active_user),
    csrf_protect: CsrfProtect = Depends()
):
    await _ensure_csrf_for_cookie_auth(request, csrf_protect)
    user_id = current_user.get("id")
    user_email = current_user.get("email")
    user_name = current_user.get("name", "User") # Ensure name is available

    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT password_hash FROM users WHERE id = ? AND email = ?", (user_id, user_email))
        user_record = cursor.fetchone()
        if not user_record:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User record not found. Please try logging out and back in.")
        
        stored_password_hash = user_record["password_hash"]
        if not stored_password_hash:
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Cannot verify password due to an account data issue. Please contact support.")

        if not auth.verify_password(payload.current_password, stored_password_hash):
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect current password.")

        new_plain_password = database.generate_secure_token(12) # Or from config
        new_hashed_password = auth.get_password_hash(new_plain_password)
        
        cursor.execute("UPDATE users SET password_hash = ?, updated_at = datetime('now') WHERE id = ?", (new_hashed_password, user_id))
        if cursor.rowcount == 0:
            conn.rollback()
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to update password due to a server error.")

        login_url_from_fastapi = str(request.url_for('get_login_page_route'))
        parsed_base_url = urlparse(config.BASE_URL)
        parsed_login_route_url = urlparse(login_url_from_fastapi)
        login_page_url = parsed_base_url._replace(path=parsed_login_route_url.path, query=parsed_login_route_url.query, fragment=parsed_login_route_url.fragment).geturl()
        
        email_sent = await email_utils.send_password_reset_email( # Re-using this, or create a dedicated one
            recipient_email=user_email, recipient_name=user_name, new_password=new_plain_password, login_url=login_page_url
        )
        if not email_sent:
            conn.rollback() # Critical: if email fails, rollback password change
            raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail="Password was reset in the database, but the notification email failed to send. The password change has been rolled back. Please try again.")

        # Invalidate all existing session tokens for this user
        now_utc_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        cursor.execute(
            "UPDATE auth_tokens SET used_at = ?, expires_at = ? WHERE user_id = ? AND token_type = 'session' AND used_at IS NULL",
            (now_utc_iso, now_utc_iso, user_id)
        )
        conn.commit()
        return models.RegeneratePasswordResponse(
            message="Password regenerated successfully. An email has been sent with your new password. You should now log out all other sessions and log back in with the new password."
        )
    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="A database error occurred while regenerating your password.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred.")
    finally:
        if conn: conn.close()

@app.patch("/api/me/update-email", response_model=models.UpdateEmailResponse, tags=["User Account Management"])
async def update_user_email(
    request: Request,
    payload: models.UpdateEmailRequest = Body(...),
    current_user: Dict[str, Any] = Depends(auth.get_current_active_user),
    csrf_protect: CsrfProtect = Depends()
):
    await _ensure_csrf_for_cookie_auth(request, csrf_protect)
    user_id = current_user.get("id")
    current_email_for_logging = current_user.get("email") # For logging comparison
    new_email_normalized = payload.new_email.lower().strip()

    if not utils.is_valid_email(new_email_normalized):
         raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid new email address format.")
    if new_email_normalized == current_email_for_logging:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="New email address is the same as the current one.")

    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT password_hash FROM users WHERE id = ?", (user_id,))
        user_record = cursor.fetchone()
        if not user_record:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User record not found. Please try logging out and back in.")
        
        stored_password_hash = user_record["password_hash"]
        if not stored_password_hash:
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Cannot verify password due to an account data issue. Please contact support.")

        if not auth.verify_password(payload.current_password, stored_password_hash):
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect current password.")

        cursor.execute("SELECT id FROM users WHERE email = ? AND id != ?", (new_email_normalized, user_id))
        if cursor.fetchone():
            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="This email address is already in use by another account.")

        cursor.execute("UPDATE users SET email = ?, updated_at = datetime('now') WHERE id = ?", (new_email_normalized, user_id))
        if cursor.rowcount == 0:
            conn.rollback()
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to update email due to a server error during the update operation.")

        # Invalidate all existing session tokens for this user as email (username) changed
        now_utc_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        cursor.execute(
            "UPDATE auth_tokens SET used_at = ?, expires_at = ? WHERE user_id = ? AND token_type = 'session' AND used_at IS NULL",
            (now_utc_iso, now_utc_iso, user_id)
        )
        conn.commit()
        return models.UpdateEmailResponse(
            message="Email updated successfully. You will now be logged out to apply changes and must log in with your new email address.",
            new_email=new_email_normalized
        )
    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="A database error occurred while updating your email.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred while updating your email.")
    finally:
        if conn: conn.close()

@app.patch("/api/me/update-name", response_model=models.UpdateNameResponse, tags=["User Account Management"])
async def update_user_name(
    request: Request,
    update_data: models.UpdateNameRequest = Body(...),
    current_user: Dict[str, Any] = Depends(auth.get_current_active_user),
    csrf_protect: CsrfProtect = Depends()
):
    await _ensure_csrf_for_cookie_auth(request, csrf_protect)
    user_id = current_user.get("id")
    new_name_stripped = update_data.new_name.strip()

    if not new_name_stripped:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="New name cannot be empty.")
    if len(new_name_stripped) > 100: # Example length validation
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="New name is too long (maximum 100 characters).")

    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT password_hash FROM users WHERE id = ?", (user_id,))
        user_record = cursor.fetchone()
        if not user_record:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User record not found. Please try logging out and back in.")
        
        stored_password_hash = user_record["password_hash"]
        if not stored_password_hash:
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Cannot verify password due to an account data issue. Please contact support.")

        if not auth.verify_password(update_data.current_password, stored_password_hash):
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect current password.")

        cursor.execute("UPDATE users SET name = ?, updated_at = datetime('now') WHERE id = ?", (new_name_stripped, user_id))
        if cursor.rowcount == 0:
            conn.rollback()
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to update name due to a server error during the update operation.")
        
        conn.commit()
        return models.UpdateNameResponse(message="Name updated successfully.", new_name=new_name_stripped)
    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="A database error occurred while updating your name.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred while updating your name.")
    finally:
        if conn: conn.close()


# --- LLM, User, Session Data (mostly GET requests or auth via Bearer, CSRF not primary concern for GET) ---

@app.get("/api/llm/providers", response_model=List[models.LLMProviderDetail], tags=["LLM Configuration"])
async def list_llm_providers(
    current_user: Optional[Dict[str, Any]] = Depends(auth.get_current_user) # Can be optional if public info
):
    # This is a GET request, so CSRF is not typically applied for read operations.
    response_providers = []
    for provider_id, provider_data_from_config_root in config.LLM_PROVIDERS.items():
        # Get runtime configuration which might include resolved env vars
        provider_runtime_config = config.get_provider_config(provider_id)
        if not provider_runtime_config:
            print(f"Warning: Runtime configuration for LLM provider '{provider_id}' not found. Skipping.")
            continue

        # Determine if the system has a key configured for this provider
        is_system_key_configured = False
        api_key_env_var_name = provider_runtime_config.get("api_key_env_var_name")
        if api_key_env_var_name and os.getenv(api_key_env_var_name):
            is_system_key_configured = True
        
        # A provider "requires_api_key_from_user" if:
        # 1. The provider definition inherently can use an API key (e.g., OpenAI, Anthropic).
        # 2. AND the system does NOT have a global key configured for it.
        # Some providers (like 'ollama' or local models) might not require a key at all.
        # Some (like 'openai_compatible_server') might always allow a user key even if a system one exists.
        
        # Base assumption: provider needs a key if it's one of the known types that use keys
        # OR if its config explicitly mentions an API key environment variable.
        provider_type_can_use_key = provider_id in config.PROVIDERS_TYPICALLY_USING_API_KEYS or \
                                    bool(api_key_env_var_name)

        # Does the user *need* to provide a key? True if the type can use a key AND system doesn't have one.
        needs_api_key_from_user = provider_type_can_use_key and not is_system_key_configured
        
        # Can the user *optionally* provide a key? (e.g. for OpenAI compatible servers, even if system has one)
        can_accept_user_api_key = provider_id in config.PROVIDERS_ALLOWING_USER_KEYS_EVEN_IF_SYSTEM_CONFIGURED or needs_api_key_from_user


        available_models_details = []
        for model_info in provider_data_from_config_root.get("available_models", []):
            available_models_details.append(
                models.LLMAvailableModel(
                    model_id=model_info.get("model_id"),
                    display_name=model_info.get("display_name"),
                    context_window=model_info.get("context_window") # Ensure this is handled if missing
                )
            )
        
        response_providers.append(
            models.LLMProviderDetail(
                id=provider_id,
                display_name=provider_data_from_config_root.get("display_name", provider_id.replace("_", " ").title()),
                type=provider_runtime_config.get("type", "unknown"),
                is_system_configured=is_system_key_configured or not provider_type_can_use_key, # System is "configured" if key is present OR if provider type doesn't need one
                can_accept_user_api_key=can_accept_user_api_key, # If user can enter their own key
                needs_api_key_from_user=needs_api_key_from_user, # If user *must* enter a key because system lacks one
                available_models=available_models_details,
                # Does provider support a user-defined base_url?
                can_accept_user_base_url=provider_runtime_config.get("type") == "openai_compatible_server" # Example
            )
        )
    return response_providers


@app.get("/api/me/llm-settings", response_model=models.UserLLMSettingsResponse, tags=["User Account Management", "LLM Configuration"])
async def get_user_llm_settings(
    current_user: Dict[str, Any] = Depends(auth.get_current_active_user) # Bearer token auth
):
    # GET request, CSRF not primary concern
    user_id = current_user["id"]
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            "SELECT selected_llm_provider_id, selected_llm_model_id, user_llm_api_key_encrypted, selected_llm_base_url FROM users WHERE id = ?",
            (user_id,)
        )
        user_settings_row = cursor.fetchone()

        if not user_settings_row: # Should not happen for an active user
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User LLM settings not found.")

        selected_provider_id = user_settings_row["selected_llm_provider_id"]
        selected_model_id = user_settings_row["selected_llm_model_id"]
        encrypted_api_key = user_settings_row["user_llm_api_key_encrypted"]
        selected_base_url_str = user_settings_row["selected_llm_base_url"]

        # If user has no provider/model selected in DB, use system defaults from config
        if selected_provider_id is None and config.DEFAULT_LLM_PROVIDER_ID:
            selected_provider_id = config.DEFAULT_LLM_PROVIDER_ID
            # If provider is defaulted, model should also be the system default model for that provider
            # or the overall system default model if the default provider doesn't specify one.
            default_provider_config = config.LLM_PROVIDERS.get(config.DEFAULT_LLM_PROVIDER_ID, {})
            if default_provider_config.get("available_models"):
                selected_model_id = default_provider_config["available_models"][0]["model_id"] # First model of default provider
            else: # Fallback to overall default model ID if any
                selected_model_id = config.DEFAULT_LLM_MODEL_ID

            # If defaulting the provider, logically clear any user-specific API key or base URL
            # as these were not explicitly chosen by the user for this default.
            encrypted_api_key = None
            selected_base_url_str = None
        elif selected_provider_id and not selected_model_id: # Provider chosen, but model missing (e.g. after config change)
            provider_config = config.LLM_PROVIDERS.get(selected_provider_id, {})
            if provider_config.get("available_models"):
                 selected_model_id = provider_config["available_models"][0]["model_id"] # Default to first model of chosen provider

        has_user_api_key = False
        if encrypted_api_key:
            if config.APP_SECRET_KEY:
                try:
                    decrypted_key_check = encryption_utils.decrypt_data(encrypted_api_key)
                    if decrypted_key_check and decrypted_key_check.strip(): # Ensure non-empty key after decryption
                        has_user_api_key = True
                except Exception: # Decryption can fail
                    print(f"WARNING: User {user_id} - Could not decrypt stored API key for has_user_api_key flag.")
                    pass # has_user_api_key remains False
            else:
                # APP_SECRET_KEY not set, cannot confirm key validity but it exists encrypted
                has_user_api_key = True # Best guess: it's there.
                print(f"WARNING: User {user_id} has an encrypted API key, but APP_SECRET_KEY is not set. Cannot fully verify for has_user_api_key flag.")

        valid_base_url_obj: Optional[HttpUrl] = None
        if selected_base_url_str:
            try:
                valid_base_url_obj = HttpUrl(selected_base_url_str)
            except ValueError:
                print(f"Warning: User {user_id} has an invalid base URL stored: {selected_base_url_str}")
                pass # Keep it None

        return models.UserLLMSettingsResponse(
            selected_llm_provider_id=selected_provider_id,
            selected_llm_model_id=selected_model_id,
            has_user_api_key=has_user_api_key,
            selected_llm_base_url=valid_base_url_obj
        )
    except sqlite3.Error as db_err:
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error retrieving LLM settings.")
    except Exception as e:
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Unexpected server error retrieving LLM settings.")
    finally:
        if conn: conn.close()


@app.get("/logout", tags=["Authentication"])
async def logout_route(
    request: Request, # To access CsrfProtect methods if needed, though not strictly for validation here
    response: FastAPIResponse, # To set/unset cookies
    session_token_value: Optional[str] = Depends(auth.cookie_scheme) # Gets session token from cookie
):
    # No CSRF validation needed for logout itself usually, as it's a benign action.
    # The main goal is to invalidate the session.
    print(f"---- SERVER LOG: GET /logout - User initiated logout. Session token from cookie: {'present' if session_token_value else 'missing'}")
    await auth.logout_user(response, session_token_value) # Invalidates session token and unsets session cookie
    
    # Unset the CSRF token cookie as well, as the session it was tied to is now invalid.
    # This requires a CsrfProtect instance. We can create one on the fly or inject it.
    # Since CSRF is app-wide, it might be cleaner if CsrfProtect had a static-like method or if we inject.
    # For simplicity here, instantiate, but in a larger app, manage dependencies carefully.
    # However, `fastapi-csrf-protect` sets cookies on responses where tokens are generated or validated.
    # The `logout_user` handles the session cookie. For the CSRF cookie, we explicitly unset.
    
    # Get a CsrfProtect instance - if we are not in a Depends context, we need to create it.
    # This is a bit of a workaround. Ideally, a CsrfProtect instance would be available.
    # We can try to get it from the app state if it was stored, or construct as needed.
    # For now, assuming we can construct one to call unset_csrf_cookie
    # csrf_protect_instance = CsrfProtect() # This would use default config if not loaded.
    # Instead of new instance, if we need to ensure it uses loaded config, we might need to pass it.
    # However, unsetting doesn't strictly need the secret key.

    # The CSRF cookie should be unset. `fastapi-csrf-protect` might do this if `validate_csrf` is called
    # and it decides to rotate/clear. For an explicit logout, better to be sure.
    # Let's assume csrf_protect.unset_csrf_cookie can be called on a response.
    # We might need to pass the `CsrfProtect` dependency.
    # Let's add it as a dependency to be safe.
    
    # Re-thinking: We don't generate new tokens or validate on logout usually.
    # We just want to clear the cookie.
    try:
        _csrf_protect_for_logout = CsrfProtect() # Standard instance
        _csrf_protect_for_logout.load_config(get_csrf_config) # Ensure it has the config
        _csrf_protect_for_logout.unset_csrf_cookie(response=response)
        print("---- SERVER LOG: GET /logout - CSRF token cookie explicitly unset.")
    except Exception as e_csrf_unset:
        print(f"---- SERVER LOG: GET /logout - Minor error unsetting CSRF cookie: {e_csrf_unset}")
        # Continue with redirect even if CSRF cookie unsetting had an issue.

    redirect_url = request.url_for('get_login_page_route')
    return RedirectResponse(url=str(redirect_url), status_code=status.HTTP_302_FOUND)


@app.get("/api/me", response_model=models.UserResponseModel, tags=["Users"])
async def get_current_user_details(
    user: Dict[str, Any] = Depends(auth.get_current_active_user) # Bearer token auth
):
    # GET request, CSRF not primary concern. Auth handled by Bearer token.
    if not user: # Should be caught by Depends
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated.")
    
    # Ensure all required fields are present in the user dict from the token/DB
    required_keys = ["id", "name", "email"]
    if not all(key in user for key in required_keys):
        print(f"ERROR: User object for /api/me is missing required keys. User: {user}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="User data is incomplete on server.")
        
    return models.UserResponseModel(id=user["id"], name=user["name"], email=user["email"])





@app.get("/api/sessions", response_model=List[models.SessionResponseModel], tags=["Sessions"])
async def get_user_sessions(
    user: Dict[str, Any] = Depends(auth.get_current_active_user) # Bearer token auth
) -> List[models.SessionResponseModel]: # Explicit return type annotation
    # GET request, CSRF not primary concern as it's a read operation
    if not user: # Should be caught by Depends, but as a safeguard
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")
    
    user_id = user.get('id')
    if not user_id:
        # This case should ideally not happen if auth.get_current_active_user guarantees 'id'
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="User ID missing in token/session.")

    sessions_list: List[models.SessionResponseModel] = []
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        # Fetches sessions where the user is a participant and session is active
        # The SQL query already aliases s.last_accessed_at AS last_active
        cursor.execute(
            """SELECT s.id, s.name, s.created_at, s.last_accessed_at AS last_active, s.host_user_id
               FROM sessions s
               JOIN session_participants sp ON s.id = sp.session_id
               WHERE sp.user_id = ? AND s.is_active = 1
               ORDER BY s.last_accessed_at DESC, s.created_at DESC""",
            (user_id,)
        )
        rows = cursor.fetchall()
        
        for row_data in rows:
            session_data_from_db = dict(row_data)
            
            # Ensure datetime fields from DB (if they are datetime objects) are converted to ISO strings
            # The model SessionResponseModel expects Optional[str] for these.
            if session_data_from_db.get("created_at") and isinstance(session_data_from_db["created_at"], (datetime.datetime, datetime.date)):
                session_data_from_db["created_at"] = session_data_from_db["created_at"].isoformat()
            
            if session_data_from_db.get("last_active") and isinstance(session_data_from_db["last_active"], (datetime.datetime, datetime.date)):
                session_data_from_db["last_active"] = session_data_from_db["last_active"].isoformat()

            # Pydantic will validate against SessionResponseModel fields:
            # id, name, created_at, last_active, host_user_id
            sessions_list.append(models.SessionResponseModel(**session_data_from_db))
            
        return sessions_list
    except sqlite3.Error as db_err:
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error while fetching sessions.")
    except Exception as e:
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred while fetching sessions.")
    finally:
        if conn:
            conn.close()

@app.get("/api/sessions/{session_id}/messages", response_model=List[models.MessageItem], tags=["Messages"])
async def get_chat_messages_for_session(
    session_id: str = FastApiPath(..., description="The ID of the session to fetch messages for."),
    user: Dict[str, Any] = Depends(auth.get_current_active_user) # Bearer token auth
) -> List[models.MessageItem]: # Explicit return type annotation
    # GET request, CSRF not primary concern
    if not user: # Should be caught by Depends
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")
    
    user_id = user.get('id')
    if not user_id:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="User ID missing in token/session.")

    messages_list: List[models.MessageItem] = []
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        
        # Verify user has access to this session
        cursor.execute(
            "SELECT 1 FROM session_participants WHERE session_id = ? AND user_id = ?", (session_id, user_id)
        )
        if not cursor.fetchone():
            # If user is not a participant, check if the session itself is valid before denying access
            cursor.execute("SELECT 1 FROM sessions WHERE id = ? AND is_active = 1", (session_id,))
            if not cursor.fetchone():
                raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Chat session not found or is inactive.")
            else: # Session exists and is active, but user is not a participant
                raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied to this chat session's messages.")
        
        # Session is valid and user is a participant, fetch messages
        # The query already includes model_provider_id and model_id
        cursor.execute(
            """SELECT id, session_id, user_id, sender_name, sender_type, content, 
                      client_id_temp, thinking_content, timestamp, turn_id, model_provider_id, model_id
               FROM chat_messages 
               WHERE session_id = ? 
               ORDER BY timestamp ASC, id ASC""", # Added id for tie-breaking if timestamps are identical
            (session_id,)
        )
        rows = cursor.fetchall()
        
        for row_data in rows:
            message_data_from_db = dict(row_data)
            
            # Ensure timestamp is ISO format string as expected by MessageItem model
            if message_data_from_db.get("timestamp") and isinstance(message_data_from_db["timestamp"], (datetime.datetime, datetime.date)):
                message_data_from_db["timestamp"] = message_data_from_db["timestamp"].isoformat()
            
            # Pydantic will validate against MessageItem fields
            messages_list.append(models.MessageItem(**message_data_from_db))
            
        return messages_list
    except sqlite3.Error as db_err:
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error while fetching messages.")
    except HTTPException as http_exc: # Re-raise if it's already an HTTPException (like 403/404)
        raise http_exc
    except Exception as e:
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred while fetching messages.")
    finally:
        if conn:
            conn.close()


# --- WebSocket Chat Logic ---
# CSRF protection is not directly applied to WebSockets by fastapi-csrf-protect.
# Auth is handled by checking the session cookie during the WebSocket upgrade request.

async def handle_chat_message(
    chain: Any, 
    memory: Any, 
    websocket: WebSocket, 
    client_js_id: str,
    current_user: Dict[str, Any], 
    session_id: str, 
    user_input: str, 
    turn_id: int,
    llm_provider_id_used: Optional[str], # For logging
    llm_model_id_used: Optional[str]     # For logging
):
    user_name = current_user.get('name', 'Anonymous User') # Fallback name
    user_db_id = current_user['id']
    full_response = ""
    thinking_content: Optional[str] = None # Placeholder for future use if 'think' mode provides preliminary thoughts
    stream_id = f"{client_js_id}_{turn_id}" 
    stop_event: Optional[asyncio.Event] = None
    
    # Store user message in DB
    db_conn_user_msg = None
    try:
        db_conn_user_msg = database.get_db_connection()
        db_cursor_user_msg = db_conn_user_msg.cursor()
        db_cursor_user_msg.execute(
            """INSERT INTO chat_messages (session_id, user_id, sender_name, sender_type, content, 
                                          client_id_temp, turn_id, timestamp, 
                                          model_provider_id, model_id) 
               VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now', 'utc'), ?, ?)""",
            (session_id, user_db_id, user_name, 'user', user_input, client_js_id, turn_id, None, None) # LLM info not applicable to user msg
        )
        db_conn_user_msg.commit()
    except Exception as db_err_user:
        traceback.print_exc()
        print(f"ERROR saving user message to DB for session {session_id}: {db_err_user}")
        if db_conn_user_msg: db_conn_user_msg.rollback()
        # Do not stop processing if DB save fails, but log it.
    finally:
        if db_conn_user_msg: db_conn_user_msg.close()

    # Process with LLM
    try:
        stop_event = await state.register_ai_stream(stream_id) # For handling 'stop generation'
        if chain is None:
            error_msg_no_chain = "<ERROR>LLM Error: Chat model is not available. Please check server configuration or your LLM settings."
            if websocket.client_state == WebSocketState.CONNECTED:
                await websocket.send_text(error_msg_no_chain)
                await websocket.send_text("<EOS>") # End of Stream signal
            return 

        async for chunk_data in chain.astream({"input": user_input}):
            if stop_event and stop_event.is_set(): # Check if stop signal received
                print(f"AI stream {stream_id} stopped by client signal.")
                break 
            
            chunk_str = ""
            if isinstance(chunk_data, dict): 
                # Adapt based on actual chain output structure (e.g., LangChain LCEL)
                # Common for LCEL chains that output AIMessageChunk or similar
                if hasattr(chunk_data, 'content'): # Langchain AIMessageChunk
                    chunk_str = chunk_data.content
                elif "answer" in chunk_data: # Older LangChain style
                    chunk_str = chunk_data.get("answer", "")
                else: # Try to find content in a common key
                    content_keys = ['content', 'text', 'chunk']
                    for key in content_keys:
                        if key in chunk_data and isinstance(chunk_data[key], str):
                            chunk_str = chunk_data[key]
                            break
                    if not chunk_str:
                         print(f"DEBUG: LLM chunk_data (dict) received with unexpected structure: {chunk_data}")

            elif hasattr(chunk_data, 'content') and isinstance(chunk_data.content, str): # For AIMessageChunk like objects
                chunk_str = chunk_data.content
            else: 
                chunk_str = str(chunk_data) # Fallback
            
            if websocket.client_state != WebSocketState.CONNECTED:
                print(f"WebSocket for stream {stream_id} disconnected during AI response.")
                return 
            
            if chunk_str: # Only send if there's content
                await websocket.send_text(chunk_str)
                full_response += chunk_str
        
        # After loop finishes (either by completing or by stop_event)
        if websocket.client_state == WebSocketState.CONNECTED:
            if stop_event and stop_event.is_set():
                 await websocket.send_text("<EOS_STOPPED>") # Signal client generation was stopped
            else:
                 await websocket.send_text("<EOS>") # Normal End of Stream signal

        if memory: 
            try:
                memory.save_context({"input": user_input}, {"output": full_response})
                if hasattr(state, 'save_memory_state_to_db'): 
                    state.save_memory_state_to_db(session_id, memory) 
            except Exception as save_mem_err: 
                traceback.print_exc()
                print(f"Error saving memory state for session {session_id}: {save_mem_err}")
        
        # Store AI response in DB
        db_conn_ai_msg = None
        try:
            db_conn_ai_msg = database.get_db_connection()
            db_cursor_ai_msg = db_conn_ai_msg.cursor()
            db_cursor_ai_msg.execute(
                """INSERT INTO chat_messages (session_id, user_id, sender_name, sender_type, content, 
                                              thinking_content, client_id_temp, turn_id, timestamp,
                                              model_provider_id, model_id) 
                   VALUES (?, ?, ?, ?, ?, ?, ?, ?, datetime('now', 'utc'), ?, ?)""", 
                (session_id, None, "AI", 'ai', full_response, thinking_content, client_js_id, turn_id, llm_provider_id_used, llm_model_id_used)
            )
            db_conn_ai_msg.commit()
        except Exception as db_err_ai:
            traceback.print_exc()
            print(f"ERROR saving AI message to DB for session {session_id}: {db_err_ai}")
            if db_conn_ai_msg: db_conn_ai_msg.rollback()
        finally:
            if db_conn_ai_msg: db_conn_ai_msg.close()

    except Exception as chain_exc:
        error_msg = f"<ERROR>LLM Error: Processing your message failed. Details: {str(chain_exc)}"
        traceback.print_exc()
        print(f"Error during LLM chain processing for session {session_id}: {chain_exc}")
        if websocket.client_state == WebSocketState.CONNECTED:
            try:
                await websocket.send_text(error_msg)
                await websocket.send_text("<EOS>") 
            except Exception as send_err:
                print(f"Error sending LLM processing error to client {client_js_id}: {send_err}")
    finally:
        if stream_id and stop_event: 
            await state.unregister_ai_stream(stream_id)


@app.websocket("/ws/{session_id_ws}/{client_js_id}")
async def websocket_endpoint(
    websocket: WebSocket,
    session_id_ws: str = FastApiPath(..., title="Session ID", description="The ID of the chat session."),
    client_js_id: str = FastApiPath(..., title="Client JS ID", description="A unique ID generated by the client-side JavaScript.")
):
    print(f"---- WS LOG: Attempting WebSocket connection for session_id_ws: {session_id_ws}, client_js_id: {client_js_id} ----")
    print(f"---- WS LOG: WebSocket request headers: {websocket.headers}")
    print(f"---- WS LOG: WebSocket request cookies: {websocket.cookies}")

    session_token_from_cookie = websocket.cookies.get(auth.SESSION_COOKIE_NAME)
    current_ws_user: Optional[Dict[str, Any]] = None

    if not session_token_from_cookie:
        print(f"---- WS ERROR: No session token found in cookies. Cookie name expected: '{auth.SESSION_COOKIE_NAME}'. Cannot authenticate WebSocket.")
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Authentication required - no session token.")
        return
    
    print(f"---- WS LOG: Session token found in cookie: '{session_token_from_cookie[:10]}...' (first 10 chars)")

    try:
        # *** CORRECTED FUNCTION NAME HERE ***
        current_ws_user = await auth.get_user_by_session_token_internal(session_token_from_cookie)
    except Exception as e_auth_token:
        print(f"---- WS ERROR: Exception during auth.get_user_by_session_token_internal for token '{session_token_from_cookie[:10]}...': {e_auth_token}")
        traceback.print_exc()
        await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Server error during token validation.")
        return

    if not current_ws_user:
        print(f"---- WS ERROR: WebSocket authentication failed for session {session_id_ws}, client {client_js_id}. Token validation returned no user.")
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Authentication failed - invalid session token.")
        return

    user_id = current_ws_user.get('id')
    user_email = current_ws_user.get('email', 'N/A') # Get email for logging
    if not user_id:
        print(f"---- WS ERROR: Authenticated user object for email '{user_email}' is missing 'id'. User object: {current_ws_user}")
        await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Server error - user data incomplete.")
        return
        
    print(f"---- WS LOG: User successfully authenticated via session token. User ID: {user_id}, Email: {user_email}")
    print(f"---- WS LOG: Verifying session access for user {user_id} on session {session_id_ws}...")

    conn_verify = None
    try:
        conn_verify = database.get_db_connection()
        cursor_verify = conn_verify.cursor()
        
        cursor_verify.execute("SELECT id, name, is_active FROM sessions WHERE id = ?", (session_id_ws,))
        session_details = cursor_verify.fetchone()

        if not session_details:
            print(f"---- WS ERROR: Session {session_id_ws} not found in database for user {user_id}.")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Session not found.")
            return
        
        if not session_details["is_active"]:
            print(f"---- WS ERROR: Session {session_id_ws} is inactive for user {user_id}. Session name: {session_details['name']}")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Session is inactive.")
            return
        
        print(f"---- WS LOG: Session {session_id_ws} (Name: {session_details['name']}) found and is active.")

        cursor_verify.execute("SELECT 1 FROM session_participants WHERE session_id = ? AND user_id = ?", (session_id_ws, user_id))
        if not cursor_verify.fetchone():
            print(f"---- WS ERROR: User {user_id} ({user_email}) is not a participant of session {session_id_ws}.")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Access denied to session.")
            return
        print(f"---- WS LOG: User {user_id} ({user_email}) is a participant of session {session_id_ws}. Access granted.")

    except sqlite3.Error as e_db_verify: # Catch specific sqlite3 errors
        print(f"---- WS ERROR: Database error during session verification for user {user_id}, session {session_id_ws}: {e_db_verify}")
        traceback.print_exc()
        await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Server error during session verification (DB).")
        return
    except Exception as e_verify:
        print(f"---- WS ERROR: Unexpected error during session verification for user {user_id}, session {session_id_ws}: {e_verify}")
        traceback.print_exc()
        await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Server error during session verification (General).")
        return
    finally:
        if conn_verify: conn_verify.close()

    try:
        await websocket.accept()
        print(f"---- WS SUCCESS: WebSocket connection accepted for user {user_id} ({user_email}), session {session_id_ws}, client {client_js_id}.")
    except Exception as accept_err:
        print(f"---- WS CRITICAL ERROR: Failed to accept WebSocket connection for user {user_id}, session {session_id_ws}: {accept_err}")
        traceback.print_exc()
        return 

    llm_provider_id_for_session: Optional[str] = None
    llm_model_id_for_session: Optional[str] = None
    user_api_key_for_session: Optional[str] = None 
    user_base_url_for_session: Optional[str] = None
    
    db_conn_settings = None
    try:
        db_conn_settings = database.get_db_connection()
        cursor_settings = db_conn_settings.cursor()
        cursor_settings.execute(
            "SELECT selected_llm_provider_id, selected_llm_model_id, user_llm_api_key_encrypted, selected_llm_base_url FROM users WHERE id = ?",
            (user_id,)
        )
        user_llm_prefs = cursor_settings.fetchone()
        if user_llm_prefs:
            llm_provider_id_for_session = user_llm_prefs["selected_llm_provider_id"]
            llm_model_id_for_session = user_llm_prefs["selected_llm_model_id"]
            user_base_url_for_session = user_llm_prefs["selected_llm_base_url"] 
            encrypted_key = user_llm_prefs["user_llm_api_key_encrypted"]
            if encrypted_key and config.APP_SECRET_KEY:
                try:
                    user_api_key_for_session = encryption_utils.decrypt_data(encrypted_key)
                    if not user_api_key_for_session or not user_api_key_for_session.strip():
                        user_api_key_for_session = None 
                except Exception:
                    user_api_key_for_session = None
                    print(f"---- WS WARNING: User {user_id} - Failed to decrypt API key for session {session_id_ws}.")
            elif encrypted_key and not config.APP_SECRET_KEY:
                print(f"---- WS WARNING: User {user_id} - API key present but APP_SECRET_KEY not set, cannot decrypt for session {session_id_ws}.")

        if not llm_provider_id_for_session or not llm_model_id_for_session:
            print(f"---- WS INFO: User {user_id} has no LLM provider/model selected or incomplete. Using system defaults for session {session_id_ws}.")
            llm_provider_id_for_session = config.DEFAULT_LLM_PROVIDER_ID
            llm_model_id_for_session = config.DEFAULT_LLM_MODEL_ID
            if user_llm_prefs and llm_provider_id_for_session != user_llm_prefs["selected_llm_provider_id"]:
                user_api_key_for_session = None
                user_base_url_for_session = None
        print(f"---- WS LOG: LLM settings for session {session_id_ws} - Provider: '{llm_provider_id_for_session}', Model: '{llm_model_id_for_session}', HasUserAPIKey: {'Yes' if user_api_key_for_session else 'No'}, BaseURL: '{user_base_url_for_session if user_base_url_for_session else 'Default'}'")

    except Exception as e_settings:
        traceback.print_exc()
        print(f"---- WS ERROR: Error fetching LLM settings for user {user_id}, session {session_id_ws}: {e_settings}. Using system defaults.")
        llm_provider_id_for_session = config.DEFAULT_LLM_PROVIDER_ID
        llm_model_id_for_session = config.DEFAULT_LLM_MODEL_ID
        user_api_key_for_session = None 
        user_base_url_for_session = None 
    finally:
        if db_conn_settings: db_conn_settings.close()

    memory_for_session = state.get_memory_for_client(session_id_ws) 
    
    def load_memory_for_current_session_chain(_ignored_input_map=None):
        loaded_vars = memory_for_session.load_memory_variables({})
        return loaded_vars.get("history", [])

    chain_for_session: Optional[Any] = None 
    try:
        chain_for_session = llm.create_chain(
            provider_id=llm_provider_id_for_session,
            model_id=llm_model_id_for_session,
            memory_loader_func=load_memory_for_current_session_chain,
            api_key=user_api_key_for_session,
            base_url_override=user_base_url_for_session
        )
        if not chain_for_session:
            raise ValueError(f"LLM chain creation returned None for provider '{llm_provider_id_for_session}', model '{llm_model_id_for_session}'.")
        print(f"---- WS LOG: LLM chain successfully created for session {session_id_ws}.")
    except Exception as chain_init_error:
        traceback.print_exc()
        print(f"---- WS CRITICAL ERROR: Could not initialize LLM chain for session {session_id_ws}: {chain_init_error}")
        if websocket.client_state == WebSocketState.CONNECTED:
            try:
                await websocket.send_json({"type": "error", "payload": {"message": f"Server error: Could not initialize chat with the selected model configuration ({str(chain_init_error)})."}})
            except Exception: pass 
        if websocket.client_state != WebSocketState.CLOSED :
            await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="LLM initialization failed.")
        return 

    try:
        while True:
            if websocket.client_state != WebSocketState.CONNECTED:
                print(f"---- WS INFO: Client {client_js_id} for session {session_id_ws} disconnected pre-receive.")
                break

            received_data = await websocket.receive_text()
            try:
                message_data = json.loads(received_data)
                message_type = message_data.get("type")
                payload = message_data.get("payload")

                if message_type == "chat_message" and payload:
                    user_input = payload.get("user_input")
                    turn_id = payload.get("turn_id") 
                    if user_input is not None and turn_id is not None:
                        print(f"---- WS LOG: Received 'chat_message' from {user_id} for session {session_id_ws}, turn {turn_id}")
                        asyncio.create_task(
                            handle_chat_message( 
                                chain_for_session, memory_for_session, websocket, client_js_id, 
                                current_ws_user, session_id_ws, user_input, turn_id,
                                llm_provider_id_for_session, llm_model_id_for_session
                            )
                        )
                    else:
                        if websocket.client_state == WebSocketState.CONNECTED:
                            await websocket.send_text("<ERROR>Invalid chat_message payload: 'user_input' or 'turn_id' missing.<EOS>")
                
                elif message_type == "run_code" and payload and payload.get("code_block_id"):
                    language = payload.get("language")
                    code = payload.get("code")
                    code_block_id = payload.get("code_block_id")
                    if language and code is not None:
                        print(f"---- WS LOG: Received 'run_code' for block {code_block_id} ({language}) from {user_id}")
                        asyncio.create_task(docker_utils.run_code_in_docker_stream(websocket, client_js_id, code_block_id, language, code))
                    else:
                        if websocket.client_state == WebSocketState.CONNECTED:
                            await websocket.send_json({"type": "code_finished", "payload": {"code_block_id": code_block_id, "exit_code": -1, "error": "Invalid run_code payload: 'language' or 'code' missing."}})
                
                elif message_type == "stop_code" and payload and payload.get("code_block_id"):
                    code_block_id = payload.get("code_block_id")
                    print(f"---- WS LOG: Received 'stop_code' for block {code_block_id} from {user_id}")
                    asyncio.create_task(docker_utils.stop_docker_container(code_block_id))

                elif message_type == "stop_ai_stream" and payload:
                    stop_client_id = payload.get("client_id") 
                    stop_session_id = payload.get("session_id") 
                    stop_turn_id = payload.get("turn_id")
                    if stop_client_id == client_js_id and stop_session_id == session_id_ws and stop_turn_id is not None:
                        stream_id_to_stop = f"{stop_client_id}_{stop_turn_id}"
                        print(f"---- WS LOG: Received 'stop_ai_stream' for stream_id: {stream_id_to_stop} from {user_id}")
                        await state.signal_stop_ai_stream(stream_id_to_stop)
                    else:
                        print(f"---- WS WARNING: Ignoring 'stop_ai_stream' with mismatched identifiers. Client: {stop_client_id}/{client_js_id}, Session: {stop_session_id}/{session_id_ws}")
                
                else: 
                    if websocket.client_state == WebSocketState.CONNECTED:
                        await websocket.send_text(f"<ERROR>Unknown command type received: {message_type}<EOS>")
            
            except json.JSONDecodeError:
                if websocket.client_state == WebSocketState.CONNECTED:
                    await websocket.send_text("<ERROR>Invalid message format. Expected JSON.<EOS>")
            except Exception as handler_exc: 
                traceback.print_exc()
                print(f"---- WS ERROR: Error handling received data for session {session_id_ws}, client {client_js_id}: {handler_exc}")
                if websocket.client_state == WebSocketState.CONNECTED:
                    try:
                        await websocket.send_text(f"<ERROR>Server error processing your request: {str(handler_exc)}<EOS>")
                    except Exception: pass

    except WebSocketDisconnect:
        print(f"---- WS INFO: Client {client_js_id} (User {user_id}, {user_email}) disconnected from session {session_id_ws}.")
    except Exception as e_ws_loop: 
        traceback.print_exc()
        print(f"---- WS CRITICAL ERROR: Unexpected error in main WebSocket loop for session {session_id_ws}, client {client_js_id}: {e_ws_loop}")
        if websocket.client_state == WebSocketState.CONNECTED:
            try: await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Unexpected server error in WebSocket.")
            except Exception: pass 
    finally:
        print(f"---- WS INFO: Cleaning up resources for client {client_js_id}, session {session_id_ws}.")
        # Ensure docker_utils.cleanup_client_containers is an async function if awaited
        await docker_utils.cleanup_client_containers(client_js_id) 
        
        if websocket.client_state == WebSocketState.CONNECTED:
            try: 
                print(f"---- WS INFO: Explicitly closing WebSocket connection for client {client_js_id}, session {session_id_ws}.")
                await websocket.close(code=status.WS_1000_NORMAL_CLOSURE)
            except Exception: pass

@app.delete("/api/sessions/{session_id}", status_code=status.HTTP_204_NO_CONTENT, tags=["Sessions"])
async def delete_session_route(
    request: Request, # For CSRF validation
    session_id: str = FastApiPath(..., description="The ID of the session to delete."),
    user: Dict[str, Any] = Depends(auth.get_current_active_user), # Ensures user is authenticated
    csrf_protect: CsrfProtect = Depends() # CSRF protection dependency
):
    """
    Deletes a specific chat session (marks it as inactive).
    Requires the user to be authenticated and provide a valid CSRF token.
    """
    print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - Attempt by user ID: {user.get('id')} ----")
    
    # Perform CSRF validation. This is crucial for state-changing operations.
    await csrf_protect.validate_csrf(request)
    print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - CSRF validation PASSED ----")

    user_id = user.get('id') # Get the ID of the authenticated user
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()

        print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - Fetching session data from DB.")
        # Fetch necessary session details, ensuring it's active
        cursor.execute("SELECT host_user_id, name FROM sessions WHERE id = ? AND is_active = 1", (session_id,))
        session_data = cursor.fetchone()

        if not session_data:
            # If not found active, check if it exists at all or was already inactive
            cursor.execute("SELECT id, name, is_active FROM sessions WHERE id = ?", (session_id,))
            already_exists_data = cursor.fetchone()
            if not already_exists_data:
                print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - Session ID truly not found in database.")
                raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Session not found.")
            else:
                # Session exists but was already inactive. Consider this a "successful" delete.
                # Use dictionary-style access for sqlite3.Row
                name_val = already_exists_data['name'] if 'name' in already_exists_data.keys() else 'N/A'
                is_active_val = already_exists_data['is_active'] if 'is_active' in already_exists_data.keys() else 'N/A'
                print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - Session found but is already inactive. Name: {name_val}, Active: {is_active_val}")
                conn.commit() # Commit if any prior transaction was started, though unlikely here
                return # Return 204 as it's effectively "deleted" or already in that state
        
        print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - Session data fetched: Type={type(session_data)}, Keys={list(session_data.keys()) if hasattr(session_data, 'keys') else 'N/A (not dict-like)'}")

        # Use dictionary-style access for sqlite3.Row
        # Ensure 'name' is in keys before accessing, or handle potential None if name can be NULL
        session_name_from_db = session_data["name"] if "name" in session_data.keys() and session_data["name"] is not None else None
        # session_host_id = session_data["host_user_id"] # Access directly if needed for permission check

        # Example permission check (if you want to re-enable it):
        # if session_host_id != user_id:
        #     print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - User {user_id} is not host ({session_host_id}). Forbidden.")
        #     raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="You do not have permission to delete this session.")

        current_time_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        deleted_session_name = f"Deleted: {session_name_from_db if session_name_from_db else session_id[:8]} ({current_time_iso})"
        
        print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - Updating session to inactive. New name: '{deleted_session_name}'")
        cursor.execute(
            "UPDATE sessions SET is_active = 0, name = ?, last_accessed_at = ? WHERE id = ?",
            (deleted_session_name, current_time_iso, session_id)
        )
        
        if cursor.rowcount == 0:
            # This case implies the session was active when fetched but couldn't be updated (e.g., race condition or DB issue).
            print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - Session was found active but UPDATE operation affected 0 rows. This is unexpected.")
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to update session state during deletion.")

        conn.commit()
        print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - Session marked as inactive by user ID: {user_id}.")

    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except sqlite3.Error as e_db:
        if conn: conn.rollback()
        print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - SQLite Error ----")
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Database error processing delete request: {e_db}")
    except Exception as e_general: # This will catch other errors like KeyError or IndexError
        if conn: conn.rollback()
        print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - Unexpected General Error ----")
        traceback.print_exc() 
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"An unexpected server error occurred: {e_general}")
    finally:
        if conn:
            conn.close()

# --- Application Startup and Static Files ---

@app.on_event("startup")
async def startup_event():
    print("Application startup: Initializing database...")
    # Ensure the database directory exists
    db_parent_dir = config.DATABASE_PATH.parent
    if not db_parent_dir.exists():
        db_parent_dir.mkdir(parents=True, exist_ok=True)
        print(f"Created database directory: {db_parent_dir}")
    database.init_db() # Initializes tables if they don't exist
    print("Database initialization check complete.")

    # Docker client check (optional, for code execution feature)
    docker_client = None
    try:
        docker_client = docker_utils.get_docker_client() 
        if docker_client is None:
            print("WARNING: Could not get Docker client via get_docker_client(). Code execution features might be disabled or limited.")
        else:
            # Perform a quick check like docker_client.ping()
            if docker_client.ping():
                print("Docker client confirmed available and responsive at startup.")
            else:
                print("WARNING: Docker client obtained, but ping failed. Docker daemon might not be running correctly. Code execution may fail.")
    except Exception as e_docker:
        print(f"WARNING: Could not connect to Docker daemon at startup: {e_docker}")
        print("Code execution via Docker will be unavailable if Docker is not running or misconfigured.")

    # Default LLM check (optional, for system health check)
    try:
        if config.DEFAULT_LLM_PROVIDER_ID and config.DEFAULT_LLM_MODEL_ID:
            print(f"Attempting to initialize default LLM: Provider='{config.DEFAULT_LLM_PROVIDER_ID}', Model='{config.DEFAULT_LLM_MODEL_ID}'")
            # This just gets the model class/config, doesn't make a call unless get_model itself does.
            # For a true health check, you might try a very short, non-streaming test call if feasible.
            default_model_instance = llm.get_model( 
                provider_id=config.DEFAULT_LLM_PROVIDER_ID,
                model_id=config.DEFAULT_LLM_MODEL_ID
                # No API key or base URL here, assumes system config if needed by default model
            )
            if default_model_instance:
                print("Default LLM model configuration seems accessible at startup.")
                # To test further, you might try creating a chain:
                # llm.create_chain(config.DEFAULT_LLM_PROVIDER_ID, config.DEFAULT_LLM_MODEL_ID, memory_loader_func=lambda: [])
                # print("Default LLM chain creation test successful.")
            else:
                print(f"CRITICAL WARNING: Could not get default LLM model instance (Provider: {config.DEFAULT_LLM_PROVIDER_ID}, Model: {config.DEFAULT_LLM_MODEL_ID}). Check LLM config and server environment.")
        else:
            print("INFO: No default LLM provider/model ID configured for startup check.")
    except Exception as e_llm_startup:
        print(f"CRITICAL ERROR during startup default LLM check: {e_llm_startup}")
        traceback.print_exc()


# Static file mounting
# Ensure config.STATIC_DIR is an absolute path or correctly relative to the app's root.
if not isinstance(config.STATIC_DIR, Path) or not config.STATIC_DIR.is_dir():
    # Try to resolve if it's a string relative to the current file's directory
    current_file_dir = Path(__file__).parent
    potential_static_dir = (current_file_dir / str(config.STATIC_DIR)).resolve()
    if potential_static_dir.is_dir():
        # Correct config.STATIC_DIR to be the resolved Path object
        # This assumes config.py might define STATIC_DIR as a relative string.
        # It's better if config.py defines it as an absolute Path.
        print(f"Warning: config.STATIC_DIR was not a valid Path object. Resolved '{config.STATIC_DIR}' to '{potential_static_dir}'. Consider defining STATIC_DIR as a Path in config.py.")
        # config.STATIC_DIR = potential_static_dir # This would modify config module, be careful.
        # Better to use the resolved path directly for mounting.
        _resolved_static_dir = potential_static_dir
    else:
        print(f"CRITICAL ERROR: Base static directory invalid or not found: '{config.STATIC_DIR}' (also checked '{potential_static_dir}'). Application may not serve frontend assets correctly.")
        # sys.exit(1) # Exiting might be too drastic if other parts can run.
        _resolved_static_dir = None # Signal that static serving might fail
else:
    _resolved_static_dir = config.STATIC_DIR


if _resolved_static_dir:
    dist_dir = _resolved_static_dir / "dist"
    if not dist_dir.is_dir():
        print(f"WARNING: Bundled assets directory not found: '{dist_dir}'. Ensure frontend assets are built (e.g., 'npm run build' or similar) and placed in the 'dist' subdirectory of your static path.")
        # Frontend might not work correctly.
    else:
        try:
            app.mount("/dist", StaticFiles(directory=dist_dir, html=False), name="dist_assets") # html=False for /dist unless it serves an index.html
            print(f"Mounted bundled assets from '{dist_dir}' at '/dist'")
        except Exception as e_mount_dist:
            print(f"ERROR mounting /dist static files from '{dist_dir}': {e_mount_dist}")

    # Mount the root static directory itself for files like login.html, _sidebar.html, etc.
    # This should come AFTER more specific mounts if there are overlaps (though /static and /dist are usually distinct).
    try:
        # If login.html, etc., are directly in STATIC_DIR and not served by specific routes.
        # However, we are serving login.html, etc., via specific routes now to inject CSRF.
        # So, this mount is for other assets like CSS (if not in /dist), JS helpers (app-ui.js), images.
        app.mount("/static", StaticFiles(directory=_resolved_static_dir, html=True), name="static_general") # html=True if it can serve index.html from subdirs
        print(f"Mounted general static files from '{_resolved_static_dir}' at '/static'")
    except Exception as e_mount_static:
        print(f"ERROR mounting /static general files from '{_resolved_static_dir}': {e_mount_static}")
else:
    print("CRITICAL: Static directory not resolved. Static file serving will likely fail.")


# Print registered routes (useful for debugging, should be near the end)
if config.DEBUG_MODE: # Only print in debug mode
    print("\n---- FastAPI Registered Routes (End of Module Definition) ----")
    for route_item in app.routes:
        if hasattr(route_item, "path"):
            methods_str = ", ".join(sorted(list(getattr(route_item, 'methods', {})))) or ( "WS" if isinstance(route_item, WebSocket) else "N/A")
            route_name = getattr(route_item, 'name', 'N/A')
            print(f"  Path: {route_item.path}, Name: {route_name}, Methods: {{{methods_str}}}")
    print("-------------------------------\n")

=== app/models.py ===
from pydantic import BaseModel, Field, EmailStr, StringConstraints, HttpUrl
from pydantic_settings import BaseSettings
from typing import Optional, List, Dict, Any, Annotated

class LLMAvailableModel(BaseModel):
    model_id: str
    display_name: str
    context_window: Optional[int] = None

class LLMProviderDetail(BaseModel):
    id: str
    display_name: str
    type: str
    is_system_configured: bool
    needs_api_key_from_user: bool
    can_accept_user_api_key: bool
    can_accept_user_base_url: bool
    available_models: List[LLMAvailableModel]

class UserLLMSettingsResponse(BaseModel):
    selected_llm_provider_id: Optional[str] = None
    selected_llm_model_id: Optional[str] = None
    has_user_api_key: bool = False
    selected_llm_base_url: Optional[HttpUrl] = None

class UserLLMSettingsUpdateRequest(BaseModel):
    selected_llm_provider_id: Optional[str] = Field(None, description="ID of the selected LLM provider (e.g., 'ollama_local'). Use null to clear.")
    selected_llm_model_id: Optional[str] = Field(None, description="ID of the selected model (e.g., 'qwen2:7b-instruct-q4_K_M'). Use null to clear if provider allows.")
    user_llm_api_key: Optional[str] = Field(None, description="User-provided API key. Will be encrypted. Send empty string or null to clear.")
    selected_llm_base_url: Optional[HttpUrl] = Field(None, description="User-defined base URL. Send empty string or null to clear.")

class Token(BaseModel):
    access_token: str
    token_type: str
    user_id: Optional[int] = None
    user_name: Optional[str] = None
    user_email: Optional[EmailStr] = None

class UserResponseModel(BaseModel):
    id: int
    name: str
    email: EmailStr

class EmailCheckRequest(BaseModel):
    email: EmailStr

class EmailCheckResponse(BaseModel):
    exists: bool
    user_name: Optional[str] = None

class RegistrationRequest(BaseModel):
    email: EmailStr
    name: Annotated[str, StringConstraints(strip_whitespace=True, min_length=1, max_length=100)]

class RegistrationResponse(BaseModel):
    message: str

class ForgotPasswordRequest(BaseModel):
    email: EmailStr

class ForgotPasswordResponse(BaseModel):
    message: str

class UpdateNameRequest(BaseModel):
    new_name: Annotated[str, StringConstraints(strip_whitespace=True, min_length=1, max_length=100)]
    current_password: str = Field(..., min_length=1)

class UpdateNameResponse(BaseModel):
    message: str
    new_name: str

class RegeneratePasswordRequest(BaseModel):
    current_password: str = Field(..., min_length=1, description="The user's current password for verification.")

class RegeneratePasswordResponse(BaseModel):
    message: str

class UpdateEmailRequest(BaseModel):
    new_email: EmailStr
    current_password: str = Field(..., min_length=1, description="The user's current password for verification.")

class UpdateEmailResponse(BaseModel):
    message: str
    new_email: EmailStr

class SessionUpdateRequest(BaseModel):
    name: Annotated[str, StringConstraints(strip_whitespace=True, min_length=1, max_length=100)]

class SessionResponseModel(BaseModel):
    id: str
    name: Optional[str] = None
    created_at: Optional[str] = None
    last_active: Optional[str] = None
    host_user_id: Optional[int] = None

class SessionListContainerResponse(BaseModel):
    sessions: List[SessionResponseModel]

class MessageItem(BaseModel):
    id: int
    session_id: str
    user_id: Optional[int] = None
    sender_name: Optional[str] = None
    sender_type: str
    content: str
    client_id_temp: Optional[str] = None
    thinking_content: Optional[str] = None
    timestamp: str
    turn_id: Optional[int] = None
    model_provider_id: Optional[str] = None
    model_id: Optional[str] = None

class MessageListContainerResponse(BaseModel):
    messages: List[MessageItem]

=== app/state.py ===
# app/state.py

import asyncio
import json
import sqlite3
import datetime
from langchain.memory import ConversationBufferMemory # Ensure this import is correct for your LangChain version
from langchain_core.messages import messages_from_dict, messages_to_dict
from typing import Dict, Any, Optional
from . import database
import traceback # For detailed error logging

# In-memory cache for client-specific conversation memory
client_memory: Dict[str, ConversationBufferMemory] = {}

# For managing Docker code execution containers (if still used, otherwise can be removed if Docker utils are separate)
running_containers: Dict[str, Dict[str, Any]] = {} 
running_containers_lock = asyncio.Lock()

# For managing active AI streaming tasks to allow stopping them
active_ai_streams: Dict[str, asyncio.Event] = {}
active_ai_streams_lock = asyncio.Lock() # Lock for safe concurrent access to active_ai_streams

def get_memory_for_client(session_id: str) -> ConversationBufferMemory:
    """
    Retrieves or creates ConversationBufferMemory for a specific session_id.
    Loads from DB if available, otherwise creates a new one.
    """
    global client_memory
    if session_id in client_memory:
        # Return from in-memory cache if available
        return client_memory[session_id]

    # Attempt to load from database
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            "SELECT memory_state_json FROM session_memory_state WHERE session_id = ?",
            (session_id,)
        )
        row = cursor.fetchone()

        if row and row["memory_state_json"]:
            try:
                memory_data_list = json.loads(row["memory_state_json"]) # Expecting a list of message dicts
                if isinstance(memory_data_list, list):
                    # Create a new memory instance
                    memory_instance = ConversationBufferMemory(
                        return_messages=True, 
                        memory_key="history" # Default memory key for ConversationBufferMemory
                    )
                    # Load messages into the new instance
                    loaded_messages = messages_from_dict(memory_data_list)
                    memory_instance.chat_memory.messages = loaded_messages
                    
                    client_memory[session_id] = memory_instance # Store in cache
                    print(f"STATE: Memory loaded from DB for session {session_id}")
                    return memory_instance
                else:
                    # Log if the stored JSON is not in the expected list format
                    print(f"STATE WARNING: Memory data for session {session_id} is not a list. Creating new memory.")
            except (json.JSONDecodeError, TypeError, Exception) as e:
                # Catch errors during JSON loading or message reconstruction
                print(f"STATE ERROR: Failed to load/parse memory for session {session_id} from DB: {e}")
                traceback.print_exc() # Log full traceback for debugging
                # Fall through to create new memory if parsing fails
    except sqlite3.Error as db_err:
        # Catch database errors during the query
        print(f"STATE DB ERROR: Could not query session_memory_state for session {session_id}: {db_err}")
        traceback.print_exc() # Log full traceback
        # Fall through to create new memory if DB query fails
    finally:
        if conn:
            conn.close()

    # If not found in cache or DB, or if loading failed, create and cache new memory
    print(f"STATE: Creating new memory for session {session_id}")
    new_memory = ConversationBufferMemory(return_messages=True, memory_key="history")
    client_memory[session_id] = new_memory
    return new_memory

def save_memory_state_to_db(session_id: str, memory: Optional[ConversationBufferMemory]):
    """
    Saves the current state of the ConversationBufferMemory to the database for a given session_id.
    Includes detailed logging for debugging.
    """
    if not memory:
        print(f"STATE WARNING (save_memory): Attempted to save null memory for session {session_id}. Skipping.")
        return

    conn = None
    print(f"STATE ATTEMPT (save_memory): Saving memory state to DB for session {session_id}.")
    try:
        # Get messages from LangChain memory object
        messages = memory.chat_memory.messages
        # Convert messages to a list of dictionaries suitable for JSON serialization
        memory_state_list = messages_to_dict(messages) 
        memory_state_json = json.dumps(memory_state_list) # Serialize the list to a JSON string
        
        current_time_utc = datetime.datetime.now(datetime.timezone.utc).isoformat()

        conn = database.get_db_connection()
        cursor = conn.cursor()
        print(f"STATE PRE-EXECUTE (save_memory): About to execute INSERT OR REPLACE for session {session_id}.")
        cursor.execute(
            """
            INSERT OR REPLACE INTO session_memory_state 
            (session_id, memory_state_json, updated_at) 
            VALUES (?, ?, ?)
            """,
            (session_id, memory_state_json, current_time_utc)
        )
        print(f"STATE POST-EXECUTE (save_memory): SQL executed for session {session_id}.")
        conn.commit()
        print(f"STATE SUCCESS (save_memory): Memory saved and committed to DB for session {session_id}.")
    except json.JSONDecodeError as json_err: 
        print(f"STATE JSON ERROR (save_memory): Failed to serialize memory for session {session_id}: {json_err}")
        traceback.print_exc()
        if conn:
            conn.rollback()
    except sqlite3.Error as db_err: 
        print(f"STATE DB ERROR (save_memory): Failed to save memory state to DB for session {session_id}: {db_err}")
        traceback.print_exc()
        if conn:
            conn.rollback()
    except Exception as e: 
        print(f"STATE UNEXPECTED ERROR (save_memory): Failed to save memory state for session {session_id}: {e}")
        traceback.print_exc()
        if conn:
            conn.rollback()
    finally:
        if conn:
            conn.close()
            print(f"STATE FINALLY (save_memory): DB connection closed for session {session_id}.")

def remove_memory_for_client(session_id: str):
    """Removes memory for a specific session_id from the in-memory cache."""
    global client_memory
    if session_id in client_memory:
        del client_memory[session_id]
        print(f"STATE: Memory removed from cache for session {session_id}")

# --- Functions to manage AI stream stop events ---
async def register_ai_stream(stream_id: str) -> asyncio.Event:
    """
    Registers a new AI stream and returns an event to signal its stopping.
    """
    async with active_ai_streams_lock:
        if stream_id in active_ai_streams:
            print(f"STATE WARNING: Stream ID {stream_id} already registered. Overwriting stop event.")
        stop_event = asyncio.Event()
        active_ai_streams[stream_id] = stop_event
        print(f"STATE: AI stream {stream_id} registered for stopping.")
        return stop_event

async def unregister_ai_stream(stream_id: str):
    """
    Unregisters an AI stream, typically when it finishes or is stopped.
    """
    async with active_ai_streams_lock:
        if stream_id in active_ai_streams:
            del active_ai_streams[stream_id]
            print(f"STATE: AI stream {stream_id} unregistered.")
        else:
            print(f"STATE WARNING: Attempted to unregister non-existent AI stream {stream_id}.")

async def signal_stop_ai_stream(stream_id: str) -> bool:
    """
    Sets the stop event for a given AI stream ID, if it exists.
    Returns True if signaled, False otherwise.
    """
    async with active_ai_streams_lock:
        stop_event = active_ai_streams.get(stream_id)
        if stop_event:
            stop_event.set()
            print(f"STATE: Stop signal sent to AI stream {stream_id}.")
            return True
        else:
            print(f"STATE WARNING: Attempted to signal stop for non-existent AI stream {stream_id}.")
            return False


=== app/temp.py ===
# app/main.py

import os
import sys
import uvicorn
import webbrowser
import traceback
from pathlib import Path
import asyncio
import json
import sqlite3
import uuid
from urllib.parse import urlparse
import datetime
from typing import Optional, Dict, Any, List

from fastapi import (
    FastAPI,
    Request,
    HTTPException,
    WebSocket,
    WebSocketDisconnect,
    Form,
    Depends,
    Response as FastAPIResponse,
    Path as FastApiPath,
    Body,
    status
)
from fastapi.responses import HTMLResponse, FileResponse, RedirectResponse, JSONResponse
from fastapi.security import OAuth2PasswordRequestForm
from fastapi.staticfiles import StaticFiles
from fastapi.websockets import WebSocketState

from pydantic import HttpUrl

from fastapi_csrf_protect import CsrfProtect
from fastapi_csrf_protect.exceptions import CsrfProtectError

from . import config
from . import state
from . import llm
from . import docker_utils
from . import utils
from . import database
from . import auth
from . import email_utils
from . import models # models.CsrfSettings will no longer be directly used by load_config
from . import encryption_utils

app = FastAPI(title="Tesseracs Chat")

@CsrfProtect.load_config
def get_csrf_config():
    csrf_secret = os.getenv("CSRF_PROTECT_SECRET_KEY")
    if not csrf_secret:
        print("CRITICAL WARNING: CSRF_PROTECT_SECRET_KEY is not set in the environment. Using a default, insecure key. Please set a strong, unique key.")
        csrf_secret = "your-default-csrf-protect-secret-key-here" # Fallback, but a warning is printed
    elif csrf_secret == "your-default-csrf-protect-secret-key-here":
         print("WARNING: Using default CSRF_PROTECT_SECRET_KEY. Please set a strong, unique key in your environment (e.g., .env file).")

    return [
        ("secret_key", csrf_secret),
        ("cookie_key", "fastapi-csrf-token"), # Default, but explicit
        ("header_name", "X-CSRF-Token")      # Default, but explicit
    ]

@app.exception_handler(CsrfProtectError)
async def csrf_protect_exception_handler(request: Request, exc: CsrfProtectError):
    return JSONResponse(
        status_code=exc.status_code,
        content={"detail": exc.message}
    )

@app.on_event("startup")
async def startup_event():
    print("Application startup: Initializing database...")
    database.DATABASE_PATH.parent.mkdir(parents=True, exist_ok=True)
    database.init_db()
    print("Database initialization check complete.")

    docker_client = None
    try:
        docker_client = docker_utils.get_docker_client()
        if docker_client is None:
            print("WARNING: Could not connect to Docker daemon via get_docker_client(). Code execution features will be disabled.")
        else:
            print("Docker client confirmed available at startup.")
    except Exception as e:
        print(f"WARNING: Could not connect to Docker daemon: {e}")
        print("Code execution via Docker will be unavailable.")

    try:
        print(f"Attempting to initialize default LLM: Provider='{config.DEFAULT_LLM_PROVIDER_ID}', Model='{config.DEFAULT_LLM_MODEL_ID}'")
        default_model_instance = llm.get_model(
            provider_id=config.DEFAULT_LLM_PROVIDER_ID,
            model_id=config.DEFAULT_LLM_MODEL_ID
        )
        if default_model_instance:
            print("Default LLM model connection checked successfully.")
        else:
            print(f"CRITICAL WARNING: Could not initialize default LLM (Provider: {config.DEFAULT_LLM_PROVIDER_ID}, Model: {config.DEFAULT_LLM_MODEL_ID}). Check LLM config and server.")
    except Exception as e:
        print(f"CRITICAL ERROR during startup default LLM check: {e}")

if not config.STATIC_DIR or not config.STATIC_DIR.is_dir():
    print(f"CRITICAL ERROR: Base static directory invalid or not found: {config.STATIC_DIR}")
    sys.exit(1)
dist_dir = config.STATIC_DIR / "dist"
if not dist_dir.is_dir():
    print(f"CRITICAL ERROR: Bundled assets directory not found: {dist_dir}. Ensure frontend assets are built (e.g., 'npm run build').")
    sys.exit(1)
app.mount("/dist", StaticFiles(directory=dist_dir), name="dist_assets")
app.mount("/static", StaticFiles(directory=config.STATIC_DIR), name="static_pages")
print(f"Mounted bundled assets from '{dist_dir}' at '/dist'")
print(f"Mounted static pages directory '{config.STATIC_DIR}' at '/static'")


@app.put("/api/me/llm-settings", response_model=models.UserLLMSettingsResponse, tags=["User Account Management", "LLM Configuration"])
async def update_user_llm_settings(
    request: Request,
    settings_update: models.UserLLMSettingsUpdateRequest,
    current_user: Dict[str, Any] = Depends(auth.get_current_active_user),
    csrf_protect: CsrfProtect = Depends()
):
    await csrf_protect.validate_csrf(request)
    user_id = current_user["id"]
    conn = None

    if settings_update.selected_llm_provider_id:
        provider_config_info = config.LLM_PROVIDERS.get(settings_update.selected_llm_provider_id)
        if not provider_config_info:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"Invalid provider ID: {settings_update.selected_llm_provider_id}")
        
        if settings_update.selected_llm_model_id:
            model_found = any(
                model.get("model_id") == settings_update.selected_llm_model_id
                for model in provider_config_info.get("available_models", [])
            )
            if not model_found:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Model ID '{settings_update.selected_llm_model_id}' not found for provider '{settings_update.selected_llm_provider_id}'."
                )
        elif provider_config_info.get("available_models"):
                raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="If a provider is selected, a model ID must also be selected.")

    encrypted_api_key_to_store: Optional[str] = None
    if settings_update.user_llm_api_key is not None: 
        if settings_update.user_llm_api_key == "": 
            encrypted_api_key_to_store = None
        else:
            if not config.APP_SECRET_KEY:
                raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Server configuration error: Cannot save API key securely.")
            encrypted_api_key_to_store = encryption_utils.encrypt_data(settings_update.user_llm_api_key)
            if not encrypted_api_key_to_store:
                raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to encrypt API key. Check server logs.")
    
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            "SELECT selected_llm_provider_id, selected_llm_model_id, user_llm_api_key_encrypted, selected_llm_base_url FROM users WHERE id = ?",
            (user_id,)
        )
        current_db_settings = cursor.fetchone()
        if not current_db_settings:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found for settings update.")

        final_provider_id = settings_update.selected_llm_provider_id if settings_update.selected_llm_provider_id is not None else current_db_settings["selected_llm_provider_id"]
        final_model_id = settings_update.selected_llm_model_id if settings_update.selected_llm_model_id is not None else current_db_settings["selected_llm_model_id"]
        
        if settings_update.user_llm_api_key is not None:
            final_api_key_encrypted = encrypted_api_key_to_store
        else: 
            final_api_key_encrypted = current_db_settings["user_llm_api_key_encrypted"]

        final_base_url_str: Optional[str] = None
        if settings_update.selected_llm_base_url is not None: 
            if not settings_update.selected_llm_base_url : 
                final_base_url_str = None
            else: 
                final_base_url_str = str(settings_update.selected_llm_base_url)
        else: 
            final_base_url_str = current_db_settings["selected_llm_base_url"]

        if settings_update.selected_llm_provider_id and settings_update.selected_llm_provider_id != current_db_settings["selected_llm_provider_id"]:
            new_provider_config = config.get_provider_config(settings_update.selected_llm_provider_id)
            if new_provider_config:
                if new_provider_config.get("type") == "ollama":
                    if settings_update.user_llm_api_key is None: 
                        final_api_key_encrypted = None
                    if settings_update.selected_llm_base_url is None: 
                        final_base_url_str = None
        
        if final_provider_id is None: 
            final_model_id = None
            final_api_key_encrypted = None
            final_base_url_str = None

        cursor.execute(
            """UPDATE users SET
                selected_llm_provider_id = ?,
                selected_llm_model_id = ?,
                user_llm_api_key_encrypted = ?,
                selected_llm_base_url = ?
                WHERE id = ?""",
            (final_provider_id, final_model_id, final_api_key_encrypted, final_base_url_str, user_id)
        )
        conn.commit()

        has_user_api_key_after_update = bool(final_api_key_encrypted)
        if final_api_key_encrypted and config.APP_SECRET_KEY: 
            decrypted_check = encryption_utils.decrypt_data(final_api_key_encrypted)
            has_user_api_key_after_update = bool(decrypted_check)
        elif final_api_key_encrypted and not config.APP_SECRET_KEY:
            has_user_api_key_after_update = False 

        updated_base_url_obj: Optional[HttpUrl] = None
        if final_base_url_str:
            try: updated_base_url_obj = HttpUrl(final_base_url_str)
            except ValueError: pass
        
        return models.UserLLMSettingsResponse(
            selected_llm_provider_id=final_provider_id,
            selected_llm_model_id=final_model_id,
            has_user_api_key=has_user_api_key_after_update,
            selected_llm_base_url=updated_base_url_obj
        )
    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error updating LLM settings.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Unexpected server error updating LLM settings.")
    finally:
        if conn:
            conn.close()

@app.post("/api/me/regenerate-password", response_model=models.RegeneratePasswordResponse, tags=["User Account Management"])
async def regenerate_user_password(
    request: Request,
    payload: models.RegeneratePasswordRequest = Body(...),
    current_user: Dict[str, Any] = Depends(auth.get_current_active_user),
    csrf_protect: CsrfProtect = Depends()
):
    await csrf_protect.validate_csrf(request)
    user_id = current_user.get("id")
    user_email = current_user.get("email")
    user_name = current_user.get("name")
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT password_hash FROM users WHERE id = ? AND email = ?", (user_id, user_email))
        user_record = cursor.fetchone()
        if not user_record:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User record not found. Please try logging out and back in.")
        stored_password_hash = user_record["password_hash"]
        if not stored_password_hash:
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Cannot verify password due to an account data issue. Please contact support.")
        if not auth.verify_password(payload.current_password, stored_password_hash):
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect current password.")
        new_plain_password = database.generate_secure_token(12)
        new_hashed_password = auth.get_password_hash(new_plain_password)
        cursor.execute("UPDATE users SET password_hash = ? WHERE id = ?", (new_hashed_password, user_id))
        if cursor.rowcount == 0:
            conn.rollback()
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to update password due to a server error.")
        login_url_from_fastapi = str(request.url_for('get_login_page_route'))
        parsed_url_from_fastapi = urlparse(login_url_from_fastapi)
        login_path_component = parsed_url_from_fastapi.path
        if parsed_url_from_fastapi.query:
            login_path_component += "?" + parsed_url_from_fastapi.query
        login_page_url = f"{config.BASE_URL.rstrip('/')}{login_path_component}"
        email_sent = await email_utils.send_password_reset_email(
            recipient_email=user_email, recipient_name=user_name, new_password=new_plain_password, login_url=login_page_url
        )
        if not email_sent:
            conn.rollback()
            raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail="Password was reset, but failed to send the notification email. Please try again.")
        now_utc_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        cursor.execute(
            "UPDATE auth_tokens SET used_at = ?, expires_at = ? WHERE user_id = ? AND token_type = 'session' AND used_at IS NULL",
            (now_utc_iso, now_utc_iso, user_id)
        )
        conn.commit()
        return models.RegeneratePasswordResponse(
            message="Password regenerated successfully. An email has been sent with your new password. You should now log out and log back in with the new password."
        )
    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error while regenerating password.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred.")
    finally:
        if conn: conn.close()

@app.patch("/api/me/update-email", response_model=models.UpdateEmailResponse, tags=["User Account Management"])
async def update_user_email(
    request: Request,
    payload: models.UpdateEmailRequest = Body(...),
    current_user: Dict[str, Any] = Depends(auth.get_current_active_user),
    csrf_protect: CsrfProtect = Depends()
):
    await csrf_protect.validate_csrf(request)
    user_id = current_user.get("id")
    current_email_for_logging = current_user.get("email")
    new_email_normalized = payload.new_email.lower().strip()
    if new_email_normalized == current_email_for_logging:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="New email address is the same as the current one.")
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT password_hash FROM users WHERE id = ?", (user_id,))
        user_record = cursor.fetchone()
        if not user_record:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User record not found. Please try logging out and back in.")
        stored_password_hash = user_record["password_hash"]
        if not stored_password_hash:
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Cannot verify password due to an account data issue. Please contact support.")
        if not auth.verify_password(payload.current_password, stored_password_hash):
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect current password.")
        cursor.execute("SELECT id FROM users WHERE email = ? AND id != ?", (new_email_normalized, user_id))
        if cursor.fetchone():
            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="This email address is already in use by another account.")
        cursor.execute("UPDATE users SET email = ? WHERE id = ?", (new_email_normalized, user_id))
        if cursor.rowcount == 0:
            conn.rollback()
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to update email due to a server error during the update operation.")
        now_utc_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        cursor.execute(
            "UPDATE auth_tokens SET used_at = ?, expires_at = ? WHERE user_id = ? AND token_type = 'session' AND used_at IS NULL",
            (now_utc_iso, now_utc_iso, user_id)
        )
        conn.commit()
        return models.UpdateEmailResponse(
            message="Email updated successfully. You will now be logged out to apply changes.",
            new_email=new_email_normalized
        )
    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="A database error occurred while updating your email.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred while updating your email.")
    finally:
        if conn: conn.close()

@app.patch("/api/me/update-name", response_model=models.UpdateNameResponse, tags=["User Account Management"])
async def update_user_name(
    request: Request,
    update_data: models.UpdateNameRequest = Body(...),
    current_user: Dict[str, Any] = Depends(auth.get_current_active_user),
    csrf_protect: CsrfProtect = Depends()
):
    await csrf_protect.validate_csrf(request)
    user_id = current_user.get("id")
    user_email = current_user.get("email")
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT password_hash FROM users WHERE id = ?", (user_id,))
        user_record = cursor.fetchone()
        if not user_record:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User record not found. Please try logging out and back in.")
        stored_password_hash = user_record["password_hash"]
        if not stored_password_hash:
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Cannot verify password due to an account data issue. Please contact support.")
        if not auth.verify_password(update_data.current_password, stored_password_hash):
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect current password.")
        new_name_stripped = update_data.new_name
        cursor.execute("UPDATE users SET name = ? WHERE id = ?", (new_name_stripped, user_id))
        if cursor.rowcount == 0:
            conn.rollback()
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to update name due to a server error during the update operation.")
        conn.commit()
        return models.UpdateNameResponse(message="Name updated successfully.", new_name=new_name_stripped)
    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="A database error occurred while updating your name.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred while updating your name.")
    finally:
        if conn:
            conn.close()

@app.post("/forgot_password", response_model=models.ForgotPasswordResponse, tags=["Authentication"])
async def handle_forgot_password(
    request_data: models.ForgotPasswordRequest,
    request: Request,
    csrf_protect: CsrfProtect = Depends()
):
    await csrf_protect.validate_csrf(request)
    email = request_data.email.lower().strip()
    client_ip = request.client.host if request.client else None
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        time_window_start = datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(hours=config.FORGOT_PASSWORD_ATTEMPT_WINDOW_HOURS)
        cursor.execute("SELECT COUNT(*) FROM password_reset_attempts WHERE email = ? AND attempted_at >= ?", (email, time_window_start.isoformat()))
        attempt_count_row = cursor.fetchone()
        recent_attempts = attempt_count_row[0] if attempt_count_row else 0
        if recent_attempts >= config.FORGOT_PASSWORD_ATTEMPT_LIMIT:
            return models.ForgotPasswordResponse(message="If an account with this email exists, a password reset email has been sent.")
        cursor.execute("INSERT INTO password_reset_attempts (email, ip_address) VALUES (?, ?)", (email, client_ip))
        cursor.execute("SELECT id, name FROM users WHERE email = ? AND is_active = 1", (email,))
        user_row = cursor.fetchone()
        if not user_row:
            conn.commit() 
            return models.ForgotPasswordResponse(message="If an account with this email exists, a password reset email has been sent.")
        user = dict(user_row)
        user_id = user["id"]
        user_name = user["name"]
        new_plain_password = database.generate_secure_token(12)
        new_hashed_password = auth.get_password_hash(new_plain_password)
        cursor.execute("UPDATE users SET password_hash = ? WHERE id = ?", (new_hashed_password, user_id))
        if cursor.rowcount == 0:
            conn.rollback()
            return models.ForgotPasswordResponse(message="If an account with this email exists, a password reset email has been sent.")
        login_url_from_fastapi = str(request.url_for('get_login_page_route'))
        parsed_url_from_fastapi = urlparse(login_url_from_fastapi)
        login_path_component = parsed_url_from_fastapi.path
        if parsed_url_from_fastapi.query:
            login_path_component += "?" + parsed_url_from_fastapi.query
        login_page_url = f"{config.BASE_URL.rstrip('/')}{login_path_component}"
        email_sent = await email_utils.send_password_reset_email(
            recipient_email=email, recipient_name=user_name, new_password=new_plain_password, login_url=login_page_url
        )
        if not email_sent:
            conn.rollback()
            return models.ForgotPasswordResponse(message="If an account with this email exists, a password reset email has been sent.")
        conn.commit()
        return models.ForgotPasswordResponse(message="If an account with this email exists, a password reset email has been sent.")
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        traceback.print_exc()
        return models.ForgotPasswordResponse(message="An error occurred while processing your request. Please try again.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        return models.ForgotPasswordResponse(message="An unexpected error occurred. Please try again.")
    finally:
        if conn: conn.close()

@app.post("/register", response_model=models.RegistrationResponse, tags=["Authentication"])
async def register_new_user(
    request_data: models.RegistrationRequest,
    request: Request,
    csrf_protect: CsrfProtect = Depends()
):
    await csrf_protect.validate_csrf(request)
    email = request_data.email.lower().strip()
    name = request_data.name.strip()
    if not name: 
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Name cannot be empty.")
    conn = None 
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT id FROM users WHERE email = ?", (email,))
        if cursor.fetchone():
            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Email already registered.")
        plain_password = database.generate_secure_token(12)
        hashed_password = auth.get_password_hash(plain_password)
        cursor.execute(
            "INSERT INTO users (name, email, password_hash, is_active) VALUES (?, ?, ?, ?)",
            (name, email, hashed_password, True)
        )
        user_id = cursor.lastrowid
        if not user_id:
            conn.rollback()
            raise sqlite3.Error("Failed to get lastrowid after user insertion.")
        login_url_from_fastapi = str(request.url_for('get_login_page_route'))
        parsed_url_from_fastapi = urlparse(login_url_from_fastapi)
        login_path_component = parsed_url_from_fastapi.path 
        if parsed_url_from_fastapi.query: 
            login_path_component += "?" + parsed_url_from_fastapi.query
        login_page_url = f"{config.BASE_URL.rstrip('/')}{login_path_component}"
        email_sent = await email_utils.send_registration_password_email(
            recipient_email=email, recipient_name=name, generated_password=plain_password, login_url=login_page_url
        )
        if not email_sent:
            conn.commit() 
            raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail="Account created, but failed to send password email. Please try resetting the password or contact support.")
        conn.commit()
        return models.RegistrationResponse(message="Account created! Your password has been sent to your email.")
    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error during registration.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred during registration.")
    finally:
        if conn: conn.close()

@app.post("/token", response_model=models.Token, tags=["Authentication"])
async def login_for_access_token(
    response: FastAPIResponse,
    form_data: OAuth2PasswordRequestForm = Depends(),
    csrf_protect: CsrfProtect = Depends() 
):
    await csrf_protect.validate_csrf_in_form(form_data) 
    email = form_data.username.lower().strip()
    password = form_data.password
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT id, name, email, password_hash, is_active FROM users WHERE email = ?", (email,))
        user_row = cursor.fetchone()
        if not user_row:
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect email or password.")
        user = dict(user_row)
        stored_password_hash = user.get("password_hash")
        if not stored_password_hash or not auth.verify_password(password, stored_password_hash):
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect email or password.")
        if not user["is_active"]:
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Account is inactive.")
        session_token_raw = await auth.create_user_session(response=response, user_id=user["id"])
        csrf_protect.set_csrf_cookie(response=response) 
        return models.Token(
            access_token=session_token_raw, token_type="bearer",
            user_id=user["id"], user_name=user["name"], user_email=user["email"]
        )
    except HTTPException as http_exc: raise http_exc
    except sqlite3.Error as db_err:
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error during login.")
    except Exception as e:
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Unexpected server error during login.")
    finally:
        if conn: conn.close()

@app.post("/sessions/create", status_code=status.HTTP_303_SEE_OTHER, tags=["Sessions"])
async def create_new_session_route(
    request: Request,
    user: Dict[str, Any] = Depends(auth.get_current_active_user),
    csrf_protect: CsrfProtect = Depends() 
):
    await csrf_protect.validate_csrf(request) 
    if not user:
        raise HTTPException(status_code=401, detail="Not authenticated")
    new_session_id = str(uuid.uuid4())
    host_user_id = user["id"]
    conn = None
    default_session_name = ""
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            """INSERT INTO sessions (id, host_user_id, name, is_active) VALUES (?, ?, ?, ?)""",
            (new_session_id, host_user_id, None, True)
        )
        cursor.execute("SELECT created_at FROM sessions WHERE id = ?", (new_session_id,))
        session_row = cursor.fetchone()
        if not session_row or not session_row["created_at"]:
            default_session_name = f"Session ({new_session_id[:4]})"
        else:
            try:
                created_at_str = session_row["created_at"].replace('Z', '+00:00')
                created_dt = datetime.datetime.fromisoformat(created_at_str)
                default_session_name = created_dt.strftime("%b %d, %Y %I:%M %p")
            except (ValueError, TypeError):
                default_session_name = f"Session ({new_session_id[:4]})"
        cursor.execute("UPDATE sessions SET name = ? WHERE id = ?", (default_session_name, new_session_id))
        cursor.execute(
            "INSERT INTO session_participants (session_id, user_id) VALUES (?, ?)",
            (new_session_id, host_user_id)
        )
        conn.commit()
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Could not create new session due to a database error.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Could not create new session due to a server error.")
    finally:
        if conn: conn.close()
    chat_url = request.url_for("get_chat_page_for_session", session_id=new_session_id)
    return RedirectResponse(url=str(chat_url), status_code=status.HTTP_303_SEE_OTHER)

@app.patch("/api/sessions/{session_id}", response_model=Dict[str, Any], tags=["Sessions"])
async def rename_session(
    request: Request,
    session_id: str = FastApiPath(..., description="The ID of the session to rename."),
    update_data: models.SessionUpdateRequest = Body(...),
    user: Dict[str, Any] = Depends(auth.get_current_active_user),
    csrf_protect: CsrfProtect = Depends()
):
    await csrf_protect.validate_csrf(request)
    if not user: raise HTTPException(status_code=401, detail="Not authenticated")
    user_id = user['id']; new_name = update_data.name.strip()
    if not new_name: raise HTTPException(status_code=400, detail="Session name cannot be empty.")
    conn = None
    try:
        conn = database.get_db_connection(); cursor = conn.cursor()
        cursor.execute(
            """SELECT s.id FROM sessions s JOIN session_participants sp ON s.id = sp.session_id
                WHERE s.id = ? AND sp.user_id = ? AND s.is_active = 1""",
            (session_id, user_id)
        )
        if not cursor.fetchone(): raise HTTPException(status_code=404, detail="Session not found or user lacks permission.")
        cursor.execute("UPDATE sessions SET name = ? WHERE id = ?", (new_name, session_id))
        if cursor.rowcount == 0:
            conn.rollback(); raise HTTPException(status_code=404, detail="Session not found during update.")
        conn.commit()
        return {"id": session_id, "name": new_name, "message": "Session renamed successfully"}
    except sqlite3.Error as db_err:
        if conn: conn.rollback(); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Database error renaming session.")
    except HTTPException as http_exc: raise http_exc
    except Exception as e:
        if conn: conn.rollback(); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Server error renaming session.")
    finally:
        if conn: conn.close()

@app.delete("/api/sessions/{session_id}", status_code=status.HTTP_204_NO_CONTENT, tags=["Sessions"])
async def delete_session_route(
    request: Request,
    session_id: str = FastApiPath(..., description="The ID of the session to delete."),
    user: Dict[str, Any] = Depends(auth.get_current_active_user),
    csrf_protect: CsrfProtect = Depends()
):
    await csrf_protect.validate_csrf(request)
    if not user: raise HTTPException(status_code=401, detail="Not authenticated")
    user_id = user['id']; conn = None
    try:
        conn = database.get_db_connection(); cursor = conn.cursor()
        cursor.execute("SELECT host_user_id FROM sessions WHERE id = ? AND is_active = 1", (session_id,))
        session_row = cursor.fetchone()
        if not session_row: raise HTTPException(status_code=404, detail="Session not found or inactive.")
        if session_row["host_user_id"] != user_id: raise HTTPException(status_code=403, detail="Only the session host can delete it.")
        cursor.execute("DELETE FROM sessions WHERE id = ?", (session_id,))
        if cursor.rowcount == 0:
            conn.rollback(); raise HTTPException(status_code=404, detail="Session found but could not be deleted.")
        conn.commit()
        return
    except sqlite3.Error as db_err:
        if conn: conn.rollback(); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Database error deleting session.")
    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except Exception as e:
        if conn: conn.rollback(); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Server error deleting session.")
    finally:
        if conn: conn.close()

@app.get("/api/llm/providers", response_model=List[models.LLMProviderDetail], tags=["LLM Configuration"])
async def list_llm_providers(
    current_user: Dict[str, Any] = Depends(auth.get_current_active_user)
):
    response_providers = []
    for provider_id, provider_details_from_config_root in config.LLM_PROVIDERS.items():
        provider_runtime_config = config.get_provider_config(provider_id)
        if not provider_runtime_config:
            continue
        requires_api_key_from_config = provider_runtime_config.get("api_key_env_var_name") is not None or provider_id in ["google_gemini", "anthropic_claude", "openai_compatible_server"]
        is_system_key_set = False
        if provider_runtime_config.get("api_key_env_var_name"):
            api_key_env_name = provider_runtime_config.get("api_key_env_var_name")
            if api_key_env_name and os.getenv(api_key_env_name):
                is_system_key_set = True
        is_system_configured = (not requires_api_key_from_config) or (requires_api_key_from_config and is_system_key_set)
        available_models_details = []
        for model_info in provider_details_from_config_root.get("available_models", []):
            available_models_details.append(
                models.LLMAvailableModel(
                    model_id=model_info.get("model_id"),
                    display_name=model_info.get("display_name"),
                    context_window=model_info.get("context_window")
                )
            )
        response_providers.append(
            models.LLMProviderDetail(
                id=provider_id,
                display_name=provider_details_from_config_root.get("display_name", provider_id),
                type=provider_runtime_config.get("type", "unknown"),
                is_system_configured=is_system_configured,
                requires_api_key=requires_api_key_from_config, 
                needs_api_key_config_for_user=requires_api_key_from_config and not is_system_key_set,
                available_models=available_models_details,
            )
        )
    return response_providers

@app.get("/api/me/llm-settings", response_model=models.UserLLMSettingsResponse, tags=["User Account Management", "LLM Configuration"])
async def get_user_llm_settings(
    current_user: Dict[str, Any] = Depends(auth.get_current_active_user)
):
    user_id = current_user["id"]
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            "SELECT selected_llm_provider_id, selected_llm_model_id, user_llm_api_key_encrypted, selected_llm_base_url FROM users WHERE id = ?",
            (user_id,)
        )
        user_settings_row = cursor.fetchone()
        if not user_settings_row:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User settings not found.")
        encrypted_api_key = user_settings_row["user_llm_api_key_encrypted"]
        has_user_api_key = False
        if encrypted_api_key:
            if config.APP_SECRET_KEY: 
                decrypted_key_check = encryption_utils.decrypt_data(encrypted_api_key)
                if decrypted_key_check: 
                    has_user_api_key = True
            else:
                print(f"WARNING: User {user_id} has an encrypted API key stored, but APP_SECRET_KEY is not set. Cannot verify.")
        selected_base_url_str = user_settings_row["selected_llm_base_url"]
        valid_base_url: Optional[HttpUrl] = None
        if selected_base_url_str:
            try:
                valid_base_url = HttpUrl(selected_base_url_str)
            except ValueError:
                print(f"Warning: User {user_id} has an invalid base URL stored: {selected_base_url_str}")
        return models.UserLLMSettingsResponse(
            selected_llm_provider_id=user_settings_row["selected_llm_provider_id"],
            selected_llm_model_id=user_settings_row["selected_llm_model_id"],
            has_user_api_key=has_user_api_key,
            selected_llm_base_url=valid_base_url
        )
    except sqlite3.Error as db_err:
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error retrieving LLM settings.")
    except Exception as e:
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Unexpected server error retrieving LLM settings.")
    finally:
        if conn:
            conn.close()

@app.get("/settings", response_class=FileResponse, name="get_settings_page", tags=["Pages"])
async def get_settings_page(
    request: Request,
    user: Dict[str, Any] = Depends(auth.get_current_active_user),
    csrf_protect: CsrfProtect = Depends() 
):
    if not user:
        return RedirectResponse(url=request.url_for('get_login_page_route'), status_code=status.HTTP_302_FOUND)
    
    settings_html_path = config.STATIC_DIR / "settings.html"
    if not settings_html_path.is_file():
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Settings page HTML file not found.")
    
    response = FileResponse(settings_html_path)
    csrf_protect.set_csrf_cookie(response=response)
    return response


@app.get("/login", response_class=HTMLResponse, name="get_login_page_route", tags=["Pages"])
async def get_login_page_route(
    request: Request, 
    user: Optional[Dict] = Depends(auth.get_current_user),
    csrf_protect: CsrfProtect = Depends() 
):
    if user:
        return RedirectResponse(url=request.url_for("get_session_choice_page"), status_code=status.HTTP_302_FOUND)
    
    login_html_path = config.STATIC_DIR / "login.html"
    if not login_html_path.is_file(): raise HTTPException(status_code=404, detail="login.html not found.")
    
    response = FileResponse(login_html_path)
    csrf_protect.set_csrf_cookie(response=response)
    return response

@app.get("/logout", tags=["Authentication"])
async def logout_route(response: FastAPIResponse, session_token_value: Optional[str] = Depends(auth.cookie_scheme)):
    await auth.logout_user(response, session_token_value)
    csrf_protect = CsrfProtect() 
    csrf_protect.unset_csrf_cookie(response=response) 
    return RedirectResponse(url="/login", status_code=status.HTTP_302_FOUND)

@app.get("/api/me", response_model=models.UserResponseModel, tags=["Users"])
async def get_current_user_details(user: Dict[str, Any] = Depends(auth.get_current_active_user)):
    if not user: raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")
    if not all(key in user for key in ["id", "name", "email"]):
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="User data incomplete.")
    return models.UserResponseModel(id=user["id"], name=user["name"], email=user["email"])

@app.get("/", response_class=HTMLResponse, name="get_session_choice_page", tags=["Pages"])
async def get_session_choice_page(request: Request, user: Optional[Dict] = Depends(auth.get_current_active_user)):
    if not user:
        return RedirectResponse(url="/login", status_code=status.HTTP_302_FOUND)
    session_choice_html_path = config.STATIC_DIR / "session-choice.html"
    if not session_choice_html_path.is_file():
        raise HTTPException(status_code=404, detail="session-choice.html not found.")
    try:
        with open(session_choice_html_path, "r", encoding="utf-8") as f: html_content = f.read()
        html_content = html_content.replace("[User Name]", user.get("name", "User"))
        return HTMLResponse(content=html_content)
    except Exception as e:
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Error loading session choice page.")

@app.get("/chat/{session_id}", response_class=HTMLResponse, name="get_chat_page_for_session", tags=["Pages"])
async def get_chat_page_for_session(
    request: Request,
    session_id: str = FastApiPath(..., description="The ID of the chat session to load."),
    user: Optional[Dict] = Depends(auth.get_current_active_user)
):
    if not user:
        return RedirectResponse(url="/login", status_code=status.HTTP_302_FOUND)
    user_id = user['id']
    conn = None
    try:
        conn = database.get_db_connection(); cursor = conn.cursor()
        cursor.execute("SELECT id, name FROM sessions WHERE id = ? AND is_active = 1", (session_id,))
        session_row = cursor.fetchone()
        if not session_row:
            raise HTTPException(status_code=404, detail="Chat session not found or is inactive.")
        cursor.execute("SELECT 1 FROM session_participants WHERE session_id = ? AND user_id = ?", (session_id, user_id))
        if not cursor.fetchone():
            raise HTTPException(status_code=403, detail="You do not have access to this chat session.")
        current_time_utc_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        cursor.execute("UPDATE sessions SET last_accessed_at = ? WHERE id = ?", (current_time_utc_iso, session_id))
        conn.commit()
    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc();
        raise HTTPException(status_code=500, detail="Error verifying session access.")
    finally:
        if conn: conn.close()
    chat_html_path = config.STATIC_DIR / "chat-session.html"
    if not chat_html_path.is_file():
        raise HTTPException(status_code=404, detail="Chat interface file not found.")
    return FileResponse(chat_html_path)

@app.get("/api/sessions", response_model=List[Dict[str, Any]], tags=["Sessions"])
async def get_user_sessions(
    user: Dict[str, Any] = Depends(auth.get_current_active_user)
):
    if not user: raise HTTPException(status_code=401, detail="Not authenticated")
    user_id = user['id']; sessions_list = []
    conn = None
    try:
        conn = database.get_db_connection(); cursor = conn.cursor()
        cursor.execute(
            """SELECT s.id, s.name, s.last_accessed_at AS last_active
                FROM sessions s JOIN session_participants sp ON s.id = sp.session_id
                WHERE sp.user_id = ? AND s.is_active = 1
                ORDER BY s.last_accessed_at DESC""",
            (user_id,)
        )
        rows = cursor.fetchall()
        for row in rows: sessions_list.append(dict(row))
        return sessions_list
    except sqlite3.Error as db_err:
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Database error fetching sessions.")
    except Exception as e:
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Server error fetching sessions.")
    finally:
        if conn: conn.close()

@app.get("/api/sessions/{session_id}/messages", response_model=List[models.MessageItem], tags=["Messages"])
async def get_chat_messages_for_session(
    session_id: str = FastApiPath(..., description="The ID of the session to fetch messages for."),
    user: Dict[str, Any] = Depends(auth.get_current_active_user)
):
    if not user: raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")
    user_id = user['id']
    messages_list = []
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT 1 FROM sessions WHERE id = ? AND is_active = 1", (session_id,))
        if not cursor.fetchone(): 
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Session not found or inactive.")
        cursor.execute("SELECT 1 FROM session_participants WHERE session_id = ? AND user_id = ?", (session_id, user_id))
        if not cursor.fetchone(): 
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied to this session.")
        cursor.execute(
            """SELECT id, session_id, user_id, sender_name, sender_type, content, client_id_temp, thinking_content, timestamp, turn_id
                FROM chat_messages WHERE session_id = ? ORDER BY timestamp ASC""",
            (session_id,)
        )
        rows = cursor.fetchall()
        for row_data in rows:
            messages_list.append(dict(row_data))
        return messages_list
    except sqlite3.Error as db_err:
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error fetching messages.")
    except HTTPException as http_exc: 
        raise http_exc
    except Exception as e:
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Server error fetching messages.")
    finally:
        if conn: 
            conn.close()

async def handle_chat_message(
    chain: Any, 
    memory: Any, 
    websocket: WebSocket, 
    client_js_id: str,
    current_user: Dict[str, Any], 
    session_id: str, 
    user_input: str, 
    turn_id: int
):
    user_name = current_user.get('name', 'User')
    user_db_id = current_user['id']
    full_response = ""
    thinking_content: Optional[str] = None 
    stream_id = f"{client_js_id}_{turn_id}"  
    stop_event: Optional[asyncio.Event] = None 
    db_conn_user_msg = None
    try:
        db_conn_user_msg = database.get_db_connection()
        db_cursor_user_msg = db_conn_user_msg.cursor()
        db_cursor_user_msg.execute(
            """INSERT INTO chat_messages (session_id, user_id, sender_name, sender_type, content, client_id_temp, turn_id)
                VALUES (?, ?, ?, ?, ?, ?, ?)""",
            (session_id, user_db_id, user_name, 'user', user_input, client_js_id, turn_id)
        )
        db_conn_user_msg.commit()
    except Exception as db_err:
        traceback.print_exc()
        if db_conn_user_msg: db_conn_user_msg.rollback()
    finally:
        if db_conn_user_msg: db_conn_user_msg.close()
    try:
        stop_event = await state.register_ai_stream(stream_id)
        if chain is None:
            error_msg_no_chain = "<ERROR>LLM Error: Chat model not available. Please check server configuration or user settings."
            if websocket.client_state == WebSocketState.CONNECTED:
                await websocket.send_text(error_msg_no_chain)
                await websocket.send_text("<EOS>")
            return 
        async for chunk_data in chain.astream({"input": user_input}):
            if stop_event and stop_event.is_set():
                break  
            chunk_str = ""
            if isinstance(chunk_data, dict): 
                chunk_str = chunk_data.get("answer", "") 
            elif hasattr(chunk_data, 'content'): 
                chunk_str = chunk_data.content
            else: 
                chunk_str = str(chunk_data) 
            if websocket.client_state != WebSocketState.CONNECTED:
                return  
            await websocket.send_text(chunk_str)
            full_response += chunk_str
        if stop_event and stop_event.is_set():
            pass
        elif websocket.client_state == WebSocketState.CONNECTED:
            await websocket.send_text("<EOS>")  
        if memory: 
            memory.save_context({"input": user_input}, {"output": full_response})
            if hasattr(state, 'save_memory_state_to_db'):  
                try: 
                    state.save_memory_state_to_db(session_id, memory)  
                except Exception as save_mem_err: 
                    traceback.print_exc()
        db_conn_ai_msg = None
        try:
            db_conn_ai_msg = database.get_db_connection()
            db_cursor_ai_msg = db_conn_ai_msg.cursor()
            db_cursor_ai_msg.execute(
                """INSERT INTO chat_messages (session_id, user_id, sender_name, sender_type, content, thinking_content, client_id_temp, turn_id)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)""",  
                (session_id, None, "AI", 'ai', full_response, thinking_content, client_js_id, turn_id)
            )
            db_conn_ai_msg.commit()
        except Exception as db_err:
            traceback.print_exc()
            if db_conn_ai_msg: db_conn_ai_msg.rollback()
        finally:
            if db_conn_ai_msg: db_conn_ai_msg.close()
    except Exception as chain_exc:
        error_msg = f"<ERROR>LLM Error: Processing your message failed. Details: {chain_exc}"
        traceback.print_exc()
        if websocket.client_state == WebSocketState.CONNECTED:
            try:
                await websocket.send_text(error_msg)
                await websocket.send_text("<EOS>") 
            except Exception as send_err:
                pass
    finally:
        if stream_id and stop_event:  
            await state.unregister_ai_stream(stream_id)

@app.websocket("/ws/{session_id_ws}/{client_js_id}")
async def websocket_endpoint(
    websocket: WebSocket,
    session_id_ws: str = FastApiPath(..., title="Session ID", description="The ID of the chat session."),
    client_js_id: str = FastApiPath(..., title="Client JS ID", description="A unique ID generated by the client-side JavaScript.")
):
    session_token_from_cookie = websocket.cookies.get(auth.SESSION_COOKIE_NAME)
    current_ws_user: Optional[Dict[str, Any]] = None
    if session_token_from_cookie:
        current_ws_user = await auth.get_user_by_session_token(session_token_from_cookie)
    if not current_ws_user:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return
    user_id = current_ws_user['id']
    conn_verify = None
    try:
        conn_verify = database.get_db_connection()
        cursor_verify = conn_verify.cursor()
        cursor_verify.execute("SELECT 1 FROM sessions WHERE id = ? AND is_active = 1", (session_id_ws,))
        if not cursor_verify.fetchone():
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION); return
        cursor_verify.execute("SELECT 1 FROM session_participants WHERE session_id = ? AND user_id = ?", (session_id_ws, user_id))
        if not cursor_verify.fetchone():
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION); return
    except Exception as e:
        traceback.print_exc()
        await websocket.close(code=status.WS_1011_INTERNAL_ERROR); return
    finally:
        if conn_verify: conn_verify.close()
    try:
        await websocket.accept()
    except Exception as accept_err:
        return 
    selected_provider_id: Optional[str] = None
    selected_model_id: Optional[str] = None
    user_api_key: Optional[str] = None 
    user_base_url: Optional[str] = None
    db_conn_settings = None
    try:
        db_conn_settings = database.get_db_connection()
        cursor_settings = db_conn_settings.cursor()
        cursor_settings.execute(
            "SELECT selected_llm_provider_id, selected_llm_model_id, user_llm_api_key_encrypted, selected_llm_base_url FROM users WHERE id = ?",
            (user_id,)
        )
        user_llm_prefs = cursor_settings.fetchone()
        if user_llm_prefs:
            selected_provider_id = user_llm_prefs["selected_llm_provider_id"]
            selected_model_id = user_llm_prefs["selected_llm_model_id"]
            user_base_url = user_llm_prefs["selected_llm_base_url"] 
            encrypted_key = user_llm_prefs["user_llm_api_key_encrypted"]
            if encrypted_key:
                if config.APP_SECRET_KEY: 
                    user_api_key = encryption_utils.decrypt_data(encrypted_key)
        if not selected_provider_id or not selected_model_id:
            selected_provider_id = config.DEFAULT_LLM_PROVIDER_ID
            selected_model_id = config.DEFAULT_LLM_MODEL_ID
            user_api_key = None 
            user_base_url = None 
    except Exception as e:
        traceback.print_exc()
        selected_provider_id = config.DEFAULT_LLM_PROVIDER_ID
        selected_model_id = config.DEFAULT_LLM_MODEL_ID
        user_api_key = None 
        user_base_url = None 
    finally:
        if db_conn_settings: db_conn_settings.close()
    memory = state.get_memory_for_client(session_id_ws) 
    def load_memory_for_current_session(_ignored_input_map=None):
        return memory.load_memory_variables({}).get("history", [])
    chain: Optional[Any] = None 
    try:
        chain = llm.create_chain(
            provider_id=selected_provider_id, model_id=selected_model_id,
            memory_loader_func=load_memory_for_current_session,
            api_key=user_api_key, base_url_override=user_base_url 
        )
        if not chain:
            raise ValueError(f"LLM chain creation failed for provider '{selected_provider_id}', model '{selected_model_id}'.")
    except Exception as chain_init_error:
        traceback.print_exc()
        if websocket.client_state == WebSocketState.CONNECTED:
            try:
                await websocket.send_json({"type": "error", "payload": {"message": "Server error: Could not initialize chat with the selected model configuration."}})
            except Exception: pass
        if websocket.client_state != WebSocketState.CLOSED :
            await websocket.close(code=status.WS_1011_INTERNAL_ERROR)
        return 
    try:
        while True:
            if websocket.client_state != WebSocketState.CONNECTED:
                break
            received_data = await websocket.receive_text()
            try:
                message_data = json.loads(received_data)
                message_type = message_data.get("type")
                payload = message_data.get("payload")
                if message_type == "chat_message" and payload:
                    user_input = payload.get("user_input")
                    turn_id = payload.get("turn_id") 
                    if user_input is not None and turn_id is not None:
                        asyncio.create_task(
                            handle_chat_message(chain, memory, websocket, client_js_id, current_ws_user, session_id_ws, user_input, turn_id)
                        )
                    else:
                        if websocket.client_state == WebSocketState.CONNECTED:
                            await websocket.send_text("<ERROR>Invalid chat message payload from client.<EOS>")
                elif message_type == "run_code" and payload and payload.get("code_block_id"):
                    language = payload.get("language")
                    code = payload.get("code")
                    code_block_id = payload.get("code_block_id")
                    if language and code is not None:
                        asyncio.create_task(docker_utils.run_code_in_docker_stream(websocket, client_js_id, code_block_id, language, code))
                    else:
                        if websocket.client_state == WebSocketState.CONNECTED:
                            await websocket.send_json({"type": "code_finished", "payload": {"code_block_id": code_block_id, "exit_code": -1, "error": "Invalid run_code payload."}})
                elif message_type == "stop_code" and payload and payload.get("code_block_id"):
                    code_block_id = payload.get("code_block_id")
                    asyncio.create_task(docker_utils.stop_docker_container(code_block_id))
                elif message_type == "stop_ai_stream" and payload:
                    stop_client_id = payload.get("client_id") 
                    stop_session_id = payload.get("session_id") 
                    stop_turn_id = payload.get("turn_id")
                    if stop_client_id == client_js_id and stop_session_id == session_id_ws and stop_turn_id is not None:
                        stream_id_to_stop = f"{stop_client_id}_{stop_turn_id}"
                        await state.signal_stop_ai_stream(stream_id_to_stop)
                else:
                    if websocket.client_state == WebSocketState.CONNECTED:
                        await websocket.send_text(f"<ERROR>Unknown command type: {message_type}<EOS>")
            except json.JSONDecodeError:
                if websocket.client_state == WebSocketState.CONNECTED:
                    await websocket.send_text("<ERROR>Invalid message format. Expected JSON.<EOS>")
            except Exception as handler_exc: 
                traceback.print_exc()
                if websocket.client_state == WebSocketState.CONNECTED:
                    try:
                        await websocket.send_text(f"<ERROR>Server error processing your request: {str(handler_exc)}<EOS>")
                    except Exception: pass
    except WebSocketDisconnect:
        pass
    except Exception as e: 
        traceback.print_exc()
        if websocket.client_state == WebSocketState.CONNECTED:
            try: await websocket.close(code=status.WS_1011_INTERNAL_ERROR)
            except Exception: pass 
    finally:
        await docker_utils.cleanup_client_containers(client_js_id) 
        if websocket.client_state == WebSocketState.CONNECTED:
            try: await websocket.close(code=status.WS_1000_NORMAL_CLOSURE)
            except Exception: pass

def start_server():
    host = os.getenv("HOST", "127.0.0.1")
    port = int(os.getenv("PORT", 8001))
    url = f"http://{host}:{port}"
    print("-" * 30)
    print(f"Tesseracs Chat Server Starting...")
    print(f"Access via: {url}/login")
    print(f"Default LLM: Provider='{config.DEFAULT_LLM_PROVIDER_ID}', Model='{config.DEFAULT_LLM_MODEL_ID}'")
    print(f"Static files from: {config.STATIC_DIR}, Bundles from: {dist_dir}")
    print("-" * 30)
    try:
        webbrowser.open(f"{url}/login")
    except Exception as browser_err:
        print(f"Warning: Could not automatically open browser: {browser_err}")
    uvicorn.run("app.main:app", host=host, port=port, log_level="info", reload=True)

if __name__ == "__main__":
    start_server()


=== app/utils.py ===
# app/utils.py

from fastapi import WebSocket, WebSocketDisconnect
from fastapi.websockets import WebSocketState
import re
import html

def escape_html(s: str) -> str:
    """
    Escapes a string for safe inclusion in HTML, preventing XSS.
    """
    if not isinstance(s, str):
        s = str(s) # Ensure it's a string
    return html.escape(s)

def is_valid_email(email: str) -> bool:
    """
    Validates an email address.
    (This is a basic example, consider a more robust library for production)
    """
    if not email:
        return False
    # Basic regex for email validation
    pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
    if re.match(pattern, email):
        return True
    return False

async def send_ws_message(websocket: WebSocket, message_type: str, payload: dict):
    """Safely sends a JSON message over the WebSocket."""
    # Check state before sending (no change needed here)
    if websocket.client_state != WebSocketState.CONNECTED:
        print(f"[utils] WebSocket not connected, cannot send {message_type} for {payload.get('code_block_id', 'N/A')}")
        return
    try:
        await websocket.send_json({"type": message_type, "payload": payload})
    except WebSocketDisconnect:
        print(f"[utils] WebSocket disconnected while trying to send {message_type} for {payload.get('code_block_id', 'N/A')}")
    except Exception as e:
        # Catch other potential errors like Runtime Error if connection closed during send
        print(f"[utils] Error sending WebSocket message ({message_type}) for {payload.get('code_block_id', 'N/A')}: {e}")
        # traceback.print_exc() # Optional: uncomment for more detail

=== app/static/_sidebar.html ===
<div class="p-4 border-b border-gray-700 flex items-center justify-between">
    <h2 class="text-xl font-semibold text-white">Tesseracs</h2>
    <a href="/" title="Home" aria-label="Home" class="text-gray-400 hover:text-white">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path></svg>
    </a>
</div>

<nav class="flex-1 p-4 space-y-2 sidebar-scrollable" aria-label="Main navigation">
    <form action="/sessions/create" method="POST" class="mb-4" id="new-chat-form-sidebar">
        <input type="hidden" name="csrf_token" id="sidebar_csrf_token">
        
        <button type="submit" id="new-chat-button-sidebar"
                class="w-full flex items-center justify-center px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-md text-white font-medium transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 disabled:opacity-70 disabled:cursor-not-allowed">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
            New Chat
        </button>
    </form>

    <div class="text-sm text-gray-400 uppercase tracking-wider mb-2" id="sessions-heading">Sessions</div>
    <ul id="session-list" class="space-y-1" aria-labelledby="sessions-heading">
        <li class="px-3 py-1 text-gray-400 italic text-sm">Loading sessions...</li>
    </ul>

    <div class="mt-auto pt-4 border-t border-gray-700"> <a href="/settings" id="settings-link-sidebar" class="flex items-center px-3 py-2 text-gray-300 hover:bg-gray-700 hover:text-white rounded-md text-sm">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826 3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
            Settings
        </a>
    </div>
</nav>

<div class="p-4 border-t border-gray-700">
    <a href="/logout" id="logout-link-sidebar" class="flex items-center justify-center w-full px-4 py-2 border border-gray-600 hover:bg-gray-700 rounded-md text-sm font-medium text-gray-300 hover:text-white transition duration-150 ease-in-out">
        Logout
    </a>
</div>

=== app/static/chat-session.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>%%SESSION_NAME_PLACEHOLDER%% - Tesseracs Chat</title>
    <link rel="stylesheet" href="/dist/input.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script id="csrf-token-script-page-chat">
     // This placeholder will be replaced by the server with the actual raw CSRF token.
     window.csrfTokenRaw = "%%CSRF_TOKEN_RAW%%";
    </script>
    <script>
     // Optional immediate diagnostic client-side to verify token injection
     if (typeof window.csrfTokenRaw !== 'undefined' && window.csrfTokenRaw !== "%%CSRF_TOKEN_RAW%%") {
       console.log('CHAT PAGE JS (after csrf-token-script): window.csrfTokenRaw is available.');
     } else {
       console.warn('CHAT PAGE JS (after csrf-token-script): window.csrfTokenRaw IS STILL THE PLACEHOLDER "%%CSRF_TOKEN_RAW%%" OR UNDEFINED. Value:', window.csrfTokenRaw);
     }
    </script>   
    <style>
        .sidebar-scrollable { overflow-y: auto; scrollbar-width: thin; scrollbar-color: #a0aec0 #edf2f7; } /* Tailwind gray-400 and gray-200 */
        .sidebar-scrollable::-webkit-scrollbar { width: 6px; }
        .sidebar-scrollable::-webkit-scrollbar-track { background: #edf2f7; border-radius: 3px; } /* Tailwind gray-200 */
        .sidebar-scrollable::-webkit-scrollbar-thumb { background-color: #a0aec0; border-radius: 3px; border: 1px solid #edf2f7; } /* Tailwind gray-400 and gray-200 */
        
        /* Style for the Stop button */
        #stop-ai-button {
            background-color: #ef4444; /* Tailwind red-500 */
            color: white;
            padding: 0.5rem 1rem; /* py-2 px-4 */
            border-radius: 0.5rem; /* rounded-lg */
            font-weight: bold;
            transition: background-color 0.15s ease-in-out;
            margin-left: 0.5rem; /* space-x-2 equivalent */
        }
        #stop-ai-button:hover {
            background-color: #dc2626; /* Tailwind red-600 */
        }
        #stop-ai-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .hidden {
            display: none !important;
        }
        /* Ensure body and html take full height for the flex container */
        html, body {
            height: 100%;
            margin: 0;
            font-family: 'Inter', sans-serif; /* Use Inter font */
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="flex h-screen overflow-hidden">
        <aside id="sidebar-loader-target" class="w-64 bg-gray-800 text-gray-200 flex flex-col overflow-hidden shrink-0">
            </aside>

        <main class="flex-1 flex flex-col overflow-hidden">
            <header class="bg-white border-b border-gray-200 p-4 shadow-sm">
                <h1 id="chat-session-title" class="text-lg font-semibold text-gray-800 truncate">%%SESSION_NAME_PLACEHOLDER%%</h1>
            </header>
            <div id="chat-history" class="flex-1 overflow-y-auto p-4 space-y-4 bg-white shadow-inner m-2 md:m-4 rounded-lg">
                </div>
            <footer class="p-4 bg-gray-200 border-t border-gray-300">
                <form id="chat-form" class="flex items-center space-x-2">
                    <div class="think-checkbox-container flex items-center text-sm text-gray-600 mr-1 md:mr-2">
                        <input type="checkbox" id="think-checkbox" class="mr-1 h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 cursor-pointer">
                        <label for="think-checkbox" class="cursor-pointer select-none">Think</label>
                    </div>
                    <input type="text" id="message-input" placeholder="Type your message..." autocomplete="off" required
                           class="flex-1 p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                    <button type="submit" id="send-button"
                            class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                        Send
                    </button>
                    <button type="button" id="stop-ai-button" class="hidden"> <svg class="w-5 h-5 inline-block mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1zm4 0a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                        Stop
                    </button>
                </form>
            </footer>
        </main>
    </div>

    <script type="module">
        // Imports loadSidebarHTML and populateSessionList from app-ui.js
        import { loadSidebarHTML, populateSessionList } from '/static/js/app-ui.js'; 

        document.addEventListener('DOMContentLoaded', async () => {
            console.log("Chat Session Page: DOMContentLoaded. Attempting to load UI components.");
            const sidebarContainer = document.getElementById('sidebar-loader-target');
            if (!sidebarContainer) {
                console.error("Chat Session Page: Sidebar container 'sidebar-loader-target' not found!");
                return;
            }
            // Load the sidebar HTML into the designated container.
            // loadSidebarHTML also calls setupSidebarCSRF internally.
            const sidebarLoaded = await loadSidebarHTML('/static/_sidebar.html', 'sidebar-loader-target');
            
            if (sidebarLoaded) {
                // If sidebar loaded, try to populate the session list within it.
                const sessionListElement = document.getElementById('session-list');
                if (sessionListElement) {
                    await populateSessionList('/api/sessions', 'session-list', '/chat/');
                } else {
                    console.error("Chat Session Page: Session list element 'session-list' not found after sidebar load.");
                }
            } else {
                console.error("Chat Session Page: Sidebar loading failed. Session list will not be populated.");
            }
        });
    </script>
    <script src="/dist/script.js" defer></script> 
</body>
</html>


=== app/static/login.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Login - Tesseracs Chat</title>
    <link rel="stylesheet" href="/dist/input.css">
    <script id="csrf-token-script">
      // This placeholder is replaced by the server with the actual raw CSRF token.
      window.csrfTokenRaw = "%%CSRF_TOKEN_RAW%%"; 
    </script>
    <script>
      // Early diagnostic log to check if the CSRF token is injected correctly by the server.
      console.log('JS EARLY DIAGNOSTIC (immediately after csrf-token-script): window.csrfTokenRaw =', "'" + window.csrfTokenRaw + "'", "(Type:", typeof window.csrfTokenRaw + ")");
    </script>
</head>
<body class="flex flex-col justify-center items-center min-h-screen bg-gray-100 font-sans p-4">
    <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-md">
        <h1 class="text-center mb-6 text-2xl font-semibold text-gray-900">Tesseracs Chat</h1>
        <div id="message-area" class="p-3 rounded-md text-sm text-center mb-4" style="display: none;"></div>
        
        <form id="auth-form" class="mt-4">
            <input type="hidden" name="csrf_token" id="csrf_token_form_field">
            
            <div class="mb-5">
                <label for="email" class="block mb-2 text-sm font-medium text-gray-700">Email:</label>
                <input type="email" id="email" name="username" required autocomplete="username" class="block w-full py-2.5 px-3 border border-gray-300 rounded-md text-sm transition-colors duration-200 ease-in-out focus:border-blue-600 focus:ring-2 focus:ring-blue-300 focus:outline-none">
            </div>
            
            <div id="password-field-container" class="mb-5 hidden">
                <label for="password" class="block mb-2 text-sm font-medium text-gray-700">Password:</label>
                <input type="password" id="password" name="password" autocomplete="current-password" class="block w-full py-2.5 px-3 border border-gray-300 rounded-md text-sm transition-colors duration-200 ease-in-out focus:border-blue-600 focus:ring-2 focus:ring-blue-300 focus:outline-none">
                <a href="#" id="forgot-password-link" class="block text-right text-sm text-gray-600 no-underline mt-2 mb-5 hover:text-blue-700 hover:underline hidden">Forgot Password?</a>
            </div>
            
            <div id="name-field-container" class="mb-5 hidden">
                <label for="name" class="block mb-2 text-sm font-medium text-gray-700">Full Name:</label>
                <input type="text" id="name" name="name" autocomplete="name" class="block w-full py-2.5 px-3 border border-gray-300 rounded-md text-sm transition-colors duration-200 ease-in-out focus:border-blue-600 focus:ring-2 focus:ring-blue-300 focus:outline-none">
            </div>
            
            <button type="submit" id="submit-button" class="w-full py-3 bg-blue-600 text-white rounded-md text-sm font-medium cursor-pointer transition-colors duration-200 ease-in-out hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed">Continue</button>
            <button type="button" id="change-email-button" class="block w-auto mt-3 mx-auto py-2 px-4 text-sm text-gray-600 bg-gray-100 border border-gray-300 rounded-md cursor-pointer text-center hover:bg-gray-200 hidden">Change Email / Start Over</button>
        </form>
        
        <p id="form-instructions" class="text-xs text-center mt-6 text-gray-500">
            Enter your email to log in or create an account.
        </p>
    </div>

    <script>
        // Utility function to get a cookie by name. Used for diagnostics or specific needs,
        // but CSRF token for AJAX is primarily handled via window.csrfTokenRaw.
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        // DOM element references
        const authForm = document.getElementById('auth-form');
        const emailInput = document.getElementById('email'); 
        const nameInput = document.getElementById('name');
        const passwordInput = document.getElementById('password');
        const nameFieldContainer = document.getElementById('name-field-container');
        const passwordFieldContainer = document.getElementById('password-field-container');
        const submitButton = document.getElementById('submit-button');
        const messageArea = document.getElementById('message-area');
        const formInstructions = document.getElementById('form-instructions');
        const forgotPasswordLink = document.getElementById('forgot-password-link');
        const changeEmailButton = document.getElementById('change-email-button');
        const csrfTokenFormField = document.getElementById('csrf_token_form_field'); // Hidden input for CSRF token in form
        
        // Placeholder string that the server is supposed to replace with the actual CSRF token.
        const CSRF_ORIGINAL_PLACEHOLDER = ['%', '%CSRF_TOKEN_RAW%', '%'].join('');

        let formState = 'initial_email'; // Manages the current state of the login/registration form
        let cachedEmail = ''; // Stores the email after it's been checked

        // Log the initial CSRF token value when the main script runs.
        console.log('JS MAIN SCRIPT: window.csrfTokenRaw at script start =', "'" + window.csrfTokenRaw + "'", "(Type:", typeof window.csrfTokenRaw + ")");
        console.log('JS MAIN SCRIPT: CSRF_ORIGINAL_PLACEHOLDER =', "'" + CSRF_ORIGINAL_PLACEHOLDER + "'");

        /**
         * Updates the UI elements (input fields, buttons, instructions) based on the current formState.
         */
        function updateUIForState() {
            // Hide all optional sections by default; specific states will unhide them.
            passwordFieldContainer.classList.add('hidden');
            nameFieldContainer.classList.add('hidden');
            forgotPasswordLink.classList.add('hidden');
            changeEmailButton.classList.add('hidden');

            // Reset 'required' attributes; states will set them if needed.
            passwordInput.required = false;
            nameInput.required = false;
            emailInput.readOnly = false; // Email input is generally editable unless a state locks it.
            submitButton.disabled = false; // Submit button is enabled by default.

            // **MODIFICATION**: messageArea is NOT hidden here by default.
            // It will be hidden explicitly by states that require a clean slate (e.g., 'initial_email').
            // Otherwise, messages shown by showMessage() will persist into the new state.

            // Populate the hidden CSRF token field if window.csrfTokenRaw is valid.
            const tokenValue = window.csrfTokenRaw;
            const isTokenValid = tokenValue && typeof tokenValue === 'string' && tokenValue !== CSRF_ORIGINAL_PLACEHOLDER && tokenValue.trim() !== "";

            if (isTokenValid) {
                csrfTokenFormField.value = tokenValue;
            } else {
                csrfTokenFormField.value = ""; // Ensure field is empty if token is invalid.
                console.warn("JS WARN (updateUIForState): window.csrfTokenRaw ('" + tokenValue + "') is not a valid token for form field. Hidden CSRF field set to empty. Is it the original placeholder?", tokenValue === CSRF_ORIGINAL_PLACEHOLDER);
            }

            // Configure UI based on the current state
            switch (formState) {
                case 'initial_email':
                    emailInput.value = ''; 
                    passwordInput.value = '';
                    nameInput.value = '';
                    cachedEmail = '';
                    submitButton.textContent = 'Continue';
                    formInstructions.textContent = 'Enter your email to log in or create an account.';
                    submitButton.disabled = emailInput.value.trim() === ''; // Disable if email is empty
                    emailInput.focus();
                    messageArea.style.display = 'none'; // Explicitly hide message area for this clean state
                    break;
                case 'login_password':
                    passwordFieldContainer.classList.remove('hidden');
                    forgotPasswordLink.classList.remove('hidden');
                    changeEmailButton.classList.remove('hidden');
                    passwordInput.required = true;
                    emailInput.readOnly = true; 
                    emailInput.value = cachedEmail; 
                    submitButton.textContent = 'Login';
                    formInstructions.textContent = 'Enter your password to log in.';
                    passwordInput.value = ''; 
                    submitButton.disabled = true; // Disable until password input
                    passwordInput.focus();
                    // messageArea might still be visible from a previous action if not explicitly hidden
                    break;
                case 'register_name':
                    nameFieldContainer.classList.remove('hidden');
                    changeEmailButton.classList.remove('hidden');
                    nameInput.required = true;
                    emailInput.readOnly = true; 
                    emailInput.value = cachedEmail; 
                    submitButton.textContent = 'Create Account & Send Password';
                    formInstructions.textContent = 'This email is not registered. Enter your name to create an account. A password will be emailed to you.';
                    nameInput.value = '';
                    submitButton.disabled = nameInput.value.trim() === ''; // Disable if name is empty
                    nameInput.focus();
                    // messageArea might still be visible (e.g. if an error occurred before reaching this state)
                    break;
                case 'forgot_password_prompt':
                    emailInput.readOnly = false; 
                    emailInput.value = cachedEmail || ''; 
                    passwordInput.value = '';
                    nameInput.value = '';
                    submitButton.textContent = 'Send Reset Email';
                    formInstructions.textContent = 'Enter your email address to receive a password reset email.';
                    changeEmailButton.classList.remove('hidden'); 
                    submitButton.disabled = emailInput.value.trim() === '';
                    emailInput.focus();
                    // messageArea might be visible from a previous action
                    break;
                case 'login_after_registration':
                case 'login_after_password_reset':
                    emailInput.value = cachedEmail; 
                    emailInput.readOnly = true;
                    passwordFieldContainer.classList.remove('hidden');
                    changeEmailButton.classList.remove('hidden');
                    passwordInput.required = true;
                    submitButton.textContent = 'Login';
                    if (formState === 'login_after_registration') {
                        // The success message from registration (via showMessage) should still be visible here.
                        formInstructions.textContent = 'Account created! Please check your email for the password and enter it below.';
                    } else { 
                        // The success message from password reset (via showMessage) should still be visible.
                        formInstructions.textContent = 'Please check your email for the new password and enter it below.';
                    }
                    passwordInput.value = '';
                    submitButton.disabled = true; // Disable until password input
                    passwordInput.focus();
                    break;
            }
        }

        // Event listeners to enable/disable submit button based on input
        emailInput.addEventListener('input', function() {
            if (formState === 'initial_email' || formState === 'forgot_password_prompt') {
                submitButton.disabled = emailInput.value.trim() === '';
            }
        });
        nameInput.addEventListener('input', function() {
            if (formState === 'register_name') {
                submitButton.disabled = nameInput.value.trim() === '';
            }
        });
        passwordInput.addEventListener('input', function() {
            if (formState === 'login_password' || formState === 'login_after_registration' || formState === 'login_after_password_reset') {
                submitButton.disabled = passwordInput.value.trim() === '';
            }
        });

        // Event listener for "Forgot Password?" link
        forgotPasswordLink.addEventListener('click', (event) => {
            event.preventDefault();
            formState = 'forgot_password_prompt';
            updateUIForState();
            messageArea.style.display = 'none'; // Clear previous messages when switching to forgot password
        });

        // Event listener for "Change Email / Start Over" button
        changeEmailButton.addEventListener('click', (event) => {
            event.preventDefault();
            formState = 'initial_email';
            updateUIForState(); // This will hide messageArea as per 'initial_email' state
        });

        /**
         * Handles form submission for all states (email check, login, registration, forgot password).
         */
        authForm.addEventListener('submit', async function(event) {
            event.preventDefault(); // Prevent default form submission
            messageArea.className = 'p-3 rounded-md text-sm text-center mb-4 border'; // Reset message area classes
            submitButton.disabled = true; // Disable submit button during processing

            const emailForLogic = emailInput.value.trim().toLowerCase();
            const currentRawCsrfToken = window.csrfTokenRaw; 
            
            console.log('JS LOG (Submit Start): currentRawCsrfToken value is:', "'" + currentRawCsrfToken + "'", "(Type:", typeof currentRawCsrfToken + ")");
            const isTokenTheOriginalPlaceholder = currentRawCsrfToken === CSRF_ORIGINAL_PLACEHOLDER;
            console.log('JS LOG (Submit Start): Is currentRawCsrfToken the original placeholder?', isTokenTheOriginalPlaceholder);
            
            const headers = { 
                // Content-Type is set per request type below (JSON or FormData)
            };

            // Set X-CSRF-Token header if the token is valid and not the placeholder.
            if (typeof currentRawCsrfToken === 'string' && !isTokenTheOriginalPlaceholder && currentRawCsrfToken.trim() !== "") {
                headers['X-CSRF-Token'] = currentRawCsrfToken;
            } else {
                console.warn('JS WARN (Submit): X-CSRF-Token header will NOT be set or will be problematic. currentRawCsrfToken:', "'" + currentRawCsrfToken + "'. Is it original placeholder?", isTokenTheOriginalPlaceholder);
                // If CSRF token is missing/invalid, for critical operations, we might stop here.
                // For now, proceeding and letting server handle it, but this is a potential failure point.
            }

            // --- State: Initial Email Check ---
            if (formState === 'initial_email') {
                submitButton.textContent = 'Checking Email...';
                headers['Content-Type'] = 'application/json';
                try {
                    const response = await fetch('/check_email', {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify({ email: emailForLogic })
                    });
                    const result = await response.json();
                    if (response.ok) {
                        cachedEmail = emailForLogic; 
                        formState = result.exists ? 'login_password' : 'register_name';
                        updateUIForState(); 
                        // No explicit message shown here by showMessage, state instructions will guide.
                    } else {
                        showMessage(result, 'error'); 
                        submitButton.textContent = 'Continue'; 
                        submitButton.disabled = emailInput.value.trim() === ''; 
                    }
                } catch (error) {
                    console.error('Email check error:', error);
                    showMessage('Network error or server issue checking email. Please try again.', 'error');
                    submitButton.textContent = 'Continue';
                    submitButton.disabled = emailInput.value.trim() === '';
                }
            } 
            // --- State: Login (Password Submission) ---
            else if (formState === 'login_password' || formState === 'login_after_registration' || formState === 'login_after_password_reset') {
                submitButton.textContent = 'Logging In...';
                const formData = new FormData(authForm); 
                // formData will include email (name="username"), password, and csrf_token (from hidden input)
                // csrfTokenFormField.value is set by updateUIForState()
                console.log('JS LOG (Submit /token): FormData csrf_token field value being sent:', "'" + csrfTokenFormField.value + "'");
                
                // The `headers` object already contains X-CSRF-Token if currentRawCsrfToken was valid.
                // For FormData, fetch sets Content-Type automatically.
                try {
                    const response = await fetch('/token', { 
                        method: 'POST', 
                        headers: headers, // Send X-CSRF-Token header
                        body: formData    // Body is FormData
                    });
                    const result = await response.json(); 
                    if (response.ok) {
                        showMessage('Login successful! Redirecting...', 'success');
                        setTimeout(() => { window.location.href = '/'; }, 1500); // Redirect to dashboard/main page
                    } else {
                        showMessage(result, 'error'); 
                        submitButton.textContent = 'Login';
                        submitButton.disabled = passwordInput.value.trim() === '';
                    }
                } catch (error) { 
                    console.error('Login error:', error);
                    showMessage('Network error or server issue during login. Please try again.', 'error');
                    submitButton.textContent = 'Login';
                    submitButton.disabled = passwordInput.value.trim() === '';
                }
            }
            // --- State: Registration (Name Submission) ---
            else if (formState === 'register_name') {
                submitButton.textContent = 'Creating Account...';
                headers['Content-Type'] = 'application/json';
                const name = nameInput.value.trim();
                try {
                    const response = await fetch('/register', {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify({ email: emailForLogic, name: name }) 
                    });
                    const result = await response.json(); // Expects models.RegistrationResponse
                    if (response.ok) {
                        // `result.message` contains the success string from the server
                        showMessage(result.message, 'success'); // This will show the green banner
                        formState = 'login_after_registration';
                        updateUIForState(); // This will set up the form for password entry
                                            // The success message from showMessage() should remain visible.
                    } else {
                        showMessage(result, 'error'); // `result` would be like {"detail": "error message"}
                        submitButton.textContent = 'Create Account & Send Password';
                        submitButton.disabled = nameInput.value.trim() === '';
                    }
                } catch (error) {
                    console.error('Registration error:', error);
                    showMessage('Network error or server issue during registration. Please try again.', 'error');
                    submitButton.textContent = 'Create Account & Send Password';
                    submitButton.disabled = nameInput.value.trim() === '';
                }
            }
            // --- State: Forgot Password ---
            else if (formState === 'forgot_password_prompt') {
                submitButton.textContent = 'Sending Reset Email...';
                headers['Content-Type'] = 'application/json';
                try {
                    const response = await fetch('/forgot_password', {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify({ email: emailForLogic })
                    });
                    const result = await response.json(); // Expects models.ForgotPasswordResponse
                    showMessage(result.message, response.ok ? 'success' : 'error'); 
                    if (response.ok) {
                        cachedEmail = emailForLogic; 
                        formState = 'login_after_password_reset';
                        updateUIForState(); // Sets up form for new password entry
                                            // The success message from showMessage() should remain.
                    } else {
                        submitButton.textContent = 'Send Reset Email';
                        submitButton.disabled = emailInput.value.trim() === '';
                    }
                } catch (error) {
                    console.error('Forgot password error:', error);
                    // Provide a generic message for security (don't confirm/deny email existence based on network error)
                    showMessage('A network error occurred. If an account with this email exists, a password reset email may have been sent.', 'error');
                    submitButton.textContent = 'Send Reset Email';
                    submitButton.disabled = emailInput.value.trim() === '';
                }
            }
        });

        /**
         * Displays a message (error, success, info) in the messageArea.
         * @param {string|object} messageData - The message string or an error object from the server.
         * @param {string} type - 'info', 'success', or 'error'.
         */
        function showMessage(messageData, type = 'info') { 
            let displayMessage = "An unexpected error occurred.";
            if (typeof messageData === 'string') {
                displayMessage = messageData;
            } else if (typeof messageData === 'object' && messageData !== null) {
                // Handle FastAPI HTTPException detail structure
                if (messageData.detail) {
                    if (typeof messageData.detail === 'string') {
                        displayMessage = messageData.detail;
                    } else if (Array.isArray(messageData.detail) && messageData.detail.length > 0) {
                        // Handle Pydantic validation error arrays
                        displayMessage = messageData.detail.map(err => {
                            let loc = err.loc ? err.loc.join('.') : 'field';
                            return `${loc}: ${err.msg}`;
                        }).join('; ');
                    } else {
                        displayMessage = JSON.stringify(messageData.detail); // Fallback for other detail structures
                    }
                } else if (messageData.message) { // Handle custom success messages like {"message": "..."}
                     displayMessage = messageData.message;
                } else {
                    displayMessage = JSON.stringify(messageData); // Fallback for other object structures
                }
            }
            
            messageArea.textContent = displayMessage;
            messageArea.className = 'p-3 rounded-md text-sm text-center mb-4 border'; // Reset base classes
            if (type === 'error') {
                messageArea.classList.add('text-red-700', 'bg-red-100', 'border-red-300');
            } else if (type === 'success') {
                messageArea.classList.add('text-green-700', 'bg-green-100', 'border-green-300');
            } else { // 'info' or default
                messageArea.classList.add('text-blue-700', 'bg-blue-100', 'border-blue-300');
            }
            messageArea.style.display = 'block'; // Make the message area visible
        }

        // Initialize the UI to the default state when the page loads.
        updateUIForState();
    </script>
</body>
</html>

=== app/static/script.js ===
// --- JS Imports ---
import { marked } from 'marked';
import katex from 'katex';
import Prism from 'prismjs';

// --- Prism Components ---

import 'prismjs/components/prism-clike';
import 'prismjs/components/prism-python';
import 'prismjs/components/prism-javascript';
import 'prismjs/components/prism-css';
import 'prismjs/components/prism-bash';
import 'prismjs/components/prism-json';
import 'prismjs/components/prism-yaml';
import 'prismjs/components/prism-sql';
import 'prismjs/components/prism-java';
import 'prismjs/components/prism-csharp';
import 'prismjs/components/prism-go';
import 'prismjs/components/prism-rust';
import 'prismjs/components/prism-docker';
import 'prismjs/components/prism-typescript';
import 'prismjs/components/prism-c';
import 'prismjs/components/prism-cpp';
// import 'prismjs/components/prism-php'; // not working
// import 'prismjs/components/prism-ruby'; // not working
// --------------------------

// --- Constants and Variables ---
const chatHistory = document.getElementById('chat-history');
const chatForm = document.getElementById('chat-form');
const messageInput = document.getElementById('message-input');
const sendButton = document.getElementById('send-button');
const thinkCheckbox = document.getElementById('think-checkbox');
const stopAiButton = document.getElementById('stop-ai-button');

let websocket;
const clientId = `web-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
let currentTurnId = 0;

const MODE_ANSWER = 'MODE_ANSWER';
const MODE_SEEKING_CODE_LANGUAGE = 'MODE_SEEKING_CODE_LANGUAGE';
const MODE_INSIDE_CODE_BLOCK = 'MODE_INSIDE_CODE_BLOCK';
const MODE_KATEX_BUFFERING_INLINE = 'MODE_KATEX_BUFFERING_INLINE';
const MODE_KATEX_BUFFERING_DISPLAY = 'MODE_KATEX_BUFFERING_DISPLAY';
const MODE_MAYBE_START_DISPLAY_KATEX = 'MODE_MAYBE_START_DISPLAY_KATEX';
const MODE_SEEKING_TAG = 'MODE_SEEKING_TAG';
const MODE_INSIDE_THINK = 'MODE_INSIDE_THINK';
const MODE_MAYBE_END_THINK = 'MODE_MAYBE_END_THINK';
const MODE_SEEKING_CODE_START_FENCE = 'MODE_SEEKING_CODE_START_FENCE';
const MODE_SEEKING_CODE_END_FENCE = 'MODE_SEEKING_CODE_END_FENCE';

let currentProcessingMode = MODE_ANSWER;
let langBuffer = '';
let currentCodeBlockLang = ''; // Stores the language name (e.g., 'python')
let currentCodeBlockElement = null; // The <code> element
let currentCodeBlockPreElement = null; // The <pre> element wrapping the code
let katexBuffer = '';
let currentKatexMarkerId = null;
let thinkBuffer = '';
let tagBuffer = '';
let fenceBuffer = ''; // Added for fence detection
let currentAiTurnContainer = null;
let currentAnswerElement = null;
let currentThinkingArea = null;
let currentThinkingPreElement = null;
let currentCodeBlocksArea = null;
let codeBlockCounterThisTurn = 0;
let thinkingRequestedForCurrentTurn = false;
let accumulatedAnswerText = '';
let lastAppendedNode = null;
let hasThinkingContentArrivedThisTurn = false;
let firstAnswerTokenReceived = false;
var currentUserInfo = null

const FENCE = '```';
const THINK_START_TAG = '<think>';
const THINK_END_TAG = '</think>';
const KATEX_PLACEHOLDER_PREFIX = '%%KATEX_PLACEHOLDER_';
const KATEX_RENDERED_ATTR = 'data-katex-rendered';
const NO_THINK_PREFIX = "\\no_think"
const THINK_PREFIX = "\\think"


function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            // Does this cookie string begin with the name we want?
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

function getSessionIdFromPath() {
    const pathName = window.location.pathname; // Get the path part of the URL (e.g., "/chat/some-session-id")
    const pathParts = pathName.split('/');    // Split the path by "/"
                                            // For "/chat/some-session-id", pathParts will be ["", "chat", "some-session-id"]

    // Check if the path structure is as expected:
    // 1. pathParts.length >= 3 (e.g., "", "chat", "session_id")
    // 2. pathParts[1] is exactly "chat"
    if (pathParts.length >= 3 && pathParts[1] === 'chat') {
        const sessionId = pathParts[2]; // The session ID is the third part
        if (sessionId && sessionId.trim() !== "") { // Ensure it's not empty
            // console.log("Extracted session ID:", sessionId); // Keep for debugging if needed
            return sessionId;
        } else {
            console.error("Session ID extracted from path is empty or invalid.");
            return null;
        }
    }

    // console.log("Not on a chat page or session ID invalid:", pathName); // Keep for debugging if needed
    return null; // Return null if the path doesn't match the expected structure
}


function scrollToBottom(behavior = 'auto') {
    const isNearBottom = chatHistory.scrollHeight - chatHistory.scrollTop - chatHistory.clientHeight < 100;
    if (isNearBottom) {
        requestAnimationFrame(() => {
            chatHistory.scrollTo({ top: chatHistory.scrollHeight, behavior: behavior });
        });
    }
}


function throttle(func, limit) {
    let lastFunc;
    let lastRan;
    return function throttledFunction(...args) {
      const context = this; // Capture the context
      if (!lastRan) {
        // If it hasn't run yet, run it immediately
        func.apply(context, args);
        lastRan = Date.now();
      } else {
        clearTimeout(lastFunc); // Clear any previously scheduled run
        // Schedule the next run after the limit has passed
        lastFunc = setTimeout(function() {
          // Check if enough time has passed since the last execution
          if ((Date.now() - lastRan) >= limit) {
            func.apply(context, args);
            lastRan = Date.now(); // Update the time it last ran
          }
        }, limit - (Date.now() - lastRan)); // Calculate remaining time needed
      }
    };
  }
  

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
};

function getCursorPosition(parentElement) {
    const selection = window.getSelection();
    if (selection.rangeCount === 0) return -1;

    const range = selection.getRangeAt(0);
    if (!parentElement.contains(range.startContainer)) {
        return -1;
    }

    const preSelectionRange = range.cloneRange();
    preSelectionRange.selectNodeContents(parentElement);
    try {
        preSelectionRange.setEnd(range.startContainer, range.startOffset);
    } catch (e) {
        console.error("Error setting preSelectionRange end:", e, "Range:", range);
        return -1;
    }
    return preSelectionRange.toString().length;
}

function setCursorPosition(parentElement, offset) {
    const selection = window.getSelection();
    if (!selection) return;

    const range = document.createRange();
    let charCount = 0;
    let foundStart = false;

    function findNodeAndOffset(node) {
        if (foundStart) return;

        if (node.nodeType === Node.TEXT_NODE) {
            const nextCharCount = charCount + node.length;
            if (!foundStart && offset >= charCount && offset <= nextCharCount) {
                try {
                    const offsetInNode = offset - charCount;
                    range.setStart(node, offsetInNode);
                    foundStart = true;
                } catch (e) {
                    console.error("Error setting range start:", e, "Node:", node, "Offset:", offsetInNode);
                }
            }
            charCount = nextCharCount;
        } else {
            for (let i = 0; i < node.childNodes.length; i++) {
                findNodeAndOffset(node.childNodes[i]);
                if (foundStart) break;
            }
        }
    }

    findNodeAndOffset(parentElement);

    if (foundStart) {
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
    } else {
        range.selectNodeContents(parentElement);
        range.collapse(false);
        selection.removeAllRanges();
        selection.addRange(range);
        console.warn(`Could not set cursor precisely at offset ${offset}. Placed at end.`);
    }
    parentElement.focus();
}


function addUserMessage(text) {
    // Ensure chatHistory and messageInput elements exist to prevent errors
    const chatHistory = document.getElementById('chat-history'); // Re-fetch or ensure it's a reliable global
    const messageInput = document.getElementById('message-input'); // Re-fetch or ensure it's a reliable global

    if (!chatHistory) {
        console.error("addUserMessage: chatHistory element not found.");
        return;
    }
    // messageInput might be null if called from a context where it's not relevant,
    // but usually it's good to have it for checks if needed.

    const messageElement = document.createElement('div');
    messageElement.classList.add('message', 'user-message', 'p-3', 'rounded-lg', 'max-w-xl', 'mb-2', 'break-words', 'flex', 'flex-col', 'bg-emerald-100', 'self-end', 'ml-auto');
    messageElement.setAttribute('data-sender', 'user');

    const senderElem = document.createElement('p');
    senderElem.classList.add('font-semibold', 'text-sm', 'mb-1', 'text-emerald-700');
    let userName = 'User';

    if (typeof window.currentUserInfo === 'object' && window.currentUserInfo !== null && window.currentUserInfo.name) {
        userName = window.currentUserInfo.name;
    }
    senderElem.textContent = escapeHTML(userName); // Assumes escapeHTML is defined
    messageElement.appendChild(senderElem);

    const contentElem = document.createElement('div');
    contentElem.classList.add('text-gray-800', 'text-sm', 'message-content');
    
    let displayedText = text;

    if (typeof NO_THINK_PREFIX === 'string' && displayedText.startsWith(NO_THINK_PREFIX)) {
         displayedText = displayedText.substring(NO_THINK_PREFIX.length);
    }
    else if (typeof THINK_PREFIX === 'string' && displayedText.startsWith(THINK_PREFIX)) {
         displayedText = displayedText.substring(THINK_PREFIX.length);
    }

    contentElem.textContent = displayedText; // Display the cleaned text
    messageElement.appendChild(contentElem);

    const timestampElem = document.createElement('p');
    timestampElem.classList.add('text-xs', 'text-slate-500', 'mt-1', 'text-right');
    timestampElem.textContent = new Date().toLocaleString();
    messageElement.appendChild(timestampElem);

    chatHistory.appendChild(messageElement);
    
    if (typeof scrollToBottom === 'function') {
        setTimeout(() => scrollToBottom('smooth'), 50);
    }
}


function addSystemMessage(text) {
   const messageElement = document.createElement('div');
   messageElement.classList.add('system-message');
   messageElement.textContent = text;
   chatHistory.appendChild(messageElement);
   setTimeout(() => scrollToBottom('smooth'), 50);
}

function addErrorMessage(text) {
   console.error("[UI ERROR] ", text);
   const messageElement = document.createElement('div');
   messageElement.classList.add('error-message');
   messageElement.textContent = `Error: ${text}`;
   if(currentAiTurnContainer) {
       const target = currentAnswerElement || currentCodeBlocksArea || currentAiTurnContainer;
       target.appendChild(messageElement);
   } else { chatHistory.appendChild(messageElement); }
   setTimeout(() => scrollToBottom('smooth'), 50);
}

function setInputDisabledState(inputsDisabled, aiResponding) {
    if (messageInput) messageInput.disabled = inputsDisabled;
    if (sendButton) sendButton.disabled = inputsDisabled;
    if (thinkCheckbox) thinkCheckbox.disabled = inputsDisabled;

    if (stopAiButton) {
        if (aiResponding) {
            stopAiButton.classList.remove('hidden');
            stopAiButton.disabled = false;
            // Set to default "Stop" state when becoming visible, in case it was "Stopping..."
            stopAiButton.innerHTML = `
                <svg class="w-5 h-5 inline-block mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1zm4 0a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                Stop`;
            if (sendButton) sendButton.classList.add('hidden');
        } else {
            stopAiButton.classList.add('hidden');
            stopAiButton.disabled = true;
            // Reset to default "Stop" state when hidden
            stopAiButton.innerHTML = `
                <svg class="w-5 h-5 inline-block mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1zm4 0a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                Stop`;
            if (sendButton) sendButton.classList.remove('hidden');
        }
    }
}

function setupNewAiTurn() {
    currentTurnId++;
    codeBlockCounterThisTurn = 0;
    accumulatedAnswerText = '';
    lastAppendedNode = null;
    thinkBuffer = '';
    hasThinkingContentArrivedThisTurn = false;
    firstAnswerTokenReceived = false;

    currentAiTurnContainer = null;
    currentThinkingArea = null;
    currentThinkingPreElement = null;
    currentAnswerElement = null;
    currentCodeBlocksArea = null;

    console.log(`[setupNewAiTurn] Starting setup for Turn ID: ${currentTurnId}. thinkingRequestedForCurrentTurn is: ${thinkingRequestedForCurrentTurn}`);

    currentAiTurnContainer = document.createElement('div');
    currentAiTurnContainer.classList.add('ai-turn-container');
    currentAiTurnContainer.dataset.turnId = currentTurnId;

    // --- Thinking Area Setup (remains the same) ---
    currentThinkingArea = document.createElement('div');
    currentThinkingArea.classList.add('thinking-area');
    currentThinkingArea.dataset.turnId = currentTurnId;
    if (!thinkingRequestedForCurrentTurn) {
        currentThinkingArea.style.display = 'none';
    }
    const details = document.createElement('details');
    details.id = `thinking-details-${currentTurnId}`;
    const summary = document.createElement('summary');
    summary.classList.add('thinking-summary');
    const summaryTextSpan = document.createElement('span');
    summaryTextSpan.classList.add('text');
    summaryTextSpan.textContent = 'Show Thinking';
    const summaryDotsSpan = document.createElement('span');
    summaryDotsSpan.classList.add('dots');
    summary.appendChild(summaryTextSpan);
    summary.appendChild(summaryDotsSpan);
    currentThinkingPreElement = document.createElement('pre');
    details.appendChild(summary);
    details.appendChild(currentThinkingPreElement);
    currentThinkingArea.appendChild(details);
    currentAiTurnContainer.appendChild(currentThinkingArea);
    details.addEventListener('toggle', (event) => {
        const textSpan = event.target.querySelector('.thinking-summary .text');
        if (!textSpan) return;
        textSpan.textContent = event.target.open ? 'Hide Thinking' : 'Show Thinking';
    });
    // --- End Thinking Area Setup ---

    // --- Answer Element (AI Message Bubble) Setup ---
    currentAnswerElement = document.createElement('div');
    currentAnswerElement.classList.add('message', 'ai-message');
    // Add styling classes similar to historical AI messages for consistency
    currentAnswerElement.classList.add('p-3', 'rounded-lg', 'max-w-xl', 'mb-2', 'break-words', 'flex', 'flex-col', 'bg-sky-100', 'self-start', 'mr-auto');


    // **NEW**: Add Sender Name ("AI") to the live answer bubble
    const senderElem = document.createElement('p');
    senderElem.classList.add('font-semibold', 'text-sm', 'mb-1', 'text-sky-700');
    senderElem.textContent = 'AI'; // Or a dynamic AI name if available
    currentAnswerElement.appendChild(senderElem); // Prepend or append as preferred; prepending here

    // Div to hold the actual streaming content (will be populated by appendToAnswer/formatAnswerBubbleFinal)
    // This is effectively the 'message-content' part of the bubble.
    // We create a dedicated div for it so the sender name and timestamp can be siblings.
    const liveContentDiv = document.createElement('div');
    liveContentDiv.classList.add('text-gray-800', 'text-sm', 'message-content', 'live-ai-content-area'); // Added a specific class
    currentAnswerElement.appendChild(liveContentDiv);


    if (thinkingRequestedForCurrentTurn) {
        currentAnswerElement.style.display = 'none'; // Hide bubble if thinking is shown first
    } else {
        // Show answer bubble immediately with loading dots if no thinking display
        const loadingSpan = document.createElement('span');
        loadingSpan.classList.add('loading-dots');
        liveContentDiv.appendChild(loadingSpan); // Add loading dots to the content area
    }
    currentAiTurnContainer.appendChild(currentAnswerElement);

    // --- Code Blocks Area Setup (remains the same) ---
    currentCodeBlocksArea = document.createElement('div');
    currentCodeBlocksArea.classList.add('code-blocks-area');
    currentAiTurnContainer.appendChild(currentCodeBlocksArea);
    // --- End Code Blocks Area Setup ---

    chatHistory.appendChild(currentAiTurnContainer);
    console.log(`[setupNewAiTurn] Finished setup for Turn ID: ${currentTurnId}.`);
}

function appendRawTextToThinkingArea(text) {
    if (text && text.trim().length > 0) {
        // console.log(`[appendRawTextToThinkingArea] Received non-empty raw think text: "${text}" (length: ${text?.length})`);
    } else if (text !== null) {
        // console.log(`[appendRawTextToThinkingArea] Received empty or whitespace raw think text (length: ${text?.length})`);
    }

    // console.log(`[appendRawTextToThinkingArea] Checking condition: !thinkingRequestedForCurrentTurn is ${!thinkingRequestedForCurrentTurn} (value: ${thinkingRequestedForCurrentTurn})`);
    if (!thinkingRequestedForCurrentTurn) {
        // console.log("[appendRawTextToThinkingArea] Condition met (!thinkingRequested). Returning early. Should NOT display thinking.");
        return;
    }

    // console.log("[appendRawTextToThinkingArea] Proceeding because thinking was requested.");

    if (!currentThinkingArea || !currentThinkingPreElement || text.length === 0) {
        return;
    }

    if (!hasThinkingContentArrivedThisTurn) {
        if (currentThinkingArea.style.display === 'none') {
            // console.log("[appendRawTextToThinkingArea] First think chunk (and requested). Making area visible NOW. Display style was: " + currentThinkingArea.style.display);
            currentThinkingArea.style.display = '';
        }
        hasThinkingContentArrivedThisTurn = true;
    }

    try {
        currentThinkingPreElement.appendChild(document.createTextNode(text));
    } catch (appendError) {
         console.error("[appendRawTextToThinkingArea] Error appending text node:", appendError, "Pre Element:", currentThinkingPreElement, "Text:", text);
        return;
    }

    const detailsElement = currentThinkingPreElement.closest('details');
    if (detailsElement && detailsElement.open) {
         const isNearBottom = currentThinkingPreElement.scrollHeight - currentThinkingPreElement.scrollTop - currentThinkingPreElement.clientHeight < 50;
         if(isNearBottom) {
             requestAnimationFrame(() => { currentThinkingPreElement.scrollTop = currentThinkingPreElement.scrollHeight; });
         }
    }
}

function appendCodeReference() {
    if (!currentAnswerElement) {
        console.error("Attempted to append code reference to null answer bubble!");
        return;
    }
    if (codeBlockCounterThisTurn > 0) {
         const refSpan = document.createElement('span');
         refSpan.classList.add('code-reference');
         refSpan.textContent = `[Code ${codeBlockCounterThisTurn}]`;
         currentAnswerElement.appendChild(refSpan);
         lastAppendedNode = refSpan;
    } else {
        console.warn("appendCodeReference called but codeBlockCounterThisTurn is 0.");
    }
}

function formatAnswerBubbleFinal() {
    if (!currentAnswerElement) {
        console.warn("[formatAnswerBubbleFinal] Skipping: currentAnswerElement is null.");
        accumulatedAnswerText = ''; lastAppendedNode = null; firstAnswerTokenReceived = false; return;
    }

    // **MODIFIED**: Target the dedicated content area
    const targetContentArea = currentAnswerElement.querySelector('.live-ai-content-area');
    if (!targetContentArea) {
        console.error("[formatAnswerBubbleFinal] '.live-ai-content-area' not found. Cannot format content.");
        // Fallback: if somehow the structure is missing, try to use currentAnswerElement directly
        // but this will mix with sender name. This is mostly a safeguard.
        if (accumulatedAnswerText.trim().length > 0) {
             currentAnswerElement.innerHTML += marked.parse(accumulatedAnswerText, { mangle: false, headerIds: false, gfm: true, breaks: true, sanitize: false });
        }
        accumulatedAnswerText = ''; lastAppendedNode = null; firstAnswerTokenReceived = false; return;
    }
    
    // Original logic from formatAnswerBubbleFinal, but operating on `targetContentArea`

    // Ensure the main answer bubble is visible if it has content or accumulated text
    if (currentAnswerElement.style.display === 'none' && (targetContentArea.hasChildNodes() || accumulatedAnswerText.trim().length > 0)) {
        currentAnswerElement.style.display = ''; // Show the whole bubble
        const loadingDots = targetContentArea.querySelector('.loading-dots'); // Dots are inside targetContentArea
        if (loadingDots) loadingDots.remove();
    }

    const hasVisualContent = targetContentArea.hasChildNodes() && !targetContentArea.querySelector('.loading-dots');
    const hasAccumulatedContent = accumulatedAnswerText.trim().length > 0;

    if (!hasVisualContent && !hasAccumulatedContent) {
        const loadingDots = targetContentArea.querySelector('.loading-dots');
        if (loadingDots) loadingDots.remove();
        accumulatedAnswerText = '';
        lastAppendedNode = null;
        // firstAnswerTokenReceived should remain true if it was set, or handle as needed
        return;
    }

    try {
        const storedKatexNodes = {};
        let placeholderIndex = 0;
        let textForMarkdown = accumulatedAnswerText; // Start with accumulated text

        // Find KaTeX spans already rendered by the live streaming logic within targetContentArea
        const katexSpans = Array.from(targetContentArea.children).filter(el => el.matches(`span[${KATEX_RENDERED_ATTR}="true"]`));

        if (katexSpans.length > 0) {
            katexSpans.forEach((el) => {
                if (!el.parentNode) return; // Should be targetContentArea
                const placeholder = `${KATEX_PLACEHOLDER_PREFIX}${placeholderIndex++}`; // KATEX_PLACEHOLDER_PREFIX is global
                storedKatexNodes[placeholder] = el.cloneNode(true);
                try {
                    // Replace the KaTeX span with a text node placeholder
                    el.parentNode.replaceChild(document.createTextNode(placeholder), el);
                } catch (replaceError) {
                    console.error(`[formatAnswerBubbleFinal] Error replacing KaTeX node with placeholder ${placeholder}:`, replaceError, "Node:", el);
                    try { el.parentNode.removeChild(el); } catch (removeError) { console.error("Failed to remove problematic KaTeX node:", removeError); }
                }
            });
            // After replacement, the innerHTML of targetContentArea contains text and placeholders
            textForMarkdown = targetContentArea.innerHTML;
        } else {
             // If no KaTeX spans but there was visual content (e.g. just text nodes from appendToAnswer)
             // and also accumulated text, we should clear the visual DOM and use accumulated text.
            if (hasVisualContent && hasAccumulatedContent) {
                targetContentArea.innerHTML = ''; // Clear existing simple text nodes
            } else if (!hasAccumulatedContent && hasVisualContent) {
                // Only visual content (e.g. from appendToAnswer(null, node) where node was not KaTeX)
                // and no accumulated text. Use existing innerHTML.
                textForMarkdown = targetContentArea.innerHTML;
            }
            // If only accumulated text, textForMarkdown is already set.
        }
        
        if (textForMarkdown.trim().length === 0 && Object.keys(storedKatexNodes).length === 0) {
             // No text to parse and no KaTeX to reinsert.
        } else {
            // Parse the potentially modified innerHTML or accumulated text
            const markdownHtml = marked.parse(textForMarkdown, {
                mangle: false, headerIds: false, gfm: true, breaks: true, sanitize: false
            });
            targetContentArea.innerHTML = markdownHtml; // Set the parsed HTML into the content area
        }


        // Reinsert KaTeX nodes if any were stored
        if (Object.keys(storedKatexNodes).length > 0) {
            const walker = document.createTreeWalker(targetContentArea, NodeFilter.SHOW_TEXT);
            let node;
            const textNodesContainingPlaceholders = [];
            while (node = walker.nextNode()) {
                if (node.nodeValue && node.nodeValue.includes(KATEX_PLACEHOLDER_PREFIX)) {
                    textNodesContainingPlaceholders.push(node);
                }
            }

            textNodesContainingPlaceholders.forEach(textNode => {
                let currentNodeValue = textNode.nodeValue;
                let parent = textNode.parentNode;
                if (!parent) return; // Should be within targetContentArea

                const fragment = document.createDocumentFragment();
                let lastSplitEnd = 0;
                const placeholderScanRegex = new RegExp(`(${KATEX_PLACEHOLDER_PREFIX}\\d+)`, 'g');
                let placeholderMatch;

                while((placeholderMatch = placeholderScanRegex.exec(currentNodeValue)) !== null) {
                    const placeholder = placeholderMatch[1];
                    const matchIndex = placeholderMatch.index;
                    if (matchIndex > lastSplitEnd) {
                        fragment.appendChild(document.createTextNode(currentNodeValue.substring(lastSplitEnd, matchIndex)));
                    }
                    if (storedKatexNodes[placeholder]) {
                        fragment.appendChild(storedKatexNodes[placeholder].cloneNode(true));
                    } else {
                        fragment.appendChild(document.createTextNode(placeholder)); // Fallback
                    }
                    lastSplitEnd = placeholderScanRegex.lastIndex;
                }
                if (lastSplitEnd < currentNodeValue.length) {
                    fragment.appendChild(document.createTextNode(currentNodeValue.substring(lastSplitEnd)));
                }
                parent.replaceChild(fragment, textNode);
            });
        }
    } catch (error) {
        console.error("Error during final Markdown/KaTeX formatting in live AI bubble:", error);
        addErrorMessage("Failed to perform final message formatting for AI response.");
        if (targetContentArea && accumulatedAnswerText.trim().length > 0) {
            targetContentArea.textContent = accumulatedAnswerText; // Fallback to raw accumulated text
        }
    }
    accumulatedAnswerText = ''; // Clear after processing
    lastAppendedNode = null; // Reset for the next stream
    // firstAnswerTokenReceived remains true.
}

function resetStreamingState() {
    // console.log("[DEBUG] Resetting streaming state.");
    currentProcessingMode = MODE_ANSWER;
    langBuffer = ''; currentCodeBlockLang = '';
    currentCodeBlockElement = null; currentCodeBlockPreElement = null;
    katexBuffer = ''; currentKatexMarkerId = null;
    thinkBuffer = ''; tagBuffer = ''; fenceBuffer = ''; // Reset fenceBuffer
    lastAppendedNode = null;
    thinkingRequestedForCurrentTurn = false;
}

function renderAndReplaceKatex(isDisplay, markerId) {

    if (!currentAnswerElement || !markerId || katexBuffer === null || katexBuffer === undefined) {
        console.error("[KaTeX Replace Marker] Error: Invalid state (element, markerId, or buffer). MarkerID:", markerId, "Buffer:", katexBuffer);
        if (markerId && currentAnswerElement) {
             try {
                 const strayMarker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);
                 if (strayMarker?.parentNode) strayMarker.parentNode.removeChild(strayMarker);
             } catch (e) { console.error("Error cleaning stray marker:", e); }
        }
        katexBuffer = '';
        return false;
    }

    const trimmedKatexBuffer = katexBuffer.trim();

    try {
        const stringToRender = trimmedKatexBuffer.length > 0 ? trimmedKatexBuffer : " ";
        const katexHtml = katex.renderToString(stringToRender, {
            displayMode: isDisplay,
            throwOnError: false,
            output: "html",
            strict: false
        });

        if (katexHtml.includes('katex-error') && trimmedKatexBuffer.length > 0) {
            console.warn(`[KaTeX Replace Marker] KaTeX reported a rendering error for buffer: "${trimmedKatexBuffer}". Marker ID: ${markerId}. Raw text will remain.`);
             try {
                 const marker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);
                 if (marker?.parentNode) marker.parentNode.removeChild(marker);
                 else console.warn("Couldn't find marker to clean up after render error.");
             } catch (cleanupError) { console.error("Error during marker cleanup after render error:", cleanupError); }
            katexBuffer = '';
            return false;
        }

        const startMarker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);

        if (!startMarker) {
            console.error(`[KaTeX Replace Marker] Error: Cannot find start marker span with ID: ${markerId}. Aborting replacement. Content might be inconsistent.`);
            katexBuffer = '';
            return false;
        }

        if (!startMarker.parentNode) {
             console.error(`[KaTeX Replace Marker] Error: Start marker span with ID ${markerId} found but has no parent (already removed?). Aborting.`);
             katexBuffer = '';
             return false;
        }

        const parent = startMarker.parentNode;
        let nodesToRemove = [];
        let currentNode = startMarker.nextSibling;

        while (currentNode) {
            nodesToRemove.push(currentNode);
            if (nodesToRemove.length > 1000) {
                console.error("[KaTeX Replace Marker] Error: Excessive node collection limit reached (1000). Aborting replacement.");
                 try { parent.removeChild(startMarker); } catch(e){}
                 katexBuffer = '';
                 return false;
            }
            currentNode = currentNode.nextSibling;
        }

        const katexSpan = document.createElement('span');
        katexSpan.setAttribute(KATEX_RENDERED_ATTR, 'true');
        katexSpan.innerHTML = katexHtml;

        parent.insertBefore(katexSpan, startMarker);
        parent.removeChild(startMarker);

        nodesToRemove.forEach(node => {
            if (node.parentNode === parent) {
                parent.removeChild(node);
            } else {
                console.warn("[KaTeX Replace Marker] Node parent changed or node removed unexpectedly during collection, skipping removal:", node);
            }
        });

        appendToAnswer(null, katexSpan);
        katexBuffer = '';
        return true;

    } catch (error) {
        console.error("[KaTeX Replace Marker] General error during marker-based replacement:", error);
        try {
            const marker = currentAnswerElement?.querySelector(`span[data-katex-start-id="${markerId}"]`);
            if (marker?.parentNode) marker.parentNode.removeChild(marker);
        } catch (cleanupError) { console.error("Error during marker cleanup after general error:", cleanupError); }
        katexBuffer = '';
        return false;
    }
}

function finalizeTurnOnErrorOrClose() {
    console.log("[DEBUG] finalizeTurnOnErrorOrClose called."); // Keep user's debug log
    if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK && currentCodeBlockElement) {
        console.warn("Stream ended unexpectedly inside code block. Finalizing highlight.");
        try { finalizeCodeBlock(true); } catch (e) { console.error("Prism highlight error on close:", e); }
    }
    // --- Incorporate user's KaTeX and Think finalization ---
    if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE ||
        currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY ||
        currentProcessingMode === MODE_MAYBE_START_DISPLAY_KATEX) {
        console.warn("Stream ended unexpectedly inside KaTeX block. Processing raw text.");
        if (currentKatexMarkerId && typeof renderAndReplaceKatex === 'function') { // Check if function exists
            renderAndReplaceKatex(currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY, currentKatexMarkerId);
            currentKatexMarkerId = null;
        } else if (katexBuffer) { // Fallback if renderAndReplaceKatex isn't available or no marker
            appendToAnswer((currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY ? "$$" : "$") + katexBuffer + (currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY ? "$$" : "$"));
            katexBuffer = '';
        }
    }
    if (currentProcessingMode === MODE_INSIDE_THINK || currentProcessingMode === MODE_MAYBE_END_THINK || currentProcessingMode === MODE_SEEKING_TAG) {
        console.warn("Stream ended unexpectedly inside/seeking Think tags. Finishing think buffer:", thinkBuffer);
        if (currentThinkingArea && currentThinkingArea.style.display !== 'none' && currentThinkingPreElement && typeof appendRawTextToThinkingArea === 'function') {
            appendRawTextToThinkingArea("\n--- (Stream ended unexpectedly during thinking) ---");
        } else if (tagBuffer) { // If not in thinking mode but had a tag buffer
            appendToAnswer(tagBuffer); // Append incomplete tag as text
        }
        // thinkBuffer itself is typically appended by appendRawTextToThinkingArea during streaming
    }
    // --- End of incorporated logic ---

    if (typeof formatAnswerBubbleFinal === 'function') {
        formatAnswerBubbleFinal(); 
    }
    if (typeof resetStreamingState === 'function') {
        resetStreamingState();     
    }
    if (typeof setInputDisabledState === 'function') {
        setInputDisabledState(false, false); // Correctly re-enables inputs and hides stop button
    }
    // --- Focus logic remains ---
    if (messageInput && messageInput.offsetParent !== null) { // Check if visible
        messageInput.focus();
    }
}

function createCodeBlockStructure(language) {
    if (!currentCodeBlocksArea) {
        console.error("createCodeBlockStructure: Code blocks area is null!");
        return;
    }
    codeBlockCounterThisTurn++;
    const currentCodeNumber = codeBlockCounterThisTurn;
    const blockId = `code-block-turn${currentTurnId}-${currentCodeNumber}`;
    const safeLanguage = (language || '').trim().toLowerCase() || 'plaintext';

    // Language aliases and Prism language determination (as before)
    const langAlias = { /* ... keep your existing aliases ... */
        'python': 'python', 'py': 'python', 'javascript': 'javascript', 'js': 'javascript',
        'html': 'markup', 'xml': 'markup', 'svg': 'markup', 'css': 'css', 'bash': 'bash',
        'sh': 'bash', 'shell': 'bash', 'json': 'json', 'yaml': 'yaml', 'yml': 'yaml',
        'markdown': 'markdown', 'md': 'markdown', 'sql': 'sql', 'java': 'java', 'c': 'c',
        'cpp': 'cpp', 'c++': 'cpp', 'csharp': 'csharp', 'cs': 'csharp', 'go': 'go',
        'rust': 'rust', 'php': 'php', 'ruby': 'ruby', 'rb': 'ruby',
        'dockerfile': 'docker', 'docker': 'docker', 'typescript': 'typescript', 'ts': 'typescript',
        'plaintext': 'plain', 'text': 'plain',
    };
    const prismLang = langAlias[safeLanguage] || safeLanguage;
    const displayLang = safeLanguage; // Use the cleaned-up language name for checks/display
    currentCodeBlockLang = prismLang; // Store the Prism language used

    // --- ADD: List of languages supported by the backend Docker execution ---
    const supportedExecutionLanguages = [
        "python", "javascript", "cpp", "csharp", "typescript", "java", "go", "rust"
        // Add or remove languages based on your config.py SUPPORTED_LANGUAGES keys
    ];
    const isLanguageSupported = supportedExecutionLanguages.includes(displayLang);
    // --- END OF ADD ---

    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;

    const container = document.createElement('div');
    container.classList.add('code-block-container');
    container.id = blockId;
    container.dataset.language = displayLang; // Store the display language

    const codeHeader = document.createElement('div');
    codeHeader.classList.add('code-block-header');

    const codeButtonsDiv = document.createElement('div');
    codeButtonsDiv.classList.add('code-block-buttons');

    // Create buttons (as before)
    const runStopBtn = document.createElement('button');
    runStopBtn.classList.add('run-code-btn', 'code-action-btn');
    runStopBtn.dataset.status = 'idle';
    runStopBtn.innerHTML = playIconSvg;
    runStopBtn.title = 'Run Code';
    runStopBtn.addEventListener('click', handleRunStopCodeClick);

    const toggleCodeBtn = document.createElement('button');
    toggleCodeBtn.classList.add('toggle-code-btn', 'code-action-btn');
    toggleCodeBtn.textContent = 'Hide';
    toggleCodeBtn.title = 'Show/Hide Code';

    const copyCodeBtn = document.createElement('button');
    copyCodeBtn.classList.add('copy-code-btn', 'code-action-btn');
    copyCodeBtn.textContent = 'Copy';
    copyCodeBtn.title = 'Copy Code';

    // --- ADD: Conditionally hide run button ---
    if (!isLanguageSupported) {
        runStopBtn.style.display = 'none'; // Hide the button entirely
        runStopBtn.title = `Run Code (language '${displayLang}' not supported for execution)`; // Update title even if hidden
        console.log(`Hiding run button for unsupported language: ${displayLang}`); // Optional log
    }
    // --- END OF ADD ---

    // Add buttons to their container (run button is added even if hidden, simplifies layout logic)
    codeButtonsDiv.appendChild(runStopBtn);
    codeButtonsDiv.appendChild(toggleCodeBtn);
    codeButtonsDiv.appendChild(copyCodeBtn);

    // Code block title (as before)
    const codeTitle = document.createElement('span');
    codeTitle.classList.add('code-block-title');
    codeTitle.textContent = `Code ${currentCodeNumber} (${displayLang})`;
    codeTitle.style.flexGrow = '1';
    codeTitle.style.textAlign = 'left';

    // Assemble header (as before)
    codeHeader.appendChild(codeButtonsDiv);
    codeHeader.appendChild(codeTitle);

    // Create pre/code elements (as before)
    const preElement = document.createElement('pre');
    preElement.classList.add('manual');
    const codeElement = document.createElement('code');
    codeElement.className = `language-${prismLang}`;
    codeElement.setAttribute('contenteditable', 'true'); // Live code is editable
    codeElement.setAttribute('spellcheck', 'false');

    // Assign to global state variables for streaming (as before)
    currentCodeBlockPreElement = preElement;
    currentCodeBlockElement = codeElement;

    // Create output area structure (as before)
    const outputHeader = document.createElement('div');
    outputHeader.classList.add('code-output-header');
    outputHeader.style.display = 'none';
    // ... (rest of output header setup: buttons, title, status span) ...
    const outputButtonsDiv = document.createElement('div');
    outputButtonsDiv.classList.add('code-block-buttons');
    const placeholderSpan = document.createElement('span');
    placeholderSpan.classList.add('output-header-button-placeholder');
    outputButtonsDiv.appendChild(placeholderSpan);
    const toggleOutputBtn = document.createElement('button');
    toggleOutputBtn.classList.add('toggle-output-btn', 'code-action-btn');
    toggleOutputBtn.textContent = 'Hide';
    toggleOutputBtn.title = 'Show/Hide Output';
    const copyOutputBtn = document.createElement('button');
    copyOutputBtn.classList.add('copy-output-btn', 'code-action-btn');
    copyOutputBtn.textContent = 'Copy';
    copyOutputBtn.title = 'Copy Output';
    outputButtonsDiv.appendChild(toggleOutputBtn);
    outputButtonsDiv.appendChild(copyOutputBtn);
    const outputTitle = document.createElement('span');
    outputTitle.classList.add('output-header-title');
    outputTitle.textContent = `Output Code ${currentCodeNumber}`;
    const codeStatusSpan = document.createElement('span');
    codeStatusSpan.classList.add('code-status-span');
    codeStatusSpan.textContent = 'Idle';
    outputHeader.appendChild(outputButtonsDiv);
    outputHeader.appendChild(outputTitle);
    outputHeader.appendChild(codeStatusSpan);

    const outputConsoleDiv = document.createElement('div');
    outputConsoleDiv.classList.add('code-output-console');
    outputConsoleDiv.style.display = 'none';
    const outputPre = document.createElement('pre');
    outputConsoleDiv.appendChild(outputPre);

    // Assemble the full block (as before)
    preElement.appendChild(codeElement);
    container.appendChild(codeHeader);
    container.appendChild(preElement);
    container.appendChild(outputHeader);
    container.appendChild(outputConsoleDiv);

    // Add event listeners (as before)
    // Toggle code listener
    toggleCodeBtn.addEventListener('click', () => {
        const isHidden = preElement.classList.toggle('hidden');
        toggleCodeBtn.textContent = isHidden ? 'Show' : 'Hide';
    });
    // Copy code listener
    copyCodeBtn.addEventListener('click', async () => {
        if (!codeElement) return;
        try {
            await navigator.clipboard.writeText(codeElement.textContent || '');
            copyCodeBtn.textContent = 'Copied!';
            copyCodeBtn.classList.add('copied');
            setTimeout(() => { copyCodeBtn.textContent = 'Copy'; copyCodeBtn.classList.remove('copied'); }, 1500);
        } catch (err) {
            console.error('Failed to copy code: ', err);
            copyCodeBtn.textContent = 'Error';
            setTimeout(() => { copyCodeBtn.textContent = 'Copy'; }, 1500);
        }
    });
    // Run button listener is already attached above
    // Debounced highlight listener for editable code (as before)
    const debouncedHighlight = debounce(() => {
        const savedPosition = getCursorPosition(codeElement);
        if (savedPosition === -1) { console.warn("Could not save cursor position or cursor not in element. Highlight may cause cursor jump."); }
        try {
            const currentText = codeElement.textContent;
            codeElement.innerHTML = ''; 
            codeElement.textContent = currentText; 
            Prism.highlightElement(codeElement);
            if (savedPosition !== -1) { setCursorPosition(codeElement, savedPosition); }
        } catch (e) {
            console.error("Error during debounced highlighting:", e);
            if (savedPosition !== -1) { setCursorPosition(codeElement, savedPosition); }
        }
    }, 500);
    codeElement.addEventListener('input', debouncedHighlight);
    codeElement.addEventListener('paste', (e) => { setTimeout(debouncedHighlight, 100); });
    // Output area listeners (as before)
    toggleOutputBtn.addEventListener('click', () => {
        const isHidden = outputConsoleDiv.classList.toggle('hidden');
        toggleOutputBtn.textContent = isHidden ? 'Show' : 'Hide';
    });
    copyOutputBtn.addEventListener('click', async () => {
        if (!outputPre) return;
        try {
            await navigator.clipboard.writeText(outputPre.textContent || '');
            copyOutputBtn.textContent = 'Copied!';
            copyOutputBtn.classList.add('copied');
            setTimeout(() => { copyOutputBtn.textContent = 'Copy'; copyOutputBtn.classList.remove('copied'); }, 1500);
        } catch (err) {
            console.error('Failed to copy output: ', err);
            copyOutputBtn.textContent = 'Error';
            setTimeout(() => { copyOutputBtn.textContent = 'Copy'; }, 1500);
        }
    });

    // Append to DOM and reset state (as before)
    currentCodeBlocksArea.appendChild(container);
    lastAppendedNode = null; // Reset last appended node for main answer bubble
}

async function handleRunStopCodeClick(event) {
    const button = event.currentTarget;
    const container = button.closest('.code-block-container');
    if (!container) return;

    const codeBlockId = container.id;
    const language = container.dataset.language;
    const codeElement = container.querySelector('code');
    const outputHeader = container.querySelector('.code-output-header');
    const outputConsoleDiv = container.querySelector('.code-output-console');
    const outputPre = outputConsoleDiv ? outputConsoleDiv.querySelector('pre') : null;
    const statusSpan = outputHeader ? outputHeader.querySelector('.code-status-span') : null;

    if (!language || !codeElement || !outputHeader || !outputConsoleDiv || !outputPre || !statusSpan) {
        console.error(`Missing elements for code block ${codeBlockId}`);
        addErrorMessage(`Cannot run code block ${codeBlockId}: Internal UI error.`);
        return;
    }

    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;
    const stopIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><rect width="100" height="100" rx="15"/></svg>`;
    const stoppingIconSvg = `<svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: block;"><path d="M12 2V6M12 18V22M6 12H2M22 12H18M19.0711 4.92893L16.2426 7.75736M7.75736 16.2426L4.92893 19.0711M19.0711 19.0711L16.2426 16.2426M7.75736 7.75736L4.92893 4.92893" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;

    const code = codeElement.textContent || '';
    const currentStatus = button.dataset.status;

    if (!websocket || websocket.readyState !== WebSocket.OPEN) {
        console.warn("WebSocket not open. Cannot run/stop code.");
        statusSpan.textContent = 'Error: Disconnected';
        statusSpan.className = 'code-status-span error';
        outputHeader.style.display = 'flex';
        addErrorMessage("Cannot run/stop code: Not connected to server.");
        return;
    }

    if (currentStatus === 'idle') {
        console.log(`Requesting run for block ${codeBlockId} (${language})`);
        button.dataset.status = 'running';
        button.innerHTML = stopIconSvg;
        button.title = 'Stop Execution';

        outputPre.innerHTML = '';
        outputHeader.style.display = 'flex';
        outputConsoleDiv.style.display = 'block';
        outputConsoleDiv.classList.remove('hidden');
        const toggleOutputBtn = outputHeader.querySelector('.toggle-output-btn');
        if (toggleOutputBtn) toggleOutputBtn.textContent = 'Hide';

        statusSpan.textContent = 'Running...';
        statusSpan.className = 'code-status-span running';

        websocket.send(JSON.stringify({
            type: 'run_code',
            payload: { code_block_id: codeBlockId, language: language, code: code }
        }));

    } else if (currentStatus === 'running') {
        console.log(`Requesting stop for block ${codeBlockId}`);
        button.dataset.status = 'stopping';
        button.innerHTML = stoppingIconSvg;
        button.title = 'Stopping...';
        button.disabled = true;

        statusSpan.textContent = 'Stopping...';
        statusSpan.className = 'code-status-span stopping';

        websocket.send(JSON.stringify({
            type: 'stop_code',
            payload: { code_block_id: codeBlockId }
        }));
    } else if (currentStatus === 'stopping') {
        console.log(`Already stopping block ${codeBlockId}`);
    }
}

function addCodeOutput(outputPreElement, streamType, text) {
    if (!outputPreElement || !text) return;

    const span = document.createElement('span');
    span.classList.add(streamType === 'stderr' ? 'stderr-output' : 'stdout-output');
    span.textContent = text;
    outputPreElement.appendChild(span);
    outputPreElement.scrollTop = outputPreElement.scrollHeight;
}


function appendToCodeBlock(text) {
    // Ensure we have a target code element to append to
    if (currentCodeBlockElement) {
        // Append the raw text node to the <code> element
        currentCodeBlockElement.appendChild(document.createTextNode(text));
        
        // Auto-scroll the code block's <pre> container if it's visible
        // currentCodeBlockPreElement is the parent <pre> element
        if(currentCodeBlockPreElement && !currentCodeBlockPreElement.classList.contains('hidden')) {
            // Check if the scroll position is near the bottom
            const isNearCodeBottom = currentCodeBlockPreElement.scrollHeight - currentCodeBlockPreElement.scrollTop - currentCodeBlockPreElement.clientHeight < 50; // Threshold of 50px
            if(isNearCodeBottom) {
                // Use requestAnimationFrame for smoother scrolling after the DOM update
                requestAnimationFrame(() => { 
                    // Check again inside animation frame as state might change rapidly
                    if(currentCodeBlockPreElement) { 
                       currentCodeBlockPreElement.scrollTop = currentCodeBlockPreElement.scrollHeight; 
                    }
                });
            }
        }

        // --- THIS IS THE SPECIFIC CHANGE FOR THIS STEP ---
        // Trigger the debounced highlighter every time text is appended
        throttledStreamHighlight()
        // --- END OF SPECIFIC CHANGE ---

    } else {
        // Log an error if we try to append but no code block is active
        console.error("Attempted to append to null code block element!");
    }
}

function appendToAnswer(text = null, node = null) {
    if (!currentAnswerElement) {
        console.error("[appendToAnswer] currentAnswerElement is null. Cannot append.");
        return;
    }

    // **MODIFIED**: Target the dedicated content area within the AI message bubble
    const targetContentArea = currentAnswerElement.querySelector('.live-ai-content-area');
    if (!targetContentArea) {
        console.error("[appendToAnswer] '.live-ai-content-area' not found in currentAnswerElement. Appending to currentAnswerElement directly as fallback.");
        // Fallback to old behavior if somehow the structure is missing, though this shouldn't happen with the updated setupNewAiTurn
        const fallbackTarget = currentAnswerElement; 
        
        // Logic from original appendToAnswer, but using fallbackTarget
        let isMeaningfulContentFallback = (text && text.trim().length > 0) ||
                                   (node && node.nodeType !== Node.COMMENT_NODE && (!node.textContent || node.textContent.trim().length > 0));

        if (!firstAnswerTokenReceived && isMeaningfulContentFallback) {
            if (fallbackTarget.style.display === 'none') {
                fallbackTarget.style.display = '';
            }
            const loadingDotsFallback = fallbackTarget.querySelector('.loading-dots');
            if (loadingDotsFallback) {
                loadingDotsFallback.remove();
            }
            firstAnswerTokenReceived = true;
        }

        if (node) {
            if (!node.classList || !node.classList.contains('loading-dots')) {
                fallbackTarget.appendChild(node);
                lastAppendedNode = node; // Keep track of last appended node relative to its parent
            }
        } else if (text !== null && text.length > 0) {
            accumulatedAnswerText += text; // Still accumulate globally for formatAnswerBubbleFinal
            if (lastAppendedNode && lastAppendedNode.nodeType === Node.TEXT_NODE && lastAppendedNode.parentNode === fallbackTarget) {
                lastAppendedNode.nodeValue += text;
            } else {
                const textNode = document.createTextNode(text);
                fallbackTarget.appendChild(textNode);
                lastAppendedNode = textNode;
            }
        }
        return; // End of fallback logic
    }


    // --- Main logic using targetContentArea ---
    let isMeaningfulContent = (text && text.trim().length > 0) ||
                              (node && node.nodeType !== Node.COMMENT_NODE && (!node.textContent || node.textContent.trim().length > 0));

    if (!firstAnswerTokenReceived && isMeaningfulContent) {
        // This logic primarily handles making the *overall* currentAnswerElement visible
        // if it was hidden (e.g., due to thinkingRequestedForCurrentTurn).
        // The loading dots are inside targetContentArea.
        if (currentAnswerElement.style.display === 'none') {
            currentAnswerElement.style.display = ''; // Show the whole bubble
        }
        const loadingDots = targetContentArea.querySelector('.loading-dots');
        if (loadingDots) {
            loadingDots.remove();
        }
        firstAnswerTokenReceived = true;
    }

    if (node) {
        // Don't append loading dots if they are the node (they are handled above)
        if (!node.classList || !node.classList.contains('loading-dots')) {
            targetContentArea.appendChild(node);
            // lastAppendedNode should refer to nodes within targetContentArea for text concatenation logic
            lastAppendedNode = (targetContentArea.contains(node)) ? node : null;
        }
    } else if (text !== null && text.length > 0) {
        accumulatedAnswerText += text; // Global accumulation for final formatting
        // Smart text node concatenation within targetContentArea
        if (lastAppendedNode && lastAppendedNode.nodeType === Node.TEXT_NODE && lastAppendedNode.parentNode === targetContentArea) {
            lastAppendedNode.nodeValue += text;
        } else {
            const textNode = document.createTextNode(text);
            targetContentArea.appendChild(textNode);
            lastAppendedNode = textNode;
        }
    }
}

function finalizeCodeBlock(isTruncated = false) {
    // Check if there is an active code block element being processed
    if (currentCodeBlockElement) {
        const blockContainer = currentCodeBlockElement.closest('.code-block-container');
        const blockId = blockContainer ? blockContainer.id : 'unknown';
        const langClass = currentCodeBlockElement.className; // e.g., "language-python"
        
        // Log the finalization attempt
        console.log(`[finalizeCodeBlock] Finalizing highlight for block ${blockId} (lang class: ${langClass}). Stream truncated: ${isTruncated}`);

        try {
            // Normalizing the text nodes within the <code> element can sometimes help 
            // Prism handle unusual spacing or fragmented text nodes correctly.
            currentCodeBlockElement.normalize(); 
            
            // --- THIS IS THE SPECIFIC CHANGE FOR THIS STEP ---
            // Perform an immediate, final highlight on the entire code block element.
            // This ensures the complete code is highlighted, catching any parts potentially 
            // missed by the last debounced call if the stream ended abruptly.
            if (typeof Prism !== 'undefined' && typeof Prism.highlightElement === 'function') {
                Prism.highlightElement(currentCodeBlockElement);
                console.log(`[finalizeCodeBlock] Final highlighting applied successfully for ${blockId}.`);
            } else {
                 console.warn(`[finalizeCodeBlock] Prism.js or highlightElement not available for final highlight on block ${blockId}.`);
            }
            // --- END OF SPECIFIC CHANGE ---

            // Optional: Cancel any pending debounced highlight call.
            // This requires your debounce implementation to have a .cancel() method.
            // If it doesn't, you can omit this block.
            // if (debouncedStreamHighlight && typeof debouncedStreamHighlight.cancel === 'function') {
            //     console.log(`[finalizeCodeBlock] Cancelling pending debounced highlight for block ${blockId}.`);
            //     debouncedStreamHighlight.cancel();
            // }

        } catch (e) {
            // Log any errors during the final highlighting process
            console.error(`Prism highlight error on finalizeCodeBlock (lang '${currentCodeBlockLang}', block ${blockId}):`, e);
        }
    } else {
         // Log a warning if this function is called when no code block is active
         console.warn("[finalizeCodeBlock] Called but currentCodeBlockElement is null.");
    }
    
    // Reset the global state variables related to the code block stream AFTER processing.
    currentCodeBlockElement = null;    // Reference to the <code> element
    currentCodeBlockPreElement = null; // Reference to the parent <pre> element
    currentCodeBlockLang = '';         // Language identifier (e.g., 'python')
    // fenceBuffer should also be reset if it's tracked globally and related
    // fenceBuffer = ''; 
}

function resetAllCodeButtonsOnErrorOrClose() {
    console.log("Resetting all code run/stop buttons and statuses due to connection issue.");
    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;

    document.querySelectorAll('.code-block-container').forEach(container => {
        const button = container.querySelector('.run-code-btn');
        const outputHeader = container.querySelector('.code-output-header');
        const statusSpan = outputHeader ? outputHeader.querySelector('.code-status-span') : null;

        if (button && button.dataset.status !== 'idle') {
            button.dataset.status = 'idle';
            button.innerHTML = playIconSvg;
            button.title = 'Run Code';
            button.disabled = false;
        }
        if (statusSpan) {
             if (!statusSpan.classList.contains('idle') && !statusSpan.classList.contains('success')) {
                 if (outputHeader) outputHeader.style.display = 'flex';
                 statusSpan.textContent = 'Error: Disconnected';
                 statusSpan.className = 'code-status-span error';
             }
        }
    });
}

function connectWebSocket() {

    let sessionId = null;
    const pathParts = window.location.pathname.split('/');
    // Example: /chat/ef7a41e6-2ba7-4882-b9bb-91c03edb25ac
    // pathParts would be ["", "chat", "ef7a41e6-2ba7-4882-b9bb-91c03edb25ac"]
    if (pathParts.length >= 3 && pathParts[1] === 'chat') {
        sessionId = pathParts[2]; // This should be the session_id
        if (!sessionId || sessionId.trim() === "") {
             console.error("Session ID extracted from path is empty.");
             sessionId = null; // Treat empty ID as invalid
        }
    }

    if (!sessionId) {
        console.error("Could not extract valid session ID from URL path:", window.location.pathname);
        // Use your existing addErrorMessage function if available
        if (typeof addErrorMessage === 'function') {
             addErrorMessage("Cannot connect to chat: Invalid session ID in URL.");
        } else {
             alert("Cannot connect to chat: Invalid session ID in URL.");
        }
        // Use your existing setInputDisabledState function if available
        if (typeof setInputDisabledState === 'function') {
             setInputDisabledState(true);
        }
        return; // Stop connection attempt
    }
    // --- END: Added logic to get session ID from URL path ---

    // Use your existing global clientId variable
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    // Construct the URL with the extracted sessionId and existing clientId
    const wsUrl = `${wsProtocol}//${window.location.host}/ws/${sessionId}/${clientId}`; // Corrected URL format

    console.log(`[DEBUG] Attempting to connect to WebSocket: ${wsUrl}`);

    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`; // Keep this if used elsewhere, otherwise remove

    try {
        // Use the corrected wsUrl
        const ws = new WebSocket(wsUrl);
        console.log('connectWebSocket: Creating WebSocket object...');

        ws.onopen = (event) => {
            console.log("[DEBUG] WebSocket connection opened. ws object:", ws);
            websocket = ws; // Assign to your global websocket variable

            // Check for your actual helper functions
            if (typeof addSystemMessage !== 'function' || typeof setupNewAiTurn !== 'function' || typeof appendToAnswer !== 'function' || typeof formatAnswerBubbleFinal !== 'function' || typeof resetStreamingState !== 'function' || typeof setInputDisabledState !== 'function') {
                console.error("CRITICAL ERROR: One or more required helper functions are not defined when ws.onopen is called. Check script order.");
                alert("Chat initialization failed. Please refresh the page. (Error: Helpers undefined)");
                if (typeof setInputDisabledState === 'function') setInputDisabledState(true);
                return;
            }

            if (typeof setInputDisabledState === 'function') setInputDisabledState(false);
            if (typeof addSystemMessage === 'function') addSystemMessage("Connected to the chat server.");

            // thinkingRequestedForCurrentTurn = false; // Assuming this is a global/accessible variable
            // setupNewAiTurn(); // Your existing function
            // const welcomeMessage = "Hello! How can I help you today?";
            // appendToAnswer(welcomeMessage); // Your existing function
            // formatAnswerBubbleFinal(); // Your existing function
            // console.log("[DEBUG ws.onopen] Resetting state after welcome message.");
            // resetStreamingState(); // Your existing function

            if(messageInput && messageInput.offsetParent !== null) messageInput.focus();
        };

        ws.onmessage = (event) => {
            // This is the full onmessage logic from your provided script
            let isJsonMessage = false;
            let messageData = null;
            try {
                if (typeof event.data === 'string' && event.data.startsWith('{')) {
                    messageData = JSON.parse(event.data);
                    if (messageData && messageData.type && messageData.payload && messageData.payload.code_block_id) {
                        isJsonMessage = true;
                    }
                }
            } catch (e) {
                isJsonMessage = false;
            }

            if (isJsonMessage) {
                // console.log("%c[ws.onmessage] Code Execution JSON received:", "color: blue;", messageData);
                const { type, payload } = messageData;
                const { code_block_id } = payload;
                const container = document.getElementById(code_block_id);

                if (!container) {
                    console.warn(`Received message for unknown code block ID: ${code_block_id}`, payload);
                    return;
                }

                const outputHeader = container.querySelector('.code-output-header');
                const outputConsoleDiv = container.querySelector('.code-output-console');
                const outputPre = outputConsoleDiv ? outputConsoleDiv.querySelector('pre') : null;
                const runStopBtn = container.querySelector('.run-code-btn');
                const statusSpan = outputHeader ? outputHeader.querySelector('.code-status-span') : null;

                if (!outputHeader || !outputPre || !runStopBtn || !statusSpan) {
                        console.error(`Missing elements for code block ${code_block_id}. Cannot process message.`);
                        return;
                }

                switch (type) {
                    case 'code_output':
                        const { stream, data } = payload;
                        if (outputHeader.style.display === 'none') {
                            // console.log(`Showing output header for ${code_block_id} on first output.`);
                            outputHeader.style.display = 'flex';
                        }
                        if (outputConsoleDiv.style.display === 'none') {
                            // console.log(`Showing output console for ${code_block_id} on first output.`);
                            outputConsoleDiv.style.display = 'block';
                            outputConsoleDiv.classList.remove('hidden');
                                const toggleOutputBtn = outputHeader.querySelector('.toggle-output-btn');
                                if (toggleOutputBtn) toggleOutputBtn.textContent = 'Hide';
                        }
                        if (runStopBtn.dataset.status === 'idle'){
                                const stopIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><rect width="100" height="100" rx="15"/></svg>`;
                                console.warn(`Received code output for ${code_block_id} while button was idle. Forcing state to running.`);
                                runStopBtn.dataset.status = 'running';
                                runStopBtn.innerHTML = stopIconSvg;
                                runStopBtn.title = 'Stop Execution';
                                runStopBtn.disabled = false;
                                statusSpan.textContent = 'Running...';
                                statusSpan.className = 'code-status-span running';
                        }
                        addCodeOutput(outputPre, stream, data); // Your existing function
                        break;

                    case 'code_finished':
                        if (outputHeader.style.display === 'none') {
                            // console.log(`Showing output header for ${code_block_id} on finish.`);
                            outputHeader.style.display = 'flex';
                        }
                            if (outputConsoleDiv.style.display === 'none') {
                            // console.log(`Showing output console for ${code_block_id} on finish.`);
                            outputConsoleDiv.style.display = 'block';
                            outputConsoleDiv.classList.remove('hidden');
                                const toggleOutputBtn = outputHeader.querySelector('.toggle-output-btn');
                                if (toggleOutputBtn) toggleOutputBtn.textContent = 'Hide';
                        }

                        const { exit_code, error } = payload;
                        let finishMessage = '';
                        let statusClass = '';

                        if (error) {
                            if (error === "Execution stopped by user.") {
                                finishMessage = 'Stopped'; statusClass = 'stopped';
                            } else if (error.startsWith("Execution timed out")) {
                                    finishMessage = 'Timeout'; statusClass = 'error';
                            } else {
                                    finishMessage = `Error (${exit_code !== undefined ? exit_code : 'N/A'})`; statusClass = 'error';
                                    console.error(`Execution error for ${code_block_id}:`, error);
                            }
                        } else {
                            finishMessage = `Finished (Exit: ${exit_code})`;
                            statusClass = exit_code === 0 ? 'success' : 'error';
                        }

                        statusSpan.textContent = finishMessage;
                        statusSpan.className = `code-status-span ${statusClass}`;

                        runStopBtn.dataset.status = 'idle';
                        // Use the playIconSvg defined earlier or redefine it if needed
                        runStopBtn.innerHTML = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;
                        runStopBtn.title = 'Run Code';
                        runStopBtn.disabled = false;
                        break;

                    default:
                        console.warn(`Received unknown code execution message type: ${type}`, payload);
                }

            } else {
                // console.log("%c[ws.onmessage] RAW chat data received:", "color: magenta;", event.data);
                let chunk = event.data;
                const currentTurnIdForMsg = currentTurnId; // Assuming currentTurnId is global/accessible

                // Inside your connectWebSocket -> ws.onmessage -> else (raw chat data) -> if (chunk === "<EOS>") block:

                if (chunk === "<EOS>") {
                    const currentTurnIdForMsg = currentTurnId; // Capture currentTurnId for logging context
                    console.log(`%c[ws.onmessage] Turn ${currentTurnIdForMsg}: Received <EOS>. Finalizing turn.`, 'color: green; font-weight: bold;');

                    // Handle cases where EOS is received unexpectedly in the middle of processing
                    if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly inside a code block. Appending any fence buffer and finalizing code block.`);
                        if (fenceBuffer && fenceBuffer.length > 0) {
                            appendToCodeBlock(fenceBuffer); // Append any partial fence characters
                        }
                        try {
                            finalizeCodeBlock(true); // true indicates truncation
                        } catch (e) {
                            console.error(`Error finalizing code block on EOS for Turn ${currentTurnIdForMsg}:`, e);
                        }
                    } else if (currentProcessingMode === MODE_SEEKING_CODE_END_FENCE) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly while seeking code end fence. Treating fence buffer '${fenceBuffer}' as part of the code.`);
                        appendToCodeBlock(fenceBuffer); // Treat buffered fence characters as code content
                        try {
                            finalizeCodeBlock(true); // true indicates truncation
                        } catch (e) {
                            console.error(`Error finalizing code block on EOS (seeking end fence) for Turn ${currentTurnIdForMsg}:`, e);
                        }
                    } else if (currentProcessingMode === MODE_SEEKING_CODE_LANGUAGE && langBuffer && langBuffer.length > 0) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly while seeking code language. Treating '${FENCE}${langBuffer}' as plain text.`);
                        appendToAnswer(FENCE + langBuffer); // Append the incomplete fence and language buffer as text
                    } else if (currentProcessingMode === MODE_SEEKING_CODE_START_FENCE && fenceBuffer && fenceBuffer.length > 0) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly while seeking code start fence. Treating '${fenceBuffer}' as plain text.`);
                        appendToAnswer(fenceBuffer); // Append the incomplete fence buffer as text
                    } else if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE || currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly inside a KaTeX block. Attempting to render buffered content: "${katexBuffer}"`);
                        if (currentKatexMarkerId) {
                            renderAndReplaceKatex(currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY, currentKatexMarkerId);
                            currentKatexMarkerId = null; // Reset marker ID
                        } else {
                             // If no marker, append raw buffer as text to avoid losing it
                            appendToAnswer((currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY ? "$$" : "$") + katexBuffer);
                        }
                    } else if (currentProcessingMode === MODE_MAYBE_START_DISPLAY_KATEX) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly after a '$'. Treating as plain text.`);
                        appendToAnswer('$'); // Append the single dollar sign
                    } else if (currentProcessingMode === MODE_INSIDE_THINK || currentProcessingMode === MODE_MAYBE_END_THINK || currentProcessingMode === MODE_SEEKING_TAG) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly while in mode '${currentProcessingMode}'. Buffered tag: "${tagBuffer}", Buffered think: "${thinkBuffer}"`);
                        if (thinkingRequestedForCurrentTurn && currentThinkingArea && currentThinkingPreElement) {
                            if (tagBuffer) appendRawTextToThinkingArea(tagBuffer); // Append any partial tag
                            // thinkBuffer should have already been appended incrementally by appendRawTextToThinkingArea
                            appendRawTextToThinkingArea("\n--- (End of stream during thinking process) ---");
                        } else if (tagBuffer) { // If not in thinking mode but had a tag buffer
                            appendToAnswer(tagBuffer);
                        }
                    }
                    // Any other modes might just proceed to formatAnswerBubbleFinal with existing accumulatedAnswerText

                    formatAnswerBubbleFinal(); // Process and finalize the main answer content

                    // Add Timestamp to the live AI answer bubble
                    if (currentAnswerElement) {
                        const timestampElem = document.createElement('p');
                        timestampElem.classList.add('text-xs', 'text-slate-500', 'mt-1', 'text-left'); // Consistent styling
                        timestampElem.textContent = new Date().toLocaleString(); // Time when EOS is received
                        currentAnswerElement.appendChild(timestampElem); // Append to the main bubble, after content div
                    }

                    resetStreamingState(); // Reset all streaming state variables for the next turn
                    
                    // Re-enable input fields
                    if (typeof setInputDisabledState === 'function') {
                        setInputDisabledState(false);
                    }
                    
                    // Focus on the message input if it's visible
                    if (messageInput && messageInput.offsetParent !== null) {
                        messageInput.focus();
                    }
                    
                    // Scroll to the bottom of the chat history
                    setTimeout(() => scrollToBottom('smooth'), 50); 
                    
                    return; // Important to exit after handling EOS
                }

                if (chunk.startsWith("<ERROR>")) {
                    const errorMessage = chunk.substring(7);
                    console.error(`[ws.onmessage] Turn ${currentTurnIdForMsg}: Received <ERROR>:`, errorMessage);
                    if (typeof addErrorMessage === 'function') addErrorMessage(errorMessage);
                    finalizeTurnOnErrorOrClose(); // Your existing function
                    resetAllCodeButtonsOnErrorOrClose(); // Your existing function
                    setTimeout(() => scrollToBottom('smooth'), 50);
                    return;
                }

                if (chunk.length === 0) {
                        return;
                }

                if (!currentAiTurnContainer) { // Assuming global/accessible
                    if (chunk.trim().length > 0) {
                        console.warn(`%c[ws.onmessage] Turn ${currentTurnIdForMsg}: First non-empty chat chunk received, but turn container not set up? Forcing setup.`, 'color: red; font-weight: bold;');
                        setupNewAiTurn(); // Your existing function
                    } else {
                        return;
                    }
                }

                // Your existing complex state machine logic to process the chunk
                let currentPos = 0;
                while (currentPos < chunk.length) {
                    const char = chunk[currentPos];
                    let incrementPos = true;
                    let previousMode = currentProcessingMode; // Assuming global/accessible

                    if (char === '\\' && currentPos + 1 < chunk.length) {
                        const nextChar = chunk[currentPos + 1];
                        const escapableChars = '$`*\\<>';
                        if (escapableChars.includes(nextChar)) {
                            if (currentProcessingMode === MODE_INSIDE_THINK) { appendRawTextToThinkingArea(nextChar); }
                            else if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE || currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY) { katexBuffer += nextChar; appendToAnswer(nextChar); } // Assuming katexBuffer is global/accessible
                            else if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK) { appendToCodeBlock(nextChar); } // Your existing function
                            else { appendToAnswer(nextChar); } // Your existing function
                            currentPos += 2;
                            incrementPos = false;
                            continue;
                        }
                    }

                    switch (currentProcessingMode) { // Assuming global/accessible
                        case MODE_ANSWER:
                            if (char === FENCE[0]) {
                                if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                katexBuffer = ''; currentKatexMarkerId = null;
                                fenceBuffer = char; // Assuming fenceBuffer is global/accessible
                                currentProcessingMode = MODE_SEEKING_CODE_START_FENCE;
                            } else if (char === '$') {
                                if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                currentProcessingMode = MODE_MAYBE_START_DISPLAY_KATEX;
                            } else if (char === '<') {
                                    if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                tagBuffer = char; // Assuming tagBuffer is global/accessible
                                currentProcessingMode = MODE_SEEKING_TAG;
                            } else {
                                if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                appendToAnswer(char);
                            }
                            break;
                        // ... include all your other cases from the state machine ...
                        case MODE_SEEKING_CODE_START_FENCE:
                            if (char === FENCE[fenceBuffer.length]) {
                                fenceBuffer += char;
                                if (fenceBuffer === FENCE) {
                                    fenceBuffer = ''; langBuffer = ''; // Assuming langBuffer is global/accessible
                                    currentProcessingMode = MODE_SEEKING_CODE_LANGUAGE;
                                }
                            } else {
                                appendToAnswer(fenceBuffer);
                                fenceBuffer = '';
                                currentProcessingMode = MODE_ANSWER;
                                incrementPos = false;
                            }
                            break;
                        case MODE_SEEKING_CODE_LANGUAGE:
                                if (char === '\n') {
                                    currentCodeBlockLang = langBuffer.trim(); // Assuming global/accessible
                                    createCodeBlockStructure(currentCodeBlockLang); // Your existing function
                                    appendCodeReference(); // Your existing function
                                    langBuffer = '';
                                    currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                                } else if (langBuffer.length > 50) {
                                    console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: Code language line too long. Treating as text.`);
                                    appendToAnswer(FENCE + langBuffer + char);
                                    langBuffer = ''; fenceBuffer = '';
                                    currentProcessingMode = MODE_ANSWER;
                                } else {
                                    langBuffer += char;
                                }
                                break;
                        case MODE_INSIDE_CODE_BLOCK:
                            if (char === FENCE[0]) {
                                fenceBuffer = char;
                                currentProcessingMode = MODE_SEEKING_CODE_END_FENCE;
                            } else {
                                appendToCodeBlock(char);
                            }
                            break;
                        case MODE_SEEKING_CODE_END_FENCE:
                            if (char === FENCE[fenceBuffer.length]) {
                                fenceBuffer += char;
                                if (fenceBuffer === FENCE) {
                                    finalizeCodeBlock(); // Your existing function
                                    fenceBuffer = '';
                                    currentProcessingMode = MODE_ANSWER;
                                    lastAppendedNode = null; // Assuming global/accessible
                                    if (currentPos + 1 < chunk.length && chunk[currentPos + 1] === '\n') {
                                        currentPos++;
                                        incrementPos = true;
                                    }
                                }
                            } else {
                                appendToCodeBlock(fenceBuffer);
                                fenceBuffer = '';
                                currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                                incrementPos = false;
                            }
                            break;
                        case MODE_MAYBE_START_DISPLAY_KATEX:
                            if (char === '$') {
                                currentKatexMarkerId = `katex-marker-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
                                const startMarkerDisp = document.createElement('span');
                                startMarkerDisp.setAttribute('data-katex-start-id', currentKatexMarkerId);
                                startMarkerDisp.style.display = 'none';
                                appendToAnswer(null, startMarkerDisp);
                                appendToAnswer('$$');
                                currentProcessingMode = MODE_KATEX_BUFFERING_DISPLAY;
                                katexBuffer = '';
                            } else {
                                currentKatexMarkerId = `katex-marker-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
                                const startMarkerInline = document.createElement('span');
                                startMarkerInline.setAttribute('data-katex-start-id', currentKatexMarkerId);
                                startMarkerInline.style.display = 'none';
                                appendToAnswer(null, startMarkerInline);
                                appendToAnswer('$');
                                appendToAnswer(char);
                                currentProcessingMode = MODE_KATEX_BUFFERING_INLINE;
                                katexBuffer = char;
                            }
                            break;
                        case MODE_KATEX_BUFFERING_INLINE:
                            if (char === '$') {
                                appendToAnswer('$');
                                if (currentKatexMarkerId) { renderAndReplaceKatex(false, currentKatexMarkerId); currentKatexMarkerId = null; }
                                else { console.error(`Attempted end inline KaTeX Turn ${currentTurnIdForMsg} no marker ID!`); }
                                currentProcessingMode = MODE_ANSWER;
                            } else { katexBuffer += char; appendToAnswer(char); }
                            break;
                        case MODE_KATEX_BUFFERING_DISPLAY:
                                if (char === '$' && currentPos + 1 < chunk.length && chunk[currentPos + 1] === '$') {
                                    appendToAnswer('$$');
                                    if (currentKatexMarkerId) { renderAndReplaceKatex(true, currentKatexMarkerId); currentKatexMarkerId = null; }
                                    else { console.error(`Attempted end display KaTeX Turn ${currentTurnIdForMsg} no marker ID!`); }
                                    currentProcessingMode = MODE_ANSWER; currentPos++;
                                } else { katexBuffer += char; appendToAnswer(char); }
                                break;
                        case MODE_SEEKING_TAG:
                            tagBuffer += char;
                            const lowerTag = tagBuffer.toLowerCase();
                            if (lowerTag === THINK_START_TAG) {
                                thinkBuffer = ''; currentProcessingMode = MODE_INSIDE_THINK; tagBuffer = ''; lastAppendedNode = null; // Assuming thinkBuffer is global/accessible
                            } else if (THINK_START_TAG.startsWith(lowerTag)) { /* Keep buffering */ }
                            else {
                                appendToAnswer(tagBuffer); currentProcessingMode = MODE_ANSWER; tagBuffer = ''; incrementPos = false;
                            }
                            if (tagBuffer.length > 20) {
                                    console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: Tag buffer excessive, treating as text: ${tagBuffer}`);
                                    appendToAnswer(tagBuffer); currentProcessingMode = MODE_ANSWER; tagBuffer = ''; incrementPos = false;
                            }
                            break;
                        case MODE_INSIDE_THINK:
                                if (char === '<') {
                                    tagBuffer = char; currentProcessingMode = MODE_MAYBE_END_THINK;
                                } else { appendRawTextToThinkingArea(char); } // Your existing function
                                break;
                        case MODE_MAYBE_END_THINK:
                                tagBuffer += char;
                                const lowerEndTag = tagBuffer.toLowerCase();
                                if (lowerEndTag === THINK_END_TAG) {
                                    thinkBuffer = ''; tagBuffer = ''; currentProcessingMode = MODE_ANSWER; lastAppendedNode = null;
                                } else if (THINK_END_TAG.startsWith(lowerEndTag)) { /* Keep buffering */ }
                                else {
                                    appendRawTextToThinkingArea(tagBuffer);
                                    currentProcessingMode = MODE_INSIDE_THINK; tagBuffer = ''; incrementPos = false;
                                }
                                if (tagBuffer.length > 20) {
                                        console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: End tag buffer excessive, treating as think text: ${tagBuffer}`);
                                        appendRawTextToThinkingArea(tagBuffer); currentProcessingMode = MODE_INSIDE_THINK; tagBuffer = ''; incrementPos = false;
                                }
                                break;
                        default:
                            console.error(`Unknown processing mode: ${currentProcessingMode} in Turn ${currentTurnIdForMsg}`);
                            appendToAnswer(char);
                            currentProcessingMode = MODE_ANSWER;
                    }

                    if (incrementPos) { currentPos++; }
                }
                scrollToBottom(); // Your existing function
            }
        };

        ws.onerror = (event) => {
            // This is the full onerror logic from your provided script
            console.error("WebSocket error observed:", event);
            if (typeof addErrorMessage === 'function') addErrorMessage("WebSocket connection error. Please check the server or try refreshing. See console for details.");
            if (typeof finalizeTurnOnErrorOrClose === 'function') finalizeTurnOnErrorOrClose();
            if (typeof resetAllCodeButtonsOnErrorOrClose === 'function') resetAllCodeButtonsOnErrorOrClose();
            if (typeof setInputDisabledState === 'function') setInputDisabledState(true);
        };

        ws.onclose = (event) => {
            // This is the full onclose logic from your provided script
            console.log("WebSocket connection closed.", event);
            if (typeof addSystemMessage === 'function') addSystemMessage(`Connection closed: ${event.reason || 'Normal closure'} (Code: ${event.code})`);
            if (typeof finalizeTurnOnErrorOrClose === 'function') finalizeTurnOnErrorOrClose();
            if (typeof resetAllCodeButtonsOnErrorOrClose === 'function') resetAllCodeButtonsOnErrorOrClose();
            if (event.code !== 1000 && event.code !== 1005) {
                console.log("Unexpected WebSocket closure. Attempting to reconnect WebSocket in 3 seconds...");
                if (typeof addSystemMessage === 'function') addSystemMessage("Attempting to reconnect...");
                if (typeof setInputDisabledState === 'function') setInputDisabledState(true);
                setTimeout(() => { websocket = null; if (typeof resetStreamingState === 'function') resetStreamingState(); currentAiTurnContainer = null; connectWebSocket(); }, 3000); // Assuming currentAiTurnContainer is global/accessible
            } else { if (typeof setInputDisabledState === 'function') setInputDisabledState(true); }
        };
        // -----------------------------------------------------------------------------------------

        console.log("[DEBUG] WebSocket object created and handlers assigned.");

    } catch (error) {
        console.error("[DEBUG] CRITICAL Error creating WebSocket object:", error);
        if (typeof addErrorMessage === 'function') { addErrorMessage(`WebSocket Creation Error: ${error.message}. Please check server and refresh.`); }
        else { alert(`WebSocket Creation Error: ${error.message}. Please check server and refresh.`); }
        if (typeof setInputDisabledState === 'function') setInputDisabledState(true);
    }
}

let throttledStreamHighlight = throttle(() => {
    // Optional: Keep logs to verify throttling
    console.log(">>> throttledStreamHighlight: Attempting highlight..."); 
    console.log(`>>> throttledStreamHighlight: currentProcessingMode = ${currentProcessingMode}`);
    console.log(">>> throttledStreamHighlight: currentCodeBlockElement =", currentCodeBlockElement);

    if (currentCodeBlockElement && currentProcessingMode === MODE_INSIDE_CODE_BLOCK) {
        console.log(">>> throttledStreamHighlight: Conditions met."); 
        try {
            if (typeof Prism !== 'undefined' && typeof Prism.highlightElement === 'function') {
                console.log(">>> throttledStreamHighlight: Calling Prism.highlightElement..."); 
                Prism.highlightElement(currentCodeBlockElement);
                console.log(">>> throttledStreamHighlight: Prism.highlightElement call completed."); 
            } else {
                console.warn(">>> throttledStreamHighlight: Prism.js or highlightElement not available!");
            }
        } catch (e) {
            console.error(">>> throttledStreamHighlight: Error during highlight:", e, currentCodeBlockElement);
        }
    } else {
         console.log(">>> throttledStreamHighlight: Conditions NOT met. Skipping highlight."); 
    }
// Throttle limit in milliseconds (e.g., run at most once every 250ms)
}, 250); // Adjust limit as needed (e.g., 200-500ms) 


// Helper function to escape HTML to prevent XSS where markdown is not intended.
function escapeHTML(str) {
    if (str === null || str === undefined) return '';
    return str.toString()
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}


function renderSingleMessage(msg, chatHistoryDiv, isHistory = false) {
    // Ensure essential parameters and libraries are available
    if (!chatHistoryDiv || !msg) {
        console.warn("[RenderMessage] Missing chatHistoryDiv or message object. Message:", msg);
        return;
    }
    if (typeof marked === 'undefined') {
        console.error("[RenderMessage] marked.js library is not loaded. Cannot render markdown content.");
        const plainTextDiv = document.createElement('div');
        plainTextDiv.classList.add('message-item', 'p-3', 'rounded-lg', 'max-w-xl', 'mb-2', 'break-words', 'bg-red-100', 'text-red-700');
        plainTextDiv.textContent = `Error: Markdown library not found. Raw content: ${msg.content || 'N/A'}`;
        chatHistoryDiv.appendChild(plainTextDiv);
        return;
    }
    if (typeof katex === 'undefined') {
        console.warn("[RenderMessage] KaTeX library not found. Math expressions may not render correctly.");
    }


    const senderType = msg.sender_type;
    let originalMessageContent = msg.content || ''; // Raw content from DB
    // Use sender_name from DB if available, otherwise determine default based on type
    const senderName = msg.sender_name || (senderType === 'ai' ? 'AI' : (senderType === 'user' ? 'User' : 'System'));
    const timestamp = msg.timestamp;
    const historicalThinkingContent = msg.thinking_content; // For AI messages

    const KATEX_PLACEHOLDER_PREFIX_HISTORICAL = '%%HISTORICAL_KATEX_PLACEHOLDER_';

    // --- Handle User and System Messages (Simpler Rendering) ---
    if (senderType === 'user' || senderType === 'system') {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message-item', 'p-3', 'rounded-lg', 'max-w-xl', 'mb-2', 'break-words', 'flex', 'flex-col');
        messageDiv.setAttribute('data-sender', senderType);
        if (msg.id) { messageDiv.setAttribute('data-message-id', String(msg.id)); }
        if (msg.client_id_temp && isHistory) { messageDiv.setAttribute('data-client-id-temp', msg.client_id_temp); }

        if (senderType === 'user') {
            messageDiv.classList.add('bg-emerald-100', 'self-end', 'ml-auto');
        } else { // System message
            messageDiv.classList.add('bg-slate-200', 'self-center', 'mx-auto', 'text-xs', 'italic');
        }

        const senderElem = document.createElement('p');
        senderElem.classList.add('font-semibold', 'text-sm', 'mb-1');
        if (senderType === 'user') senderElem.classList.add('text-emerald-700');
        else senderElem.classList.add('text-slate-600');
        // Use the senderName determined earlier (from DB or default)
        senderElem.textContent = escapeHTML(senderName); // escapeHTML should be defined
        messageDiv.appendChild(senderElem);

        const contentElem = document.createElement('div');
        contentElem.classList.add('text-gray-800', 'text-sm', 'message-content');

        // --- ADDED: Strip NO_THINK_PREFIX for historical user messages ---
        let displayedContent = originalMessageContent;
        if (senderType === 'user' && typeof NO_THINK_PREFIX === 'string' && NO_THINK_PREFIX.length > 0 && displayedContent.startsWith(NO_THINK_PREFIX)) {
            displayedContent = displayedContent.substring(NO_THINK_PREFIX.length);
            // console.log(`[RenderMessage] Stripped NO_THINK_PREFIX from historical user message ID: ${msg.id}`); // Optional log
        }
        // --- END OF ADDED CHANGE ---

        // For user/system, content is parsed as Markdown (after potential prefix stripping for user)
        contentElem.innerHTML = marked.parse(displayedContent);
        messageDiv.appendChild(contentElem);

        if (timestamp) {
            const timestampElem = document.createElement('p');
            timestampElem.classList.add('text-xs', 'text-slate-500', 'mt-1');
            if (senderType === 'user') timestampElem.classList.add('text-right');
            else timestampElem.classList.add('text-center');
            try {
                timestampElem.textContent = new Date(timestamp).toLocaleString();
            } catch (e) {
                timestampElem.textContent = String(timestamp); // Fallback for invalid date
            }
            messageDiv.appendChild(timestampElem);
        }
        chatHistoryDiv.appendChild(messageDiv);

    // --- Handle AI Messages (Complex Rendering - Assumed Correct from Previous Steps) ---
    } else if (senderType === 'ai') {
        // ... (Keep the complex AI message rendering logic from the previous version) ...
        // ... (This includes thinking area, code block extraction/rendering, KaTeX processing) ...
        
        // For brevity, the full AI rendering logic is omitted here, but it should be the
        // same as the one in the previous complete 'renderSingleMessage' function.
        // Ensure the following steps are performed on originalMessageContent:
        // 1. Extract code blocks, render them using createHistoricalCodeBlockDisplay, replace with placeholders.
        // 2. Extract KaTeX, render using katex.renderToString, replace with placeholders.
        // 3. Parse the remaining content with marked.parse().
        // 4. Reinsert the rendered KaTeX HTML.
        // 5. Assemble the full ai-turn-container with thinking, answer bubble, and code blocks area.

        // --- Start of AI Message Rendering Logic (Copied from previous complete version) ---
        const turnIdSuffix = msg.id ? String(msg.id) : `hist-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
        const aiTurnContainer = document.createElement('div');
        aiTurnContainer.classList.add('ai-turn-container');
        aiTurnContainer.setAttribute('data-sender', 'ai');
        if (msg.id) { aiTurnContainer.setAttribute('data-message-id', String(msg.id)); }
        if (msg.client_id_temp && isHistory) { aiTurnContainer.setAttribute('data-client-id-temp', msg.client_id_temp); }
        aiTurnContainer.dataset.turnId = `historical-${turnIdSuffix}`;

        // --- 1. Thinking Area Setup ---
        const thinkingArea = document.createElement('div');
        thinkingArea.classList.add('thinking-area');
        thinkingArea.dataset.turnId = `historical-${turnIdSuffix}`; 
        const details = document.createElement('details');
        details.id = `thinking-details-historical-${turnIdSuffix}`;
        const summary = document.createElement('summary');
        summary.classList.add('thinking-summary');
        const summaryTextSpan = document.createElement('span');
        summaryTextSpan.classList.add('text');
        summaryTextSpan.textContent = 'Show Thinking';
        const summaryDotsSpan = document.createElement('span'); 
        summaryDotsSpan.classList.add('dots');
        summary.appendChild(summaryTextSpan);
        summary.appendChild(summaryDotsSpan);
        const thinkingPreElement = document.createElement('pre');
        if (historicalThinkingContent && historicalThinkingContent.trim() !== "") {
            thinkingPreElement.textContent = historicalThinkingContent;
        } else {
            thinkingPreElement.textContent = '(No historical thinking data available for this AI message)';
            thinkingArea.style.display = 'none'; 
        }
        details.appendChild(summary);
        details.appendChild(thinkingPreElement);
        thinkingArea.appendChild(details);
        aiTurnContainer.appendChild(thinkingArea);
        details.addEventListener('toggle', (event) => {
            const textSpan = event.target.querySelector('.thinking-summary .text');
            if (!textSpan) return;
            textSpan.textContent = event.target.open ? 'Hide Thinking' : 'Show Thinking';
        });

        // --- Main Answer Bubble & Code Blocks Area ---
        const answerElement = document.createElement('div');
        answerElement.classList.add('message', 'ai-message', 'p-3', 'rounded-lg', 'max-w-xl', 'mb-2', 'break-words', 'flex', 'flex-col', 'bg-sky-100', 'self-start', 'mr-auto');
        const codeBlocksArea = document.createElement('div');
        codeBlocksArea.classList.add('code-blocks-area');
        let contentForProcessing = originalMessageContent;

        // --- 2. Extract and Render Code Blocks ---
        let historicalCodeBlockCounter = 0;
        const codeBlockRegex = /```(\w*)\n([\s\S]*?)\n```/g; 
        let matchCode;
        const extractedCodeBlocks = [];
        let tempContentForCodeExtraction = contentForProcessing;
        let contentAfterCodeExtraction = "";
        let lastCodeMatchEndIndex = 0;
        while ((matchCode = codeBlockRegex.exec(tempContentForCodeExtraction)) !== null) {
            historicalCodeBlockCounter++;
            const language = matchCode[1] || 'plaintext'; 
            const code = matchCode[2];
            const placeholder = `%%HISTORICAL_CODE_BLOCK_${historicalCodeBlockCounter}%%`;
            extractedCodeBlocks.push({ language, code, placeholder, index: historicalCodeBlockCounter });
            contentAfterCodeExtraction += tempContentForCodeExtraction.substring(lastCodeMatchEndIndex, matchCode.index);
            contentAfterCodeExtraction += placeholder;
            lastCodeMatchEndIndex = codeBlockRegex.lastIndex; 
        }
        contentAfterCodeExtraction += tempContentForCodeExtraction.substring(lastCodeMatchEndIndex);
        contentForProcessing = contentAfterCodeExtraction; 
        extractedCodeBlocks.forEach(block => {
            if (typeof createHistoricalCodeBlockDisplay === 'function') {
                createHistoricalCodeBlockDisplay(block.language, block.code, turnIdSuffix, block.index, codeBlocksArea);
            } else {
                console.warn('createHistoricalCodeBlockDisplay function is not defined. Cannot render historical code block fully.');
                 const fallbackDiv = document.createElement('div'); 
                 fallbackDiv.textContent = `[Code ${block.index} (${block.language}) - Full display unavailable]`;
                 codeBlocksArea.appendChild(fallbackDiv);
            }
            const referenceText = ` [Code ${block.index}] `;
            contentForProcessing = contentForProcessing.replace(block.placeholder, referenceText);
        });

        // --- 3. Pre-process for KaTeX ---
        const storedHistoricalKatex = {}; 
        let katexPlaceholderIndex = 0;
        const katexRegexGlobal = /(?<!\\)\$\$([\s\S]+?)(?<!\\)\$\$|(?<!\\)\$((?:\\\$|[^$])+?)(?<!\\)\$/g;
        let textForMarkdownParsing = contentForProcessing.replace(katexRegexGlobal, (match, displayContent, inlineContent) => {
            const isDisplayMode = !!displayContent; 
            const katexString = displayContent || inlineContent;
            const cleanedKatexString = katexString.replace(/\\([$])/g, '$1');
            let katexHtml = '';
            if (typeof katex !== 'undefined' && typeof katex.renderToString === 'function') {
                try {
                    katexHtml = katex.renderToString(cleanedKatexString, {
                        displayMode: isDisplayMode, throwOnError: false, output: "html", strict: false 
                    });
                } catch (e) {
                    console.error("Error rendering historical KaTeX:", e, "Original string:", match);
                    katexHtml = `<span class="katex-error" title="${escapeHTML(e.toString())}">${escapeHTML(match)}</span>`;
                }
            } else {
                return match; 
            }
            const placeholderId = `${KATEX_PLACEHOLDER_PREFIX_HISTORICAL}${katexPlaceholderIndex++}`;
            storedHistoricalKatex[placeholderId] = katexHtml; 
            return placeholderId; 
        });

        // --- 4. Markdown Parsing ---
        const senderElemAI = document.createElement('p'); // Use different var name to avoid conflict
        senderElemAI.classList.add('font-semibold', 'text-sm', 'mb-1', 'text-sky-700');
        senderElemAI.textContent = escapeHTML(senderName); // Use senderName which is 'AI' here
        answerElement.appendChild(senderElemAI);
        const contentElemAI = document.createElement('div'); // Use different var name
        contentElemAI.classList.add('text-gray-800', 'text-sm', 'message-content');
        contentElemAI.innerHTML = marked.parse(textForMarkdownParsing); 
        answerElement.appendChild(contentElemAI);

        // --- 5. KaTeX Post-processing ---
        if (Object.keys(storedHistoricalKatex).length > 0) {
            const walker = document.createTreeWalker(contentElemAI, NodeFilter.SHOW_TEXT, null, false);
            let node;
            const textNodesToModify = []; 
            while (node = walker.nextNode()) {
                if (node.nodeValue && node.nodeValue.includes(KATEX_PLACEHOLDER_PREFIX_HISTORICAL)) {
                    textNodesToModify.push(node);
                }
            }
            textNodesToModify.forEach(textNode => {
                let currentTextValue = textNode.nodeValue;
                const parent = textNode.parentNode;
                if (!parent) return;
                const fragment = document.createDocumentFragment(); 
                let lastSplitEnd = 0;
                const placeholderScanRegex = new RegExp(`(${KATEX_PLACEHOLDER_PREFIX_HISTORICAL}\\d+)`, 'g');
                let placeholderMatch;
                while((placeholderMatch = placeholderScanRegex.exec(currentTextValue)) !== null) {
                    const placeholderId = placeholderMatch[1]; 
                    const matchStartIndex = placeholderMatch.index;
                    if (matchStartIndex > lastSplitEnd) {
                        fragment.appendChild(document.createTextNode(currentTextValue.substring(lastSplitEnd, matchStartIndex)));
                    }
                    if (storedHistoricalKatex[placeholderId]) {
                        const katexWrapperSpan = document.createElement('span');
                        katexWrapperSpan.innerHTML = storedHistoricalKatex[placeholderId];
                        if (katexWrapperSpan.childNodes.length === 1 && katexWrapperSpan.firstChild.nodeType === Node.ELEMENT_NODE) {
                             fragment.appendChild(katexWrapperSpan.firstChild);
                        } else {
                             fragment.appendChild(katexWrapperSpan);
                        }
                    } else {
                        fragment.appendChild(document.createTextNode(placeholderId));
                    }
                    lastSplitEnd = placeholderScanRegex.lastIndex; 
                }
                if (lastSplitEnd < currentTextValue.length) {
                    fragment.appendChild(document.createTextNode(currentTextValue.substring(lastSplitEnd)));
                }
                parent.replaceChild(fragment, textNode);
            });
        }

        // --- Timestamp and Final Assembly ---
        if (timestamp) {
            const timestampElemAI = document.createElement('p'); // Use different var name
            timestampElemAI.classList.add('text-xs', 'text-slate-500', 'mt-1', 'text-left');
            try {
                timestampElemAI.textContent = new Date(timestamp).toLocaleString();
            } catch (e) {
                timestampElemAI.textContent = String(timestamp);
            }
            answerElement.appendChild(timestampElemAI);
        }
        aiTurnContainer.appendChild(answerElement); 
        aiTurnContainer.appendChild(codeBlocksArea);  
        chatHistoryDiv.appendChild(aiTurnContainer); 
        // --- End of AI Message Rendering Logic ---
    }
}


async function loadAndDisplayChatHistory(sessionId) {
    const chatHistoryDiv = document.getElementById('chat-history');
    if (!chatHistoryDiv) {
        console.error("Chat history container 'chat-history' not found.");
        return;
    }

    // Update chat session title - assuming it's available via an API or could be fetched.
    // For now, we'll set a generic one or rely on existing logic if it sets the title.
    // const chatSessionTitleElement = document.getElementById('chat-session-title');
    // if (chatSessionTitleElement) chatSessionTitleElement.textContent = `Chat: ${sessionId.substring(0,8)}...`;


    chatHistoryDiv.innerHTML = '<p class="text-center text-gray-500 p-4">Loading history...</p>'; 

    try {
        const response = await fetch(`/api/sessions/${sessionId}/messages`);
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ detail: "Failed to load chat history." }));
            console.error(`Error fetching chat history for session ${sessionId}:`, response.status, errorData.detail);
            chatHistoryDiv.innerHTML = `<p class="text-center text-red-500 p-4">Error loading history: ${escapeHTML(errorData.detail || response.statusText)}</p>`;
            return;
        }

        const messages = await response.json();
        chatHistoryDiv.innerHTML = ''; // Clear loading indicator

        if (messages.length === 0) {
            chatHistoryDiv.innerHTML = '<p class="text-center text-gray-500 p-4">No messages in this session yet. Start chatting!</p>';
        } else {
            messages.forEach(msg => {
                // Use the new renderSingleMessage function
                renderSingleMessage(msg, chatHistoryDiv, true);
            });
            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight; 
        }
        console.log(`Successfully loaded ${messages.length} messages for session ${sessionId}.`);

    } catch (error) {
        console.error(`Failed to fetch or display chat history for session ${sessionId}:`, error);
        chatHistoryDiv.innerHTML = `<p class="text-center text-red-500 p-4">An unexpected error occurred while loading history. Check console.</p>`;
    }
}


function createHistoricalCodeBlockDisplay(language, codeContent, turnIdSuffix, codeBlockIndex, codeBlocksAreaElement) {
    // Ensure the target area for code blocks exists
    if (!codeBlocksAreaElement) {
        console.error("createHistoricalCodeBlockDisplay: Code blocks area element is null! Cannot append code block.");
        return;
    }

    const blockId = `historical-code-block-turn${turnIdSuffix}-${codeBlockIndex}`;
    const safeLanguage = (language || '').trim().toLowerCase() || 'plaintext';

    // Language aliases and Prism language determination (as before)
    const langAlias = { /* ... keep your existing aliases ... */
        'python': 'python', 'py': 'python', 'javascript': 'javascript', 'js': 'javascript',
        'html': 'markup', 'xml': 'markup', 'svg': 'markup', 'css': 'css', 'bash': 'bash',
        'sh': 'bash', 'shell': 'bash', 'json': 'json', 'yaml': 'yaml', 'yml': 'yaml',
        'markdown': 'markdown', 'md': 'markdown', 'sql': 'sql', 'java': 'java', 'c': 'c',
        'cpp': 'cpp', 'c++': 'cpp', 'csharp': 'csharp', 'cs': 'csharp', 'go': 'go',
        'rust': 'rust', 'php': 'php', 'ruby': 'ruby', 'rb': 'ruby',
        'dockerfile': 'docker', 'docker': 'docker', 'typescript': 'typescript', 'ts': 'typescript',
        'plaintext': 'plain', 'text': 'plain',
     };
    const prismLang = langAlias[safeLanguage] || safeLanguage;
    const displayLang = safeLanguage; // Use the cleaned-up language name for checks/display

    // --- ADD: List of languages supported by the backend Docker execution ---
    // Make sure this list matches the one in createCodeBlockStructure
    const supportedExecutionLanguages = [
        "python", "javascript", "cpp", "csharp", "typescript", "java", "go", "rust"
        // Add or remove languages based on your config.py SUPPORTED_LANGUAGES keys
    ];
    const isLanguageSupported = supportedExecutionLanguages.includes(displayLang);
    // --- END OF ADD ---


    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;

    const container = document.createElement('div');
    container.classList.add('code-block-container', 'historical-code-block');
    container.id = blockId;
    container.dataset.language = displayLang;

    const codeHeader = document.createElement('div');
    codeHeader.classList.add('code-block-header');

    const codeButtonsDiv = document.createElement('div');
    codeButtonsDiv.classList.add('code-block-buttons');

    // Create buttons (as before)
    const runStopBtn = document.createElement('button');
    runStopBtn.classList.add('run-code-btn', 'code-action-btn');
    runStopBtn.innerHTML = playIconSvg;
    runStopBtn.title = 'Run Code';
    runStopBtn.dataset.status = 'idle';
    runStopBtn.addEventListener('click', handleRunStopCodeClick);

    const toggleCodeBtn = document.createElement('button');
    toggleCodeBtn.classList.add('toggle-code-btn', 'code-action-btn');
    toggleCodeBtn.textContent = 'Hide';
    toggleCodeBtn.title = 'Show/Hide Code';

    const copyCodeBtn = document.createElement('button');
    copyCodeBtn.classList.add('copy-code-btn', 'code-action-btn');
    copyCodeBtn.textContent = 'Copy';
    copyCodeBtn.title = 'Copy Code';

    // --- ADD: Conditionally hide run button ---
    if (!isLanguageSupported) {
        runStopBtn.style.display = 'none'; // Hide the button entirely
        runStopBtn.title = `Run Code (language '${displayLang}' not supported for execution)`; // Update title
    }
    // --- END OF ADD ---

    // Add buttons to their container
    codeButtonsDiv.appendChild(runStopBtn);
    codeButtonsDiv.appendChild(toggleCodeBtn);
    codeButtonsDiv.appendChild(copyCodeBtn);

    // Code block title (as before)
    const codeTitle = document.createElement('span');
    codeTitle.classList.add('code-block-title');
    codeTitle.textContent = `Code ${codeBlockIndex} (${displayLang})`;
    codeTitle.style.flexGrow = '1';
    codeTitle.style.textAlign = 'left';

    // Assemble header (as before)
    codeHeader.appendChild(codeButtonsDiv);
    codeHeader.appendChild(codeTitle);

    // Create pre/code elements (as before)
    const preElement = document.createElement('pre');
    preElement.classList.add('manual');
    const codeElement = document.createElement('code');
    codeElement.className = `language-${prismLang}`;
    codeElement.setAttribute('contenteditable', 'true'); // Historical code editable
    codeElement.setAttribute('spellcheck', 'false');
    codeElement.textContent = codeContent;

    // Assemble code display area (as before)
    preElement.appendChild(codeElement);
    container.appendChild(codeHeader);
    container.appendChild(preElement);

    // Create output area structure (as before)
    const outputHeader = document.createElement('div');
    outputHeader.classList.add('code-output-header');
    outputHeader.style.display = 'none';
    // ... (rest of output header setup: buttons, title, status span) ...
    const outputButtonsDiv = document.createElement('div');
    outputButtonsDiv.classList.add('code-block-buttons');
    const placeholderSpan = document.createElement('span');
    placeholderSpan.classList.add('output-header-button-placeholder');
    outputButtonsDiv.appendChild(placeholderSpan);
    const toggleOutputBtn = document.createElement('button');
    toggleOutputBtn.classList.add('toggle-output-btn', 'code-action-btn');
    toggleOutputBtn.textContent = 'Hide';
    toggleOutputBtn.title = 'Show/Hide Output';
    const copyOutputBtn = document.createElement('button');
    copyOutputBtn.classList.add('copy-output-btn', 'code-action-btn');
    copyOutputBtn.textContent = 'Copy';
    copyOutputBtn.title = 'Copy Output';
    outputButtonsDiv.appendChild(toggleOutputBtn);
    outputButtonsDiv.appendChild(copyOutputBtn);
    const outputTitle = document.createElement('span');
    outputTitle.classList.add('output-header-title');
    outputTitle.textContent = `Output Code ${codeBlockIndex}`;
    const codeStatusSpan = document.createElement('span');
    codeStatusSpan.classList.add('code-status-span');
    codeStatusSpan.textContent = 'Idle';
    outputHeader.appendChild(outputButtonsDiv);
    outputHeader.appendChild(outputTitle);
    outputHeader.appendChild(codeStatusSpan);

    const outputConsoleDiv = document.createElement('div');
    outputConsoleDiv.classList.add('code-output-console');
    outputConsoleDiv.style.display = 'none';
    const outputPre = document.createElement('pre');
    outputConsoleDiv.appendChild(outputPre);

    // Append output area to container (as before)
    container.appendChild(outputHeader);
    container.appendChild(outputConsoleDiv);

    // Add event listeners (as before)
    // Toggle code listener
    toggleCodeBtn.addEventListener('click', () => {
        const isHidden = preElement.classList.toggle('hidden');
        toggleCodeBtn.textContent = isHidden ? 'Show' : 'Hide';
    });
    // Copy code listener
    copyCodeBtn.addEventListener('click', async () => {
        try {
            await navigator.clipboard.writeText(codeElement.textContent || '');
            copyCodeBtn.textContent = 'Copied!';
            copyCodeBtn.classList.add('copied');
            setTimeout(() => { copyCodeBtn.textContent = 'Copy'; copyCodeBtn.classList.remove('copied'); }, 1500);
        } catch (err) {
            console.error('Failed to copy historical code: ', err);
            copyCodeBtn.textContent = 'Error';
            setTimeout(() => { copyCodeBtn.textContent = 'Copy'; }, 1500);
        }
    });
    // Run button listener is already attached above
    // Debounced highlight listener for editable historical code (as before)
    const debouncedHistoricalHighlight = debounce(() => {
        const savedPosition = getCursorPosition(codeElement);
        if (savedPosition === -1) { console.warn(`Could not save cursor position for historical block ${blockId}. Highlight may cause cursor jump.`); }
        try {
            const currentText = codeElement.textContent;
            codeElement.innerHTML = ''; 
            codeElement.textContent = currentText; 
            Prism.highlightElement(codeElement); 
            if (savedPosition !== -1) { setCursorPosition(codeElement, savedPosition); }
        } catch (e) {
            console.error(`Error during debounced highlighting for historical block ${blockId}:`, e);
            if (savedPosition !== -1) { setCursorPosition(codeElement, savedPosition); }
        }
    }, 500); 
    codeElement.addEventListener('input', debouncedHistoricalHighlight);
    codeElement.addEventListener('paste', (e) => { setTimeout(debouncedHistoricalHighlight, 100); });
    // Output area listeners (as before)
    toggleOutputBtn.addEventListener('click', () => {
        const isHidden = outputConsoleDiv.classList.toggle('hidden');
        toggleOutputBtn.textContent = isHidden ? 'Show' : 'Hide';
    });
    copyOutputBtn.addEventListener('click', async () => {
        if (!outputPre) return;
        try {
            await navigator.clipboard.writeText(outputPre.textContent || '');
            copyOutputBtn.textContent = 'Copied!';
            copyOutputBtn.classList.add('copied');
            setTimeout(() => { copyOutputBtn.textContent = 'Copy'; copyOutputBtn.classList.remove('copied'); }, 1500);
        } catch (err) {
            console.error('Failed to copy historical output: ', err);
            copyOutputBtn.textContent = 'Error';
            setTimeout(() => { copyOutputBtn.textContent = 'Copy'; }, 1500);
        }
    });

    // Apply initial Prism highlighting (as before)
    if (typeof Prism !== 'undefined' && typeof Prism.highlightElement === 'function') {
        try {
            Prism.highlightElement(codeElement);
        } catch (e) {
            console.error(`Prism highlight error on initial historical code block (lang '${prismLang}', ID: ${blockId}):`, e, codeElement);
        }
    } else {
        console.warn("Prism.js or Prism.highlightElement not available. Historical code will not be highlighted.");
    }

    // Append the fully constructed code block to the designated area
    codeBlocksAreaElement.appendChild(container);
}


async function initializeCurrentUser() {
    try {
        const response = await fetch('/api/me');
        if (response.ok) {
            const userData = await response.json();
            if (userData && userData.name) {
                window.currentUserInfo = {
                    name: userData.name,
                    email: userData.email,
                    id: userData.id
                };
            } else {
                window.currentUserInfo = null;
            }
        } else {
            window.currentUserInfo = null;
        }
    } catch (error) {
        window.currentUserInfo = null;
    }
}

async function fetchAndDisplaySessions() {
    // This function should be defined in your script.js
    const sessionListElement = document.getElementById('session-list');
    const chatSessionTitle = document.getElementById('chat-session-title'); // If you use this to update title

    if (!sessionListElement) {
        console.error("[fetchAndDisplaySessions] Session list element (#session-list) not found.");
        return;
    }

    sessionListElement.innerHTML = '<li class="px-3 py-1 text-gray-400 italic text-sm">Loading sessions...</li>';

    try {
        const response = await fetch('/api/sessions');
        if (!response.ok) {
            let errorDetail = `HTTP error ${response.status}`;
            try {
                const errorJson = await response.json();
                errorDetail = errorJson.detail || errorDetail;
            } catch (e) { /* Ignore JSON parsing error if response is not JSON */ }
            console.error(`[fetchAndDisplaySessions] Error fetching sessions: ${errorDetail}`);
            sessionListElement.innerHTML = `<li class="px-3 py-1 text-red-400 italic text-sm">Error loading sessions</li>`;
            return;
        }

        const sessions = await response.json();
        sessionListElement.innerHTML = ''; 

        if (sessions.length === 0) {
            sessionListElement.innerHTML = '<li class="px-3 py-1 text-gray-400 italic text-sm">No sessions yet. Click "New Chat".</li>';
        } else {
            const activeSessionId = getSessionIdFromPath(); 

            sessions.forEach((session) => {
                if (!session.id || typeof session.name === 'undefined') { // Check if name is undefined, allow empty string
                    console.warn('Session object is missing id or name:', session);
                    return;
                }

                const listItem = document.createElement('li');
                // Added group for group-hover effects on the delete button
                listItem.className = 'flex items-center justify-between pr-2 group hover:bg-gray-700 rounded-md'; 

                const link = document.createElement('a');
                // Ensure chatPageBaseUrl is defined or use a fixed prefix like /chat/
                const chatPageBaseUrl = '/chat/'; 
                const base = chatPageBaseUrl.endsWith('/') ? chatPageBaseUrl : chatPageBaseUrl + '/';
                link.href = `${base}${session.id}`;
                
                // Make link take up available space, truncate text
                link.className = 'block pl-3 pr-1 py-2 text-gray-300 group-hover:text-white rounded-l-md text-sm truncate flex-grow';
                
                let lastActiveDisplay = "Never";
                if (session.last_active) {
                    try {
                        lastActiveDisplay = new Date(session.last_active).toLocaleString();
                    } catch (e) {
                        lastActiveDisplay = session.last_active; 
                    }
                }
                link.title = `${session.name || `Session ${session.id.substring(0,4)}...`}\nLast active: ${lastActiveDisplay}`;
                link.textContent = session.name || `Session ${session.id.substring(0, 8)}`;
                
                if (session.id === activeSessionId) {
                    link.classList.add('bg-gray-900', 'text-white', 'font-semibold');
                    listItem.classList.remove('hover:bg-gray-700'); // Remove general hover if active
                    listItem.classList.add('bg-gray-900'); // Highlight the whole li item
                    if (chatSessionTitle) {
                        chatSessionTitle.textContent = session.name || `Chat Session ${session.id.substring(0, 4)}`;
                    }
                }

                // --- ADDED DELETE BUTTON ---
                const deleteButton = document.createElement('button');
                deleteButton.innerHTML = '&#x2715;'; // Cross mark (X)
                // Styling for visibility on hover of the list item (group-hover)
                deleteButton.className = 'ml-2 p-1 text-gray-500 hover:text-red-400 focus:outline-none rounded-full hover:bg-gray-600 transition-colors duration-150 ease-in-out text-xs opacity-0 group-hover:opacity-100 focus:opacity-100 flex-shrink-0';
                deleteButton.title = `Delete session: ${session.name || 'Unnamed Session'}`;
                
                deleteButton.onclick = (event) => {
                    event.stopPropagation(); // Prevent navigating to the session link
                    event.preventDefault();   // Prevent any default button action
                    // Call a handler function, passing necessary info
                    handleDeleteSession(session.id, session.name || `Session ${session.id.substring(0,8)}`);
                };
                // --- END OF ADDED DELETE BUTTON ---

                listItem.appendChild(link);
                listItem.appendChild(deleteButton); // Append the delete button
                sessionListElement.appendChild(listItem);
            });
        }
    } catch (error) {
        console.error("[fetchAndDisplaySessions] Failed to fetch or display sessions:", error);
        sessionListElement.innerHTML = `<li class="px-3 py-1 text-red-400 italic text-sm">Error loading sessions</li>`;
    }
}


async function handleDeleteSession(sessionId, sessionName) {
    if (!window.confirm(`Are you sure you want to delete the session "${sessionName}"? This action cannot be undone.`)) {
        return;
    }

    // Get the CSRF token
    const csrfToken = getCookie('fastapi-csrf-token'); // Use the cookie name set by fastapi-csrf-protect

    if (!csrfToken) {
        const errorMsg = "Could not perform action: CSRF token not found. Please refresh the page.";
        console.error(errorMsg);
        if (typeof addErrorMessage === 'function') addErrorMessage(errorMsg);
        else alert(errorMsg);
        return;
    }

    try {
        const response = await fetch(`/api/sessions/${sessionId}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': csrfToken // Add the CSRF token header
                // Add other authorization headers if your API requires them,
                // though your session cookie should handle auth for this route.
            }
        });

        if (!response.ok) {
            // Try to parse error detail from JSON response
            let errorDetail = `Failed to delete session. Status: ${response.status}`;
            try {
                const errorData = await response.json();
                errorDetail = errorData.detail || errorDetail;
            } catch (e) {
                // If response is not JSON or parsing fails, use statusText
                errorDetail = response.statusText || errorDetail;
            }
            console.error(`Failed to delete session ${sessionId}.`, errorDetail);
            if(typeof addErrorMessage === 'function') addErrorMessage(`Error deleting session: ${errorDetail}`);
            else alert(`Error deleting session: ${errorDetail}`);
            return;
        }

        // Session deleted successfully (response.status === 204 No Content)
        console.log(`Session ${sessionId} successfully deleted.`);
        
        const currentPathSessionId = getSessionIdFromPath(); // Ensure this function is available
        if (currentPathSessionId === sessionId) {
            window.location.href = '/'; // Redirect to the session choice page
        } else {
            if (typeof fetchAndDisplaySessions === 'function') { // Ensure this function is available
                await fetchAndDisplaySessions();
            }
        }
    } catch (error) {
        console.error('Error during delete session request:', error);
        const errorMsg = 'An error occurred while trying to delete the session.';
        if(typeof addErrorMessage === 'function') addErrorMessage(errorMsg);
        else alert(errorMsg + " Please check the console.");
    }
}


document.addEventListener('DOMContentLoaded', async () => {
    await initializeCurrentUser();

    if (typeof setInputDisabledState === 'function') {
        setInputDisabledState(true, false); 
    }

    if (typeof marked !== 'undefined' && typeof marked.setOptions === 'function') {
        marked.setOptions({
            gfm: true, breaks: true, sanitize: false, smartLists: true, smartypants: false,
        });
    }

    if (typeof fetchAndDisplaySessions === 'function') {
        await fetchAndDisplaySessions();
    }


    if (chatForm && messageInput && sendButton && stopAiButton) {
        chatForm.addEventListener('submit', (event) => {
            event.preventDefault();
            const userMessage = messageInput.value.trim();
            if (!userMessage) return;
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                if (typeof addErrorMessage === 'function') addErrorMessage("Not connected to the server.");
                return;
            }
            try {
                if (typeof addUserMessage === 'function') addUserMessage(userMessage);
                thinkingRequestedForCurrentTurn = thinkCheckbox ? thinkCheckbox.checked : false;
                let messageTextForPayload;
                if (thinkingRequestedForCurrentTurn) {
                    messageTextForPayload = THINK_PREFIX + userMessage.replace(NO_THINK_PREFIX, '').replace(THINK_PREFIX, '');
                } else {
                    messageTextForPayload = NO_THINK_PREFIX + userMessage.replace(NO_THINK_PREFIX, '').replace(THINK_PREFIX, '');
                }
                if (typeof setupNewAiTurn === 'function') setupNewAiTurn();
                
                const messagePayload = {
                    type: "chat_message",
                    payload: {
                        user_input: messageTextForPayload,
                        turn_id: currentTurnId 
                    }
                };
                websocket.send(JSON.stringify(messagePayload));
                
                messageInput.value = '';
                if (typeof setInputDisabledState === 'function') {
                    setInputDisabledState(true, true); 
                }
            } catch (sendError) {
                if (typeof addErrorMessage === 'function') addErrorMessage(`Failed to send message: ${sendError.message}`);
            }
        });

        stopAiButton.addEventListener('click', () => {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                if (typeof addErrorMessage === 'function') addErrorMessage("Cannot stop: Not connected.");
                return;
            }
            const sessionId = (typeof getSessionIdFromPath === 'function') ? getSessionIdFromPath() : null;
            if (!sessionId) {
                if (typeof addErrorMessage === 'function') addErrorMessage("Cannot stop: Session ID not found.");
                return;
            }
            websocket.send(JSON.stringify({
                type: "stop_ai_stream",
                payload: {
                    client_id: clientId,
                    session_id: sessionId,
                    turn_id: currentTurnId 
                }
            }));
            stopAiButton.disabled = true;
            // The text/icon will be reset by finalizeTurnOnErrorOrClose -> setInputDisabledState
            
            if (typeof finalizeTurnOnErrorOrClose === 'function') {
                finalizeTurnOnErrorOrClose(); 
            }
        });

    } else {
        if (window.location.pathname.includes("/chat/")) {
            if (typeof addErrorMessage === 'function') addErrorMessage("Initialization Error: Chat input components missing.");
        }
    }

    const currentSessionId = (typeof getSessionIdFromPath === 'function') ? getSessionIdFromPath() : null;
    if (currentSessionId) {
        if (typeof loadAndDisplayChatHistory === 'function') { 
            await loadAndDisplayChatHistory(currentSessionId); 
        }
        if (typeof connectWebSocket === 'function') {
            connectWebSocket();
        } else {
            if (typeof addErrorMessage === 'function') addErrorMessage("Error: Cannot connect to chat server.");
        }
    } else {
        if (messageInput && typeof setInputDisabledState === 'function') {
             setInputDisabledState(true, false); 
        }
    }
});

=== app/static/session-choice.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to Tesseracs Chat</title>
    <link rel="stylesheet" href="/dist/input.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <script id="csrf-token-script-page-session-choice">
      // This placeholder will be replaced by the server with the actual raw CSRF token.
      window.csrfTokenRaw = "%%CSRF_TOKEN_RAW%%";
    </script>
    <script>
      // Optional immediate diagnostic client-side to verify token injection
      if (typeof window.csrfTokenRaw !== 'undefined' && window.csrfTokenRaw !== "%%CSRF_TOKEN_RAW%%") {
        console.log('SESSION CHOICE PAGE JS (after csrf-token-script): window.csrfTokenRaw is available.');
      } else {
        console.warn('SESSION CHOICE PAGE JS (after csrf-token-script): window.csrfTokenRaw IS STILL THE PLACEHOLDER "%%CSRF_TOKEN_RAW%%" OR UNDEFINED. Value:', window.csrfTokenRaw);
      }
    </script>    
    <style>
        .sidebar-scrollable { overflow-y: auto; scrollbar-width: thin; scrollbar-color: #a0aec0 #edf2f7; } /* Tailwind gray-400 and gray-200 */
        .sidebar-scrollable::-webkit-scrollbar { width: 6px; }
        .sidebar-scrollable::-webkit-scrollbar-track { background: #edf2f7; border-radius: 3px; } /* Tailwind gray-200 */
        .sidebar-scrollable::-webkit-scrollbar-thumb { background-color: #a0aec0; border-radius: 3px; border: 1px solid #edf2f7; } /* Tailwind gray-400 and gray-200 */
        /* Ensure body and html take full height for the flex container */
        html, body {
            height: 100%;
            margin: 0;
            font-family: 'Inter', sans-serif; /* Use Inter font */
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="flex h-screen overflow-hidden">
        <aside id="sidebar-loader-target" class="w-64 bg-gray-800 text-gray-200 flex flex-col overflow-hidden shrink-0">
            </aside>

        <main id="session-choice-content" class="flex-1 flex flex-col p-6 overflow-y-auto items-center justify-center">
            <div class="bg-white p-8 rounded-lg shadow-xl text-center max-w-lg">
                <h1 class="text-3xl font-bold text-gray-800 mb-4">Welcome to Tesseracs Chat, [User Name]!</h1>
                <p class="text-gray-600 mb-6">
                    Select an existing session from the sidebar to continue your conversations,
                    or click "New Chat" in the sidebar to start a fresh one.
                </p>
                <p class="text-gray-500 text-sm">
                    Engage in dynamic chat sessions, powered by advanced AI. Your discussions are saved and can be revisited anytime.
                </p>
            </div>
            <div class="mt-10 text-center">
                <h2 class="text-xl font-semibold text-gray-700 mb-3">About Tesseracs</h2>
                <p class="text-gray-600">
                    Tesseracs Chat is designed for seamless and intelligent conversations. <br/>
                    Manage your chat sessions efficiently and collaborate with AI.
                </p>
            </div>
        </main>
    </div>

    <script type="module">
        import { loadSidebarHTML, populateSessionList } from '/static/js/app-ui.js'; // Ensure setupSidebarCSRF is called within/after loadSidebarHTML

        document.addEventListener('DOMContentLoaded', async () => {
            console.log("Session Choice Page (Welcome Page): DOMContentLoaded. Attempting to load UI components.");
            const sidebarContainer = document.getElementById('sidebar-loader-target');
            if (!sidebarContainer) {
                console.error("Session Choice Page: Sidebar container 'sidebar-loader-target' not found!");
                return;
            }
            
            const sidebarLoaded = await loadSidebarHTML('/static/_sidebar.html', 'sidebar-loader-target');
            
            if (sidebarLoaded) {
                // The setupSidebarCSRF() call should ideally be part of loadSidebarHTML's success logic
                // or called immediately after if loadSidebarHTML is synchronous in its DOM update.
                const sessionListElement = document.getElementById('session-list');
                 if (sessionListElement) {
                    await populateSessionList('/api/sessions', 'session-list', '/chat/');
                } else {
                    console.error("Session Choice Page: Session list element 'session-list' not found after sidebar load.");
                }
            } else {
                console.error("Session Choice Page: Sidebar loading failed. Session list will not be populated.");
            }
        });
    </script>
    </body>
</html>

=== app/static/settings.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>User Settings - Tesseracs Chat</title>
    <link rel="stylesheet" href="/dist/input.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <script id="csrf-token-script-page-settings">
      // This placeholder will be replaced by the server with the actual raw CSRF token.
      window.csrfTokenRaw = "%%CSRF_TOKEN_RAW%%";
    </script>
    <script>
      // Optional immediate diagnostic client-side to verify token injection
      if (typeof window.csrfTokenRaw !== 'undefined' && window.csrfTokenRaw !== "%%CSRF_TOKEN_RAW%%") {
        console.log('SETTINGS PAGE JS (after csrf-token-script): window.csrfTokenRaw is available.');
      } else {
        console.warn('SETTINGS PAGE JS (after csrf-token-script): window.csrfTokenRaw IS STILL THE PLACEHOLDER "%%CSRF_TOKEN_RAW%%" OR UNDEFINED. Value:', window.csrfTokenRaw);
      }
    </script>    
    <style>
        .sidebar-scrollable { overflow-y: auto; scrollbar-width: thin; scrollbar-color: #a0aec0 #edf2f7; }
        .sidebar-scrollable::-webkit-scrollbar { width: 6px; }
        .sidebar-scrollable::-webkit-scrollbar-track { background: #edf2f7; border-radius: 3px; }
        .sidebar-scrollable::-webkit-scrollbar-thumb { background-color: #a0aec0; border-radius: 3px; border: 1px solid #edf2f7; }
        /* Additional styles for focused state or loading states if needed */
        input:read-only, select:disabled {
            background-color: #f3f4f6; /* Tailwind gray-100 */
            cursor: not-allowed;
            opacity: 0.7;
        }
        label {
            user-select: none;
        }
    </style>
</head>
<body class="font-inter bg-gray-100 text-gray-800">

    <div class="flex h-screen overflow-hidden">
        <aside id="sidebar-loader-target" class="w-64 bg-gray-800 text-gray-200 flex flex-col overflow-hidden">
            </aside>

        <main class="flex-1 flex flex-col overflow-y-auto p-6 items-center">
            <div class="bg-white p-6 md:p-8 rounded-lg shadow-xl w-full max-w-2xl lg:max-w-3xl"> <h1 class="text-2xl lg:text-3xl font-semibold text-gray-900 mb-6 border-b border-gray-200 pb-4">User Settings</h1>

                <div id="settings-message-area" class="p-3 rounded-md text-sm text-center mb-4" style="display: none;" role="alert" aria-live="polite"></div>

                <section id="account-settings" aria-labelledby="account-settings-heading" class="mb-8">
                    <h2 id="account-settings-heading" class="text-xl font-semibold text-gray-700 mb-5">Account Information</h2>
                    
                    <form id="update-name-form" class="space-y-4 mb-6">
                        <div class="mb-4">
                            <label for="current-name" class="block text-sm font-medium text-gray-700 mb-1">Current Name</label>
                            <input type="text" id="current-name" name="current-name" readonly
                                   class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm"
                                   placeholder="Loading...">
                        </div>
                        <div class="mb-4">
                            <label for="new-name" class="block text-sm font-medium text-gray-700 mb-1">New Name</label>
                            <input type="text" id="new-name" name="new_name" required autocomplete="name"
                                   class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:outline-none transition-colors duration-150"
                                   minlength="1" maxlength="100">
                        </div>
                        <div class="mb-4">
                            <label for="current-password-for-name" class="block text-sm font-medium text-gray-700 mb-1">Current Password <span class="text-gray-500">(to confirm name change)</span></label>
                            <input type="password" id="current-password-for-name" name="current_password" required autocomplete="current-password"
                                   class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:outline-none transition-colors duration-150">
                        </div>
                        <div>
                            <button type="submit" id="update-name-button"
                                    class="py-2.5 px-5 bg-blue-600 text-white rounded-md font-medium text-sm transition-colors duration-150 hover:bg-blue-700 focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:bg-gray-400 disabled:cursor-not-allowed">
                                Update Name
                            </button>
                        </div>
                    </form>

                    <div class="mt-6 pt-6 border-t border-gray-200">
                        <h3 class="text-lg font-medium text-gray-700 mb-3">Change Email</h3>
                        <p class="text-sm text-gray-500 mb-3" id="change-email-description">You will be logged out after successfully changing your email address.</p>
                        <form id="update-email-form" class="space-y-4 mb-6" aria-describedby="change-email-description">
                            <div class="mb-4">
                                <label for="current-email" class="block text-sm font-medium text-gray-700 mb-1">Current Email</label>
                                <input type="email" id="current-email" name="current-email" readonly
                                       class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm"
                                       placeholder="Loading...">
                            </div>
                            <div class="mb-4">
                                <label for="new-email" class="block text-sm font-medium text-gray-700 mb-1">New Email Address</label>
                                <input type="email" id="new-email" name="new_email" required autocomplete="email"
                                       class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:outline-none transition-colors duration-150">
                            </div>
                            <div class="mb-4">
                                <label for="current-password-for-email" class="block text-sm font-medium text-gray-700 mb-1">Current Password <span class="text-gray-500">(to confirm email change)</span></label>
                                <input type="password" id="current-password-for-email" name="current_password" required autocomplete="current-password"
                                       class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:outline-none transition-colors duration-150">
                            </div>
                            <div>
                                <button type="submit" id="update-email-button"
                                        class="py-2.5 px-5 bg-blue-600 text-white rounded-md font-medium text-sm transition-colors duration-150 hover:bg-blue-700 focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:bg-gray-400 disabled:cursor-not-allowed">
                                    Update Email Address
                                </button>
                            </div>
                        </form>
                    </div>

                    <div class="mt-6 pt-6 border-t border-gray-200">
                        <h3 class="text-lg font-medium text-gray-700 mb-3">Regenerate Password</h3>
                        <p class="text-sm text-gray-500 mb-3" id="regenerate-password-description">A new password will be generated and emailed to your current email address. You will be logged out after this action.</p>
                        <form id="regenerate-password-form" class="space-y-4" aria-describedby="regenerate-password-description">
                            <div class="mb-4">
                                <label for="current-password-for-regen" class="block text-sm font-medium text-gray-700 mb-1">Current Password <span class="text-gray-500">(to confirm password regeneration)</span></label>
                                <input type="password" id="current-password-for-regen" name="current_password" required autocomplete="current-password"
                                       class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:outline-none transition-colors duration-150">
                            </div>
                            <div>
                                <button type="submit" id="regenerate-password-button"
                                        class="py-2.5 px-5 bg-orange-600 text-white rounded-md font-medium text-sm transition-colors duration-150 hover:bg-orange-700 focus:ring-2 focus:ring-orange-500 focus:ring-offset-2 disabled:bg-gray-400 disabled:cursor-not-allowed">
                                    Regenerate Password & Send Email
                                </button>
                            </div>
                        </form>
                    </div>
                </section>

                <section id="llm-settings" class="mt-8 pt-6 border-t border-gray-200" aria-labelledby="llm-settings-heading">
                    <h2 id="llm-settings-heading" class="text-xl font-semibold text-gray-700 mb-5">LLM Configuration</h2>
                    <form id="llm-settings-form" class="space-y-4">
                        <div class="mb-4">
                            <label for="llm-provider" class="block text-sm font-medium text-gray-700 mb-1">Chat Provider</label>
                            <select id="llm-provider" name="selected_llm_provider_id"
                                    class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm bg-white focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:outline-none transition-colors duration-150"
                                    aria-describedby="llm-provider-status">
                                <option value="">Loading providers...</option>
                            </select>
                            <p id="llm-provider-status" class="text-xs text-gray-500 mt-1"></p>
                        </div>

                        <div class="mb-4">
                            <label for="llm-model" class="block text-sm font-medium text-gray-700 mb-1">Model</label>
                            <select id="llm-model" name="selected_llm_model_id"
                                    class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm bg-white focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:outline-none transition-colors duration-150"
                                    disabled> <option value="">Select a provider first</option>
                            </select>
                        </div>

                        <div id="llm-api-key-group" class="mb-4" style="display: none;" aria-hidden="true">
                            <label for="llm-api-key" class="block text-sm font-medium text-gray-700 mb-1">API Key</label>
                            <input type="password" id="llm-api-key" name="user_llm_api_key" autocomplete="off"
                                   class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:outline-none transition-colors duration-150"
                                   placeholder="Leave blank to use system key or if not required"
                                   aria-describedby="llm-api-key-status">
                            <p id="llm-api-key-status" class="text-xs text-gray-500 mt-1"></p>
                        </div>

                        <div id="llm-base-url-group" class="mb-4" style="display: none;" aria-hidden="true">
                            <label for="llm-base-url" class="block text-sm font-medium text-gray-700 mb-1">Custom Base URL <span class="text-gray-500">(Optional)</span></label>
                            <input type="url" id="llm-base-url" name="selected_llm_base_url" autocomplete="off"
                                   class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:outline-none transition-colors duration-150"
                                   placeholder="e.g., http://localhost:11434/v1"
                                   aria-describedby="llm-base-url-description">
                               <p id="llm-base-url-description" class="text-xs text-gray-500 mt-1">Typically for OpenAI-compatible servers or custom Ollama instances.</p>
                        </div>
                        <div>
                            <button type="submit" id="save-llm-settings-button"
                                    class="py-2.5 px-5 bg-blue-600 text-white rounded-md font-medium text-sm transition-colors duration-150 hover:bg-blue-700 focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:bg-gray-400 disabled:cursor-not-allowed">
                                Save LLM Settings
                            </button>
                        </div>
                    </form>
                </section>
            </div>
        </main>
    </div>

    <script type="module" src="/static/js/settings.js"></script>
    </body>
</html>

=== app/static/email_templates/password_reset_email.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Password Reset - Tesseracs Chat</title>
    <style>
        body {
            font-family: 'Inter', Arial, sans-serif;
            line-height: 1.6;
            color: #333333;
            margin: 0;
            padding: 0;
            background-color: #f7fafc;
        }
        .email-container {
            width: 100%;
            max-width: 600px;
            margin: 20px auto;
            background-color: #ffffff;
            padding: 25px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }
        .header {
            text-align: center;
            padding-bottom: 20px;
            border-bottom: 1px solid #edf2f7;
        }
        .header h2 {
            color: #2c5282;
            margin: 0;
            font-size: 24px;
            font-weight: 600;
        }
        .content {
            padding-top: 10px;
        }
        .content p {
            margin: 18px 0;
            font-size: 16px;
            color: #4a5568;
        }
        .content strong {
            color: #2b6cb0;
            font-weight: 500;
        }
        .password-display-container {
            margin: 25px 0;
            text-align: center;
        }
        .password-label {
            font-size: 16px;
            color: #4a5568;
            margin-bottom: 8px;
            display: block;
        }
        .password-value {
            background-color: #edf2f7;
            padding: 15px 20px;
            border-radius: 6px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.2em;
            text-align: center;
            color: #1a202c;
            border: 1px solid #cbd5e0;
            display: inline-block;
            letter-spacing: 1px;
            word-break: break-all;
        }
        .login-button-container {
            text-align: center;
            margin: 30px 0;
        }
        .login-button {
            display: inline-block;
            background-color: #3182ce;
            color: #ffffff !important;
            padding: 14px 28px;
            text-decoration: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.2s ease-in-out;
        }
        .login-button:hover {
            background-color: #2b6cb0;
        }
        .footer {
            text-align: center;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #edf2f7;
            font-size: 0.875em;
            color: #718096;
        }
        .link {
            color: #3182ce;
            text-decoration: none;
        }
        .link:hover {
            text-decoration: underline;
        }
        .url-display { /* Style for displaying the URL as text */
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            color: #718096; /* Tailwind gray-600 */
            word-break: break-all;
        }
    </style>
</head>
<body>
    <div class="email-container">
        <div class="header">
            <h2>Password Reset for Tesseracs Chat</h2>
        </div>
        <div class="content">
            <p>Hello {{ recipient_name }},</p>
            <p>As requested, your password for Tesseracs Chat has been reset.</p>
            <p>Your email: <strong>{{ email }}</strong></p>
            <div class="password-display-container">
                <span class="password-label">Your new password is:</span>
                <div class="password-value">{{ password }}</div>
            </div>
            <p>Please use this new password to log in. You can log in here:</p>
            <div class="login-button-container">
                <a href="{{ login_url }}" class="login-button">Log In to Tesseracs Chat</a>
            </div>
            <p>If the button doesn't work, you can also <a href="{{ login_url }}" class="link">click here to log in</a> or copy and paste the following URL into your browser: <br><span class="url-display">{{ login_url }}</span></p>
            <p>If you did not request a password reset, please contact support or secure your account immediately.</p>
        </div>
        <div class="footer">
            <p>Thanks,<br>The Tesseracs Chat Team</p>
            <p><small>This is an automated message. Please do not reply directly to this email.</small></p>
        </div>
    </div>
</body>
</html>


=== app/static/email_templates/registration_email.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to Tesseracs Chat</title>
    <style>
        body {
            font-family: 'Inter', Arial, sans-serif;
            line-height: 1.6;
            color: #333333;
            margin: 0;
            padding: 0;
            background-color: #f7fafc; /* Tailwind gray-100 */
        }
        .email-container {
            width: 100%;
            max-width: 600px;
            margin: 20px auto;
            background-color: #ffffff;
            padding: 25px;
            border: 1px solid #e2e8f0; /* Tailwind gray-300 */
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }
        .header {
            text-align: center;
            padding-bottom: 20px;
            border-bottom: 1px solid #edf2f7; /* Tailwind gray-200 */
        }
        .header h2 {
            color: #2c5282; /* Tailwind blue-800 */
            margin: 0;
            font-size: 24px;
            font-weight: 600;
        }
        .content {
            padding-top: 10px;
        }
        .content p {
            margin: 18px 0;
            font-size: 16px;
            color: #4a5568; /* Tailwind gray-700 */
        }
        .content strong {
            color: #2b6cb0; /* Tailwind blue-700 */
            font-weight: 500;
        }
        .password-display-container {
            margin: 25px 0;
            text-align: center;
        }
        .password-label {
            font-size: 16px;
            color: #4a5568; /* Tailwind gray-700 */
            margin-bottom: 8px;
            display: block;
        }
        .password-value {
            background-color: #edf2f7; /* Tailwind gray-200 */
            padding: 15px 20px;
            border-radius: 6px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.2em;
            text-align: center;
            color: #1a202c; /* Tailwind gray-900 */
            border: 1px solid #cbd5e0; /* Tailwind gray-400 */
            display: inline-block;
            letter-spacing: 1px;
            word-break: break-all;
        }
        .login-button-container {
            text-align: center;
            margin: 30px 0;
        }
        .login-button {
            display: inline-block;
            background-color: #3182ce; /* Tailwind blue-500 */
            color: #ffffff !important;
            padding: 14px 28px;
            text-decoration: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.2s ease-in-out;
        }
        .login-button:hover {
            background-color: #2b6cb0; /* Tailwind blue-600 */
        }
        .footer {
            text-align: center;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #edf2f7; /* Tailwind gray-200 */
            font-size: 0.875em; /* text-sm */
            color: #718096; /* Tailwind gray-600 */
        }
        .link {
            color: #3182ce; /* Tailwind blue-500 */
            text-decoration: none;
        }
        .link:hover {
            text-decoration: underline;
        }
        .url-display { /* Style for displaying the URL as text */
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            color: #718096; /* Tailwind gray-600 */
            word-break: break-all;
        }
    </style>
</head>
<body>
    <div class="email-container">
        <div class="header">
            <h2>Welcome to Tesseracs Chat, {{ recipient_name }}!</h2>
        </div>
        <div class="content">
            <p>Your account has been successfully created.</p>
            <p>Your email: <strong>{{ email }}</strong></p>
            <div class="password-display-container">
                <span class="password-label">Your password is:</span>
                <div class="password-value">{{ password }}</div>
            </div>
            <p>Please use this password to log in. You can log in here:</p>
            <div class="login-button-container">
                <a href="{{ login_url }}" class="login-button">Log In to Tesseracs Chat</a>
            </div>
            <p>If the button doesn't work, you can also <a href="{{ login_url }}" class="link">click here to log in</a> or copy and paste the following URL into your browser: <br><span class="url-display">{{ login_url }}</span></p>
            <p>Please keep this password secure. Currently, there is no option to change this password.</p>
            <p>If you did not request this account, please ignore this email.</p>
        </div>
        <div class="footer">
            <p>Thanks,<br>The Tesseracs Chat Team</p>
            <p><small>This is an automated message. Please do not reply directly to this email.</small></p>
        </div>
    </div>
</body>
</html>


=== app/static/js/app-ui.js ===
// static/js/app-ui.js

function setupSidebarCSRF() {
    const sidebarCsrfField = document.getElementById('sidebar_csrf_token');
    const newChatButton = document.getElementById('new-chat-button-sidebar'); // For disabling/enabling

    // First, ensure the critical CSRF input field exists.
    if (!sidebarCsrfField) {
        console.error("app-ui.js: CRITICAL - CSRF token input field 'sidebar_csrf_token' NOT FOUND in the sidebar HTML. 'New Chat' functionality will be impaired or fail.");
        if (newChatButton) {
            newChatButton.disabled = true;
            newChatButton.title = "Error: Security component missing. Cannot create new chat.";
        }
        // alert("A critical security component for creating new chats is missing. Please refresh or contact support if this persists.");
        return; // Stop execution if the field isn't there; nothing more to do.
    }

    // If the field exists, attempt to populate it.
    if (window.csrfTokenRaw && 
        typeof window.csrfTokenRaw === 'string' && 
        window.csrfTokenRaw !== "%%CSRF_TOKEN_RAW%%" && 
        window.csrfTokenRaw.trim() !== "") {
        
        sidebarCsrfField.value = window.csrfTokenRaw;
        console.log("app-ui.js: Sidebar CSRF token field ('sidebar_csrf_token') populated successfully.");
        if (newChatButton) {
            newChatButton.disabled = false; // Ensure button is enabled as token is available
            newChatButton.title = "Start a new chat session"; // Reset title
        }
    } else {
        // The field exists, but the global CSRF token is invalid or missing.
        console.warn("app-ui.js: window.csrfTokenRaw is invalid, placeholder, or empty. CSRF token for sidebar form cannot be populated. Value of window.csrfTokenRaw:", window.csrfTokenRaw);
        sidebarCsrfField.value = ""; // Ensure the field is empty if the token is bad
        if (newChatButton) {
            newChatButton.disabled = true; // Disable button if token is missing/invalid
            newChatButton.title = "New Chat disabled: Security token missing or invalid. Please refresh the page.";
        }
        // alert("A security token required for creating a new chat is missing or invalid. Please try refreshing the page. If the issue persists, contact support.");
    }
}

/**
 * Loads HTML content (like a sidebar) from a given path into a target element.
 * Also sets up CSRF token for forms within the loaded HTML and handles
 * the "New Chat" form submission via AJAX.
 * @param {string} sidebarHtmlPath - Path to the HTML file to load (e.g., '/static/_sidebar.html').
 * @param {string} targetElementId - ID of the DOM element to load the HTML into.
 * @returns {Promise<boolean>} - True if successful, false otherwise.
 */
export async function loadSidebarHTML(sidebarHtmlPath = '/static/_sidebar.html', targetElementId = 'sidebar-loader-target') {
    const sidebarTarget = document.getElementById(targetElementId);
    if (!sidebarTarget) {
        console.error(`app-ui.js: Sidebar target element with ID '${targetElementId}' not found.`);
        return false;
    }
    try {
        const response = await fetch(sidebarHtmlPath); // Fetch the static _sidebar.html
        if (!response.ok) {
            console.error(`app-ui.js: Failed to fetch sidebar HTML from ${sidebarHtmlPath}. Status: ${response.status}`);
            sidebarTarget.innerHTML = `<p class="p-4 text-red-400">Error loading sidebar (status: ${response.status}).</p>`;
            return false;
        }
        const sidebarHTML = await response.text();
        sidebarTarget.innerHTML = sidebarHTML;
        console.log(`app-ui.js: Sidebar HTML successfully loaded from ${sidebarHtmlPath} into #${targetElementId}`);

        // Setup CSRF for the loaded sidebar form AFTER injecting HTML
        // This function (setupSidebarCSRF) should populate the #sidebar_csrf_token input field
        setupSidebarCSRF();

        // --- MODIFIED PART: Handle "New Chat" form submission with AJAX ---
        const newChatFormSidebar = document.getElementById('new-chat-form-sidebar');
        const sidebarCsrfTokenInput = document.getElementById('sidebar_csrf_token'); // The hidden input
        const newChatButton = document.getElementById('new-chat-button-sidebar');

        if (newChatFormSidebar && sidebarCsrfTokenInput && newChatButton) {
            newChatFormSidebar.addEventListener('submit', async function(event) {
                event.preventDefault(); // Prevent default HTML form submission

                const rawCsrfToken = sidebarCsrfTokenInput.value;

                if (!rawCsrfToken || rawCsrfToken === "%%CSRF_TOKEN_RAW%%" || rawCsrfToken.trim() === "") {
                    alert("A security token for creating new chats is missing or invalid. Please refresh the page.");
                    console.error("New Chat submission: CSRF token from sidebar_csrf_token input is missing or placeholder:", rawCsrfToken);
                    return;
                }

                newChatButton.disabled = true;
                newChatButton.innerHTML = `
                    <svg class="animate-spin h-5 w-5 mr-2 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    Creating...`;

                try {
                    const fetchResponse = await fetch('/sessions/create', { // The form's action attribute
                        method: 'POST', // The form's method attribute
                        headers: {
                            'X-CSRF-Token': rawCsrfToken // Send the raw token in the header
                            // Content-Type is not strictly necessary for an empty POST body,
                            // but if issues arise, 'application/x-www-form-urlencoded' could be added.
                            // However, the server endpoint /sessions/create doesn't expect other form data.
                        }
                        // No body is sent, as the original form only contained the CSRF token for this purpose.
                    });

                    if (fetchResponse.ok) {
                        // The server responds with HTTP 303 See Other,
                        // fetch with redirect: 'follow' (default) should handle this.
                        // The browser will navigate to the URL specified in the Location header.
                        if (fetchResponse.redirected) {
                            window.location.href = fetchResponse.url;
                        } else {
                            // If for some reason it wasn't redirected (e.g. server didn't send 303 or Location)
                            // or if the status is OK but not a redirect (e.g. 200 with JSON URL)
                            // We might need to manually parse a redirect URL if the server sends one in JSON.
                            // For now, assume the 303 redirect will be followed.
                            // If the server sends Location header, browser handles it.
                            // If not, a page reload or navigation to '/' might be a fallback.
                            console.warn("New chat creation was successful, but no redirect occurred client-side. Server status:", fetchResponse.status);
                            // Attempt to get location header if browser didn't auto-redirect
                            const locationHeader = fetchResponse.headers.get('Location');
                            if (locationHeader) {
                                window.location.href = locationHeader;
                            } else {
                                window.location.href = '/'; // Fallback to home/session choice
                            }
                        }
                    } else {
                        const errorData = await fetchResponse.json().catch(() => ({ 
                            detail: `Failed to create new chat. Server responded with status: ${fetchResponse.status}` 
                        }));
                        console.error('Failed to create new chat session:', errorData.detail);
                        alert(`Error creating new chat: ${errorData.detail}`);
                        newChatButton.disabled = false;
                        newChatButton.innerHTML = `
                            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
                            New Chat`;
                    }
                } catch (error) {
                    console.error('Network error or other issue trying to create new chat session:', error);
                    alert('An error occurred while creating the new chat session. Please check your network connection and try again.');
                    newChatButton.disabled = false;
                    newChatButton.innerHTML = `
                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
                        New Chat`;
                }
            });
        } else {
            console.warn("app-ui.js: 'New Chat' form or its CSRF input field was not found after sidebar load. AJAX submission not configured.");
        }
        // --- END OF MODIFIED PART ---
        
        return true;
    } catch (error) {
        console.error('app-ui.js: Could not load sidebar due to an error:', error);
        sidebarTarget.innerHTML = '<p class="p-4 text-red-400">Error loading sidebar content (exception).</p>';
        return false;
    }
}

export async function handleDeleteSession(sessionId, sessionName, apiEndpointForList, listElementId, chatPageBaseUrl) {
    if (!window.confirm(`Are you sure you want to delete the session "${sessionName}"? This action cannot be undone.`)) {
        return;
    }

    console.log(`app-ui.js: Attempting to delete session: ${sessionId}`);
    
    // *** ADDED DETAILED LOGGING FOR window.csrfTokenRaw ***
    const currentTokenValue = window.csrfTokenRaw;
    const isPlaceholder = currentTokenValue === "%%CSRF_TOKEN_RAW%%";
    const isEmptyOrWhitespace = !currentTokenValue || currentTokenValue.trim() === "";

    console.log(`app-ui.js (handleDeleteSession): Checking CSRF token. 
        Value: '${currentTokenValue}'
        Is Placeholder: ${isPlaceholder}
        Is Undefined/Null/Empty/Whitespace: ${isEmptyOrWhitespace}`);

    if (!currentTokenValue || isPlaceholder || isEmptyOrWhitespace) {
        console.error(`app-ui.js: CSRF token is missing or invalid. Cannot proceed with delete operation. 
            Raw Value: '${currentTokenValue}', 
            Is Placeholder: ${isPlaceholder}, 
            Is Empty: ${isEmptyOrWhitespace}`);
        alert("Error: Could not perform action: CSRF token not found. Please refresh the page.");
        return;
    }

    try {
        const response = await fetch(`/api/sessions/${sessionId}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': currentTokenValue // Use the validated token
            }
        });

        if (response.status === 204) {
            console.log(`app-ui.js: Session ${sessionId} successfully deleted from server.`);
            const currentPath = window.location.pathname;
            const base = chatPageBaseUrl.endsWith('/') ? chatPageBaseUrl : chatPageBaseUrl + '/';
            const deletedSessionPath = `${base}${sessionId}`;

            if (currentPath === deletedSessionPath || currentPath === `${deletedSessionPath}/`) {
                window.location.href = '/'; 
            } else {
                await populateSessionList(apiEndpointForList, listElementId, chatPageBaseUrl);
            }
        } else {
            const errorData = await response.json().catch(() => ({ detail: `Failed to delete session. Server responded with status: ${response.status}` }));
            console.error(`app-ui.js: Failed to delete session ${sessionId}. Status: ${response.status}`, errorData);
            alert(`Error deleting session: ${errorData.detail || response.statusText || `Status ${response.status}`}`);
        }
    } catch (error) {
        console.error('app-ui.js: Error during delete session request:', error);
        alert('An error occurred while trying to delete the session. Please check the console for details.');
    }
}

/**
 * Fetches and populates the list of user sessions in the sidebar.
 * @param {string} apiEndpoint - API endpoint to fetch sessions (e.g., '/api/sessions').
 * @param {string} listElementId - ID of the ul element to populate.
 * @param {string} chatPageBaseUrl - Base URL for constructing chat page links (e.g., '/chat/').
 */
export async function populateSessionList(apiEndpoint = '/api/sessions', listElementId = 'session-list', chatPageBaseUrl = '/chat/') {
    const sessionListElement = document.getElementById(listElementId);
    if (!sessionListElement) {
        console.error(`app-ui.js: Session list element with ID '${listElementId}' not found.`);
        return;
    }
    sessionListElement.innerHTML = '<li class="px-3 py-1 text-gray-400 italic text-sm">Loading sessions...</li>';

    try {
        console.log(`app-ui.js: Fetching sessions from: ${apiEndpoint}`);
        const response = await fetch(apiEndpoint); // GET request, no CSRF header needed for this

        if (!response.ok) {
            const errorText = await response.text().catch(() => "Unknown server error");
            console.error(`app-ui.js: Failed to fetch sessions from ${apiEndpoint}. Status: ${response.status}. Response: ${errorText}`);
            sessionListElement.innerHTML = `<li class="px-3 py-1 text-red-400 text-sm">Error loading sessions (status: ${response.status}).</li>`;
            return; // Stop further processing
        }
        
        const sessions = await response.json();
        if (!Array.isArray(sessions)) {
            console.error(`app-ui.js: Data from ${apiEndpoint} is not an array:`, sessions);
            sessionListElement.innerHTML = '<li class="px-3 py-1 text-red-400 text-sm">Error: Invalid session data format.</li>';
            return; // Stop further processing
        }

        if (sessions.length === 0) {
            sessionListElement.innerHTML = '<li class="px-3 py-1 text-gray-400 text-sm italic">No active sessions found.</li>';
        } else {
            sessionListElement.innerHTML = ''; // Clear "Loading..." or previous list
            sessions.forEach(session => {
                if (!session.id || typeof session.name === 'undefined') { // Check for essential properties
                    console.warn('app-ui.js: Session object is missing id or name:', session);
                    return; // Skip this malformed session entry
                }

                const listItem = document.createElement('li');
                // Added group for hover effects on children (like the delete button)
                listItem.className = 'flex items-center justify-between pr-2 group hover:bg-gray-700 rounded-md transition-colors duration-100';

                const link = document.createElement('a');
                const base = chatPageBaseUrl.endsWith('/') ? chatPageBaseUrl : chatPageBaseUrl + '/';
                link.href = `${base}${session.id}`;
                
                // Apply active state styling if this session's link matches the current page path
                const currentPath = window.location.pathname;
                const isActive = currentPath === link.pathname || currentPath === `${link.pathname}/`;
                
                link.className = `block pl-3 pr-1 py-2 text-gray-300 group-hover:text-white rounded-l-md text-sm truncate flex-grow ${isActive ? 'bg-gray-700 text-white font-semibold' : 'hover:text-white'}`;
                if (isActive) {
                    listItem.classList.add('bg-gray-700'); // Highlight the whole li item if active
                }
                
                let lastActiveDisplay = "Never";
                if (session.last_active) {
                    try {
                        // Format date for better readability; toLocaleString can be verbose
                        const date = new Date(session.last_active);
                        lastActiveDisplay = `${date.toLocaleDateString()} ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
                    } catch (e) {
                        console.warn("app-ui.js: Could not parse last_active date:", session.last_active, e);
                        lastActiveDisplay = session.last_active; // show raw if parsing fails
                    }
                }
                link.title = `${session.name || 'Unnamed Session'}\nLast active: ${lastActiveDisplay}`;
                link.textContent = session.name || `Session ${session.id.substring(0, 8)}...`;
                
                const deleteButton = document.createElement('button');
                deleteButton.innerHTML = '&#x2715;'; // Multiplication X, a common delete symbol
                deleteButton.className = 'ml-2 p-1 text-gray-500 hover:text-red-400 focus:outline-none rounded-full hover:bg-gray-600 transition-colors duration-150 ease-in-out text-xs opacity-0 group-hover:opacity-100 focus:opacity-100 flex-shrink-0'; 
                deleteButton.title = `Delete session: ${session.name || 'Unnamed Session'}`;
                deleteButton.setAttribute('aria-label', `Delete session: ${session.name || 'Unnamed Session'}`);
                
                deleteButton.onclick = (event) => {
                    event.preventDefault(); // Prevent link navigation if button is somehow inside <a> or form
                    event.stopPropagation(); // Prevent triggering link navigation or other parent events
                    handleDeleteSession(session.id, session.name || 'Unnamed Session', apiEndpoint, listElementId, base);
                };

                listItem.appendChild(link);
                listItem.appendChild(deleteButton);
                sessionListElement.appendChild(listItem);
            });
        }
        console.log(`app-ui.js: Session list successfully populated from ${apiEndpoint} with ${sessions.length} sessions.`);

    } catch (error) {
        console.error('app-ui.js: Error populating session list:', error);
        if (sessionListElement) { // Check again in case it became null
            sessionListElement.innerHTML = `<li class="px-3 py-1 text-red-400 text-sm">Could not load sessions. Error: ${error.message || 'Unknown error'}</li>`;
        }
    }
}

=== app/static/js/settings.js ===
// app/static/js/settings.js
import { loadSidebarHTML, populateSessionList } from '/static/js/app-ui.js';

/**
 * Retrieves a cookie value by its name.
 * @param {string} name The name of the cookie to retrieve.
 * @returns {string|null} The cookie value, or null if not found.
 */
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            // Does this cookie string begin with the name we want?
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

document.addEventListener('DOMContentLoaded', async () => {
    console.log("Settings Page: DOMContentLoaded.");

    // Ensure sidebar is scrollable using the class defined in input.css
    const sidebarLoaderTarget = document.getElementById('sidebar-loader-target');
    if (sidebarLoaderTarget) {
        sidebarLoaderTarget.classList.add('sidebar-scrollable');
    }

    const sidebarLoaded = await loadSidebarHTML('/static/_sidebar.html', 'sidebar-loader-target');
    if (sidebarLoaded) {
        await populateSessionList('/api/sessions', 'session-list', '/chat/');
    } else {
        console.error("Settings Page: Sidebar loading failed.");
    }

    const settingsMessageArea = document.getElementById('settings-message-area');

    /**
     * Displays a message in the settings message area and focuses it.
     * @param {string} message The message to display.
     * @param {string} type The type of message ('info', 'success', 'error').
     * @param {number} duration Time in ms to display the message (0 for indefinite).
     * @param {HTMLElement|null} elementToFocusAfter An optional element to return focus to after message timeout.
     */
    function showSettingsMessage(message, type = 'info', duration = 0, elementToFocusAfter = null) {
        settingsMessageArea.textContent = message;
        settingsMessageArea.className = 'py-3 px-4 rounded-md text-center mb-4 text-sm'; // Reset classes
        if (type === 'success') {
            settingsMessageArea.classList.add('bg-green-100', 'text-green-800', 'border', 'border-green-300');
        } else if (type === 'error') {
            settingsMessageArea.classList.add('bg-red-100', 'text-red-800', 'border', 'border-red-300');
        } else { // 'info' or default
            settingsMessageArea.classList.add('bg-blue-100', 'text-blue-700', 'border', 'border-blue-300');
        }
        settingsMessageArea.style.display = 'block';

        settingsMessageArea.setAttribute('tabindex', '-1');
        settingsMessageArea.focus();

        if (duration > 0) {
            setTimeout(() => {
                settingsMessageArea.style.display = 'none';
                settingsMessageArea.removeAttribute('tabindex');
                if (elementToFocusAfter && typeof elementToFocusAfter.focus === 'function') {
                    elementToFocusAfter.focus();
                }
            }, duration);
        }
    }

    const currentNameInput = document.getElementById('current-name');
    const currentEmailInput = document.getElementById('current-email');

    async function fetchCurrentUser() {
        try {
            const response = await fetch('/api/me', { cache: 'no-store' });
            if (response.ok) {
                const userData = await response.json();
                if (currentNameInput) currentNameInput.value = userData.name;
                if (currentEmailInput) currentEmailInput.value = userData.email;
                window.currentUserDetails = userData;
            } else {
                showSettingsMessage('Could not load your current user details.', 'error', 0, document.body);
                if (currentNameInput) currentNameInput.value = 'Error loading';
                if (currentEmailInput) currentEmailInput.value = 'Error loading';
            }
        } catch (error) {
            console.error("Error fetching current user:", error);
            showSettingsMessage('An error occurred while loading your details.', 'error', 0, document.body);
        }
    }
    await fetchCurrentUser();

    // --- Account Settings Forms (Keep existing logic for these) ---
    const updateNameForm = document.getElementById('update-name-form');
    if (updateNameForm) {
        const newNameInput = document.getElementById('new-name');
        updateNameForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            settingsMessageArea.style.display = 'none';
            const updateNameButton = document.getElementById('update-name-button');
            updateNameButton.disabled = true;
            updateNameButton.textContent = 'Updating...';
            const newName = newNameInput.value;
            const currentPasswordForName = document.getElementById('current-password-for-name');
            const currentPassword = currentPasswordForName.value;
            // Use window.csrfTokenRaw which should be populated by the server
            const csrfToken = window.csrfTokenRaw; 
            let focusTargetAfterMessage = newNameInput;

            if (!csrfToken || csrfToken === "%%CSRF_TOKEN_RAW%%") {
                showSettingsMessage('CSRF token missing. Cannot update name. Please refresh.', 'error', 0, updateNameButton);
                updateNameButton.disabled = false;
                updateNameButton.textContent = 'Update Name';
                return;
            }

            try {
                const response = await fetch('/api/me/update-name', {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': csrfToken
                    },
                    body: JSON.stringify({ new_name: newName, current_password: currentPassword })
                });
                const result = await response.json();
                if (response.ok) {
                    showSettingsMessage(result.message || 'Name updated successfully!', 'success', 3000, newNameInput);
                    if (currentNameInput) currentNameInput.value = result.new_name;
                    currentPasswordForName.value = '';
                    newNameInput.value = '';
                } else {
                    focusTargetAfterMessage = result.field === 'current_password' ? currentPasswordForName : newNameInput;
                    showSettingsMessage(result.detail || 'Failed to update name.', 'error', 0, focusTargetAfterMessage);
                }
            } catch (error) {
                console.error("Error updating name:", error);
                showSettingsMessage('An error occurred. Please try again.', 'error', 0, newNameInput);
            } finally {
                updateNameButton.disabled = false;
                updateNameButton.textContent = 'Update Name';
            }
        });
    }

    const updateEmailForm = document.getElementById('update-email-form');
    if (updateEmailForm) {
        const newEmailInput = document.getElementById('new-email');
        updateEmailForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            settingsMessageArea.style.display = 'none';
            const updateEmailButton = document.getElementById('update-email-button');
            updateEmailButton.disabled = true;
            updateEmailButton.textContent = 'Updating Email...';
            const newEmail = newEmailInput.value;
            const currentPasswordForEmail = document.getElementById('current-password-for-email');
            const currentPassword = currentPasswordForEmail.value;
            const csrfToken = window.csrfTokenRaw; // Use window.csrfTokenRaw
            let focusTargetAfterMessage = newEmailInput;

            if (!csrfToken || csrfToken === "%%CSRF_TOKEN_RAW%%") {
                showSettingsMessage('CSRF token missing. Cannot update email. Please refresh.', 'error', 0, updateEmailButton);
                updateEmailButton.disabled = false;
                updateEmailButton.textContent = 'Update Email Address';
                return;
            }

            try {
                const response = await fetch('/api/me/update-email', {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': csrfToken
                    },
                    body: JSON.stringify({ new_email: newEmail, current_password: currentPassword })
                });
                const result = await response.json();
                if (response.ok) {
                    showSettingsMessage(result.message || 'Email updated. Logging out...', 'success', 0);
                    setTimeout(() => { window.location.href = '/logout'; }, 4000);
                } else {
                    focusTargetAfterMessage = result.field === 'current_password' ? currentPasswordForEmail : newEmailInput;
                    showSettingsMessage(result.detail || 'Failed to update email.', 'error', 0, focusTargetAfterMessage);
                    updateEmailButton.disabled = false;
                    updateEmailButton.textContent = 'Update Email Address';
                }
            } catch (error) {
                console.error("Error updating email:", error);
                showSettingsMessage('An error occurred. Please try again.', 'error', 0, newEmailInput);
                updateEmailButton.disabled = false;
                updateEmailButton.textContent = 'Update Email Address';
            }
        });
    }

    const regeneratePasswordForm = document.getElementById('regenerate-password-form');
    if (regeneratePasswordForm) {
        const currentPasswordForRegen = document.getElementById('current-password-for-regen');
        regeneratePasswordForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            settingsMessageArea.style.display = 'none';
            const regeneratePasswordButton = document.getElementById('regenerate-password-button');
            regeneratePasswordButton.disabled = true;
            regeneratePasswordButton.textContent = 'Regenerating...';
            const currentPassword = currentPasswordForRegen.value;
            const csrfToken = window.csrfTokenRaw; // Use window.csrfTokenRaw

            if (!csrfToken || csrfToken === "%%CSRF_TOKEN_RAW%%") {
                showSettingsMessage('CSRF token missing. Cannot regenerate password. Please refresh.', 'error', 0, regeneratePasswordButton);
                regeneratePasswordButton.disabled = false;
                regeneratePasswordButton.textContent = 'Regenerate Password & Send Email';
                return;
            }

            try {
                const response = await fetch('/api/me/regenerate-password', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': csrfToken
                    },
                    body: JSON.stringify({ current_password: currentPassword })
                });
                const result = await response.json();
                if (response.ok) {
                    showSettingsMessage(result.message || 'Password regenerated. Check email. Logging out...', 'success', 0);
                    setTimeout(() => { window.location.href = '/logout'; }, 4000);
                } else {
                    showSettingsMessage(result.detail || 'Failed to regenerate password.', 'error', 0, currentPasswordForRegen);
                    regeneratePasswordButton.disabled = false;
                    regeneratePasswordButton.textContent = 'Regenerate Password & Send Email';
                }
            } catch (error) {
                console.error("Error regenerating password:", error);
                showSettingsMessage('An error occurred. Please try again.', 'error', 0, currentPasswordForRegen);
                regeneratePasswordButton.disabled = false;
                regeneratePasswordButton.textContent = 'Regenerate Password & Send Email';
            }
        });
    }

    // --- LLM Settings Functionality ---
    const llmProviderSelect = document.getElementById('llm-provider');
    const llmModelSelect = document.getElementById('llm-model');
    const llmApiKeyGroup = document.getElementById('llm-api-key-group');
    const llmApiKeyInput = document.getElementById('llm-api-key');
    const llmApiKeyStatus = document.getElementById('llm-api-key-status');
    const llmBaseUrlGroup = document.getElementById('llm-base-url-group');
    const llmBaseUrlInput = document.getElementById('llm-base-url');
    const llmProviderStatus = document.getElementById('llm-provider-status');
    const saveLLMSettingsButton = document.getElementById('save-llm-settings-button');
    const llmSettingsForm = document.getElementById('llm-settings-form');

    let availableProvidersData = []; // To store fetched provider details, including their models

    /**
     * Loads initial LLM configuration data: available providers and current user's LLM settings.
     * Populates the provider dropdown and sets initial values for other fields.
     */
    async function loadLLMConfigData() {
        if (!llmProviderSelect || !llmModelSelect) {
            console.error("LLM configuration select elements not found in the DOM.");
            return;
        }
        try {
            // Fetch all available providers and their details (including models)
            const providersResponse = await fetch('/api/llm/providers');
            if (!providersResponse.ok) {
                showSettingsMessage('Failed to load LLM providers configuration.', 'error', 0, llmProviderSelect);
                llmProviderSelect.innerHTML = '<option value="">Error loading providers</option>';
                llmModelSelect.innerHTML = '<option value="">-- Select Provider First --</option>';
                llmModelSelect.disabled = true;
                return;
            }
            availableProvidersData = await providersResponse.json(); // Store for later use

            // Fetch the current user's saved LLM settings
            const userSettingsResponse = await fetch('/api/me/llm-settings', { cache: 'no-store' });
            const currentUserLLMSettings = userSettingsResponse.ok ? await userSettingsResponse.json() : {};
            
            if (!userSettingsResponse.ok && availableProvidersData.length > 0) {
                showSettingsMessage('Could not load your saved LLM settings. Defaults may be shown.', 'error', 4000, llmProviderSelect);
            }

            // Populate the providers dropdown
            populateLLMProviders(currentUserLLMSettings.selected_llm_provider_id);

            // Set the initially selected provider (if any)
            const effectiveProviderId = currentUserLLMSettings.selected_llm_provider_id || "";
            if (llmProviderSelect.querySelector(`option[value="${effectiveProviderId}"]`)) {
                 llmProviderSelect.value = effectiveProviderId;
            } else {
                llmProviderSelect.value = ""; // Default to "Select Provider"
            }
           

            // Update model dropdown and other fields based on the (potentially) selected provider
            updateModelDropdown(llmProviderSelect.value, currentUserLLMSettings.selected_llm_model_id, currentUserLLMSettings);
            updateProviderSpecificFields(llmProviderSelect.value, currentUserLLMSettings);

        } catch (error) {
            console.error("Error loading LLM configuration:", error);
            showSettingsMessage('A critical error occurred while loading LLM configuration.', 'error', 0, llmProviderSelect);
            llmProviderSelect.innerHTML = '<option value="">Error</option>';
            llmModelSelect.innerHTML = '<option value="">Error</option>';
            llmModelSelect.disabled = true;
        }
    }

    /**
     * Populates the LLM Provider dropdown.
     * @param {string|null} currentProviderId The ID of the currently selected provider (to pre-select it).
     */
    function populateLLMProviders(currentProviderId) {
        llmProviderSelect.innerHTML = '<option value="">-- Select Provider --</option>'; // Default empty option
        availableProvidersData.forEach(provider => {
            // You might have filtering logic here if needed, e.g., based on provider.is_system_configured
            const option = document.createElement('option');
            option.value = provider.id;
            option.textContent = provider.display_name;
            if (provider.id === currentProviderId) {
                option.selected = true;
            }
            llmProviderSelect.appendChild(option);
        });
    }

    /**
     * Updates the LLM Model dropdown based on the selected provider.
     * Enables or disables the model dropdown accordingly.
     * @param {string} providerId The ID of the selected provider.
     * @param {string|null} currentModelId The ID of the currently selected model (to pre-select it).
     * @param {object} userSettings The current user's LLM settings (for context).
     */
    function updateModelDropdown(providerId, currentModelId, userSettings = {}) {
        llmModelSelect.innerHTML = '<option value="">-- Select Model --</option>'; // Default empty option
        const selectedProvider = availableProvidersData.find(p => p.id === providerId);

        if (selectedProvider && selectedProvider.available_models && selectedProvider.available_models.length > 0) {
            llmModelSelect.disabled = false; // *** ENABLE the dropdown ***
            selectedProvider.available_models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.model_id;
                // Display both name and ID for clarity, especially if names are not unique across providers
                option.textContent = model.display_name ? `${model.display_name} (${model.model_id})` : model.model_id;
                
                // Pre-select if this model was the user's saved choice for this provider
                if (providerId === userSettings.selected_llm_provider_id && model.model_id === currentModelId) {
                    option.selected = true;
                }
                llmModelSelect.appendChild(option);
            });
        } else if (providerId) { // Provider selected, but no models
            llmModelSelect.innerHTML = '<option value="">No models available for this provider</option>';
            llmModelSelect.disabled = true; // *** DISABLE if no models ***
        } else { // No provider selected
            llmModelSelect.innerHTML = '<option value="">-- Select Provider First --</option>';
            llmModelSelect.disabled = true; // *** DISABLE if no provider selected ***
        }
    }

    /**
     * Updates provider-specific fields (API key, base URL) based on the selected provider.
     * @param {string} providerId The ID of the selected provider.
     * @param {object} userSettings The current user's LLM settings.
     */
    function updateProviderSpecificFields(providerId, userSettings = {}) {
        const selectedProvider = availableProvidersData.find(p => p.id === providerId);

        // Hide all optional groups by default
        llmApiKeyGroup.style.display = 'none';
        llmApiKeyGroup.setAttribute('aria-hidden', 'true');
        llmBaseUrlGroup.style.display = 'none';
        llmBaseUrlGroup.setAttribute('aria-hidden', 'true');

        // Reset fields and status messages
        llmProviderStatus.textContent = providerId ? "Loading provider details..." : "Select a provider to see more options.";
        llmApiKeyInput.value = '';
        llmApiKeyInput.placeholder = '';
        llmApiKeyStatus.textContent = '';
        llmBaseUrlInput.value = '';
        llmBaseUrlInput.placeholder = '';

        if (selectedProvider) {
            // API Key field visibility and status
            if (selectedProvider.can_accept_user_api_key) { // Check if provider *can* accept a user key
                llmApiKeyGroup.style.display = 'block';
                llmApiKeyGroup.setAttribute('aria-hidden', 'false');
                if (userSettings.has_user_api_key && selectedProvider.id === userSettings.selected_llm_provider_id) {
                    llmApiKeyInput.placeholder = "•••••••• (A key is currently saved)";
                    llmApiKeyStatus.textContent = "A key is saved. Edit to change, or clear field and save to remove your key.";
                } else if (selectedProvider.is_system_configured && selectedProvider.needs_api_key_from_user === false) {
                    // System has a key, and user doesn't strictly need to provide one, but can.
                    llmApiKeyInput.placeholder = "API Key (Optional - System key available)";
                    llmApiKeyStatus.textContent = "A system key is configured. You can provide your own to override it for your account.";
                } else if (selectedProvider.needs_api_key_from_user === true) {
                    llmApiKeyInput.placeholder = "API Key (Required)";
                    llmApiKeyStatus.textContent = "Please enter your API key for this provider.";
                } else { // Can accept, but not strictly required and no system key (e.g. some local models)
                    llmApiKeyInput.placeholder = "API Key (Optional)";
                    llmApiKeyStatus.textContent = "You can optionally provide an API key.";
                }
            }

            // Base URL field visibility and status
            if (selectedProvider.can_accept_user_base_url) { // Check if provider *can* accept a user base URL
                llmBaseUrlGroup.style.display = 'block';
                llmBaseUrlGroup.setAttribute('aria-hidden', 'false');
                if (selectedProvider.id === userSettings.selected_llm_provider_id && userSettings.selected_llm_base_url) {
                    llmBaseUrlInput.value = userSettings.selected_llm_base_url;
                }
                // Provide more specific placeholders based on provider type if available
                if (selectedProvider.type === 'ollama') {
                    llmBaseUrlInput.placeholder = "e.g., http://localhost:11434 (uses system default if empty)";
                } else if (selectedProvider.type === 'openai_compatible_server') {
                    llmBaseUrlInput.placeholder = "e.g., https://api.example.com/v1 (Required if no system default)";
                } else {
                    llmBaseUrlInput.placeholder = "Custom Base URL (Optional)";
                }
            }

            // General provider status message
            if (!selectedProvider.is_system_configured && selectedProvider.needs_api_key_from_user === true) {
                llmProviderStatus.textContent = "This provider requires configuration (e.g., an API key).";
            } else if (selectedProvider.is_system_configured && selectedProvider.needs_api_key_from_user === false) {
                llmProviderStatus.textContent = "This provider is system-configured and ready to use.";
            } else if (selectedProvider.can_accept_user_api_key || selectedProvider.can_accept_user_base_url) {
                llmProviderStatus.textContent = "This provider can be customized with your own API key or base URL.";
            } else {
                llmProviderStatus.textContent = "This provider does not require additional configuration.";
            }

        } else if (providerId === "") { // "-- Select Provider --" is chosen
             llmProviderStatus.textContent = "Select a provider to see configuration options.";
        }
    }

    // Event listener for when the LLM provider selection changes
    llmProviderSelect.addEventListener('change', async (event) => {
        const selectedProviderId = event.target.value;
        
        // Fetch the latest user settings as they might have changed or to get defaults for the new provider
        const userSettingsResponse = await fetch('/api/me/llm-settings', {cache: 'no-store'});
        const currentUserLLMSettings = userSettingsResponse.ok ? await userSettingsResponse.json() : {};

        // Determine which model should be pre-selected.
        // If the newly selected provider is the same as the user's saved provider, use their saved model.
        // Otherwise, no specific model is pre-selected (will default to "-- Select Model --").
        const modelToSelect = (selectedProviderId === currentUserLLMSettings.selected_llm_provider_id)
                                ? currentUserLLMSettings.selected_llm_model_id
                                : null; // Let updateModelDropdown handle the default "-- Select Model --"

        updateModelDropdown(selectedProviderId, modelToSelect, currentUserLLMSettings);
        updateProviderSpecificFields(selectedProviderId, currentUserLLMSettings);
    });

    // Event listener for saving LLM settings
    llmSettingsForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        settingsMessageArea.style.display = 'none';
        saveLLMSettingsButton.disabled = true;
        saveLLMSettingsButton.textContent = 'Saving...';
        const csrfToken = window.csrfTokenRaw; // Use the globally available raw CSRF token

        if (!csrfToken || csrfToken === "%%CSRF_TOKEN_RAW%%") {
            showSettingsMessage('CSRF token missing. Cannot save settings. Please refresh.', 'error', 0, saveLLMSettingsButton);
            saveLLMSettingsButton.disabled = false;
            saveLLMSettingsButton.textContent = 'Save LLM Settings';
            return;
        }

        const providerId = llmProviderSelect.value;
        const modelId = llmModelSelect.value;
        // Only include API key if the input group is visible (meaning provider accepts it)
        const apiKey = (llmApiKeyGroup.style.display !== 'none') ? llmApiKeyInput.value : undefined;
        // Only include base URL if the input group is visible
        const baseUrl = (llmBaseUrlGroup.style.display !== 'none') ? llmBaseUrlInput.value : undefined;

        const payload = {
            selected_llm_provider_id: providerId || null, // Send null if empty string
            selected_llm_model_id: modelId || null,     // Send null if empty string
        };

        // Conditionally add api_key and base_url to the payload
        // The backend expects `user_llm_api_key` and `selected_llm_base_url`
        if (apiKey !== undefined) { // Check for undefined, empty string means "clear the key"
            payload.user_llm_api_key = apiKey;
        }
        if (baseUrl !== undefined) { // Check for undefined, empty string means "clear the base URL"
            payload.selected_llm_base_url = baseUrl || null; // Send null if empty string
        }

        try {
            const response = await fetch('/api/me/llm-settings', {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': csrfToken
                },
                body: JSON.stringify(payload)
            });
            const result = await response.json();
            if (response.ok) {
                showSettingsMessage('LLM settings saved successfully!', 'success', 3000, saveLLMSettingsButton);
                // Reload the config data to reflect saved settings (e.g., has_user_api_key status)
                await loadLLMConfigData(); 
            } else {
                let fieldToFocus = llmProviderSelect;
                if (result.detail && typeof result.detail === 'string') {
                    if (result.detail.toLowerCase().includes('model')) fieldToFocus = llmModelSelect;
                    else if (result.detail.toLowerCase().includes('api key')) fieldToFocus = llmApiKeyInput;
                    else if (result.detail.toLowerCase().includes('base url')) fieldToFocus = llmBaseUrlInput;
                }
                showSettingsMessage(result.detail || 'Failed to save LLM settings.', 'error', 0, fieldToFocus);
            }
        } catch (error) {
            console.error("Error saving LLM settings:", error);
            showSettingsMessage('An error occurred while saving LLM settings.', 'error', 0, saveLLMSettingsButton);
        } finally {
            saveLLMSettingsButton.disabled = false;
            saveLLMSettingsButton.textContent = 'Save LLM Settings';
        }
    });

    // Initial load of LLM configuration when the page is ready
    await loadLLMConfigData(); 
});


=== app/static/js/temp.js ===
// app/static/js/settings.js
import { loadSidebarHTML, populateSessionList } from '/static/js/app-ui.js';

/**
 * Retrieves a cookie value by its name.
 * @param {string} name The name of the cookie to retrieve.
 * @returns {string|null} The cookie value, or null if not found.
 */
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            // Does this cookie string begin with the name we want?
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

document.addEventListener('DOMContentLoaded', async () => {
    console.log("Settings Page: DOMContentLoaded.");

    // Ensure sidebar is scrollable using the class defined in input.css
    const sidebarLoaderTarget = document.getElementById('sidebar-loader-target');
    if (sidebarLoaderTarget) {
        sidebarLoaderTarget.classList.add('sidebar-scrollable');
    }

    const sidebarLoaded = await loadSidebarHTML('/static/_sidebar.html', 'sidebar-loader-target');
    if (sidebarLoaded) {
        await populateSessionList('/api/sessions', 'session-list', '/chat/');
    } else {
        console.error("Settings Page: Sidebar loading failed.");
    }

    const settingsMessageArea = document.getElementById('settings-message-area');

    /**
     * Displays a message in the settings message area and focuses it.
     * @param {string} message The message to display.
     * @param {string} type The type of message ('info', 'success', 'error').
     * @param {number} duration Time in ms to display the message (0 for indefinite).
     * @param {HTMLElement|null} elementToFocusAfter An optional element to return focus to after message timeout.
     */
    function showSettingsMessage(message, type = 'info', duration = 0, elementToFocusAfter = null) {
        settingsMessageArea.textContent = message;
        settingsMessageArea.className = 'py-3 px-4 rounded-md text-center mb-4 text-sm'; // Reset classes
        if (type === 'success') {
            settingsMessageArea.classList.add('bg-green-100', 'text-green-800', 'border', 'border-green-300');
        } else if (type === 'error') {
            settingsMessageArea.classList.add('bg-red-100', 'text-red-800', 'border', 'border-red-300');
        } else { // 'info' or default
            settingsMessageArea.classList.add('bg-blue-100', 'text-blue-700', 'border', 'border-blue-300');
        }
        settingsMessageArea.style.display = 'block';

        settingsMessageArea.setAttribute('tabindex', '-1');
        settingsMessageArea.focus();

        if (duration > 0) {
            setTimeout(() => {
                settingsMessageArea.style.display = 'none';
                settingsMessageArea.removeAttribute('tabindex');
                if (elementToFocusAfter && typeof elementToFocusAfter.focus === 'function') {
                    elementToFocusAfter.focus();
                }
            }, duration);
        }
    }

    const currentNameInput = document.getElementById('current-name');
    const currentEmailInput = document.getElementById('current-email');

    async function fetchCurrentUser() {
        try {
            const response = await fetch('/api/me', { cache: 'no-store' });
            if (response.ok) {
                const userData = await response.json();
                if (currentNameInput) currentNameInput.value = userData.name;
                if (currentEmailInput) currentEmailInput.value = userData.email;
                window.currentUserDetails = userData;
            } else {
                showSettingsMessage('Could not load your current user details.', 'error', 0, document.body);
                if (currentNameInput) currentNameInput.value = 'Error loading';
                if (currentEmailInput) currentEmailInput.value = 'Error loading';
            }
        } catch (error) {
            console.error("Error fetching current user:", error);
            showSettingsMessage('An error occurred while loading your details.', 'error', 0, document.body);
        }
    }
    await fetchCurrentUser();

    // --- Account Settings Forms (Keep existing logic for these) ---
    const updateNameForm = document.getElementById('update-name-form');
    if (updateNameForm) {
        const newNameInput = document.getElementById('new-name');
        updateNameForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            settingsMessageArea.style.display = 'none';
            const updateNameButton = document.getElementById('update-name-button');
            updateNameButton.disabled = true;
            updateNameButton.textContent = 'Updating...';
            const newName = newNameInput.value;
            const currentPasswordForName = document.getElementById('current-password-for-name');
            const currentPassword = currentPasswordForName.value;
            // Use window.csrfTokenRaw which should be populated by the server
            const csrfToken = window.csrfTokenRaw; 
            let focusTargetAfterMessage = newNameInput;

            if (!csrfToken || csrfToken === "%%CSRF_TOKEN_RAW%%") {
                showSettingsMessage('CSRF token missing. Cannot update name. Please refresh.', 'error', 0, updateNameButton);
                updateNameButton.disabled = false;
                updateNameButton.textContent = 'Update Name';
                return;
            }

            try {
                const response = await fetch('/api/me/update-name', {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': csrfToken
                    },
                    body: JSON.stringify({ new_name: newName, current_password: currentPassword })
                });
                const result = await response.json();
                if (response.ok) {
                    showSettingsMessage(result.message || 'Name updated successfully!', 'success', 3000, newNameInput);
                    if (currentNameInput) currentNameInput.value = result.new_name;
                    currentPasswordForName.value = '';
                    newNameInput.value = '';
                } else {
                    focusTargetAfterMessage = result.field === 'current_password' ? currentPasswordForName : newNameInput;
                    showSettingsMessage(result.detail || 'Failed to update name.', 'error', 0, focusTargetAfterMessage);
                }
            } catch (error) {
                console.error("Error updating name:", error);
                showSettingsMessage('An error occurred. Please try again.', 'error', 0, newNameInput);
            } finally {
                updateNameButton.disabled = false;
                updateNameButton.textContent = 'Update Name';
            }
        });
    }

    const updateEmailForm = document.getElementById('update-email-form');
    if (updateEmailForm) {
        const newEmailInput = document.getElementById('new-email');
        updateEmailForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            settingsMessageArea.style.display = 'none';
            const updateEmailButton = document.getElementById('update-email-button');
            updateEmailButton.disabled = true;
            updateEmailButton.textContent = 'Updating Email...';
            const newEmail = newEmailInput.value;
            const currentPasswordForEmail = document.getElementById('current-password-for-email');
            const currentPassword = currentPasswordForEmail.value;
            const csrfToken = window.csrfTokenRaw; // Use window.csrfTokenRaw
            let focusTargetAfterMessage = newEmailInput;

            if (!csrfToken || csrfToken === "%%CSRF_TOKEN_RAW%%") {
                showSettingsMessage('CSRF token missing. Cannot update email. Please refresh.', 'error', 0, updateEmailButton);
                updateEmailButton.disabled = false;
                updateEmailButton.textContent = 'Update Email Address';
                return;
            }

            try {
                const response = await fetch('/api/me/update-email', {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': csrfToken
                    },
                    body: JSON.stringify({ new_email: newEmail, current_password: currentPassword })
                });
                const result = await response.json();
                if (response.ok) {
                    showSettingsMessage(result.message || 'Email updated. Logging out...', 'success', 0);
                    setTimeout(() => { window.location.href = '/logout'; }, 4000);
                } else {
                    focusTargetAfterMessage = result.field === 'current_password' ? currentPasswordForEmail : newEmailInput;
                    showSettingsMessage(result.detail || 'Failed to update email.', 'error', 0, focusTargetAfterMessage);
                    updateEmailButton.disabled = false;
                    updateEmailButton.textContent = 'Update Email Address';
                }
            } catch (error) {
                console.error("Error updating email:", error);
                showSettingsMessage('An error occurred. Please try again.', 'error', 0, newEmailInput);
                updateEmailButton.disabled = false;
                updateEmailButton.textContent = 'Update Email Address';
            }
        });
    }

    const regeneratePasswordForm = document.getElementById('regenerate-password-form');
    if (regeneratePasswordForm) {
        const currentPasswordForRegen = document.getElementById('current-password-for-regen');
        regeneratePasswordForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            settingsMessageArea.style.display = 'none';
            const regeneratePasswordButton = document.getElementById('regenerate-password-button');
            regeneratePasswordButton.disabled = true;
            regeneratePasswordButton.textContent = 'Regenerating...';
            const currentPassword = currentPasswordForRegen.value;
            const csrfToken = window.csrfTokenRaw; // Use window.csrfTokenRaw

            if (!csrfToken || csrfToken === "%%CSRF_TOKEN_RAW%%") {
                showSettingsMessage('CSRF token missing. Cannot regenerate password. Please refresh.', 'error', 0, regeneratePasswordButton);
                regeneratePasswordButton.disabled = false;
                regeneratePasswordButton.textContent = 'Regenerate Password & Send Email';
                return;
            }

            try {
                const response = await fetch('/api/me/regenerate-password', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': csrfToken
                    },
                    body: JSON.stringify({ current_password: currentPassword })
                });
                const result = await response.json();
                if (response.ok) {
                    showSettingsMessage(result.message || 'Password regenerated. Check email. Logging out...', 'success', 0);
                    setTimeout(() => { window.location.href = '/logout'; }, 4000);
                } else {
                    showSettingsMessage(result.detail || 'Failed to regenerate password.', 'error', 0, currentPasswordForRegen);
                    regeneratePasswordButton.disabled = false;
                    regeneratePasswordButton.textContent = 'Regenerate Password & Send Email';
                }
            } catch (error) {
                console.error("Error regenerating password:", error);
                showSettingsMessage('An error occurred. Please try again.', 'error', 0, currentPasswordForRegen);
                regeneratePasswordButton.disabled = false;
                regeneratePasswordButton.textContent = 'Regenerate Password & Send Email';
            }
        });
    }

    // --- LLM Settings Functionality ---
    const llmProviderSelect = document.getElementById('llm-provider');
    const llmModelSelect = document.getElementById('llm-model');
    const llmApiKeyGroup = document.getElementById('llm-api-key-group');
    const llmApiKeyInput = document.getElementById('llm-api-key');
    const llmApiKeyStatus = document.getElementById('llm-api-key-status');
    const llmBaseUrlGroup = document.getElementById('llm-base-url-group');
    const llmBaseUrlInput = document.getElementById('llm-base-url');
    const llmProviderStatus = document.getElementById('llm-provider-status');
    const saveLLMSettingsButton = document.getElementById('save-llm-settings-button');
    const llmSettingsForm = document.getElementById('llm-settings-form');

    let availableProvidersData = []; // To store fetched provider details, including their models

    /**
     * Loads initial LLM configuration data: available providers and current user's LLM settings.
     * Populates the provider dropdown and sets initial values for other fields.
     */
    async function loadLLMConfigData() {
        if (!llmProviderSelect || !llmModelSelect) {
            console.error("LLM configuration select elements not found in the DOM.");
            return;
        }
        try {
            // Fetch all available providers and their details (including models)
            const providersResponse = await fetch('/api/llm/providers');
            if (!providersResponse.ok) {
                showSettingsMessage('Failed to load LLM providers configuration.', 'error', 0, llmProviderSelect);
                llmProviderSelect.innerHTML = '<option value="">Error loading providers</option>';
                llmModelSelect.innerHTML = '<option value="">-- Select Provider First --</option>';
                llmModelSelect.disabled = true;
                return;
            }
            availableProvidersData = await providersResponse.json(); // Store for later use

            // Fetch the current user's saved LLM settings
            const userSettingsResponse = await fetch('/api/me/llm-settings', { cache: 'no-store' });
            const currentUserLLMSettings = userSettingsResponse.ok ? await userSettingsResponse.json() : {};
            
            if (!userSettingsResponse.ok && availableProvidersData.length > 0) {
                showSettingsMessage('Could not load your saved LLM settings. Defaults may be shown.', 'error', 4000, llmProviderSelect);
            }

            // Populate the providers dropdown
            populateLLMProviders(currentUserLLMSettings.selected_llm_provider_id);

            // Set the initially selected provider (if any)
            const effectiveProviderId = currentUserLLMSettings.selected_llm_provider_id || "";
            if (llmProviderSelect.querySelector(`option[value="${effectiveProviderId}"]`)) {
                 llmProviderSelect.value = effectiveProviderId;
            } else {
                llmProviderSelect.value = ""; // Default to "Select Provider"
            }
           

            // Update model dropdown and other fields based on the (potentially) selected provider
            updateModelDropdown(llmProviderSelect.value, currentUserLLMSettings.selected_llm_model_id, currentUserLLMSettings);
            updateProviderSpecificFields(llmProviderSelect.value, currentUserLLMSettings);

        } catch (error) {
            console.error("Error loading LLM configuration:", error);
            showSettingsMessage('A critical error occurred while loading LLM configuration.', 'error', 0, llmProviderSelect);
            llmProviderSelect.innerHTML = '<option value="">Error</option>';
            llmModelSelect.innerHTML = '<option value="">Error</option>';
            llmModelSelect.disabled = true;
        }
    }

    /**
     * Populates the LLM Provider dropdown.
     * @param {string|null} currentProviderId The ID of the currently selected provider (to pre-select it).
     */
    function populateLLMProviders(currentProviderId) {
        llmProviderSelect.innerHTML = '<option value="">-- Select Provider --</option>'; // Default empty option
        availableProvidersData.forEach(provider => {
            // You might have filtering logic here if needed, e.g., based on provider.is_system_configured
            const option = document.createElement('option');
            option.value = provider.id;
            option.textContent = provider.display_name;
            if (provider.id === currentProviderId) {
                option.selected = true;
            }
            llmProviderSelect.appendChild(option);
        });
    }

    /**
     * Updates the LLM Model dropdown based on the selected provider.
     * Enables or disables the model dropdown accordingly.
     * @param {string} providerId The ID of the selected provider.
     * @param {string|null} currentModelId The ID of the currently selected model (to pre-select it).
     * @param {object} userSettings The current user's LLM settings (for context).
     */
    function updateModelDropdown(providerId, currentModelId, userSettings = {}) {
        llmModelSelect.innerHTML = '<option value="">-- Select Model --</option>'; // Default empty option
        const selectedProvider = availableProvidersData.find(p => p.id === providerId);

        if (selectedProvider && selectedProvider.available_models && selectedProvider.available_models.length > 0) {
            llmModelSelect.disabled = false; // *** ENABLE the dropdown ***
            selectedProvider.available_models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.model_id;
                // Display both name and ID for clarity, especially if names are not unique across providers
                option.textContent = model.display_name ? `${model.display_name} (${model.model_id})` : model.model_id;
                
                // Pre-select if this model was the user's saved choice for this provider
                if (providerId === userSettings.selected_llm_provider_id && model.model_id === currentModelId) {
                    option.selected = true;
                }
                llmModelSelect.appendChild(option);
            });
        } else if (providerId) { // Provider selected, but no models
            llmModelSelect.innerHTML = '<option value="">No models available for this provider</option>';
            llmModelSelect.disabled = true; // *** DISABLE if no models ***
        } else { // No provider selected
            llmModelSelect.innerHTML = '<option value="">-- Select Provider First --</option>';
            llmModelSelect.disabled = true; // *** DISABLE if no provider selected ***
        }
    }

    /**
     * Updates provider-specific fields (API key, base URL) based on the selected provider.
     * @param {string} providerId The ID of the selected provider.
     * @param {object} userSettings The current user's LLM settings.
     */
    function updateProviderSpecificFields(providerId, userSettings = {}) {
        const selectedProvider = availableProvidersData.find(p => p.id === providerId);

        // Hide all optional groups by default
        llmApiKeyGroup.style.display = 'none';
        llmApiKeyGroup.setAttribute('aria-hidden', 'true');
        llmBaseUrlGroup.style.display = 'none';
        llmBaseUrlGroup.setAttribute('aria-hidden', 'true');

        // Reset fields and status messages
        llmProviderStatus.textContent = providerId ? "Loading provider details..." : "Select a provider to see more options.";
        llmApiKeyInput.value = '';
        llmApiKeyInput.placeholder = '';
        llmApiKeyStatus.textContent = '';
        llmBaseUrlInput.value = '';
        llmBaseUrlInput.placeholder = '';

        if (selectedProvider) {
            // API Key field visibility and status
            if (selectedProvider.can_accept_user_api_key) { // Check if provider *can* accept a user key
                llmApiKeyGroup.style.display = 'block';
                llmApiKeyGroup.setAttribute('aria-hidden', 'false');
                if (userSettings.has_user_api_key && selectedProvider.id === userSettings.selected_llm_provider_id) {
                    llmApiKeyInput.placeholder = "•••••••• (A key is currently saved)";
                    llmApiKeyStatus.textContent = "A key is saved. Edit to change, or clear field and save to remove your key.";
                } else if (selectedProvider.is_system_configured && selectedProvider.needs_api_key_from_user === false) {
                    // System has a key, and user doesn't strictly need to provide one, but can.
                    llmApiKeyInput.placeholder = "API Key (Optional - System key available)";
                    llmApiKeyStatus.textContent = "A system key is configured. You can provide your own to override it for your account.";
                } else if (selectedProvider.needs_api_key_from_user === true) {
                    llmApiKeyInput.placeholder = "API Key (Required)";
                    llmApiKeyStatus.textContent = "Please enter your API key for this provider.";
                } else { // Can accept, but not strictly required and no system key (e.g. some local models)
                    llmApiKeyInput.placeholder = "API Key (Optional)";
                    llmApiKeyStatus.textContent = "You can optionally provide an API key.";
                }
            }

            // Base URL field visibility and status
            if (selectedProvider.can_accept_user_base_url) { // Check if provider *can* accept a user base URL
                llmBaseUrlGroup.style.display = 'block';
                llmBaseUrlGroup.setAttribute('aria-hidden', 'false');
                if (selectedProvider.id === userSettings.selected_llm_provider_id && userSettings.selected_llm_base_url) {
                    llmBaseUrlInput.value = userSettings.selected_llm_base_url;
                }
                // Provide more specific placeholders based on provider type if available
                if (selectedProvider.type === 'ollama') {
                    llmBaseUrlInput.placeholder = "e.g., http://localhost:11434 (uses system default if empty)";
                } else if (selectedProvider.type === 'openai_compatible_server') {
                    llmBaseUrlInput.placeholder = "e.g., https://api.example.com/v1 (Required if no system default)";
                } else {
                    llmBaseUrlInput.placeholder = "Custom Base URL (Optional)";
                }
            }

            // General provider status message
            if (!selectedProvider.is_system_configured && selectedProvider.needs_api_key_from_user === true) {
                llmProviderStatus.textContent = "This provider requires configuration (e.g., an API key).";
            } else if (selectedProvider.is_system_configured && selectedProvider.needs_api_key_from_user === false) {
                llmProviderStatus.textContent = "This provider is system-configured and ready to use.";
            } else if (selectedProvider.can_accept_user_api_key || selectedProvider.can_accept_user_base_url) {
                llmProviderStatus.textContent = "This provider can be customized with your own API key or base URL.";
            } else {
                llmProviderStatus.textContent = "This provider does not require additional configuration.";
            }

        } else if (providerId === "") { // "-- Select Provider --" is chosen
             llmProviderStatus.textContent = "Select a provider to see configuration options.";
        }
    }

    // Event listener for when the LLM provider selection changes
    llmProviderSelect.addEventListener('change', async (event) => {
        const selectedProviderId = event.target.value;
        
        // Fetch the latest user settings as they might have changed or to get defaults for the new provider
        const userSettingsResponse = await fetch('/api/me/llm-settings', {cache: 'no-store'});
        const currentUserLLMSettings = userSettingsResponse.ok ? await userSettingsResponse.json() : {};

        // Determine which model should be pre-selected.
        // If the newly selected provider is the same as the user's saved provider, use their saved model.
        // Otherwise, no specific model is pre-selected (will default to "-- Select Model --").
        const modelToSelect = (selectedProviderId === currentUserLLMSettings.selected_llm_provider_id)
                                ? currentUserLLMSettings.selected_llm_model_id
                                : null; // Let updateModelDropdown handle the default "-- Select Model --"

        updateModelDropdown(selectedProviderId, modelToSelect, currentUserLLMSettings);
        updateProviderSpecificFields(selectedProviderId, currentUserLLMSettings);
    });

    // Event listener for saving LLM settings
    llmSettingsForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        settingsMessageArea.style.display = 'none';
        saveLLMSettingsButton.disabled = true;
        saveLLMSettingsButton.textContent = 'Saving...';
        const csrfToken = window.csrfTokenRaw; // Use the globally available raw CSRF token

        if (!csrfToken || csrfToken === "%%CSRF_TOKEN_RAW%%") {
            showSettingsMessage('CSRF token missing. Cannot save settings. Please refresh.', 'error', 0, saveLLMSettingsButton);
            saveLLMSettingsButton.disabled = false;
            saveLLMSettingsButton.textContent = 'Save LLM Settings';
            return;
        }

        const providerId = llmProviderSelect.value;
        const modelId = llmModelSelect.value;
        // Only include API key if the input group is visible (meaning provider accepts it)
        const apiKey = (llmApiKeyGroup.style.display !== 'none') ? llmApiKeyInput.value : undefined;
        // Only include base URL if the input group is visible
        const baseUrl = (llmBaseUrlGroup.style.display !== 'none') ? llmBaseUrlInput.value : undefined;

        const payload = {
            selected_llm_provider_id: providerId || null, // Send null if empty string
            selected_llm_model_id: modelId || null,     // Send null if empty string
        };

        // Conditionally add api_key and base_url to the payload
        // The backend expects `user_llm_api_key` and `selected_llm_base_url`
        if (apiKey !== undefined) { // Check for undefined, empty string means "clear the key"
            payload.user_llm_api_key = apiKey;
        }
        if (baseUrl !== undefined) { // Check for undefined, empty string means "clear the base URL"
            payload.selected_llm_base_url = baseUrl || null; // Send null if empty string
        }

        try {
            const response = await fetch('/api/me/llm-settings', {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': csrfToken
                },
                body: JSON.stringify(payload)
            });
            const result = await response.json();
            if (response.ok) {
                showSettingsMessage('LLM settings saved successfully!', 'success', 3000, saveLLMSettingsButton);
                // Reload the config data to reflect saved settings (e.g., has_user_api_key status)
                await loadLLMConfigData(); 
            } else {
                let fieldToFocus = llmProviderSelect;
                if (result.detail && typeof result.detail === 'string') {
                    if (result.detail.toLowerCase().includes('model')) fieldToFocus = llmModelSelect;
                    else if (result.detail.toLowerCase().includes('api key')) fieldToFocus = llmApiKeyInput;
                    else if (result.detail.toLowerCase().includes('base url')) fieldToFocus = llmBaseUrlInput;
                }
                showSettingsMessage(result.detail || 'Failed to save LLM settings.', 'error', 0, fieldToFocus);
            }
        } catch (error) {
            console.error("Error saving LLM settings:", error);
            showSettingsMessage('An error occurred while saving LLM settings.', 'error', 0, saveLLMSettingsButton);
        } finally {
            saveLLMSettingsButton.disabled = false;
            saveLLMSettingsButton.textContent = 'Save LLM Settings';
        }
    });

    // Initial load of LLM configuration when the page is ready
    await loadLLMConfigData(); 
});



=== LLM Instructions ===
Now please just read the project and the rules for writing code and just wait for instructions.

Here are the rules:
1. DONT write comments, placeholders or docstrings if not explicitely told.
2. Write functions with the correct initial indentation so that if the function is indented so is your code that you write.
3. DO NOT USE NON-TERMINATED SPACES. MAKE SURE TO FOLLOW THIS! ITS SUPER IMPORTANT AND YOU SEEM TO BREAK IT, PLEASE!!!
4. For changes that require multiple replacements please tell me what to replace with what instead of rewriting large portions of text. You can use vscode valid regexp for instance.
5. For small functions less than 100 lines of code please rewrite the full function. For larger functions please only write complete control statements if/while/case.
6. Never omit/change working logic if not explicitely statet that it should be removed/change
7. DONT use the CANVAS TOOL where code is written in artifacts.
8. Write only functions that are new seperately from functions that needs updates.
9. Make sure to write what has been change where to place/what to replace for each code snippet.
