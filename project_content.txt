=== Project Directory Structure ===
Root: C:\Users\viktor.jonsson\OneDrive - CellMax Technologies AB\Documents\Repositories\svenviktorjonsson\tesseracs-chat
Relevant files and folders (excluding specified patterns):

.
├── Readme.md
├── build.js
├── fetch_assets.py
├── package-lock.json
├── package.json
├── postcss.config.js
├── project_content.txt
├── pyproject.toml
├── tailwind.config.js
├── temp.js
├── temp.py
├── write_project_content_to_file.py
app/
├── __init__.py
├── auth.py
├── config.py
├── database.py
├── docker_utils.py
├── email_utils.py
├── llm.py
├── main.py
├── models.py
├── state.py
├── utils.py
├── static/
│   ├── _sidebar.html
│   ├── chat-session.html
│   ├── input.css
│   ├── login.html
│   ├── script.js
│   ├── session-choice.html
│   ├── settings.html
│   ├── email_templates/
│   │   ├── password_reset_email.html
│   │   ├── registration_email.html
│   ├── js/
│   │   ├── app-ui.js


=== File Contents ===

=== Readme.md ===
Readme


=== build.js ===
--- CONTENT EXCLUDED (listed in exclude_files) ---


=== fetch_assets.py ===
import os
import requests
import sys

# --- Configuration ---
# Get the directory where the script is located
script_dir = os.path.dirname(os.path.abspath(__file__))
print(f"DEBUG: Script is running from directory: {script_dir}") # <-- Added Debug Print

# Define paths relative to the script's location
static_dir = os.path.join(script_dir, 'app', 'static')
assets_dir = os.path.join(static_dir, 'assets')
css_dir = os.path.join(assets_dir, 'css')
fonts_dir = os.path.join(assets_dir, 'fonts') # Define fonts dir for creation

# Print the calculated target directories for verification
print(f"DEBUG: Target static directory: {static_dir}")
print(f"DEBUG: Target assets directory: {assets_dir}")
print(f"DEBUG: Target CSS directory: {css_dir}")
print(f"DEBUG: Target fonts directory: {fonts_dir}") # <-- Added Debug Print

# List of CSS files to download
css_files_to_download = [
    {
        'name': 'katex.min.css',
        'url': 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css',
        'dest': os.path.join(css_dir, 'katex.min.css')
    },
    {
        'name': 'prism-tomorrow.min.css',
        'url': 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css',
        'dest': os.path.join(css_dir, 'prism-tomorrow.min.css')
    }
]

# --- Helper Functions ---
def ensure_dir_exists(dir_path):
    """Creates a directory if it doesn't exist."""
    if not os.path.exists(dir_path):
        print(f"Creating directory: {dir_path}")
        try:
            os.makedirs(dir_path, exist_ok=True)
        except OSError as e:
            print(f"Error creating directory {dir_path}: {e}", file=sys.stderr)
            sys.exit(1) # Exit if directory creation fails

def download_file(url, destination_path):
    """Downloads a file from a URL to a destination path."""
    print(f"Attempting to download {os.path.basename(destination_path)} to {destination_path} from {url}...") # <-- Added Debug Print
    try:
        response = requests.get(url, stream=True, timeout=30) # Added timeout
        response.raise_for_status() # Raise an exception for bad status codes (4xx or 5xx)

        with open(destination_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
        print(f"Successfully downloaded: {os.path.basename(destination_path)}")
        return True
    except requests.exceptions.RequestException as e:
        print(f"Error downloading {url}: {e}", file=sys.stderr)
        # Clean up partially downloaded file if it exists
        if os.path.exists(destination_path):
            try:
                os.remove(destination_path)
                print(f"Removed partially downloaded file: {os.path.basename(destination_path)}")
            except OSError as remove_error:
                print(f"Error removing partial file {destination_path}: {remove_error}", file=sys.stderr)
        return False
    except Exception as e:
        print(f"An unexpected error occurred during download of {url}: {e}", file=sys.stderr)
        return False


# --- Main Execution ---
def main():
    print("Starting Python asset fetching process...")

    # 1. Ensure directories exist
    print("Ensuring necessary directories exist...")
    ensure_dir_exists(static_dir)
    ensure_dir_exists(assets_dir)
    ensure_dir_exists(css_dir)
    ensure_dir_exists(fonts_dir) # Also create fonts dir
    print("Directory check complete.")

    # 2. Download CSS files
    print("\nDownloading CSS files...")
    success_count = 0
    failure_count = 0
    for file_info in css_files_to_download:
        # Print the destination path before downloading
        print(f"DEBUG: Calculated destination for {file_info['name']}: {file_info['dest']}") # <-- Added Debug Print
        if download_file(file_info['url'], file_info['dest']):
            success_count += 1
        else:
            failure_count += 1

    print(f"\nDownload summary: {success_count} succeeded, {failure_count} failed.")

    if failure_count > 0:
        print("\nOne or more downloads failed. Please check the errors above.", file=sys.stderr)
        sys.exit(1) # Exit with error code if any download failed
    else:
        print("\nPython asset fetching process completed successfully.")
        print("CSS files downloaded to:", css_dir)
        print("Ensure font files are placed in:", fonts_dir)

if __name__ == "__main__":
    main()


=== package-lock.json ===
--- CONTENT EXCLUDED (listed in exclude_files) ---


=== package.json ===
{
  "name": "tesseracs-chat",
  "version": "1.0.0",
  "description": "Readme",
  "main": "temp.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "node build.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/svenviktorjonsson/tesseracs-chat.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/svenviktorjonsson/tesseracs-chat/issues"
  },
  "homepage": "https://github.com/svenviktorjonsson/tesseracs-chat#readme",
  "devDependencies": {
    "autoprefixer": "^10.4.21",
    "esbuild": "^0.25.4",
    "esbuild-style-plugin": "^1.6.3",
    "postcss": "^8.5.3",
    "tailwindcss": "^3.4.17"
  },
  "dependencies": {
    "katex": "^0.16.22",
    "marked": "^15.0.11",
    "prismjs": "^1.29.0"
  }
}


=== postcss.config.js ===
// postcss.config.js
module.exports = {
  plugins: {
    'tailwindcss': {}, // Use 'tailwindcss' for v3
    'autoprefixer': {},
  },
}

=== project_content.txt ===


=== pyproject.toml ===
[tool.poetry]
name = "tesseracs-chat"
version = "1.0.1"
description = "Web chat interface for Ollama using FastAPI and LangChain"
authors = ["Viktor Jonsson <viktor.jonsson@tesseracs.com>"]
readme = "README.md" # Optional README
packages = [
    { include = "app" },
]

[tool.poetry.dependencies]
python = "^3.9" # Adjust Python version if needed
fastapi = "^0.110.0"
uvicorn = {extras = ["standard"], version = "^0.29.0"}

# Let Poetry resolve the latest compatible LangChain versions
# Using "*" allows any version, but be aware this might pull in breaking changes in the future.
langchain = "*"
langchain-ollama = "*"
langchain-core = "*"
langchain-community = "*"
langchain-text-splitters = "*"

# Other dependencies
websockets = "^12.0" # Required by FastAPI for WebSockets
python-dotenv = "^1.0.1" # For optional .env file
aiofiles = "^23.2.1" # For serving static files asynchronously
docker = "^7.1.0"
requests = "^2.32.3"
python-multipart = "^0.0.20"
fastapi-mail = "^1.4.2"
certifi = "^2025.4.26"
pydantic = "^2.11.4"
passlib = {extras = ["bcrypt"], version = "*"}

[tool.poetry.scripts]
app = "app.main:start_server" # Command to run the app

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"



=== tailwind.config.js ===
/** @type {import('tailwindcss').Config} */
module.exports = {
    content: [
      "./app/static/**/*.html", // Scan HTML files in static
      "./app/static/**/*.js",   // Scan JS files in static
    ],
    theme: {
      extend: {},
    },
    plugins: [],
  }

=== temp.js ===
// --- DOM Elements ---
const chatHistory = document.getElementById('chat-history');
const chatForm = document.getElementById('chat-form');
const messageInput = document.getElementById('message-input');
const sendButton = document.getElementById('send-button');
const thinkCheckbox = document.getElementById('think-checkbox'); // Restored

// --- WebSocket & Client ID ---
let websocket;
const clientId = `web-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
let currentTurnId = 0; // Simple counter for unique IDs per turn

// --- State Machine Modes ---
const MODE_ANSWER = 'MODE_ANSWER';
const MODE_SEEKING_CODE_START_FENCE = 'MODE_SEEKING_CODE_START_FENCE'; // Looking for ```
const MODE_SEEKING_CODE_LANGUAGE = 'MODE_SEEKING_CODE_LANGUAGE';     // Reading language after ```
const MODE_INSIDE_CODE_BLOCK = 'MODE_INSIDE_CODE_BLOCK';        // Inside the code block
const MODE_SEEKING_CODE_END_FENCE = 'MODE_SEEKING_CODE_END_FENCE';   // Found potential closing ```

// --- State Variables ---
let currentProcessingMode = MODE_ANSWER;
let fenceBuffer = '';             // Buffer for detecting ``` fences
let langBuffer = '';              // Buffer for language string
let codeBuffer = '';              // Buffer for code content within a block
let currentCodeBlockLang = '';    // Detected language for the current block
let currentCodeBlockElement = null; // The <code> element being filled
let currentCodeBlockPreElement = null; // The <pre> element wrapping the code
let currentAiTurnContainer = null;  // The main container for the AI bubble + its code blocks
let currentAnswerElement = null;    // The div.ai-message bubble
let currentCodeBlocksArea = null; // The div below bubble holding code blocks
let codeBlockCounterThisTurn = 0; // Counter for code blocks within the *current* AI turn
let thinkingRequestedForCurrentTurn = false; // Restored
let isFirstContentChunkForTurn = true;

// --- Constants ---
const FENCE = '```';

// --- Helper Functions ---

function scrollToBottom() {
    // Adding a small delay can sometimes help ensure scrolling happens after render
    setTimeout(() => {
        chatHistory.scrollTo({ top: chatHistory.scrollHeight, behavior: 'smooth' });
    }, 50);
}

function addUserMessage(text) {
    const messageElement = document.createElement('div');
    messageElement.classList.add('message', 'user-message');
    messageElement.textContent = text;
    chatHistory.appendChild(messageElement);
    scrollToBottom();
}

function addSystemMessage(text) {
     const messageElement = document.createElement('div');
     messageElement.classList.add('system-message');
     messageElement.textContent = text;
     chatHistory.appendChild(messageElement);
     scrollToBottom();
}

function addErrorMessage(text) {
     console.error("[UI ERROR] ", text);
     const messageElement = document.createElement('div');
     messageElement.classList.add('error-message'); // Use error styling
     messageElement.textContent = `Error: ${text}`;
     if(currentAiTurnContainer) {
         currentAiTurnContainer.appendChild(messageElement); // Append error within the turn container
     } else {
         chatHistory.appendChild(messageElement); // Fallback if no turn container exists
     }
     scrollToBottom();
}

function setInputDisabledState(disabled) {
    messageInput.disabled = disabled;
    sendButton.disabled = disabled;
    if (thinkCheckbox) {
        thinkCheckbox.disabled = disabled;
    }
}

function finalizeTurnOnErrorOrClose() {
    console.log("[DEBUG] finalizeTurnOnErrorOrClose called.");
    if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK && currentCodeBlockElement) {
        console.warn("Stream ended unexpectedly inside a code block.");
        try {
            Prism.highlightElement(currentCodeBlockElement);
        } catch (e) { console.error("Prism highlighting error on incomplete block:", e); }
    }
    resetStreamingState();
    setInputDisabledState(true); // Disable input on error/close
}

function resetStreamingState() {
    console.log("[DEBUG] Resetting streaming state.");
    currentProcessingMode = MODE_ANSWER;
    fenceBuffer = '';
    langBuffer = '';
    codeBuffer = '';
    currentCodeBlockLang = '';
    currentCodeBlockElement = null;
    currentCodeBlockPreElement = null;
    // Note: Turn-specific elements (currentAiTurnContainer, etc.) are managed by setupNewAiTurn
}

function setupNewAiTurn() {
    currentTurnId++;
    codeBlockCounterThisTurn = 0; // Reset code block counter
    isFirstContentChunkForTurn = true; // <<< Reset the flag for the new turn

    currentAiTurnContainer = document.createElement('div');
    currentAiTurnContainer.classList.add('ai-turn-container');
    currentAiTurnContainer.dataset.turnId = currentTurnId;

    currentAnswerElement = document.createElement('div');
    currentAnswerElement.classList.add('message', 'ai-message');
    currentAiTurnContainer.appendChild(currentAnswerElement);

    currentCodeBlocksArea = document.createElement('div');
    currentCodeBlocksArea.classList.add('code-blocks-area');
    currentAiTurnContainer.appendChild(currentCodeBlocksArea);

    chatHistory.appendChild(currentAiTurnContainer);
}

function appendToAnswerBubble(text) {
    if (!currentAnswerElement) {
        console.error("Attempted to append to null answer bubble!");
        // Attempt recovery only if there's actual text content
        if (text.trim().length === 0) return; // Don't try to recover for whitespace only

        if (currentAiTurnContainer && !currentAiTurnContainer.querySelector('.ai-message')) {
             currentAnswerElement = document.createElement('div');
             currentAnswerElement.classList.add('message', 'ai-message');
             currentAiTurnContainer.insertBefore(currentAnswerElement, currentCodeBlocksArea);
        } else if (currentAiTurnContainer) {
             currentAnswerElement = currentAiTurnContainer.querySelector('.ai-message');
             if(!currentAnswerElement) {
                console.error("CRITICAL: Cannot find or create answer bubble in turn container.");
                return;
             }
        } else {
            console.error("CRITICAL: No turn container to recover answer bubble.");
            return;
        }
    }

    // <<< START: Added Leading Whitespace Trim Logic >>>
    let processedText = text;
    if (isFirstContentChunkForTurn) {
        processedText = text.trimStart(); // Remove leading whitespace ONLY for the first chunk
        // Only set flag to false if we actually processed non-empty text after trimming
        if (processedText.length > 0) {
             isFirstContentChunkForTurn = false;
        }
    }
    // <<< END: Added Leading Whitespace Trim Logic >>>

    // Append text content only if there is something left after trimming
    if (processedText.length > 0) {
        currentAnswerElement.appendChild(document.createTextNode(processedText));
    }
}


function appendCodeReference() {
    if (!currentAnswerElement) {
        console.error("Attempted to append code reference to null answer bubble!");
        return;
    }
    codeBlockCounterThisTurn++;
    const refSpan = document.createElement('span');
    refSpan.classList.add('code-reference');
    refSpan.textContent = `[Code ${codeBlockCounterThisTurn}]`;
    currentAnswerElement.appendChild(refSpan); // Append the span node
}

function createCodeBlockStructure(language) {
    if (!currentCodeBlocksArea) {
        console.error("Attempted to create code block in null area!");
        return;
    }

    const blockId = `code-block-turn${currentTurnId}-${codeBlockCounterThisTurn}`;
    // Normalize language: lowercase, trim, default 'plain', handle potential null/undefined
    const safeLanguage = (language || '').trim().toLowerCase() || 'plain';
    // Alias common variations
    const langAlias = {
        'python': 'python', 'py': 'python',
        'javascript': 'javascript', 'js': 'javascript',
        'html': 'markup', 'xml': 'markup', 'svg': 'markup', // Prism uses 'markup' for HTML/XML
        'css': 'css',
        'bash': 'bash', 'shell': 'bash',
        'java': 'java',
        'csharp': 'csharp', 'cs': 'csharp',
        'cpp': 'cpp', 'c++': 'cpp',
        'ruby': 'ruby', 'rb': 'ruby',
        'go': 'go',
        'php': 'php',
        'json': 'json',
        'yaml': 'yaml', 'yml': 'yaml',
        'sql': 'sql',
        'markdown': 'markdown', 'md': 'markdown'
    };
    const prismLang = langAlias[safeLanguage] || safeLanguage; // Use alias or original safe name
    const displayLang = safeLanguage; // Show the user what they typed (or 'plain')


    const container = document.createElement('div');
    container.classList.add('code-block-container');
    container.id = blockId;

    const header = document.createElement('div');
    header.classList.add('code-block-header');

    const title = document.createElement('span');
    title.textContent = `Code ${codeBlockCounterThisTurn} (${displayLang})`;

    const buttonsDiv = document.createElement('div');
    const toggleBtn = document.createElement('button');
    toggleBtn.classList.add('toggle-code-btn');
    toggleBtn.textContent = 'Show'; // Default text
    const copyBtn = document.createElement('button');
    copyBtn.classList.add('copy-code-btn');
    copyBtn.textContent = 'Copy';

    buttonsDiv.appendChild(toggleBtn);
    buttonsDiv.appendChild(copyBtn);

    // Append buttons first, then title
    header.appendChild(buttonsDiv);
    header.appendChild(title);

    // Create pre/code elements but store references locally for listeners
    const preElement = document.createElement('pre');
    const codeElement = document.createElement('code');
    codeElement.classList.add(`language-${prismLang}`);
    preElement.classList.add('hidden'); // Add hidden class by default

    // Assign references for streaming
    currentCodeBlockPreElement = preElement;
    currentCodeBlockElement = codeElement; // This global ref is used *during* streaming

    preElement.appendChild(codeElement);
    container.appendChild(header);
    container.appendChild(preElement);

    // --- Event Listeners ---

    toggleBtn.addEventListener('click', () => {
        // Find the pre element relative to the button clicked
        const containerDiv = toggleBtn.closest('.code-block-container');
        const preToToggle = containerDiv?.querySelector('pre');
        if (preToToggle) {
            const isHidden = preToToggle.classList.toggle('hidden');
            toggleBtn.textContent = isHidden ? 'Show' : 'Hide'; // Toggle text
        }
    });

    copyBtn.addEventListener('click', () => {
        // <<< START: Updated Copy Logic >>>
        // Find the specific container and code element relative to *this* button
        const containerDiv = copyBtn.closest('.code-block-container');
        const codeElementToCopy = containerDiv?.querySelector('pre > code');

        if (!codeElementToCopy) {
            console.error('Could not find code element to copy for button:', copyBtn);
            copyBtn.textContent = 'Error!';
             setTimeout(() => { copyBtn.textContent = 'Copy'; }, 1500);
            return; // Exit if element not found
        }

        const codeContent = codeElementToCopy.textContent;
        navigator.clipboard.writeText(codeContent).then(() => {
            copyBtn.textContent = 'Copied!';
            copyBtn.classList.add('copied'); // Add class for potential styling feedback
            setTimeout(() => {
                // Check if the text is still 'Copied!' before resetting
                // (prevents flicker if user clicks multiple times quickly)
                if (copyBtn.textContent === 'Copied!') {
                    copyBtn.textContent = 'Copy';
                    copyBtn.classList.remove('copied');
                }
            }, 1500); // Reset after 1.5 seconds
        }).catch(err => {
            console.error('Failed to copy code: ', err);
            copyBtn.textContent = 'Error!';
             // Remove copied class if it was somehow added
            copyBtn.classList.remove('copied');
            setTimeout(() => {
                 if (copyBtn.textContent === 'Error!') {
                    copyBtn.textContent = 'Copy';
                 }
            }, 1500); // Reset after 1.5 seconds
        });
        // <<< END: Updated Copy Logic >>>
    });

    currentCodeBlocksArea.appendChild(container);
}

function appendToCodeBlock(text) {
    if (currentCodeBlockElement) {
        // Append text content to the <code> element
         currentCodeBlockElement.appendChild(document.createTextNode(text));
    } else {
        console.error("Attempted to append to null code block element!");
    }
}

function finalizeCodeBlock() {
    if (currentCodeBlockElement) {
        try {
            // Highlight the completed block using Prism
            Prism.highlightElement(currentCodeBlockElement);
            console.log(`[DEBUG] Highlighted code block ${codeBlockCounterThisTurn} (lang: ${currentCodeBlockLang})`);
            // Optional: Add line numbers if plugin is active
            // if (currentCodeBlockPreElement.classList.contains('line-numbers')) {
            //     Prism.plugins.lineNumbers.resize(currentCodeBlockPreElement);
            // }
        } catch (e) {
            console.error(`Prism highlighting error for lang '${currentCodeBlockLang}':`, e);
            // Add a class indicating error?
             currentCodeBlockElement.classList.add('prism-highlight-error');
        }
    }
    // Reset code block specific state
    currentCodeBlockElement = null;
    currentCodeBlockPreElement = null;
    currentCodeBlockLang = '';
    codeBuffer = ''; // Clear code buffer
}

// --- WebSocket Connection ---
function connectWebSocket() {
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${window.location.host}/ws/${clientId}`;
    console.log(`[DEBUG] Attempting to connect to WebSocket: ${wsUrl}`);

    try {
        const ws = new WebSocket(wsUrl);

        ws.onopen = (event) => {
            console.log("[DEBUG] WebSocket connection opened");
            websocket = ws;
            setInputDisabledState(false); // Enable inputs
            addSystemMessage("Connected to the chat server.");
            // Add initial AI message
            setupNewAiTurn();
            appendToAnswerBubble("AI: Hello! How can I help you today?");
            resetStreamingState(); // Reset state machine after initial message

            if(messageInput.offsetParent !== null) messageInput.focus();
        };

        ws.onmessage = (event) => {
            let chunk = event.data;

            // --- Handle Control Messages First ---
            if (chunk === "<EOS>") {
                console.log("[DEBUG] Received <EOS>. Finalizing turn.");
                 // If ended inside a code block, finalize it
                 if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK) {
                    finalizeCodeBlock();
                } else if (currentProcessingMode === MODE_SEEKING_CODE_END_FENCE && fenceBuffer.length > 0) {
                    // Ended while seeking end fence, treat buffer as regular text
                    appendToAnswerBubble(fenceBuffer);
                 } else if (currentProcessingMode === MODE_SEEKING_CODE_LANGUAGE && langBuffer.length > 0) {
                     // Ended while seeking language, treat as regular text
                    appendToAnswerBubble(FENCE + langBuffer);
                 } else if (currentProcessingMode === MODE_SEEKING_CODE_START_FENCE && fenceBuffer.length > 0) {
                     // Ended while seeking start fence, treat as regular text
                    appendToAnswerBubble(fenceBuffer);
                 }

                resetStreamingState();
                setInputDisabledState(false); // Re-enable inputs
                if(messageInput.offsetParent !== null) messageInput.focus();
                scrollToBottom();
                return; // End processing for this message
            }
            if (chunk.startsWith("<ERROR>")) {
                const errorMessage = chunk.substring(7);
                console.error("[DEBUG] Received <ERROR>:", errorMessage);
                addErrorMessage(errorMessage);
                finalizeTurnOnErrorOrClose(); // Disables input
                scrollToBottom();
                return; // End processing for this message
            }

            // <<< --- START: Tag Filtering --- >>>
            // Remove <think> and </think> tags and any surrounding whitespace globally
            chunk = chunk.replace(/\s*<think>\s*/g, '').replace(/\s*<\/think>\s*/g, '');
            // If the chunk becomes empty after filtering, skip further processing for this chunk
            if (chunk.length === 0) {
                return;
            }
            // <<< --- END: Tag Filtering --- >>>


            // Ensure AI turn container exists (should be set up by setupNewAiTurn)
             if (!currentAiTurnContainer) {
                 console.error("CRITICAL: No AI turn container set up before message chunk received!");
                 // Attempt recovery only if chunk contains non-whitespace content after filtering
                 if (chunk.trim().length > 0) {
                    setupNewAiTurn();
                 } else {
                    return; // Don't set up turn for empty/whitespace-only chunks
                 }
            }

            // --- State Machine Processing ---
            let currentPos = 0;
            while (currentPos < chunk.length) {
                const char = chunk[currentPos];
                let incrementPos = true;

                switch (currentProcessingMode) {
                    case MODE_ANSWER:
                        if (char === FENCE[0]) {
                            fenceBuffer = char;
                            currentProcessingMode = MODE_SEEKING_CODE_START_FENCE;
                        } else {
                            appendToAnswerBubble(char);
                        }
                        break;

                    case MODE_SEEKING_CODE_START_FENCE:
                        if (char === FENCE[fenceBuffer.length]) {
                            fenceBuffer += char;
                            if (fenceBuffer === FENCE) {
                                console.log("[DEBUG] Found ``` start fence.");
                                fenceBuffer = '';
                                langBuffer = '';
                                currentProcessingMode = MODE_SEEKING_CODE_LANGUAGE;
                            }
                        } else {
                            appendToAnswerBubble(fenceBuffer + char);
                            fenceBuffer = '';
                            currentProcessingMode = MODE_ANSWER;
                        }
                        break;

                    case MODE_SEEKING_CODE_LANGUAGE:
                        if (char === '\n') {
                            console.log(`[DEBUG] Found language line: '${langBuffer}'`);
                            currentCodeBlockLang = langBuffer; // Keep raw lang buffer for createCodeBlockStructure
                            appendCodeReference();
                            createCodeBlockStructure(currentCodeBlockLang); // Handles normalization/aliasing
                            langBuffer = '';
                            codeBuffer = '';
                            currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                        } else if (langBuffer.length > 50) { // Prevent runaway language buffer
                             console.warn("Language line too long, assuming no language.");
                             appendToAnswerBubble(FENCE + langBuffer + char); // Treat as text
                             langBuffer = '';
                             fenceBuffer = '';
                             currentProcessingMode = MODE_ANSWER;
                        } else {
                            langBuffer += char;
                        }
                        break;

                    case MODE_INSIDE_CODE_BLOCK:
                        if (char === FENCE[0]) {
                            fenceBuffer = char;
                            currentProcessingMode = MODE_SEEKING_CODE_END_FENCE;
                        } else {
                            appendToCodeBlock(char);
                        }
                        break;

                    case MODE_SEEKING_CODE_END_FENCE:
                        if (char === FENCE[fenceBuffer.length]) {
                            fenceBuffer += char;
                            if (fenceBuffer === FENCE) {
                                console.log("[DEBUG] Found ``` end fence.");
                                // Check for immediate newline after fence, common pattern
                                if (currentPos + 1 < chunk.length && chunk[currentPos + 1] === '\n') {
                                     currentPos++; // Consume the newline
                                } else {
                                     // If next char is not newline, maybe check later chunks?
                                     // For simplicity, we'll just finalize here.
                                }
                                finalizeCodeBlock();
                                fenceBuffer = '';
                                currentProcessingMode = MODE_ANSWER;
                            }
                        } else {
                            appendToCodeBlock(fenceBuffer + char);
                            fenceBuffer = '';
                            currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                        }
                        break;

                    default:
                        console.error("Unknown processing mode:", currentProcessingMode);
                        currentProcessingMode = MODE_ANSWER;
                        incrementPos = false;
                }

                if (incrementPos) {
                    currentPos++;
                }
            } // end while loop over chunk

            scrollToBottom();
        }; // end onmessage

        ws.onerror = (event) => {
             console.error("WebSocket error:", event);
             addErrorMessage("WebSocket connection error. Please try refreshing the page.");
             finalizeTurnOnErrorOrClose();
        };

        ws.onclose = (event) => {
             console.log(`[DEBUG] WebSocket connection closed: Code=${event.code}, Reason='${event.reason}', WasClean=${event.wasClean}`);
             addSystemMessage(`Connection closed. ${event.reason ? event.reason : ''} (Code: ${event.code}). Attempting to reconnect...`);
             finalizeTurnOnErrorOrClose();
             websocket = undefined;
             const reconnectDelay = Math.min(1000 * (2 ** Math.min(8, event.code === 1000 ? 0 : 1)), 30000);
             console.log(`[DEBUG] Attempting reconnect in ${reconnectDelay}ms`);
             setTimeout(connectWebSocket, reconnectDelay);
        };

        console.log("[DEBUG] WebSocket object created and handlers assigned.");

    } catch (error) {
        console.error("[DEBUG] Error creating WebSocket:", error);
        addErrorMessage(`Failed to initialize WebSocket connection: ${error.message}. Check browser console.`);
        finalizeTurnOnErrorOrClose();
    }
}

if (chatForm) {
    chatForm.addEventListener('submit', (event) => {
        event.preventDefault(); // Prevent default form submission

        const userMessage = messageInput.value.trim(); // Get user text

        if (!userMessage) {
            return; // Do nothing if message is empty
        }

        // --- Check WebSocket State BEFORE Attempting Send ---
        if (!websocket || websocket.readyState !== WebSocket.OPEN) {
            console.warn("[Submit] WebSocket not ready or not defined. State:", websocket?.readyState);
            addErrorMessage("Not connected to the server. Please wait or refresh.");
            return; // Exit if not connected
        }

        // --- If WebSocket is OPEN, proceed ---
        try {
            // --- Step 1: Display User Message ---
            addUserMessage(userMessage); // Show user's raw message immediately

            // --- Step 2: Determine Thinking State & Prepare Message for Backend ---
            thinkingRequestedForCurrentTurn = thinkCheckbox ? thinkCheckbox.checked : false;
            console.log(`[Submit] Checkbox checked: ${thinkingRequestedForCurrentTurn}.`);

            let messageToSend = userMessage; // Default to the raw user message
            // Ensure NO_THINK_PREFIX is defined globally, e.g., const NO_THINK_PREFIX = "\\no_think";
            if (!thinkingRequestedForCurrentTurn) {
                messageToSend = NO_THINK_PREFIX + userMessage;
                console.log(`[Submit] Prepended '${NO_THINK_PREFIX}'. Prepared message: "${messageToSend.substring(0, 100)}..."`);
            } else {
                console.log(`[Submit] Prepared raw message (thinking requested): "${messageToSend.substring(0, 100)}..."`);
            }

            // --- Step 3: Setup UI for AI Response ---
            setupNewAiTurn(); // Uses thinkingRequestedForCurrentTurn for initial visibility

            // --- Step 4: Attempt to Send Message to WebSocket ---
            console.log(`[Submit] >>> About to call websocket.send(). State: ${websocket?.readyState}`); // Log state right before send

            websocket.send(messageToSend); // *** THE ACTUAL SEND CALL ***

            console.log("[Submit] <<< websocket.send() call completed (no immediate error thrown)."); // Log right after send

            // --- Step 5: Clear Input & Disable ---
            messageInput.value = '';          // Clear the input field
            setInputDisabledState(true); // Disable inputs while waiting for response
            console.log("[Submit] Input cleared and disabled.");

        } catch (sendError) {
            // --- Catch Errors During Send or Subsequent Steps ---
            console.error("[Submit] !!! ERROR during send attempt or post-send steps:", sendError);
            addErrorMessage(`Failed to send message: ${sendError.message}`);
            // Optionally re-enable input if send fails? Or leave disabled?
            // setInputDisabledState(false);
        }

    }); // End of submit handler
} else {
    // Handle case where the form element itself is missing
    console.error("CRITICAL ERROR: Could not find chat form element with ID 'chat-form'. Messages cannot be sent.");
    if (typeof addErrorMessage === 'function') {
        addErrorMessage("Initialization Error: Chat input form not found.");
    } else {
        alert("Initialization Error: Chat input form not found.");
    }
}

// --- Initial Setup ---
setInputDisabledState(true); // Disable inputs until connected
connectWebSocket(); // Start connection (will add initial AI message and enable inputs onopen)

=== temp.py ===
import os
import asyncio
import sys
import uvicorn
import webbrowser
import tempfile
import shutil
import json # Added for WebSocket message parsing/sending
import traceback # For detailed error logging
from pathlib import Path
from dotenv import load_dotenv
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Request, HTTPException
from fastapi.responses import HTMLResponse # JSONResponse no longer needed for run_code
from fastapi.staticfiles import StaticFiles
from fastapi.websockets import WebSocketState # Import WebSocketState
from pydantic import BaseModel # Keep for potential future HTTP models
import docker # Docker SDK
from docker.errors import DockerException, ImageNotFound, APIError, NotFound # Docker specific errors
from docker.models.containers import Container # For type hinting
from langchain_ollama.llms import OllamaLLM
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.output_parsers import StrOutputParser
from langchain.memory import ConversationBufferMemory
from langchain_core.runnables import RunnablePassthrough # RunnableLambda no longer needed here
from langchain_core.messages import HumanMessage, AIMessage

# --- Configuration ---
load_dotenv()
MODEL_ID = os.getenv("MODEL_ID", "qwen3")
OLLAMA_BASE_URL = os.getenv("OLLAMA_BASE_URL", "http://localhost:11434")
# NO_THINK_PREFIX is handled by frontend, backend receives prefixed message
NO_THINK_PREFIX = "\\no_think"

# --- Docker Configuration ---
SUPPORTED_LANGUAGES = {
    "python": {
        "image": "python:3.11-slim",
        "filename": "script.py",
        "command": ["python", "-u", "/app/script.py"] # Added -u for unbuffered output
    },
    "javascript": {
        "image": "node:18-alpine",
        "filename": "script.js",
        "command": ["node", "/app/script.js"]
    },
    # Add more languages here if needed
}
DOCKER_TIMEOUT_SECONDS = 30 # Increased timeout for potentially longer runs
DOCKER_MEM_LIMIT = "128m"

# --- FastAPI App Initialization ---
# Ensure the app object is created correctly
app = FastAPI(title="Ollama Web Chat")

# --- Docker Client Initialization ---
docker_client = None
try:
    docker_client = docker.from_env()
    docker_client.ping()
    print("Successfully connected to Docker daemon.")
except DockerException as e:
    print(f"CRITICAL WARNING: Could not connect to Docker daemon: {e}")
    print("Code execution via Docker will be unavailable.")
    docker_client = None

# --- Static Files Setup ---
# Determine the static files directory relative to this script's location
# This assumes main.py is either in the project root or inside an 'app' directory.
script_location = Path(__file__).parent
static_dir_in_app = script_location / "static"
static_dir_at_root = script_location.parent / "static" # If main.py is in 'app' dir

if static_dir_in_app.is_dir():
    static_dir = static_dir_in_app
    print(f"Found static directory at: {static_dir}")
elif script_location.name == "app" and static_dir_at_root.is_dir():
     # If script is in 'app' and 'static' is sibling to 'app'
     static_dir = static_dir_at_root
     print(f"Found static directory at: {static_dir}")
else:
    # Fallback check if script is in root and static is in root
    if (script_location.parent / "static").is_dir():
         static_dir = script_location.parent / "static"
         print(f"Found static directory at: {static_dir}")
    else:
        print(f"CRITICAL ERROR: Static directory not found near '{script_location}'. Looked for '{static_dir_in_app}' and '{static_dir_at_root}'. Exiting.")
        sys.exit(1)

# Mount static files - THIS MUST BE CORRECT FOR CSS/JS
app.mount("/static", StaticFiles(directory=str(static_dir)), name="static")
print(f"Mounted static directory '{static_dir}' at '/static'")


# --- LangChain Setup ---
try:
    model = OllamaLLM(model=MODEL_ID, base_url=OLLAMA_BASE_URL)
    print(f"Successfully initialized OllamaLLM: {MODEL_ID} at {OLLAMA_BASE_URL}")
except Exception as e:
    print(f"CRITICAL ERROR: OllamaLLM init failed: {e}"); sys.exit(1)

# --- Global State for WebSocket Connections and Running Containers ---
client_memory = {}
# Stores info about currently running code executions
# Format: { "code_block_id": {"container": Container, "stream_task": asyncio.Task, "client_id": str, "websocket": WebSocket, "stop_event": asyncio.Event} }
running_containers = {}
running_containers_lock = asyncio.Lock() # Lock for safe concurrent access

# --- Memory Management Functions (Unchanged) ---
def get_memory_for_client(client_id: str) -> ConversationBufferMemory:
    """Retrieves or creates memory for a specific client."""
    if client_id not in client_memory:
        client_memory[client_id] = ConversationBufferMemory(return_messages=True, memory_key="history")
        print(f"Initialized new memory for client: {client_id}")
    return client_memory[client_id]

def remove_memory_for_client(client_id: str):
    """Removes memory when a client disconnects."""
    if client_id in client_memory:
        del client_memory[client_id]
        print(f"Removed memory for client: {client_id}")

# --- LangChain Prompt and Chain Setup (Unchanged) ---
prompt = ChatPromptTemplate.from_messages([
    ("system", "You are a helpful AI assistant chatting in a web interface. Answer the user's questions concisely. Always use katex for math ($...$ or $$...$$). For a literal dollar sign use \\$. When providing code, use standard markdown code blocks (e.g., ```python ... ```)."),
    MessagesPlaceholder(variable_name="history"),
    ("human", "{input}")
])
output_parser = StrOutputParser()

# --- Helper Functions for WebSocket Code Execution (Unchanged from previous version) ---

async def send_ws_message(websocket: WebSocket, message_type: str, payload: dict):
    """Safely sends a JSON message over the WebSocket."""
    # Check state before sending
    if websocket.client_state != WebSocketState.CONNECTED:
         print(f"WebSocket not connected, cannot send {message_type} for {payload.get('code_block_id', 'N/A')}")
         return
    try:
        await websocket.send_json({"type": message_type, "payload": payload})
    except WebSocketDisconnect:
        print(f"WebSocket disconnected while trying to send {message_type} for {payload.get('code_block_id', 'N/A')}")
    except Exception as e:
        # Catch other potential errors like Runtime Error if connection closed during send
        print(f"Error sending WebSocket message ({message_type}) for {payload.get('code_block_id', 'N/A')}: {e}")
        # traceback.print_exc() # Optional: uncomment for more detail

# This function runs in a separate thread via run_in_executor
def sync_log_streamer(container: Container, websocket: WebSocket, code_block_id: str, loop: asyncio.AbstractEventLoop, stop_event: asyncio.Event):
    """
    Synchronously iterates through Docker logs and schedules sending messages
    back to the main asyncio loop. Runs in an executor thread.
    """
    try:
        # Note: follow=True keeps the stream open until container stops or stream is closed.
        log_stream = container.logs(stream=True, follow=True, stdout=True, stderr=True)
        print(f"[Thread-{code_block_id}] Starting log iteration for container {container.short_id}")

        for line_bytes in log_stream:
            if stop_event.is_set():
                print(f"[Thread-{code_block_id}] Stop event set, breaking log iteration.")
                break

            line_str = line_bytes.decode('utf-8', errors='replace')
            # Schedule the send_ws_message coroutine to run on the main event loop
            asyncio.run_coroutine_threadsafe(
                send_ws_message(websocket, "code_output", {
                    "code_block_id": code_block_id,
                    "stream": "stdout", # Sending all as stdout for simplicity, could try parsing later
                    "data": line_str
                }),
                loop # Pass the main event loop
            )

        print(f"[Thread-{code_block_id}] Finished log iteration for container {container.short_id}")

    except Exception as e:
        # Log error from the thread
        print(f"[Thread-{code_block_id}] Error during log streaming: {e}")
        # Don't print traceback here usually, as it might be expected on stop
        # traceback.print_exc()
        # Try to send an error message back to the client via the main loop
        asyncio.run_coroutine_threadsafe(
            send_ws_message(websocket, "code_output", {
                "code_block_id": code_block_id,
                "stream": "error",
                "data": f"\n[Error streaming logs from container: {str(e)}]"
            }),
            loop
        )

async def stream_docker_logs_via_executor(websocket: WebSocket, container: Container, code_block_id: str, stop_event: asyncio.Event):
    """
    Runs the synchronous log streamer function in an executor thread.
    """
    loop = asyncio.get_running_loop()
    print(f"Scheduling log streaming task in executor for {code_block_id}")
    # Run the sync function in the default executor
    await loop.run_in_executor(
        None, # Use default thread pool executor
        sync_log_streamer, # The function to run
        container, websocket, code_block_id, loop, stop_event # Arguments for the function
    )
    print(f"Executor task for log streaming finished for {code_block_id}")


async def run_code_in_docker_stream(websocket: WebSocket, client_id: str, code_block_id: str, language: str, code: str):
    """Runs code in Docker, streams output via WebSocket, and manages container lifecycle."""
    global docker_client, running_containers, running_containers_lock

    if not docker_client:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": "Docker service is unavailable on the server."
        })
        return

    lang_key = language.lower()
    lang_config = SUPPORTED_LANGUAGES.get(lang_key)
    if not lang_config:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": f"Language '{language}' not supported for execution."
        })
        return

    image_name = lang_config["image"]
    script_filename = lang_config["filename"]
    command = lang_config["command"]
    container_obj: Container | None = None
    stream_task: asyncio.Task | None = None
    tmpdir_obj = None # To hold the TemporaryDirectory object
    stop_event = asyncio.Event() # Event to signal cancellation to the streamer thread

    try:
        # Create temporary directory safely
        tmpdir_obj = tempfile.TemporaryDirectory()
        tmpdir = tmpdir_obj.name # Get the path string
        host_script_path = Path(tmpdir) / script_filename
        with open(host_script_path, "w", encoding="utf-8") as f:
            f.write(code)

        print(f"Attempting to run block {code_block_id} ({lang_key}) in Docker image {image_name}...")

        # Run the container detached
        container_obj = docker_client.containers.run(
            image=image_name,
            command=command,
            volumes={tmpdir: {'bind': '/app', 'mode': 'ro'}}, # Read-only mount
            working_dir='/app',
            mem_limit=DOCKER_MEM_LIMIT,
            stdout=True,
            stderr=True,
            detach=True, # Run in background
            # auto_remove=True, # Cannot auto-remove if we need to wait/get logs/stop
        )
        print(f"Container {container_obj.short_id} started for {code_block_id}")

        # Start the log streaming task using the executor helper
        stream_task = asyncio.create_task(
            stream_docker_logs_via_executor(websocket, container_obj, code_block_id, stop_event),
            name=f"log_stream_{code_block_id}" # Give the task a name for debugging
        )

        # Store container and task info BEFORE waiting
        async with running_containers_lock:
            if code_block_id in running_containers:
                 # This should ideally not happen if frontend disables button, but handle defensively
                 print(f"WARNING: Code block {code_block_id} was already running. Stopping previous run.")
                 # Call stop without await here, as we are inside the lock
                 # stop_docker_container needs to acquire the lock itself, so we schedule it
                 asyncio.create_task(stop_docker_container(code_block_id))


            running_containers[code_block_id] = {
                "container": container_obj,
                "stream_task": stream_task,
                "client_id": client_id,
                "websocket": websocket,
                "stop_event": stop_event # Store the stop event
            }

        # Wait for the container to finish execution or timeout
        print(f"Waiting for container {container_obj.short_id} ({code_block_id}) to finish...")
        loop = asyncio.get_running_loop()
        result = await loop.run_in_executor(
            None, # Use default executor
            lambda: container_obj.wait(timeout=DOCKER_TIMEOUT_SECONDS)
        )
        exit_code = result.get("StatusCode", -1)
        error_msg = result.get("Error", None)
        print(f"Container {container_obj.short_id} ({code_block_id}) finished. Result: {result}")

        # Ensure log streaming task is complete (it should be if container exited naturally)
        # Set stop event first to signal the thread, then wait/cancel task
        stop_event.set()
        try:
            # Wait briefly for the executor task to finish processing final logs
            await asyncio.wait_for(stream_task, timeout=5.0)
        except asyncio.TimeoutError:
            print(f"Warning: Log streaming task for {code_block_id} did not finish quickly after container exit.")
            # If it timed out, ensure it's cancelled (though setting stop_event should handle it)
            if not stream_task.done():
                stream_task.cancel()
        except asyncio.CancelledError:
             print(f"Log streaming task for {code_block_id} was cancelled (likely during stop).")
             pass # Already handled

        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id,
            "exit_code": exit_code,
            "error": error_msg # Send Docker-level error if any
        })

    except asyncio.TimeoutError: # Timeout from container_obj.wait()
        print(f"ERROR: Docker execution timed out for block {code_block_id} after {DOCKER_TIMEOUT_SECONDS}s.")
        await send_ws_message(websocket, "code_finished", {
             "code_block_id": code_block_id, "exit_code": -1,
             "error": f"Execution timed out after {DOCKER_TIMEOUT_SECONDS} seconds."
        })
        # Attempt to stop the timed-out container (this will also cancel the stream task via stop_docker_container)
        # Schedule stop_docker_container as it needs to acquire the lock
        asyncio.create_task(stop_docker_container(code_block_id))


    except ImageNotFound:
        error_msg = f"Server Error: Docker image '{image_name}' not found. Please pull it."
        print(f"ERROR for block {code_block_id}: {error_msg}")
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except APIError as e:
        error_msg = f"Server Error: Docker API error: {e}"
        print(f"ERROR for block {code_block_id}: {error_msg}")
        traceback.print_exc()
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except Exception as e:
        error_msg = f"Server Execution Error: {str(e)}"
        print(f"ERROR during Docker execution setup or wait for block {code_block_id}: {e}")
        traceback.print_exc()
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
        # Ensure stream task is cancelled if it was started
        if stream_task and not stream_task.done():
            print(f"Cancelling stream task for {code_block_id} due to setup/wait error.")
            stop_event.set() # Signal thread to stop
            stream_task.cancel()

    finally:
        # --- Final Cleanup ---
        # Remove from tracking dict if it hasn't been removed by stop_docker_container already
        async with running_containers_lock:
            if code_block_id in running_containers:
                print(f"Performing final cleanup check for {code_block_id}")
                task_to_cancel = running_containers[code_block_id]["stream_task"]
                stop_ev = running_containers[code_block_id]["stop_event"]
                if task_to_cancel and not task_to_cancel.done():
                     print(f"Final cleanup: Cancelling stream task for {code_block_id}")
                     stop_ev.set() # Signal thread
                     task_to_cancel.cancel()
                # Remove from tracking dict
                del running_containers[code_block_id]
                print(f"Removed {code_block_id} from running_containers during final cleanup")

        # Remove container if it exists and hasn't been removed by stop
        if container_obj:
            try:
                # Check if container still exists before removing
                await asyncio.get_running_loop().run_in_executor(None, container_obj.reload)
                print(f"Removing container {container_obj.short_id} ({code_block_id}) in final cleanup")
                # Need to run blocking remove in executor
                await asyncio.get_running_loop().run_in_executor(None, lambda: container_obj.remove(force=True))
            except NotFound:
                 print(f"Container {container_obj.short_id} already removed.")
                 pass # Already removed
            except Exception as rm_err:
                print(f"Error removing container {container_obj.short_id} in final cleanup: {rm_err}")

        # Clean up temporary directory
        if tmpdir_obj:
             try:
                  tmpdir_obj.cleanup()
             except Exception as cleanup_err:
                  print(f"Error cleaning up temp directory {tmpdir}: {cleanup_err}")


async def stop_docker_container(code_block_id: str):
    """Stops a running Docker container and cancels its log stream task."""
    global running_containers, running_containers_lock
    print(f"Attempting to stop execution for code block: {code_block_id}")
    loop = asyncio.get_running_loop()
    container_info = None
    container_obj = None
    stream_task = None
    websocket = None
    stop_event = None

    async with running_containers_lock:
        if code_block_id in running_containers:
            # Pop the entry to prevent others from trying to stop it simultaneously
            container_info = running_containers.pop(code_block_id)
            container_obj = container_info["container"]
            stream_task = container_info["stream_task"]
            websocket = container_info["websocket"] # Get websocket for final message
            stop_event = container_info["stop_event"]
            print(f"Found and removed running container {container_obj.short_id} for {code_block_id} from tracking.")
        else:
            print(f"Stop request for {code_block_id}, but it was not found in running_containers.")
            return # Nothing to stop

    # Perform actions outside the lock

    # 1. Signal the streaming thread to stop and cancel the task
    if stop_event:
        print(f"Setting stop event for {code_block_id}")
        stop_event.set()
    if stream_task and not stream_task.done():
        print(f"Cancelling stream task for {code_block_id}")
        stream_task.cancel()
        try:
            # Wait briefly for cancellation to be processed by the task
            await asyncio.wait_for(stream_task, timeout=1.0)
        except asyncio.TimeoutError:
            print(f"Stream task for {code_block_id} did not cancel quickly.")
        except asyncio.CancelledError:
            print(f"Stream task for {code_block_id} cancelled successfully.")
            pass # Expected

    # 2. Stop the container
    if container_obj:
        try:
            print(f"Stopping container {container_obj.short_id} ({code_block_id})...")
            # Stop needs to run in executor
            await loop.run_in_executor(None, lambda: container_obj.stop(timeout=5))
            print(f"Container {container_obj.short_id} stopped.")
        except Exception as stop_err:
            print(f"Error stopping container {container_obj.short_id}, attempting kill: {stop_err}")
            try:
                # Kill needs to run in executor
                await loop.run_in_executor(None, container_obj.kill)
                print(f"Container {container_obj.short_id} killed.")
            except Exception as kill_err:
                # Ignore kill error if container is already gone
                if "No such container" not in str(kill_err):
                     print(f"Error killing container {container_obj.short_id}: {kill_err}")

        # 3. Remove the container
        try:
            print(f"Removing container {container_obj.short_id} ({code_block_id}) after stop request.")
            # Remove needs to run in executor
            await loop.run_in_executor(None, lambda: container_obj.remove(force=True))
        except NotFound:
             pass # Already removed
        except Exception as rm_err:
            print(f"Error removing container {container_obj.short_id} after stop: {rm_err}")

    # 4. Send final message to client if websocket is still valid
    if websocket and websocket.client_state == WebSocketState.CONNECTED:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id,
            "exit_code": -1, # Indicate abnormal termination
            "error": "Execution stopped by user."
        })
    else:
         print(f"Cannot send stop confirmation for {code_block_id}, WebSocket reference lost or disconnected.")


async def cleanup_client_containers(client_id: str):
    """Stops and cleans up all running containers associated with a client ID."""
    global running_containers, running_containers_lock
    print(f"Cleaning up containers for disconnected client: {client_id}")
    containers_to_stop = []
    # Create a separate list to avoid modifying dict while iterating
    async with running_containers_lock:
         # Find code_block_ids associated with the client
         ids_for_client = [cb_id for cb_id, info in running_containers.items() if info["client_id"] == client_id]
         containers_to_stop.extend(ids_for_client)

    # Stop each container outside the lock to avoid holding it too long
    if containers_to_stop:
         print(f"Found containers to stop for client {client_id}: {containers_to_stop}")
         # Use asyncio.gather to stop them concurrently
         # Note: stop_docker_container already removes the entry from running_containers
         stop_tasks = [stop_docker_container(cb_id) for cb_id in containers_to_stop]
         results = await asyncio.gather(*stop_tasks, return_exceptions=True) # Log exceptions if any stop fails
         for i, result in enumerate(results):
              if isinstance(result, Exception):
                   print(f"Error during cleanup stop for {containers_to_stop[i]}: {result}")
         print(f"Finished cleanup for client {client_id}")
    else:
         print(f"No running containers found for client {client_id} during cleanup.")

# --- FastAPI Routes ---

# Root route to serve the main HTML page
@app.get("/", response_class=HTMLResponse)
async def get_chat_page(request: Request):
    """Serves the main chat HTML page."""
    html_file_path = static_dir / "index.html"
    if not html_file_path.is_file():
         print(f"ERROR: index.html not found at expected location: {html_file_path}")
         raise HTTPException(status_code=404, detail="index.html not found")
    try:
        with open(html_file_path, "r", encoding="utf-8") as f:
            html_content = f.read()
        return HTMLResponse(content=html_content)
    except Exception as e:
        print(f"ERROR reading index.html: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error reading index.html: {e}")


# --- WebSocket Endpoint ---
@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: str):
    """Handles WebSocket connections for chat and code execution."""
    await websocket.accept()
    print(f"WebSocket connection accepted for client: {client_id}")
    memory = get_memory_for_client(client_id)

    # Function to load history using this client's memory (Unchanged)
    def load_memory_for_current_client(_):
        loaded_vars = memory.load_memory_variables({})
        return loaded_vars.get("history", [])

    # Simple chain using the fixed global 'prompt' (Unchanged)
    chain = (
        RunnablePassthrough.assign(history=load_memory_for_current_client)
        | prompt
        | model
        | output_parser
    )
    print(f"LCEL Chain created for client: {client_id}")

    try:
        while True:
            # Check state before receiving
            if websocket.client_state != WebSocketState.CONNECTED:
                 print(f"WebSocket no longer connected for {client_id} before receive. Breaking loop.")
                 break

            received_data = await websocket.receive_text()

            # Check if it's a JSON command or regular chat input
            try:
                message_data = json.loads(received_data)
                message_type = message_data.get("type")
                payload = message_data.get("payload")

                if message_type and payload and isinstance(payload, dict):
                    # --- Handle JSON Commands ---
                    code_block_id = payload.get("code_block_id")
                    if not code_block_id:
                         print(f"Received JSON command without code_block_id: {message_data}")
                         continue

                    if message_type == "run_code":
                        language = payload.get("language")
                        code = payload.get("code")
                        if language and code is not None:
                             print(f"Received 'run_code' request for block {code_block_id} ({language}) from {client_id}")
                             # Start execution in background task
                             asyncio.create_task(
                                 run_code_in_docker_stream(websocket, client_id, code_block_id, language, code)
                             )
                        else:
                             print(f"Invalid 'run_code' payload received: {payload}")
                             await send_ws_message(websocket, "code_finished", {
                                  "code_block_id": code_block_id, "exit_code": -1,
                                  "error": "Invalid run_code request payload from client."
                             })

                    elif message_type == "stop_code":
                        print(f"Received 'stop_code' request for block {code_block_id} from {client_id}")
                        # Stop execution in background task
                        asyncio.create_task(
                             stop_docker_container(code_block_id)
                        )

                    else:
                        print(f"Received unknown JSON command type '{message_type}' from {client_id}")

                else:
                     # Treat as chat if JSON structure is invalid
                     print(f"Received invalid JSON structure from {client_id}, treating as chat: {received_data[:100]}...")
                     await handle_chat_message(chain, memory, websocket, client_id, received_data)

            except json.JSONDecodeError:
                # --- Handle Regular Chat Message ---
                # print(f"Handling text message from {client_id}: '{received_data[:50]}...'")
                await handle_chat_message(chain, memory, websocket, client_id, received_data)

    except WebSocketDisconnect:
        print(f"WebSocket disconnected during receive/process for client: {client_id}")
    except Exception as e:
        print(f"Unknown Error in WebSocket loop for client {client_id}: {e}")
        traceback.print_exc()
    finally:
        # --- Cleanup on Disconnect or Error ---
        print(f"Cleaning up resources for client: {client_id}")
        remove_memory_for_client(client_id)
        # Stop any running containers for this client
        await cleanup_client_containers(client_id)
        # Attempt to close websocket gracefully if it's not already closed
        if websocket.client_state == WebSocketState.CONNECTED:
            try:
                await websocket.close(code=1000) # Normal closure
                print(f"WebSocket closed gracefully for {client_id}")
            except Exception as close_exc:
                # Ignore errors if already closed or cannot close
                 print(f"Ignoring error during explicit WebSocket close for {client_id}: {close_exc}")
                 pass
        else:
             print(f"WebSocket already closed for {client_id} during cleanup.")


async def handle_chat_message(chain, memory, websocket: WebSocket, client_id: str, user_input: str):
     """Handles processing and streaming response for a regular chat message."""
     print(f"Handling chat message from {client_id}: '{user_input[:50]}...'")
     full_response = ""
     try:
         # Stream response using the chain
         async for chunk in chain.astream({"input": user_input}):
             # Check connection before sending each chunk
             if websocket.client_state != WebSocketState.CONNECTED:
                  print(f"WebSocket disconnected during chat stream for {client_id}. Aborting send.")
                  return # Stop sending if disconnected
             await websocket.send_text(chunk)
             full_response += chunk
     except Exception as chain_exc:
         error_msg = f"<ERROR>Error processing message: {chain_exc}"
         print(f"ERROR during chain execution for {client_id}: {chain_exc}")
         traceback.print_exc()
         # Try sending error message only if connected
         if websocket.client_state == WebSocketState.CONNECTED:
              await websocket.send_text(error_msg)
         # Don't save context if chain failed, but allow next message
         return

     # Send End Of Stream marker for chat message only if connected
     if websocket.client_state == WebSocketState.CONNECTED:
          await websocket.send_text("<EOS>")
          print(f"Finished streaming chat response to {client_id}")
          # Save context to memory
          # Note: user_input might contain the NO_THINK_PREFIX, which is fine for memory
          memory.save_context({"input": user_input}, {"output": full_response})
          print(f"Saved chat context to memory for client: {client_id}")
     else:
          print(f"WebSocket disconnected before sending <EOS> for {client_id}.")


# --- Function to run the server ---
def start_server():
    """Starts the Uvicorn server and opens the browser."""
    host = "127.0.0.1"
    port = 8001
    url = f"http://{host}:{port}"
    print(f"Starting server at {url}...")
    print(f"Using Ollama base URL: {OLLAMA_BASE_URL}")
    print(f"Using Model ID: {MODEL_ID}")
    print(f"Static files served from: {static_dir}")
    print(f"Supported execution languages: {list(SUPPORTED_LANGUAGES.keys())}")
    if not docker_client:
        print("WARNING: Docker client unavailable. Code execution will fail.")

    print(f"Attempting to open browser at {url}...")
    try:
        webbrowser.open(url)
    except Exception as browser_err:
        print(f"Warning: Could not automatically open browser: {browser_err}")
        print(f"Please navigate to {url} manually.")

    # --- Uvicorn Run ---
    # IMPORTANT: The target 'app.main:app' assumes this script (main.py)
    # is located inside a directory named 'app' relative to where you
    # run the uvicorn command OR that you run python like: python -m app.main
    # If main.py is at the project root, change the target to "main:app"
    uvicorn_target = "app.main:app"
    # Check if running directly (e.g., python main.py) vs module (python -m app.main)
    # A simple check: if the script's directory is named 'app'
    if Path(__file__).parent.name == "app":
         print(f"Running Uvicorn with target: '{uvicorn_target}' (assuming script is in 'app' directory)")
    else:
         # If not in 'app', assume it's at the root
         uvicorn_target = "main:app"
         print(f"Running Uvicorn with target: '{uvicorn_target}' (assuming script is at project root)")

    uvicorn.run(uvicorn_target, host=host, port=port, log_level="info", reload=True)

if __name__ == "__main__":
    # Add basic check for Docker client availability at startup
    if docker_client is None:
         print("\n---")
         print("WARNING: Docker is not running or accessible.")
         print("Code execution features will be disabled.")
         print("Please start Docker and restart this application for code execution.")
         print("---\n")
    start_server()



=== write_project_content_to_file.py ===
import os
import sys

# --- Configuration ---

# Set the starting directory (e.g., "." for current directory)
root = "."

# Extensions to include
extensions = ('.py', '.html', '.css', '.js', '.json', '.md', '.txt', '.yaml', '.yml', '.toml')

# Directories to completely exclude (will not be walked)
exclude_dirs = (
    '.git',
    '__pycache__',
    '.pytest_cache',
    'node_modules',
    'build',
    'old2',
    'testing-bundles', # Exclude this directory name wherever it appears
    '.venv',           # Common virtual environment folder
    'venv',
    'env',
    '.env',
    'dist',
    "assets"
)

# Files to list in the tree but exclude their *content*
exclude_files = (
    'package-lock.json',
    'yarn.lock',
    'katex.min.css',
    'katex.min.js',
    'build.js',
    'docker_utils.js',
    'llm.py',
    'input.css'
    # Add other large or irrelevant files by name here
)

# Output file name
output_filename = "project_content.txt"

# --- Script Logic ---

try:
    root = os.path.abspath(root)
    print(f"Starting directory: {root}")
    print(f"Output file: {output_filename}")
    print(f"Excluding directories: {exclude_dirs}")
    print(f"Excluding content of files: {exclude_files}")

    # Use a set for faster lookups
    exclude_dirs_set = set(exclude_dirs)
    exclude_files_set = set(exclude_files)

    with open(output_filename, "w", encoding="utf-8", errors="replace") as outfile:
        # === Add Directory Structure ===
        outfile.write("=== Project Directory Structure ===\n")
        outfile.write(f"Root: {root}\n")
        outfile.write("Relevant files and folders (excluding specified patterns):\n\n")

        structure_lines = []
        processed_dirs_for_structure = set()

        for current_root, dirs, files in os.walk(root, topdown=True):
            # Filter directories *in place* to prevent walking into excluded ones
            # Also exclude hidden directories starting with '.' unless root is hidden
            original_dirs = list(dirs) # Keep original for path checking if needed
            dirs[:] = [d for d in dirs if d not in exclude_dirs_set and not (d.startswith('.') and d != '.')]

            rel_path_from_start = os.path.relpath(current_root, root)

            # --- Skip processing if current path is inside an excluded directory ---
            # Check if any component of the relative path is in the exclusion list
            # Normalize path separators for consistent checking
            norm_rel_path = os.path.normpath(rel_path_from_start).replace(os.sep, '/')
            path_components = set(comp for comp in norm_rel_path.split('/') if comp and comp != '.')

            if any(comp in exclude_dirs_set or (comp.startswith('.') and comp != '.') for comp in path_components):
                 continue # Skip this directory entirely if any parent was excluded

            level = norm_rel_path.count('/') if norm_rel_path != '.' else 0

            # Add directory entry
            if rel_path_from_start == '.':
                 structure_lines.append(".\n")
            else:
                 indent = '│   ' * (level - 1) + '├── ' if level > 0 else ''
                 dir_name = os.path.basename(current_root)
                 # Check if this specific dir name should be excluded (e.g., if it's at the root)
                 if dir_name not in exclude_dirs_set and not (dir_name.startswith('.') and dir_name != '.'):
                     structure_lines.append(f"{indent}{dir_name}/\n")
                     processed_dirs_for_structure.add(norm_rel_path)


            # Add file entries for this directory
            file_indent = '│   ' * level + '├── '
            files.sort()
            for file in files:
                if file.endswith(extensions) and not file.startswith('.'):
                     structure_lines.append(f"{file_indent}{file}\n")

        # Write collected structure lines
        for line in structure_lines:
             outfile.write(line)

        outfile.write("\n\n=== File Contents ===\n\n")

        # === Add File Contents ===
        for current_root, dirs, files in os.walk(root, topdown=True):
            # Apply the same directory filtering as in the first walk
            dirs[:] = [d for d in dirs if d not in exclude_dirs_set and not (d.startswith('.') and d != '.')]

            rel_path_from_start = os.path.relpath(current_root, root)

            # --- Skip processing if current path is inside an excluded/hidden directory ---
            norm_rel_path = os.path.normpath(rel_path_from_start).replace(os.sep, '/')
            path_components = set(comp for comp in norm_rel_path.split('/') if comp and comp != '.')
            if any(comp in exclude_dirs_set or (comp.startswith('.') and comp != '.') for comp in path_components):
                 continue # Skip files in this directory

            files.sort()
            for file in files:
                 # Exclude hidden files and check extensions
                 if file.endswith(extensions) and not file.startswith('.'):
                     file_path = os.path.join(current_root, file)
                     relative_path = os.path.relpath(file_path, root)
                     display_path = relative_path.replace(os.sep, '/')

                     outfile.write(f"=== {display_path} ===\n")

                     # Check if the file *content* should be excluded
                     if file in exclude_files_set:
                         outfile.write("--- CONTENT EXCLUDED (listed in exclude_files) ---\n")
                     else:
                         try:
                             # Try reading with utf-8 first
                             with open(file_path, "r", encoding="utf-8") as infile:
                                 outfile.write(infile.read())
                         except UnicodeDecodeError:
                             # Fallback for non-utf8 files
                             try:
                                 with open(file_path, "r", encoding="latin-1") as infile:
                                     outfile.write(infile.read())
                                 outfile.write("\n--- (Warning: Read using latin-1 encoding) ---\n")
                             except Exception as inner_e:
                                 outfile.write(f"--- Error reading file (fallback failed): {inner_e} ---\n")
                         except Exception as e:
                             # Handle other potential file reading errors
                             outfile.write(f"--- Error reading file: {e} ---\n")

                     outfile.write("\n\n") # Add separation between file contents

    print(f"Successfully generated project content file: {output_filename}")

except FileNotFoundError:
    print(f"Error: Starting directory not found: {root}", file=sys.stderr)
except IOError as e:
    print(f"Error writing to output file {output_filename}: {e}", file=sys.stderr)
except Exception as e:
    print(f"An unexpected error occurred: {e}", file=sys.stderr)

=== app/__init__.py ===


=== app/auth.py ===
# app/auth.py
import datetime
import sqlite3
import traceback
from fastapi import Request, Response, HTTPException, Depends
from fastapi.security import APIKeyCookie
from pydantic import BaseModel
from passlib.context import CryptContext # Import CryptContext
from starlette.status import HTTP_401_UNAUTHORIZED
from typing import Optional, Dict, Any

# Assuming database utilities are in the same directory
# We still need generate_secure_token for session tokens, but hash_value is removed for passwords
from .database import get_db_connection, generate_secure_token, hash_value as hash_session_token # Rename hash_value import

# --- Passlib Configuration ---
# Use bcrypt, the recommended default. Schemes lists hashing algorithms.
# deprecated="auto" will automatically upgrade hashes if needed in the future.
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
# --- End Passlib Configuration ---

# Configuration for the session cookie
SESSION_COOKIE_NAME = "tesseracs_chat_session_token"
SESSION_DURATION_DAYS = 7

# Dependency for getting the session token from the cookie
cookie_scheme = APIKeyCookie(name=SESSION_COOKIE_NAME, auto_error=False)

# Pydantic model for the token response (used by /token endpoint)
class Token(BaseModel):
    access_token: str
    token_type: str
    user_id: Optional[int] = None
    user_name: Optional[str] = None
    user_email: Optional[str] = None

# --- Password Hashing Utilities ---
def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifies a plain password against a stored hash using passlib."""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Hashes a plain password using passlib."""
    return pwd_context.hash(password)
# --- End Password Hashing Utilities ---


async def create_user_session(response: Response, user_id: int) -> str:
    """
    Creates a new session token in the database for the given user_id,
    and sets the raw token value in an HTTPOnly cookie on the response object.
    (Uses hash_session_token for the session token itself, not passlib)
    """
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        session_token_raw = generate_secure_token(32)
        # Use the specific hash function for session tokens (e.g., SHA256)
        session_token_hashed = hash_session_token(session_token_raw)
        now_utc = datetime.datetime.now(datetime.timezone.utc)
        expires_at = now_utc + datetime.timedelta(days=SESSION_DURATION_DAYS)
        cursor.execute(
            "INSERT INTO auth_tokens (user_id, token_hash, token_type, expires_at) VALUES (?, ?, ?, ?)",
            (user_id, session_token_hashed, "session", expires_at.isoformat())
        )
        conn.commit()
        print(f"AUTH: Session token stored in DB for user_id: {user_id}")
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        print(f"AUTH ERROR: Storing session token failed: {db_err}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Could not create session due to a database error.")
    except Exception as e:
        if conn: conn.rollback()
        print(f"AUTH ERROR: Unexpected error storing session token: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Unexpected server error during session creation.")
    finally:
        if conn: conn.close()

    response.set_cookie(
        key=SESSION_COOKIE_NAME,
        value=session_token_raw,
        httponly=True,
        secure=False, # TODO: Set to True in production (HTTPS)
        samesite="lax",
        max_age=int(datetime.timedelta(days=SESSION_DURATION_DAYS).total_seconds()),
        path="/",
        domain=None
    )
    print(f"AUTH: Session cookie '{SESSION_COOKIE_NAME}' set in response for user_id: {user_id}.")
    return session_token_raw


async def get_current_user(
    request: Request,
    session_token_raw: Optional[str] = Depends(cookie_scheme)
) -> Optional[Dict[str, Any]]:
    """
    FastAPI Dependency: Retrieves the current authenticated user based on the
    session token found in the request's cookie.
    (Uses hash_session_token for the session token itself, not passlib)
    """
    token_to_verify = session_token_raw
    if not token_to_verify:
        token_to_verify = request.cookies.get(SESSION_COOKIE_NAME)
    if not token_to_verify:
        return None

    # Use the specific hash function for session tokens
    session_token_hashed = hash_session_token(token_to_verify)
    conn = None
    user_dict = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        now_utc_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        cursor.execute(
            """
            SELECT u.id, u.name, u.email, u.is_active
            FROM users u JOIN auth_tokens at ON u.id = at.user_id
            WHERE at.token_hash = ? AND at.token_type = 'session'
              AND at.expires_at > ? AND at.used_at IS NULL
            """,
            (session_token_hashed, now_utc_iso)
        )
        user_row = cursor.fetchone()
        if user_row:
            user_dict = dict(user_row)
            if not user_dict["is_active"]:
                print(f"AUTH get_current_user: User {user_dict.get('email')} found but is INACTIVE.")
                user_dict = None
    except sqlite3.Error as db_err:
        print(f"AUTH ERROR: Database error during session token verification: {db_err}")
        traceback.print_exc()
        user_dict = None
    except Exception as e:
        print(f"AUTH ERROR: Unexpected error during session token verification: {e}")
        traceback.print_exc()
        user_dict = None
    finally:
        if conn: conn.close()
    return user_dict


async def get_current_active_user(
    user: Optional[Dict[str, Any]] = Depends(get_current_user)
) -> Optional[Dict[str, Any]]:
    """FastAPI Dependency: Gets the current active user."""
    return user


async def get_user_by_session_token(session_token_raw: str) -> Optional[Dict[str, Any]]:
    """
    Authenticates a user based purely on a raw session token string.
    (Uses hash_session_token for the session token itself, not passlib)
    """
    if not session_token_raw:
        return None

    # Use the specific hash function for session tokens
    session_token_hashed = hash_session_token(session_token_raw)
    conn = None
    user_dict = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        now_utc = datetime.datetime.now(datetime.timezone.utc)
        now_utc_iso = now_utc.isoformat()
        cursor.execute(
            """
            SELECT u.id, u.name, u.email, u.is_active
            FROM users u JOIN auth_tokens at ON u.id = at.user_id
            WHERE at.token_hash = ? AND at.token_type = 'session'
              AND at.expires_at > ? AND at.used_at IS NULL
            """,
            (session_token_hashed, now_utc_iso)
        )
        user_row = cursor.fetchone()
        if user_row:
            user_dict = dict(user_row)
            if not user_dict["is_active"]:
                user_dict = None
    except sqlite3.Error as db_err:
        print(f"AUTH ERROR (get_user_by_session_token): Database error: {db_err}")
        traceback.print_exc()
        user_dict = None
    except Exception as e:
        print(f"AUTH ERROR (get_user_by_session_token): Unexpected error: {e}")
        traceback.print_exc()
        user_dict = None
    finally:
        if conn: conn.close()
    return user_dict


async def logout_user(response: Response, session_token_raw: Optional[str]):
    """
    Logs out the user by invalidating the session token in the database
    (if provided) and clearing the session cookie from the browser.
    (Uses hash_session_token for the session token itself, not passlib)
    """
    if session_token_raw:
        # Use the specific hash function for session tokens
        session_token_hashed = hash_session_token(session_token_raw)
        conn = None
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            now_utc_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            cursor.execute(
                """
                UPDATE auth_tokens SET used_at = ?, expires_at = ?
                WHERE token_hash = ? AND token_type = 'session'
                """,
                (now_utc_iso, now_utc_iso, session_token_hashed)
            )
            conn.commit()
            print(f"AUTH: Session token invalidated in DB for hash {session_token_hashed[:10]}.")
        except sqlite3.Error as db_err:
            if conn: conn.rollback()
            print(f"AUTH ERROR: Failed to invalidate session token in DB: {db_err}")
            traceback.print_exc()
        except Exception as e:
             if conn: conn.rollback()
             print(f"AUTH ERROR: Unexpected error invalidating session token: {e}")
             traceback.print_exc()
        finally:
            if conn: conn.close()

    response.delete_cookie(
        SESSION_COOKIE_NAME,
        httponly=True,
        secure=False, # TODO: Set to True in production (HTTPS)
        samesite="lax",
        path="/"
    )
    print(f"AUTH: Session cookie '{SESSION_COOKIE_NAME}' cleared from browser.")


=== app/config.py ===
# app/config.py
import os
import sys
from pathlib import Path
from dotenv import load_dotenv

# Load environment variables from a .env file if it exists
load_dotenv()

# --- Application Base URL ---
# This is the primary public-facing URL for your application.
# Used for generating absolute URLs in emails, etc.
# Ensure this matches your production domain and includes the scheme (http or https).
# It can be overridden by setting a BASE_URL environment variable.
BASE_URL = os.getenv("BASE_URL", "http://tesseracs.com") # Default to http://tesseracs.com

# --- LLM Configuration ---
MODEL_ID = os.getenv("MODEL_ID", "qwen3:8B")
OLLAMA_BASE_URL = os.getenv("OLLAMA_BASE_URL", "http://localhost:11434") # This is for the Ollama service
NO_THINK_PREFIX = "\\no_think"
THINK_PREFIX = "\\think"

# --- Docker Configuration ---
SUPPORTED_LANGUAGES = {
    "python": {
        "image": "python:3.11-slim",
        "filename": "script.py",
        "command": ["python", "-u", "/app/script.py"]
    },
    "javascript": {
        "image": "node:18-alpine",
        "filename": "script.js",
        "command": ["node", "/app/script.js"]
    },
    "cpp": {
        "image": "gcc:latest",
        "filename": "script.cpp",
        "command": ["sh", "-c", "g++ /app/script.cpp -o /app/output_executable && /app/output_executable"]
    },
    "csharp": {
        "image": "mcr.microsoft.com/dotnet/sdk:latest",
        "filename": "Script.cs",
        "command": [
            "sh", "-c",
            "cd /app && dotnet new console --force -o . > /dev/null && cp Script.cs Program.cs && rm Script.cs && dotnet run"
        ]
    },
    "typescript": {
        "image": "node:18-alpine",
        "filename": "script.ts",
        "command": ["sh", "-c", "tsc --module commonjs /app/script.ts && node /app/script.js"]
    },
    "java": {
        "image": "openjdk:17-jdk-slim",
        "filename": "Main.java",
        "command": ["sh", "-c", "javac /app/Main.java && java -cp /app Main"]
    },
    "go": {
        "image": "golang:1.21-alpine",
        "filename": "script.go",
        "command": ["go", "run", "/app/script.go"]
    },
    "rust": {
        "image": "rust:1-slim",
        "filename": "main.rs",
        "command": ["sh", "-c", "cd /app && rustc main.rs -o main_executable && ./main_executable"]
    }
}
DOCKER_TIMEOUT_SECONDS = int(os.getenv("DOCKER_TIMEOUT_SECONDS", 30))
DOCKER_MEM_LIMIT = os.getenv("DOCKER_MEM_LIMIT", "128m")

# --- Static Files Configuration ---
APP_DIR = Path(__file__).parent
PROJECT_ROOT = APP_DIR.parent
STATIC_DIR_IN_APP = APP_DIR / "static"
STATIC_DIR_AT_ROOT_LEVEL = PROJECT_ROOT / "static"
STATIC_DIR = None
if STATIC_DIR_IN_APP.is_dir(): STATIC_DIR = STATIC_DIR_IN_APP
elif STATIC_DIR_AT_ROOT_LEVEL.is_dir(): STATIC_DIR = STATIC_DIR_AT_ROOT_LEVEL
else:
    print(f"CRITICAL ERROR: Static directory not found. Looked in '{STATIC_DIR_IN_APP}' and '{STATIC_DIR_AT_ROOT_LEVEL}'. Exiting.")
    sys.exit(1)

# --- Email Configuration ---
MAIL_CONFIG = {
    "MAIL_USERNAME": os.getenv("MAIL_USERNAME"),
    "MAIL_PASSWORD": os.getenv("MAIL_PASSWORD"),
    "MAIL_FROM": os.getenv("MAIL_FROM"),
    "MAIL_PORT": int(os.getenv("MAIL_PORT", 465)),
    "MAIL_SERVER": os.getenv("MAIL_SERVER"),
    "MAIL_FROM_NAME": os.getenv("MAIL_FROM_NAME", "Tesseracs Chat"),
    "MAIL_STARTTLS": os.getenv("MAIL_STARTTLS", 'False').lower() in ('true', '1', 't'),
    "MAIL_SSL_TLS": os.getenv("MAIL_SSL_TLS", 'True').lower() in ('true', '1', 't'),
    "USE_CREDENTIALS": True,
    "VALIDATE_CERTS": os.getenv("MAIL_VALIDATE_CERTS", 'True').lower() in ('true', '1', 't')
}

if not all([MAIL_CONFIG["MAIL_USERNAME"], MAIL_CONFIG["MAIL_PASSWORD"], MAIL_CONFIG["MAIL_SERVER"]]):
    print("WARNING: Essential email configuration missing in .env file.")

print(f"DEBUG config: Email certificate validation (VALIDATE_CERTS) is set to: {MAIL_CONFIG['VALIDATE_CERTS']}")
print(f"DEBUG config: Application BASE_URL is set to: {BASE_URL}") # Added log for BASE_URL


# --- Rate Limiting Configuration ---
FORGOT_PASSWORD_ATTEMPT_LIMIT = int(os.getenv("FORGOT_PASSWORD_ATTEMPT_LIMIT", 3))
FORGOT_PASSWORD_ATTEMPT_WINDOW_HOURS = int(os.getenv("FORGOT_PASSWORD_ATTEMPT_WINDOW_HOURS", 24))


=== app/database.py ===
# app/database.py
import sqlite3
import os
from pathlib import Path
import hashlib # For password hashing (even if magic links are primary)
import secrets # For generating secure tokens
import datetime # For timestamps

# Determine the project root directory based on the location of this file
# Assuming this file is app/database.py
APP_DIR = Path(__file__).parent
PROJECT_ROOT = APP_DIR.parent
DATABASE_NAME = "tesseracs_chat.db"
DATABASE_PATH = PROJECT_ROOT / DATABASE_NAME

def get_db_connection():
    """Establishes a connection to the SQLite database."""
    # print(f"Attempting to connect to database at: {DATABASE_PATH}")
    conn = sqlite3.connect(DATABASE_PATH)
    conn.row_factory = sqlite3.Row # Access columns by name
    return conn

def init_db():
    """Initializes the database schema if it doesn't exist."""
    print(f"Initializing database schema at {DATABASE_PATH}...")
    conn = get_db_connection()
    cursor = conn.cursor()

    # Users Table
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        email TEXT UNIQUE NOT NULL,
        password_hash TEXT, 
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        is_active BOOLEAN DEFAULT TRUE NOT NULL 
    );
    """)
    print("Ensured 'users' table exists.")

    # Auth Tokens Table
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS auth_tokens (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        token_hash TEXT UNIQUE NOT NULL, 
        token_type TEXT NOT NULL CHECK(token_type IN ('magic_login', 'session', 'password_reset')),
        expires_at TIMESTAMP NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        used_at TIMESTAMP, 
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
    );
    """)
    print("Ensured 'auth_tokens' table exists.")

    # Sessions Table
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS sessions (
        id TEXT PRIMARY KEY, 
        host_user_id INTEGER NOT NULL, 
        name TEXT, 
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        last_accessed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        is_active BOOLEAN DEFAULT TRUE NOT NULL, 
        FOREIGN KEY (host_user_id) REFERENCES users (id) ON DELETE CASCADE
    );
    """)
    print("Ensured 'sessions' table exists.")

    # Session Participants Table
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS session_participants (
        session_id TEXT NOT NULL,
        user_id INTEGER NOT NULL,
        joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (session_id, user_id), 
        FOREIGN KEY (session_id) REFERENCES sessions (id) ON DELETE CASCADE,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
    );
    """)
    print("Ensured 'session_participants' table exists.")

    # Chat Messages Table
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS chat_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id TEXT NOT NULL,         
        user_id INTEGER,               
        sender_name TEXT,               
        sender_type TEXT NOT NULL CHECK(sender_type IN ('user', 'ai', 'system', 'anon_user')), 
        content TEXT NOT NULL,           
        client_id_temp TEXT,           
        turn_id INTEGER,             
        thinking_content TEXT,         
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (session_id) REFERENCES sessions (id) ON DELETE CASCADE,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE SET NULL 
    );
    """)
    print("Ensured 'chat_messages' table exists.")

    # Session Memory State Table
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS session_memory_state (
        session_id TEXT PRIMARY KEY,         -- Links directly to the session
        memory_state_json TEXT NOT NULL,     -- Stores the serialized memory state (e.g., as JSON)
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- When the memory was last saved
        FOREIGN KEY (session_id) REFERENCES sessions (id) ON DELETE CASCADE
    );
    """)
    print("Ensured 'session_memory_state' table exists.")

    # --- ADDED TABLE for Password Reset Attempts ---
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS password_reset_attempts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        email TEXT NOT NULL,                            -- The email for which the reset was attempted.
        ip_address TEXT,                                -- Optional: IP address of the requester.
        attempted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP -- Timestamp of the attempt.
    );
    """)
    print("Ensured 'password_reset_attempts' table exists.")
    # --- END OF ADDED TABLE ---

    # Add indexes for frequently queried columns for performance
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_users_email ON users (email);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_auth_tokens_token_hash ON auth_tokens (token_hash);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_auth_tokens_user_id ON auth_tokens (user_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_sessions_host_user_id ON sessions (host_user_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_session_participants_session_id ON session_participants (session_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_session_participants_user_id ON session_participants (user_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_chat_messages_session_id ON chat_messages (session_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_session_memory_state_session_id ON session_memory_state (session_id);")
    
    # --- ADDED INDEX for Password Reset Attempts ---
    # Index on email and timestamp for efficient querying of recent attempts.
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_password_reset_attempts_email_time ON password_reset_attempts (email, attempted_at);")
    print("Ensured 'idx_password_reset_attempts_email_time' index exists.")
    # --- END OF ADDED INDEX ---

    print("Ensured all indexes exist.")

    conn.commit()
    conn.close()
    print("Database initialization process complete.")

def hash_value(value: str) -> str:
    """Hashes a string value (e.g., password or token) using SHA256."""
    return hashlib.sha256(value.encode('utf-8')).hexdigest()

def generate_secure_token(length: int = 32) -> str:
    """Generates a cryptographically secure URL-safe token."""
    return secrets.token_urlsafe(length)

# You can run this file directly to initialize the database:
# python -m app.database
if __name__ == "__main__":
    print(f"Running database script directly. CWD: {Path.cwd()}")
    print(f"Project Root should be: {PROJECT_ROOT}")
    print(f"Database will be created/checked at: {DATABASE_PATH}")
    # Ensure the parent directory for the database exists
    DATABASE_PATH.parent.mkdir(parents=True, exist_ok=True)
    init_db()


=== app/docker_utils.py ===
# app/docker_utils.py

import asyncio
import tempfile
import shutil
import traceback
from pathlib import Path
import docker # Docker SDK for Python
from docker.errors import DockerException, ImageNotFound, APIError, NotFound # Docker specific errors
from docker.models.containers import Container # For type hinting container objects
from fastapi import WebSocket # For type hinting WebSockets

# Relative imports for modules within the 'app' package
from . import config
from . import state
from .utils import send_ws_message # Utility function for sending WebSocket messages

# --- Docker Client Initialization ---
# Attempt to initialize the Docker client from the environment settings.
# This typically connects to the Docker daemon running locally.
docker_client = None
try:
    # Get Docker client from environment variables (DOCKER_HOST, etc.)
    docker_client = docker.from_env()
    # Ping the Docker daemon to ensure connectivity
    docker_client.ping()
    print("Successfully connected to Docker daemon.")
except DockerException as e:
    # Handle exceptions if the Docker daemon is not reachable
    print(f"CRITICAL WARNING: Could not connect to Docker daemon: {e}")
    print("Code execution via Docker will be unavailable.")
    docker_client = None # Ensure client is None if connection failed

def get_docker_client():
    """
    Returns the initialized Docker client instance.
    Returns None if the client failed to initialize.
    """
    return docker_client

# --- Log Streaming Logic (Designed to Run in Executor Thread) ---

def sync_log_streamer(container: Container, websocket: WebSocket, code_block_id: str, loop: asyncio.AbstractEventLoop, stop_event: asyncio.Event):
    """
    Synchronously iterates through Docker container logs and schedules sending
    log lines back to the main asyncio event loop via WebSocket.
    This function is blocking and intended to be run in a separate thread using run_in_executor.

    Args:
        container: The Docker container object to stream logs from.
        websocket: The WebSocket connection to send log messages to.
        code_block_id: Identifier for the code block being executed.
        loop: The main asyncio event loop to schedule coroutines on.
        stop_event: An asyncio.Event used to signal when to stop streaming.
    """
    try:
        # Get a blocking generator for log lines (stdout and stderr)
        # follow=True keeps the stream open until the container stops or stop_event is set.
        log_stream = container.logs(stream=True, follow=True, stdout=True, stderr=True)
        print(f"[Thread-{code_block_id}] Starting log iteration for container {container.short_id}")

        # Iterate through the log stream line by line
        for line_bytes in log_stream:
            # Check if the stop event has been set (e.g., by user cancellation)
            if stop_event.is_set():
                print(f"[Thread-{code_block_id}] Stop event set, breaking log iteration.")
                break # Exit the loop if stop is requested

            # Decode bytes to string, replacing errors
            line_str = line_bytes.decode('utf-8', errors='replace')

            # Schedule the asynchronous send_ws_message function to run on the main event loop
            # This is crucial for thread safety when interacting with asyncio objects like WebSockets.
            asyncio.run_coroutine_threadsafe(
                send_ws_message(websocket, "code_output", {
                    "code_block_id": code_block_id,
                    "stream": "stdout", # Simplification: send both stdout/stderr as stdout type for now
                    "data": line_str
                }),
                loop # Pass the main event loop
            )

        print(f"[Thread-{code_block_id}] Finished log iteration for container {container.short_id}")

    except Exception as e:
        # Handle exceptions during log streaming (e.g., container removed unexpectedly)
        print(f"[Thread-{code_block_id}] Error during log streaming: {e}")
        # Schedule sending an error message back to the client via the main loop
        asyncio.run_coroutine_threadsafe(
            send_ws_message(websocket, "code_output", {
                "code_block_id": code_block_id,
                "stream": "error", # Indicate an error stream
                "data": f"\n[Error streaming logs from container: {str(e)}]"
            }),
            loop
        )

async def stream_docker_logs_via_executor(websocket: WebSocket, container: Container, code_block_id: str, stop_event: asyncio.Event):
    """
    Asynchronously runs the synchronous log streamer function (`sync_log_streamer`)
    in a separate thread using asyncio's default executor.

    Args:
        websocket: The WebSocket connection.
        container: The Docker container object.
        code_block_id: Identifier for the code block.
        stop_event: Event to signal stopping the stream.
    """
    loop = asyncio.get_running_loop()
    print(f"Scheduling log streaming task in executor for {code_block_id}")
    # Run the blocking sync_log_streamer function in the thread pool executor
    await loop.run_in_executor(
        None, # Use the default executor
        sync_log_streamer, # The function to run
        # Arguments to pass to sync_log_streamer:
        container, websocket, code_block_id, loop, stop_event
    )
    print(f"Executor task for log streaming finished for {code_block_id}")


# --- Docker Code Execution Core Function ---

async def run_code_in_docker_stream(websocket: WebSocket, client_id: str, code_block_id: str, language: str, code: str):
    """
    Handles the complete process of running user-provided code in a Docker container:
    1. Validates language and Docker availability.
    2. Creates a temporary directory and writes the code to a file.
    3. Starts the appropriate Docker container based on the language config.
    4. Starts a background task to stream container logs back via WebSocket.
    5. Waits for the container to finish or timeout.
    6. Sends a final status message (success, error, timeout) via WebSocket.
    7. Cleans up the container and temporary directory.

    Args:
        websocket: The client's WebSocket connection.
        client_id: The unique ID of the client.
        code_block_id: Identifier for the specific code block being run.
        language: The programming language of the code (e.g., "python", "c++").
        code: The actual code string provided by the user.
    """
    # Get the initialized Docker client instance
    local_docker_client = get_docker_client()

    # Check if Docker client is available
    if not local_docker_client:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": "Docker service is unavailable on the server."
        })
        return

    # Validate the requested language against the configuration
    lang_key = language.lower()
    lang_config = config.SUPPORTED_LANGUAGES.get(lang_key)
    if not lang_config:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": f"Language '{language}' not supported for execution."
        })
        return

    # Extract language-specific configuration
    image_name = lang_config["image"]
    script_filename = lang_config["filename"]
    command = lang_config["command"]

    # Initialize variables for container, task, temp dir, and stop event
    container_obj: Container | None = None
    stream_task: asyncio.Task | None = None
    tmpdir_obj = None # To hold the TemporaryDirectory object for proper cleanup
    stop_event = asyncio.Event() # Event to signal cancellation to the streamer thread

    try:
        # Create a temporary directory to store the script file
        # Using 'with' ensures cleanup even if errors occur later, but we need the path
        # outside the 'with', so we create it manually and clean up in 'finally'.
        tmpdir_obj = tempfile.TemporaryDirectory()
        tmpdir = tmpdir_obj.name # Get the path string
        host_script_path = Path(tmpdir) / script_filename

        # Write the user's code to the script file inside the temp directory
        with open(host_script_path, "w", encoding="utf-8") as f:
            f.write(code)

        print(f"Attempting to run block {code_block_id} ({lang_key}) in Docker image {image_name}...")

        # Run the Docker container
        # This might implicitly pull the image if not found locally
        container_obj = local_docker_client.containers.run(
            image=image_name,
            command=command, # Command defined in config.py
            # Mount the temporary directory read-write into /app inside the container
            # Changed mode from 'ro' to 'rw' to allow compilation output
            volumes={tmpdir: {'bind': '/app', 'mode': 'rw'}}, # <<< CHANGED HERE
            working_dir='/app', # Set working directory inside the container
            mem_limit=config.DOCKER_MEM_LIMIT, # Apply memory limit from config
            stdout=True, # Capture stdout
            stderr=True, # Capture stderr
            detach=True, # Run the container in the background
            # auto_remove=True, # Cannot auto-remove if we need logs/exit code/manual stop
        )
        print(f"Container {container_obj.short_id} started for {code_block_id}")

        # Create and start the background task for streaming logs
        stream_task = asyncio.create_task(
            stream_docker_logs_via_executor(websocket, container_obj, code_block_id, stop_event),
            name=f"log_stream_{code_block_id}" # Name the task for easier debugging
        )

        # Add the running container info to the global state dictionary (thread-safe)
        async with state.running_containers_lock:
            # Check if another execution for the same block ID is already running
            if code_block_id in state.running_containers:
                # This shouldn't happen if frontend disables button, but handle defensively
                print(f"WARNING: Code block {code_block_id} was already running. Stopping previous run.")
                # Schedule stop_docker_container; do not await inside the lock
                asyncio.create_task(stop_docker_container(code_block_id))

            # Store container details in the shared state dictionary
            state.running_containers[code_block_id] = {
                "container": container_obj,
                "stream_task": stream_task,
                "client_id": client_id,
                "websocket": websocket,
                "stop_event": stop_event # Store the stop event for cancellation
            }

        # Wait for the container to finish execution (blocking call run in executor)
        print(f"Waiting for container {container_obj.short_id} ({code_block_id}) to finish...")
        loop = asyncio.get_running_loop()
        # container.wait() is blocking, so run it in the executor
        result = await loop.run_in_executor(
            None, # Use default executor
            lambda: container_obj.wait(timeout=config.DOCKER_TIMEOUT_SECONDS) # Wait with timeout
        )
        # Extract exit code and potential error message from the result
        exit_code = result.get("StatusCode", -1) # Default to -1 if status code missing
        error_msg = result.get("Error", None) # Docker daemon error message
        print(f"Container {container_obj.short_id} ({code_block_id}) finished. Result: {result}")

        # --- Container Finished Normally or Errored ---
        # Signal the log streaming thread that it can stop
        stop_event.set()
        try:
            # Wait briefly for the log streaming task to finish processing final logs
            await asyncio.wait_for(stream_task, timeout=5.0)
        except asyncio.TimeoutError:
            print(f"Warning: Log streaming task for {code_block_id} did not finish quickly after container exit.")
            # Cancel the task if it's still running after the timeout
            if stream_task and not stream_task.done():
                stream_task.cancel()
        except asyncio.CancelledError:
            # Expected if the task was cancelled during stop_docker_container
             print(f"Log streaming task for {code_block_id} was cancelled (likely during stop).")

        # Send the final result message to the client
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id,
            "exit_code": exit_code,
            "error": error_msg # Send Docker-level error if any (e.g., OOMKilled)
        })

    except asyncio.TimeoutError: # Timeout triggered by container_obj.wait()
        # Handle the case where the container ran longer than DOCKER_TIMEOUT_SECONDS
        print(f"ERROR: Docker execution timed out for block {code_block_id} after {config.DOCKER_TIMEOUT_SECONDS}s.")
        await send_ws_message(websocket, "code_finished", {
             "code_block_id": code_block_id, "exit_code": -1,
             "error": f"Execution timed out after {config.DOCKER_TIMEOUT_SECONDS} seconds."
        })
        # Schedule the container stop process in the background
        asyncio.create_task(stop_docker_container(code_block_id))

    except ImageNotFound:
        # Handle case where the specified Docker image doesn't exist locally and couldn't be pulled
        error_msg = f"Server Error: Docker image '{image_name}' not found. Please ensure it's pulled or available."
        print(f"ERROR for block {code_block_id}: {error_msg}")
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except APIError as e:
        # Handle errors from the Docker daemon API
        error_msg = f"Server Error: Docker API error: {e}"
        print(f"ERROR for block {code_block_id}: {error_msg}")
        traceback.print_exc() # Print full traceback for server logs
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except Exception as e:
        # Catch any other unexpected errors during setup or execution
        error_msg = f"Server Execution Error: An unexpected error occurred." # Generic message for client
        print(f"ERROR during Docker execution setup or wait for block {code_block_id}: {e}")
        traceback.print_exc() # Print full traceback for server logs
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
        # Ensure stream task is cancelled if it was started before the error
        if stream_task and not stream_task.done():
            print(f"Cancelling stream task for {code_block_id} due to setup/wait error.")
            stop_event.set() # Signal thread to stop
            stream_task.cancel()

    finally:
        # --- Final Cleanup ---
        # This block executes whether the try block succeeded or failed

        # Remove container info from tracking dict if it hasn't been removed already
        async with state.running_containers_lock:
            if code_block_id in state.running_containers:
                print(f"Performing final cleanup check for {code_block_id}")
                # Retrieve task and event references before deleting the entry
                task_to_cancel = state.running_containers[code_block_id].get("stream_task")
                stop_ev = state.running_containers[code_block_id].get("stop_event")
                # Ensure task is stopped and cancelled if still running
                if task_to_cancel and not task_to_cancel.done():
                    print(f"Final cleanup: Cancelling stream task for {code_block_id}")
                    if stop_ev: stop_ev.set() # Signal thread
                    task_to_cancel.cancel()
                # Remove the entry from the tracking dictionary
                del state.running_containers[code_block_id]
                print(f"Removed {code_block_id} from running_containers during final cleanup")

        # Ensure the Docker container is removed
        if container_obj:
            try:
                # Need to run blocking Docker SDK calls in an executor thread
                loop = asyncio.get_running_loop()
                # Check if container still exists before trying to remove
                await loop.run_in_executor(None, container_obj.reload)
                print(f"Removing container {container_obj.short_id} ({code_block_id}) in final cleanup")
                # Force remove the container
                await loop.run_in_executor(None, lambda: container_obj.remove(force=True))
            except NotFound:
                # Container was already removed (e.g., by stop_docker_container)
                 print(f"Container {container_obj.short_id} already removed.")
            except Exception as rm_err:
                # Log error if removal fails for some other reason
                 print(f"Error removing container {container_obj.short_id} in final cleanup: {rm_err}")

        # Clean up the temporary directory
        if tmpdir_obj:
             try:
                 tmpdir_obj.cleanup() # Deletes the temporary directory and its contents
             except Exception as cleanup_err:
                 print(f"Error cleaning up temp directory {tmpdir_obj.name}: {cleanup_err}")


# --- Container Stopping Logic ---

async def stop_docker_container(code_block_id: str):
    """
    Stops a specific running Docker container identified by code_block_id.
    Handles cancelling the log stream task and removing the container.

    Args:
        code_block_id: The identifier of the code block whose container needs stopping.
    """
    print(f"Attempting to stop execution for code block: {code_block_id}")
    loop = asyncio.get_running_loop()
    container_info = None
    container_obj = None
    stream_task = None
    websocket = None
    stop_event = None

    # Safely access and remove the container info from the shared state
    async with state.running_containers_lock:
        if code_block_id in state.running_containers:
            # Pop the entry to prevent race conditions with other stop requests or cleanup
            container_info = state.running_containers.pop(code_block_id)
            container_obj = container_info.get("container")
            stream_task = container_info.get("stream_task")
            websocket = container_info.get("websocket") # Get websocket for final message
            stop_event = container_info.get("stop_event")
            print(f"Found and removed running container info for {code_block_id} from tracking.")
        else:
            # If not found, it might have finished or been stopped already
            print(f"Stop request for {code_block_id}, but it was not found in running_containers.")
            return # Nothing further to do

    # --- Perform actions outside the lock ---

    # 1. Signal the streaming thread to stop and cancel the asyncio task
    if stop_event:
        print(f"Setting stop event for {code_block_id}")
        stop_event.set()
    if stream_task and not stream_task.done():
        print(f"Cancelling stream task for {code_block_id}")
        stream_task.cancel()
        try:
            # Wait briefly for cancellation to be processed
            await asyncio.wait_for(stream_task, timeout=1.0)
        except asyncio.TimeoutError:
            print(f"Stream task for {code_block_id} did not cancel quickly.")
        except asyncio.CancelledError:
            print(f"Stream task for {code_block_id} cancelled successfully.")
            pass # Expected outcome

    # 2. Stop the Docker container (run blocking calls in executor)
    if container_obj:
        try:
            print(f"Stopping container {container_obj.short_id} ({code_block_id})...")
            # container.stop() is blocking
            await loop.run_in_executor(None, lambda: container_obj.stop(timeout=5))
            print(f"Container {container_obj.short_id} stopped.")
        except Exception as stop_err:
            # If stop fails (e.g., timeout), attempt to kill the container
            print(f"Error stopping container {container_obj.short_id}, attempting kill: {stop_err}")
            try:
                # container.kill() is blocking
                await loop.run_in_executor(None, container_obj.kill)
                print(f"Container {container_obj.short_id} killed.")
            except Exception as kill_err:
                # Ignore "No such container" error if already gone, log others
                 if "No such container" not in str(kill_err):
                     print(f"Error killing container {container_obj.short_id}: {kill_err}")

        # 3. Remove the Docker container (run blocking call in executor)
        try:
            print(f"Removing container {container_obj.short_id} ({code_block_id}) after stop request.")
            # container.remove() is blocking
            await loop.run_in_executor(None, lambda: container_obj.remove(force=True))
        except NotFound:
            pass # Container already removed
        except Exception as rm_err:
            print(f"Error removing container {container_obj.short_id} after stop: {rm_err}")

    # 4. Send final "stopped by user" message if WebSocket is still valid
    if websocket: # Check if websocket reference exists
         try:
             await send_ws_message(websocket, "code_finished", {
                 "code_block_id": code_block_id,
                 "exit_code": -1, # Indicate abnormal termination
                 "error": "Execution stopped by user."
             })
         except Exception as send_err:
              print(f"Error sending stop confirmation for {code_block_id}: {send_err}")
    else:
         print(f"Cannot send stop confirmation for {code_block_id}, WebSocket reference lost.")


# --- Client Disconnect Cleanup ---

async def cleanup_client_containers(client_id: str):
    """
    Stops and cleans up all running Docker containers associated with a specific client ID
    when that client disconnects.

    Args:
        client_id: The ID of the client that disconnected.
    """
    print(f"Cleaning up containers for disconnected client: {client_id}")
    containers_to_stop = []
    # Safely get a list of code_block_ids associated with the disconnected client
    async with state.running_containers_lock:
        # List comprehension to find matching client_id
        ids_for_client = [
            cb_id for cb_id, info in state.running_containers.items()
            if info.get("client_id") == client_id
        ]
        containers_to_stop.extend(ids_for_client)

    # Stop each container concurrently using asyncio.gather
    if containers_to_stop:
        print(f"Found containers to stop for client {client_id}: {containers_to_stop}")
        # Create a list of stop tasks
        stop_tasks = [stop_docker_container(cb_id) for cb_id in containers_to_stop]
        # Run tasks concurrently and gather results (including exceptions)
        results = await asyncio.gather(*stop_tasks, return_exceptions=True)
        # Log any errors that occurred during the cleanup stops
        for i, result in enumerate(results):
             if isinstance(result, Exception):
                 print(f"Error during cleanup stop for {containers_to_stop[i]}: {result}")
        print(f"Finished cleanup for client {client_id}")
    else:
        print(f"No running containers found for client {client_id} during cleanup.")



=== app/email_utils.py ===
# app/email_utils.py
from fastapi_mail import FastMail, MessageSchema, ConnectionConfig
from pathlib import Path
import traceback
from . import config # Import your config module

# --- Email Configuration ---
# Create the ConnectionConfig using settings from config.py
# This configuration is used to connect to the email server.
conf = ConnectionConfig(
    MAIL_USERNAME=config.MAIL_CONFIG.get("MAIL_USERNAME"),
    MAIL_PASSWORD=config.MAIL_CONFIG.get("MAIL_PASSWORD"),
    MAIL_FROM=config.MAIL_CONFIG.get("MAIL_FROM"),
    MAIL_PORT=config.MAIL_CONFIG.get("MAIL_PORT", 587), # Default to 587 if not in config
    MAIL_SERVER=config.MAIL_CONFIG.get("MAIL_SERVER"),
    MAIL_FROM_NAME=config.MAIL_CONFIG.get("MAIL_FROM_NAME"),
    MAIL_STARTTLS=config.MAIL_CONFIG.get("MAIL_STARTTLS", True), # Default to True
    MAIL_SSL_TLS=config.MAIL_CONFIG.get("MAIL_SSL_TLS", False),   # Default to False
    USE_CREDENTIALS=config.MAIL_CONFIG.get("USE_CREDENTIALS", True),
    VALIDATE_CERTS=config.MAIL_CONFIG.get("VALIDATE_CERTS", True) # Default to True
)

# Initialize FastMail instance with the configuration
fm = FastMail(conf)

# Define the base path for email templates
# config.APP_DIR should point to the 'app' directory.
EMAIL_TEMPLATES_DIR = config.APP_DIR / "static" / "email_templates"

async def send_registration_password_email(
    recipient_email: str,
    recipient_name: str,
    generated_password: str,
    login_url: str
) -> bool:
    """
    Sends the generated password to a new user using an HTML template.
    The password sent is the user's actual password.
    """
    # Basic check for essential mail server configuration
    if not conf.MAIL_FROM or not conf.MAIL_SERVER:
        print("EMAIL ERROR: Mail configuration (MAIL_FROM, MAIL_SERVER) is incomplete. Cannot send registration password email.")
        return False

    template_path = EMAIL_TEMPLATES_DIR / "registration_email.html"
    subject = "Welcome to Tesseracs Chat - Your Account Details"

    try:
        # Read the HTML template from file
        with open(template_path, "r", encoding="utf-8") as f:
            html_template = f.read()

        # Replace placeholders in the template
        # Ensure all placeholders match those in the HTML template
        html_body = html_template.replace("{{ recipient_name }}", recipient_name)
        html_body = html_body.replace("{{ email }}", recipient_email) # Changed from {{ recipient_email }} for consistency
        html_body = html_body.replace("{{ password }}", generated_password)
        html_body = html_body.replace("{{ login_url }}", login_url)

    except FileNotFoundError:
        print(f"EMAIL ERROR: Registration email template not found at {template_path}")
        return False
    except Exception as e:
        print(f"EMAIL ERROR: Failed to read or process registration email template: {e}")
        traceback.print_exc()
        return False

    # Create the email message schema
    message = MessageSchema(
        subject=subject,
        recipients=[recipient_email],
        body=html_body,
        subtype="html"
    )

    try:
        # Attempt to send the email
        print(f"EMAIL: Attempting to send registration password to {recipient_email} via {conf.MAIL_SERVER}:{conf.MAIL_PORT}")
        await fm.send_message(message)
        print(f"EMAIL: Registration password email successfully sent to {recipient_email}.")
        return True  # Indicate success
    except Exception as e:
        # Log any errors during email sending
        print(f"EMAIL ERROR: Failed to send registration password email to {recipient_email}")
        print(f"EMAIL ERROR DETAILS: {type(e).__name__} - {e}")
        traceback.print_exc()
        return False # Indicate failure

async def send_password_reset_email(
    recipient_email: str,
    recipient_name: str,
    new_password: str,
    login_url: str
) -> bool:
    """
    Sends an email containing a newly generated password after a reset request,
    using an HTML template.
    """
    # Basic check for essential mail server configuration
    if not conf.MAIL_FROM or not conf.MAIL_SERVER:
        print("EMAIL ERROR: Mail configuration (MAIL_FROM, MAIL_SERVER) is incomplete. Cannot send password reset email.")
        return False

    template_path = EMAIL_TEMPLATES_DIR / "password_reset_email.html"
    subject = "Your Tesseracs Chat Password Has Been Reset"

    try:
        # Read the HTML template from file
        with open(template_path, "r", encoding="utf-8") as f:
            html_template = f.read()

        # Replace placeholders in the template
        # Ensure all placeholders match those in the HTML template
        html_body = html_template.replace("{{ recipient_name }}", recipient_name)
        html_body = html_body.replace("{{ email }}", recipient_email) # Changed from {{ recipient_email }} for consistency
        html_body = html_body.replace("{{ password }}", new_password)
        html_body = html_body.replace("{{ login_url }}", login_url)

    except FileNotFoundError:
        print(f"EMAIL ERROR: Password reset email template not found at {template_path}")
        return False
    except Exception as e:
        print(f"EMAIL ERROR: Failed to read or process password reset email template: {e}")
        traceback.print_exc()
        return False

    # Create the email message schema
    message = MessageSchema(
        subject=subject,
        recipients=[recipient_email],
        body=html_body,
        subtype="html"
    )

    try:
        # Attempt to send the email
        print(f"EMAIL: Attempting to send password reset to {recipient_email} via {conf.MAIL_SERVER}:{conf.MAIL_PORT}")
        await fm.send_message(message)
        print(f"EMAIL: Password reset email successfully sent to {recipient_email}.")
        return True # Indicate success
    except Exception as e:
        # Log any errors during email sending
        print(f"EMAIL ERROR: Failed to send password reset email to {recipient_email}")
        print(f"EMAIL ERROR DETAILS: {type(e).__name__} - {e}")
        traceback.print_exc()
        return False # Indicate failure


=== app/llm.py ===
--- CONTENT EXCLUDED (listed in exclude_files) ---


=== app/main.py ===

# app/main.py

# Standard library imports
import os
import sys
import uvicorn
import webbrowser
import traceback
from pathlib import Path
import asyncio
import json
import sqlite3
import uuid
from urllib.parse import urlparse
import datetime
from typing import Optional, Dict, Any, List # For type hinting

# FastAPI and related imports
from fastapi import (
    FastAPI,
    Request,
    HTTPException,
    WebSocket,
    WebSocketDisconnect,
    Form,
    Depends,
    Response as FastAPIResponse, # Aliased to avoid naming conflicts
    Path as FastApiPath,        # Aliased to avoid naming conflicts
    Body,
    status
)
from fastapi.responses import HTMLResponse, FileResponse, RedirectResponse
from fastapi.security import OAuth2PasswordRequestForm
from fastapi.staticfiles import StaticFiles
from fastapi.websockets import WebSocketState

# Pydantic core imports (might still be needed for FastAPI's dependency injection if not all models are covered)
# However, specific model fields like EmailStr, constr are now expected to be used within app/models.py
from pydantic import BaseModel # BaseModel might be used if you define ad-hoc request/response models directly in routes
                             # If all models are in app/models.py, this specific line might become redundant.

# Project local imports
from . import config
from . import state
from . import llm
from . import docker_utils
from . import utils
from . import database
from . import auth
from . import email_utils
from . import models # Import your new models file

# --- FastAPI App Initialization ---
app = FastAPI(title="Tesseracs Chat")

# --- Database Initialization on Startup ---
# This event handler runs when the FastAPI application starts up.
@app.on_event("startup")
async def startup_event():
    """
    Performs initialization tasks when the application starts:
    - Ensures the database directory exists.
    - Initializes the database schema.
    - Checks Docker client availability.
    - Checks LLM model connection.
    """
    print("Application startup: Initializing database...")
    # Ensure the parent directory for the SQLite database file exists.
    database.DATABASE_PATH.parent.mkdir(parents=True, exist_ok=True)
    # Initialize database tables if they don't already exist.
    database.init_db()
    print("Database initialization check complete.")

    # Check if the Docker client is available.
    if docker_utils.get_docker_client() is None:
        print("WARNING: Docker client unavailable during startup. Code execution features will be disabled.")
    else:
        print("Docker client confirmed available at startup.")

    # Attempt to connect to the LLM.
    try:
        llm.get_model() # This function should attempt to initialize/connect to the LLM.
        print("LLM model connection checked successfully.")
    except Exception as e:
        print(f"CRITICAL ERROR during startup LLM check: {e}")
        # Depending on severity, you might want to sys.exit(1) here if LLM is essential.


# --- Static Files Setup ---
# This section configures how static files (CSS, JavaScript, images) are served.

# Validate that the base static directory is correctly configured and exists.
if not config.STATIC_DIR or not config.STATIC_DIR.is_dir():
    print(f"CRITICAL ERROR: Base static directory invalid or not found: {config.STATIC_DIR}")
    sys.exit(1) # Exit if the static directory is not found.

# Define the path to the 'dist' directory, typically containing bundled frontend assets.
dist_dir = config.STATIC_DIR / "dist"
if not dist_dir.is_dir():
    print(f"CRITICAL ERROR: Bundled assets directory not found: {dist_dir}. Ensure frontend assets are built (e.g., 'npm run build').")
    sys.exit(1) # Exit if the distribution directory is not found.

# Mount the 'dist' directory to serve its contents under the '/dist' path.
# These are typically the compiled/minified CSS and JavaScript files.
app.mount("/dist", StaticFiles(directory=dist_dir), name="dist_assets")

# Mount the base static directory (e.g., 'app/static') to serve its contents under the '/static' path.
# This can be used for HTML files, images, or other assets not part of the frontend build process.
app.mount("/static", StaticFiles(directory=config.STATIC_DIR), name="static_pages")

print(f"Mounted bundled assets from '{dist_dir}' at '/dist'")
print(f"Mounted static pages directory '{config.STATIC_DIR}' at '/static'")


@app.post("/register", response_model=models.RegistrationResponse, tags=["Authentication"])
async def register_new_user(request_data: models.RegistrationRequest, request: Request):
    """
    Registers a new user, hashes their generated password, and emails it to them.
    The emailed password is their actual password for the account.
    Uses config.BASE_URL for the login link.
    """
    email = request_data.email.lower().strip()
    name = request_data.name.strip()

    if not name: # Basic validation for the name
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Name cannot be empty.")

    conn = None # Initialize connection variable
    try:
        # Establish database connection
        conn = database.get_db_connection()
        cursor = conn.cursor()

        # Check if email already exists
        cursor.execute("SELECT id FROM users WHERE email = ?", (email,))
        if cursor.fetchone():
            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Email already registered.")

        # Generate a secure password for the user
        plain_password = database.generate_secure_token(12)
        hashed_password = auth.get_password_hash(plain_password)

        # Insert the new user into the database
        cursor.execute(
            "INSERT INTO users (name, email, password_hash, is_active) VALUES (?, ?, ?, ?)",
            (name, email, hashed_password, True)
        )
        user_id = cursor.lastrowid
        if not user_id:
            conn.rollback()
            raise sqlite3.Error("Failed to get lastrowid after user insertion.")

        # --- Construct login_page_url using config.BASE_URL ---
        # Get the URL from FastAPI's url_for for the path component
        login_url_from_fastapi = str(request.url_for('get_login_page_route'))
        
        # Parse the URL to reliably extract only the path and query parameters
        parsed_url_from_fastapi = urlparse(login_url_from_fastapi)
        login_path_component = parsed_url_from_fastapi.path # e.g., "/login"
        if parsed_url_from_fastapi.query: # Append query string if it exists
            login_path_component += "?" + parsed_url_from_fastapi.query
            
        # Use config.BASE_URL (which should not have a trailing slash)
        login_page_url = f"{config.BASE_URL.rstrip('/')}{login_path_component}"
        
        print(f"DEBUG (register): config.BASE_URL: {config.BASE_URL}")
        print(f"DEBUG (register): request.url_for('get_login_page_route') returned: {login_url_from_fastapi}")
        print(f"DEBUG (register): Extracted path component: {login_path_component}")
        print(f"DEBUG (register): Constructed login_page_url for email: {login_page_url}")
        # --- END OF URL CONSTRUCTION ---

        email_sent = await email_utils.send_registration_password_email(
            recipient_email=email,
            recipient_name=name,
            generated_password=plain_password,
            login_url=login_page_url
        )

        if not email_sent:
            conn.commit() 
            print(f"User {email} (ID: {user_id}) created, but password email FAILED to send.")
            raise HTTPException(
                status_code=status.HTTP_502_BAD_GATEWAY,
                detail="Account created, but failed to send password email. Please try resetting the password or contact support."
            )

        conn.commit()
        print(f"New user registered: {email} (ID: {user_id}). Password email sent with login URL: {login_page_url}")

        return models.RegistrationResponse(message="Account created! Your password has been sent to your email.")

    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        print(f"API ERROR (/register): Database error for {email}: {db_err}")
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error during registration.")
    except Exception as e:
        if conn: conn.rollback()
        print(f"API ERROR (/register): Unexpected error for {email}: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred during registration.")
    finally:
        if conn: conn.close()

@app.post("/api/me/regenerate-password", response_model=models.RegeneratePasswordResponse, tags=["User Account Management"])
async def regenerate_user_password(
    request: Request, # To construct login URL for email
    response: FastAPIResponse, # To potentially clear cookies if we decide to logout from backend
    payload: models.RegeneratePasswordRequest = Body(...),
    current_user: Dict[str, Any] = Depends(auth.get_current_active_user)
):
    """
    Allows an authenticated user to regenerate their password.
    Requires the user's current password for verification.
    A new password will be generated and emailed to the user.
    The client is expected to handle logout after a successful response.
    """
    user_id = current_user.get("id")
    user_email = current_user.get("email")
    user_name = current_user.get("name") # For the email

    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()

        # Fetch the current user's stored password hash for verification
        cursor.execute("SELECT password_hash FROM users WHERE id = ? AND email = ?", (user_id, user_email))
        user_record = cursor.fetchone()

        if not user_record:
            print(f"ACCOUNT ERROR (regenerate-password): User ID {user_id} / Email {user_email} not found in database despite being authenticated.")
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User record not found. Please try logging out and back in."
            )

        stored_password_hash = user_record["password_hash"]
        if not stored_password_hash:
             print(f"ACCOUNT ERROR (regenerate-password): User ID {user_id} ({user_email}) has no password hash stored.")
             raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Cannot verify password due to an account data issue. Please contact support."
            )

        # Verify the provided current password
        if not auth.verify_password(payload.current_password, stored_password_hash):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect current password."
            )

        # If current password is correct, generate a new password
        new_plain_password = database.generate_secure_token(12) # Generate a new 12-character password
        new_hashed_password = auth.get_password_hash(new_plain_password)

        # Update the user's password hash in the database
        cursor.execute("UPDATE users SET password_hash = ? WHERE id = ?", (new_hashed_password, user_id))
        if cursor.rowcount == 0:
            conn.rollback()
            print(f"ACCOUNT ERROR (regenerate-password): Failed to update password hash for user ID {user_id} ({user_email}).")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to update password due to a server error."
            )

        # Construct the login URL for the email using config.BASE_URL
        login_url_from_fastapi = str(request.url_for('get_login_page_route'))
        parsed_url_from_fastapi = urlparse(login_url_from_fastapi)
        login_path_component = parsed_url_from_fastapi.path
        if parsed_url_from_fastapi.query:
            login_path_component += "?" + parsed_url_from_fastapi.query
        login_page_url = f"{config.BASE_URL.rstrip('/')}{login_path_component}"

        # Send an email with the new password
        # We can reuse send_password_reset_email or create a new specific template/function
        # For now, reusing send_password_reset_email which sends the new password.
        email_sent = await email_utils.send_password_reset_email(
            recipient_email=user_email,
            recipient_name=user_name, # Pass the user's name
            new_password=new_plain_password,
            login_url=login_page_url
        )

        if not email_sent:
            # If email sending fails, we should roll back the password change
            # to avoid leaving the user in a state where their password changed
            # but they didn't receive the new one.
            conn.rollback()
            print(f"ACCOUNT ERROR (regenerate-password): Password for user {user_id} ({user_email}) was updated in DB, but FAILED to send email. DB changes rolled back.")
            raise HTTPException(
                status_code=status.HTTP_502_BAD_GATEWAY,
                detail="Password was reset, but failed to send the notification email. Please try again."
            )

        # Invalidate all existing session tokens for this user to force re-login on other devices.
        # This is an important security step after a password change.
        now_utc_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        cursor.execute(
            """
            UPDATE auth_tokens 
            SET used_at = ?, expires_at = ? 
            WHERE user_id = ? AND token_type = 'session' AND used_at IS NULL
            """,
            (now_utc_iso, now_utc_iso, user_id)
        )
        print(f"ACCOUNT (regenerate-password): Invalidated {cursor.rowcount} active session tokens for user ID {user_id} ({user_email}).")


        conn.commit()
        print(f"ACCOUNT: User ID {user_id} ({user_email}) successfully regenerated their password. New password email sent.")
        
        # The client will handle the actual logout.
        # We do not clear the cookie here, but the session tokens are invalidated.
        # The current session cookie on the client's browser will become invalid on the next request
        # that requires auth, or the client can explicitly clear it.

        return models.RegeneratePasswordResponse(
            message="Password regenerated successfully. An email has been sent with your new password. You should now log out and log back in with the new password."
        )

    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        print(f"API ERROR (/api/me/regenerate-password): Database error for user {user_email}: {db_err}")
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error while regenerating password.")
    except Exception as e:
        if conn: conn.rollback()
        print(f"API ERROR (/api/me/regenerate-password): Unexpected error for user {user_email}: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred.")
    finally:
        if conn: conn.close()


@app.get("/settings", response_class=FileResponse, name="get_settings_page", tags=["Pages"])
async def get_settings_page(
    request: Request,
    user: Dict[str, Any] = Depends(auth.get_current_active_user) # Protect the route
):
    """
    Serves the user settings page.
    Requires authentication.
    """
    if not user:
        # This should be handled by the Depends(auth.get_current_active_user)
        # but as a safeguard, redirect to login if somehow user is None.
        return RedirectResponse(url=request.url_for('get_login_page_route'), status_code=status.HTTP_302_FOUND)

    settings_html_path = config.STATIC_DIR / "settings.html"
    if not settings_html_path.is_file():
        print(f"ERROR: settings.html not found at expected location: {settings_html_path}")
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Settings page HTML file not found.")
    
    return FileResponse(settings_html_path)

# --- Add this new route for updating user email ---
@app.patch("/api/me/update-email", response_model=models.UpdateEmailResponse, tags=["User Account Management"])
async def update_user_email(
    response: FastAPIResponse, # To potentially clear cookies if we decide to logout from backend
    payload: models.UpdateEmailRequest = Body(...),
    current_user: Dict[str, Any] = Depends(auth.get_current_active_user)
):
    """
    Allows an authenticated user to update their email address.
    Requires the user's current password for verification.
    Checks if the new email is already in use.
    If successful, invalidates existing sessions and the client is expected to handle logout.
    """
    user_id = current_user.get("id")
    current_email_for_logging = current_user.get("email") # For logging
    new_email_normalized = payload.new_email.lower().strip()

    if new_email_normalized == current_email_for_logging:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="New email address is the same as the current one."
        )

    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()

        # 1. Fetch the current user's stored password hash for verification
        cursor.execute("SELECT password_hash FROM users WHERE id = ?", (user_id,))
        user_record = cursor.fetchone()

        if not user_record:
            print(f"ACCOUNT ERROR (update-email): User ID {user_id} not found in database despite being authenticated.")
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User record not found. Please try logging out and back in."
            )

        stored_password_hash = user_record["password_hash"]
        if not stored_password_hash:
             print(f"ACCOUNT ERROR (update-email): User ID {user_id} ({current_email_for_logging}) has no password hash stored.")
             raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Cannot verify password due to an account data issue. Please contact support."
            )

        # 2. Verify the provided current password
        if not auth.verify_password(payload.current_password, stored_password_hash):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect current password."
            )

        # 3. Check if the new email address is already in use by another user
        cursor.execute("SELECT id FROM users WHERE email = ? AND id != ?", (new_email_normalized, user_id))
        existing_user_with_new_email = cursor.fetchone()
        if existing_user_with_new_email:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="This email address is already in use by another account."
            )

        # 4. If password is correct and new email is available, update the email
        cursor.execute("UPDATE users SET email = ? WHERE id = ?", (new_email_normalized, user_id))
        if cursor.rowcount == 0:
            conn.rollback()
            print(f"ACCOUNT ERROR (update-email): Failed to update email for user ID {user_id} ({current_email_for_logging}) even after checks. Rowcount was 0.")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to update email due to a server error during the update operation."
            )

        # 5. Invalidate all existing session tokens for this user to force re-login.
        now_utc_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        cursor.execute(
            """
            UPDATE auth_tokens 
            SET used_at = ?, expires_at = ? 
            WHERE user_id = ? AND token_type = 'session' AND used_at IS NULL
            """,
            (now_utc_iso, now_utc_iso, user_id)
        )
        print(f"ACCOUNT (update-email): Invalidated {cursor.rowcount} active session tokens for user ID {user_id} (old email: {current_email_for_logging}).")

        conn.commit()
        print(f"ACCOUNT: User ID {user_id} successfully updated email from '{current_email_for_logging}' to '{new_email_normalized}'.")
        
        # The client will handle the actual logout.
        # The current session cookie on the client's browser will become invalid on the next request
        # that requires auth, or the client can explicitly clear it.

        return models.UpdateEmailResponse(
            message="Email updated successfully. You will now be logged out to apply changes.",
            new_email=new_email_normalized
        )

    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        print(f"API ERROR (/api/me/update-email): Database error for user {current_email_for_logging}: {db_err}")
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="A database error occurred while updating your email.")
    except Exception as e:
        if conn: conn.rollback()
        print(f"API ERROR (/api/me/update-email): Unexpected error for user {current_email_for_logging}: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred while updating your email.")
    finally:
        if conn: conn.close()

# --- Add this new route for updating user name ---
@app.patch("/api/me/update-name", response_model=models.UpdateNameResponse, tags=["User Account Management"])
async def update_user_name(
    update_data: models.UpdateNameRequest = Body(...), # Use models.UpdateNameRequest
    current_user: Dict[str, Any] = Depends(auth.get_current_active_user) # Dependency to get authenticated user
):
    """
    Allows an authenticated user to update their display name.
    Requires the user's current password for verification.
    """
    # current_user is already validated by auth.get_current_active_user,
    # which raises HTTPException(status_code=401) if not authenticated or inactive.

    user_id = current_user.get("id")
    user_email = current_user.get("email") # For logging purposes

    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()

        # Fetch the current user's stored password hash for verification
        cursor.execute("SELECT password_hash FROM users WHERE id = ?", (user_id,))
        user_record = cursor.fetchone()

        if not user_record:
            # This should ideally not happen if user is authenticated and their record exists
            print(f"ACCOUNT ERROR (update-name): User ID {user_id} not found in database despite being authenticated.")
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND, # Or 500 if this indicates a severe inconsistency
                detail="User record not found. Please try logging out and back in."
            )

        stored_password_hash = user_record["password_hash"]
        if not stored_password_hash:
             # This indicates an issue with the user's account data (e.g., created without a password hash)
             print(f"ACCOUNT ERROR (update-name): User ID {user_id} ({user_email}) has no password hash stored.")
             raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Cannot verify password due to an account data issue. Please contact support."
            )

        # Verify the provided current password against the stored hash
        if not auth.verify_password(update_data.current_password, stored_password_hash):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED, # Incorrect password
                detail="Incorrect current password."
            )

        # If password is correct, update the name
        # new_name is already stripped and validated by Pydantic's constr in models.UpdateNameRequest
        new_name_stripped = update_data.new_name

        cursor.execute("UPDATE users SET name = ? WHERE id = ?", (new_name_stripped, user_id))
        if cursor.rowcount == 0:
            # This would be unusual if the user exists and password was verified,
            # might indicate a concurrent deletion or DB issue.
            conn.rollback()
            print(f"ACCOUNT ERROR (update-name): Failed to update name for user ID {user_id} ({user_email}) even after password verification. Rowcount was 0.")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to update name due to a server error during the update operation."
            )

        conn.commit()
        print(f"ACCOUNT: User ID {user_id} ({user_email}) successfully updated name to '{new_name_stripped}'.")
        
        # Return a success response including the new name
        return models.UpdateNameResponse(message="Name updated successfully.", new_name=new_name_stripped)

    except HTTPException as http_exc:
        # Re-raise HTTPExceptions that were intentionally raised (e.g., 401, 404)
        if conn: conn.rollback() # Ensure rollback if transaction was started
        raise http_exc
    except sqlite3.Error as db_err:
        # Handle database-specific errors
        if conn: conn.rollback()
        print(f"API ERROR (/api/me/update-name): Database error for user {user_email}: {db_err}")
        traceback.print_exc()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="A database error occurred while updating your name."
        )
    except Exception as e:
        # Handle any other unexpected errors
        if conn: conn.rollback()
        print(f"API ERROR (/api/me/update-name): Unexpected error for user {user_email}: {e}")
        traceback.print_exc()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="An unexpected server error occurred while updating your name."
        )
    finally:
        # Always close the database connection if it was opened
        if conn:
            conn.close()

@app.post("/forgot_password", response_model=models.ForgotPasswordResponse, tags=["Authentication"])
async def handle_forgot_password(
    request_data: models.ForgotPasswordRequest,
    request: Request # To construct login URL for email and get client IP
):
    """
    Handles a forgot password request with rate limiting.
    Uses config.BASE_URL for the login link.
    Rate limiting parameters are sourced from config.py.
    """
    email = request_data.email.lower().strip()
    client_ip = request.client.host if request.client else None

    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()

        time_window_start = datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(hours=config.FORGOT_PASSWORD_ATTEMPT_WINDOW_HOURS)
        
        cursor.execute(
            "SELECT COUNT(*) FROM password_reset_attempts WHERE email = ? AND attempted_at >= ?",
            (email, time_window_start.isoformat())
        )
        attempt_count_row = cursor.fetchone()
        recent_attempts = attempt_count_row[0] if attempt_count_row else 0

        if recent_attempts >= config.FORGOT_PASSWORD_ATTEMPT_LIMIT:
            print(f"AUTH (/forgot_password): Rate limit exceeded for email {email}. Recent attempts: {recent_attempts} (Limit: {config.FORGOT_PASSWORD_ATTEMPT_LIMIT})")
            return models.ForgotPasswordResponse(message="If an account with this email exists, a password reset email has been sent.")

        cursor.execute(
            "INSERT INTO password_reset_attempts (email, ip_address) VALUES (?, ?)",
            (email, client_ip)
        )
        
        cursor.execute("SELECT id, name FROM users WHERE email = ? AND is_active = 1", (email,))
        user_row = cursor.fetchone()

        if not user_row:
            conn.commit() 
            print(f"AUTH (/forgot_password): Reset requested for non-existent/inactive email: {email}. Attempt logged.")
            return models.ForgotPasswordResponse(message="If an account with this email exists, a password reset email has been sent.")

        user = dict(user_row)
        user_id = user["id"]
        user_name = user["name"]

        new_plain_password = database.generate_secure_token(12)
        new_hashed_password = auth.get_password_hash(new_plain_password)

        cursor.execute("UPDATE users SET password_hash = ? WHERE id = ?", (new_hashed_password, user_id))
        if cursor.rowcount == 0:
            conn.rollback()
            print(f"AUTH ERROR (/forgot_password): Failed to update password hash for user {user_id} ({email}).")
            return models.ForgotPasswordResponse(message="If an account with this email exists, a password reset email has been sent.")

        # --- Construct login_page_url using config.BASE_URL ---
        login_url_from_fastapi = str(request.url_for('get_login_page_route'))
        parsed_url_from_fastapi = urlparse(login_url_from_fastapi)
        login_path_component = parsed_url_from_fastapi.path
        if parsed_url_from_fastapi.query:
            login_path_component += "?" + parsed_url_from_fastapi.query
        
        # Use config.BASE_URL (which should not have a trailing slash)
        login_page_url = f"{config.BASE_URL.rstrip('/')}{login_path_component}"

        print(f"DEBUG (forgot_password): config.BASE_URL: {config.BASE_URL}")
        print(f"DEBUG (forgot_password): request.url_for('get_login_page_route') returned: {login_url_from_fastapi}")
        print(f"DEBUG (forgot_password): Extracted path component: {login_path_component}")
        print(f"DEBUG (forgot_password): Constructed login_page_url for email: {login_page_url}")
        # --- END OF URL CONSTRUCTION ---
        
        email_sent = await email_utils.send_password_reset_email(
            recipient_email=email,
            recipient_name=user_name,
            new_password=new_plain_password,
            login_url=login_page_url
        )

        if not email_sent:
            conn.rollback()
            print(f"AUTH ERROR (/forgot_password): Password reset email FAILED to send for user {user_id} ({email}). DB changes rolled back.")
            return models.ForgotPasswordResponse(message="If an account with this email exists, a password reset email has been sent.")

        conn.commit()
        print(f"AUTH (/forgot_password): Password reset successful for user {user_id} ({email}). New password email sent. Attempt logged.")
        return models.ForgotPasswordResponse(message="If an account with this email exists, a password reset email has been sent.")

    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        print(f"API ERROR (/forgot_password): DB error for {email}: {db_err}")
        traceback.print_exc()
        return models.ForgotPasswordResponse(message="An error occurred while processing your request. Please try again.")
    except Exception as e:
        if conn: conn.rollback()
        print(f"API ERROR (/forgot_password): Unexpected error for {email}: {e}")
        traceback.print_exc()
        return models.ForgotPasswordResponse(message="An unexpected error occurred. Please try again.")
    finally:
        if conn: conn.close()


@app.on_event("startup")
async def startup_event():
    print("Application startup: Initializing database...")
    database.DATABASE_PATH.parent.mkdir(parents=True, exist_ok=True)
    database.init_db()
    print("Database initialization check complete.")
    if docker_utils.get_docker_client() is None:
        print("WARNING: Docker client unavailable during startup.")
    else:
        print("Docker client confirmed available at startup.")
    try:
        llm.get_model()
        print("LLM model connection checked successfully.")
    except Exception as e:
        print(f"CRITICAL ERROR during startup LLM check: {e}")


# --- Static Files Setup ---
if not config.STATIC_DIR or not config.STATIC_DIR.is_dir():
    sys.exit(f"CRITICAL ERROR: Base static directory invalid: {config.STATIC_DIR}")
dist_dir = config.STATIC_DIR / "dist"
if not dist_dir.is_dir():
    sys.exit(f"CRITICAL ERROR: Bundled assets dir not found: {dist_dir}. Run 'npm run build'.")
app.mount("/dist", StaticFiles(directory=dist_dir), name="dist_assets")
app.mount("/static", StaticFiles(directory=config.STATIC_DIR), name="static_pages")
print(f"Mounted bundled assets from '{dist_dir}' at '/dist'")
print(f"Mounted static pages directory '{config.STATIC_DIR}' at '/static'")


# --- Authentication & User Routes ---

@app.post("/token", response_model=models.Token, tags=["Authentication"])
async def login_for_access_token(
    response: FastAPIResponse,
    form_data: OAuth2PasswordRequestForm = Depends()
):
    """Handles email/password login, sets session cookie."""
    email = form_data.username.lower().strip()
    password = form_data.password
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT id, name, email, password_hash, is_active FROM users WHERE email = ?", (email,))
        user_row = cursor.fetchone()
        if not user_row:
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect email or password.")

        user = dict(user_row)
        stored_password_hash = user.get("password_hash")
        if not stored_password_hash or not auth.verify_password(password, stored_password_hash):
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect email or password.")

        if not user["is_active"]:
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Account is inactive.")

        session_token_raw = await auth.create_user_session(response=response, user_id=user["id"])
        print(f"AUTH (/token): User '{email}' (ID: {user['id']}) logged in successfully.")
        return models.Token(
            access_token=session_token_raw, token_type="bearer",
            user_id=user["id"], user_name=user["name"], user_email=user["email"]
        )
    except HTTPException as http_exc: raise http_exc
    except sqlite3.Error as db_err:
        print(f"API ERROR (/token): DB error for {email}: {db_err}"); traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error during login.")
    except Exception as e:
        print(f"API ERROR (/token): Unexpected error for {email}: {e}"); traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Unexpected server error during login.")
    finally:
        if conn: conn.close()


@app.post("/check_email", response_model=models.EmailCheckResponse, tags=["Authentication"])
async def check_email_exists(request_data: models.EmailCheckRequest):
    """Checks if an email exists in the database."""
    email_to_check = request_data.email.lower()
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT id, name FROM users WHERE email = ?", (email_to_check,))
        user_row = cursor.fetchone()
        if user_row:
            return models.EmailCheckResponse(exists=True, user_name=user_row["name"])
        else:
            return models.EmailCheckResponse(exists=False)
    except sqlite3.Error as db_err:
        print(f"API ERROR (/check_email): DB error for {email_to_check}: {db_err}"); traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error checking email.")
    except Exception as e:
        print(f"API ERROR (/check_email): Unexpected error for {email_to_check}: {e}"); traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Unexpected server error checking email.")
    finally:
        if conn: conn.close()


@app.post("/register", response_model=models.RegistrationResponse, tags=["Authentication"])
async def register_new_user(request_data: models.RegistrationRequest, request: Request):
    """Registers a new user, hashes password, emails generated password."""
    email = request_data.email.lower().strip()
    name = request_data.name.strip()
    if not name: raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Name cannot be empty.")
    conn = None
    try:
        conn = database.get_db_connection(); cursor = conn.cursor()
        cursor.execute("SELECT id FROM users WHERE email = ?", (email,))
        if cursor.fetchone(): raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Email already registered.")

        plain_password = database.generate_secure_token(12)
        hashed_password = auth.get_password_hash(plain_password) # Use passlib

        cursor.execute("INSERT INTO users (name, email, password_hash, is_active) VALUES (?, ?, ?, ?)", (name, email, hashed_password, True))
        user_id = cursor.lastrowid
        if not user_id: conn.rollback(); raise sqlite3.Error("Failed to get lastrowid.")

        base_url = str(request.base_url).rstrip('/'); login_page_url = f"{base_url}{request.url_for('get_login_page_route')}"
        email_sent = await email_utils.send_registration_password_email(
            recipient_email=email, recipient_name=name, generated_password=plain_password, login_url=login_page_url
        )
        if not email_sent:
            conn.commit(); print(f"User {email} created (ID: {user_id}), but password email FAILED.")
            raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail="Account created, but failed to send password email.")

        conn.commit(); print(f"New user registered: {email} (ID: {user_id}). Password email sent.")
        return models.RegistrationResponse(message="Account created! Temporary password sent to your email.")
    except HTTPException as http_exc:
        if conn: conn.rollback(); raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback(); print(f"API ERROR (/register): DB error for {email}: {db_err}"); traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error during registration.")
    except Exception as e:
        if conn: conn.rollback(); print(f"API ERROR (/register): Unexpected error for {email}: {e}"); traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Unexpected server error during registration.")
    finally:
        if conn: conn.close()


@app.get("/login", response_class=HTMLResponse, name="get_login_page_route", tags=["Pages"])
async def get_login_page_route(request: Request, user: Optional[Dict] = Depends(auth.get_current_user)):
    """Serves the login page or redirects if already logged in."""
    if user:
        return RedirectResponse(url=request.url_for("get_session_choice_page"), status_code=status.HTTP_302_FOUND)
    login_html_path = config.STATIC_DIR / "login.html"
    if not login_html_path.is_file(): raise HTTPException(status_code=404, detail="login.html not found.")
    return FileResponse(login_html_path)


@app.get("/logout", tags=["Authentication"])
async def logout_route(response: FastAPIResponse, session_token_value: Optional[str] = Depends(auth.cookie_scheme)):
    """Logs the user out by invalidating the session and clearing the cookie."""
    await auth.logout_user(response, session_token_value)
    return RedirectResponse(url="/login", status_code=status.HTTP_302_FOUND)


@app.get("/api/me", response_model=models.UserResponseModel, tags=["Users"])
async def get_current_user_details(user: Dict[str, Any] = Depends(auth.get_current_active_user)):
    """Gets details for the currently authenticated user."""
    if not user: raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")
    if not all(key in user for key in ["id", "name", "email"]):
        print(f"ERROR /api/me: User dict missing keys. User: {user}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="User data incomplete.")
    return models.UserResponseModel(id=user["id"], name=user["name"], email=user["email"])

# --- Main Application Routes (Protected) ---

@app.get("/", response_class=HTMLResponse, name="get_session_choice_page", tags=["Pages"])
async def get_session_choice_page(request: Request, user: Optional[Dict] = Depends(auth.get_current_active_user)):
    """Serves the session choice/dashboard page."""
    if not user:
        return RedirectResponse(url="/login", status_code=status.HTTP_302_FOUND)

    session_choice_html_path = config.STATIC_DIR / "session-choice.html"
    if not session_choice_html_path.is_file():
        raise HTTPException(status_code=404, detail="session-choice.html not found.")
    try:
        with open(session_choice_html_path, "r", encoding="utf-8") as f: html_content = f.read()
        # Consider passing user data via context if using a template engine
        # For simple replacement:
        html_content = html_content.replace("[User Name]", user.get("name", "User"))
        return HTMLResponse(content=html_content)
    except Exception as e:
        print(f"Error reading/serving session-choice.html: {e}"); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Error loading session choice page.")


@app.post("/sessions/create", status_code=status.HTTP_303_SEE_OTHER, tags=["Sessions"]) # Use 303 for POST-redirect-GET
async def create_new_session_route(
    request: Request,
    user: Dict[str, Any] = Depends(auth.get_current_active_user)
):
    """Creates a new chat session and redirects to it."""
    if not user: # Should be handled by Depends, but belt-and-suspenders
        raise HTTPException(status_code=401, detail="Not authenticated")

    new_session_id = str(uuid.uuid4())
    host_user_id = user["id"]
    conn = None
    default_session_name = ""

    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()

        # Insert session first
        cursor.execute(
            """INSERT INTO sessions (id, host_user_id, name, is_active) VALUES (?, ?, ?, ?)""",
            (new_session_id, host_user_id, None, True)
        )

        # Get creation timestamp to generate default name
        cursor.execute("SELECT created_at FROM sessions WHERE id = ?", (new_session_id,))
        session_row = cursor.fetchone()

        if not session_row or not session_row["created_at"]:
            default_session_name = f"Session ({new_session_id[:4]})"
            print(f"WARNING: Could not fetch created_at for session {new_session_id}. Using fallback name.")
        else:
            try:
                # Attempt to parse ISO format timestamp (adjust if your DB stores differently)
                created_at_str = session_row["created_at"].replace('Z', '+00:00') # Handle Z for UTC
                created_dt = datetime.datetime.fromisoformat(created_at_str)
                # Format timestamp for default name (adjust format as desired)
                default_session_name = created_dt.strftime("%b %d, %Y %I:%M %p")
            except (ValueError, TypeError) as fmt_err:
                print(f"WARNING: Error formatting timestamp '{session_row['created_at']}': {fmt_err}. Using fallback name.")
                default_session_name = f"Session ({new_session_id[:4]})"

        # Update session name with the generated default
        cursor.execute("UPDATE sessions SET name = ? WHERE id = ?", (default_session_name, new_session_id))

        # Add creator as participant
        cursor.execute(
            "INSERT INTO session_participants (session_id, user_id) VALUES (?, ?)",
            (new_session_id, host_user_id)
        )

        conn.commit()
        print(f"New session created: ID {new_session_id}, Name: '{default_session_name}', Hosted by User ID {host_user_id}")

    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        print(f"Database error creating session: {db_err}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Could not create new session due to a database error.")
    except Exception as e:
        if conn: conn.rollback()
        print(f"Unexpected error creating session: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Could not create new session due to a server error.")
    finally:
        if conn: conn.close()

    chat_url = request.url_for("get_chat_page_for_session", session_id=new_session_id)
    # Use 303 See Other for redirect after POST
    return RedirectResponse(url=str(chat_url), status_code=status.HTTP_303_SEE_OTHER)


@app.get("/chat/{session_id}", response_class=HTMLResponse, name="get_chat_page_for_session", tags=["Pages"])
async def get_chat_page_for_session(
    request: Request,
    session_id: str = FastApiPath(..., description="The ID of the chat session to load."),
    user: Optional[Dict] = Depends(auth.get_current_active_user)
):
    """Serves the chat page for a specific session after verifying access."""
    if not user:
        return RedirectResponse(url="/login", status_code=status.HTTP_302_FOUND)

    user_id = user['id']
    conn = None
    try:
        conn = database.get_db_connection(); cursor = conn.cursor()
        # Verify session exists and is active
        cursor.execute("SELECT id, name FROM sessions WHERE id = ? AND is_active = 1", (session_id,))
        session_row = cursor.fetchone()
        if not session_row:
            raise HTTPException(status_code=404, detail="Chat session not found or is inactive.")
        # Verify user is a participant
        cursor.execute("SELECT 1 FROM session_participants WHERE session_id = ? AND user_id = ?", (session_id, user_id))
        if not cursor.fetchone():
            raise HTTPException(status_code=403, detail="You do not have access to this chat session.")

        # Update last_accessed_at for the session
        current_time_utc_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        cursor.execute("UPDATE sessions SET last_accessed_at = ? WHERE id = ?", (current_time_utc_iso, session_id))
        conn.commit()

        print(f"User {user['email']} accessing chat for session: {session_id}. Last accessed updated.")
    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except Exception as e:
        if conn: conn.rollback()
        print(f"Error verifying session access or updating last_accessed_at: {e}"); traceback.print_exc();
        raise HTTPException(status_code=500, detail="Error verifying session access.")
    finally:
        if conn: conn.close()

    chat_html_path = config.STATIC_DIR / "chat-session.html"
    if not chat_html_path.is_file():
        raise HTTPException(status_code=404, detail="Chat interface file not found.")
    # Consider passing session_name or user_name to the template if needed
    return FileResponse(chat_html_path)


async def handle_chat_message(
    chain: Any,                     # Your LangChain chain
    memory: Any,                    # The conversation memory object
    websocket: WebSocket,
    client_js_id: str,              # Unique ID for the JS client instance
    current_user: Dict[str, Any],   # Authenticated user details
    session_id: str,                # The ID of the chat session
    user_input: str,
    turn_id: int                    # <<< NEW: The turn ID from the frontend
):
    """
    Handles processing a chat message with the LLM, streaming the response,
    and allowing the stream to be stopped.
    """
    user_name = current_user.get('name', 'User')
    user_db_id = current_user['id']
    full_response = ""
    thinking_content = None # Placeholder for future
    
    # --- MODIFIED: Create a unique stream ID and register for stopping ---
    stream_id = f"{client_js_id}_{turn_id}" # Use client_js_id and frontend's turn_id
    stop_event: asyncio.Event = None # Initialize to None

    db_conn_user_msg = None
    try:
        # Save user message to DB (existing logic)
        db_conn_user_msg = database.get_db_connection()
        db_cursor_user_msg = db_conn_user_msg.cursor()
        db_cursor_user_msg.execute(
            """INSERT INTO chat_messages (session_id, user_id, sender_name, sender_type, content, client_id_temp)
               VALUES (?, ?, ?, ?, ?, ?)""",
            (session_id, user_db_id, user_name, 'user', user_input, client_js_id)
        )
        db_conn_user_msg.commit()
    except Exception as db_err:
        print(f"DB ERROR saving user message for session {session_id} (client {client_js_id}, turn {turn_id}): {db_err}")
        if db_conn_user_msg: db_conn_user_msg.rollback()
    finally:
        if db_conn_user_msg: db_conn_user_msg.close()

    try:
        # --- MODIFIED: Register stream and get stop_event ---
        stop_event = await state.register_ai_stream(stream_id)
        print(f"AI STREAM (handle_chat_message): Starting stream {stream_id} for session {session_id}")

        # Stream response using the chain
        async for chunk_data in chain.astream({"input": user_input}):
            # --- MODIFIED: Check stop_event in the loop ---
            if stop_event.is_set():
                print(f"AI STREAM (handle_chat_message): Stop event set for stream {stream_id}. Breaking loop.")
                break # Exit the streaming loop if stop is signaled

            # Extract content (your existing logic for handling chunk_data)
            if isinstance(chunk_data, dict):
                chunk_str = chunk_data.get("answer", "") # Or your relevant key
            else:
                chunk_str = str(chunk_data)

            if websocket.client_state != WebSocketState.CONNECTED:
                print(f"WS: WebSocket disconnected during LLM stream for session {session_id}, stream {stream_id}. Aborting send.")
                return 
            await websocket.send_text(chunk_str)
            full_response += chunk_str
        
        # --- MODIFIED: Check if loop was broken by stop_event before sending EOS ---
        if stop_event.is_set():
            print(f"AI STREAM (handle_chat_message): Stream {stream_id} was stopped by signal. Not sending EOS from here, frontend will finalize.")
            # Frontend's finalizeTurnOnErrorOrClose will handle UI. Backend might send EOS in stop_ai_stream handler.
        elif websocket.client_state == WebSocketState.CONNECTED:
            await websocket.send_text("<EOS>") # Send End-Of-Stream marker if finished naturally
            print(f"AI STREAM (handle_chat_message): Finished streaming naturally for stream {stream_id} to session {session_id}")
        
        # Save context to memory and DB (existing logic)
        memory.save_context({"input": user_input}, {"output": full_response})
        if hasattr(state, 'save_memory_state_to_db'): # Check if function exists
            try:
                state.save_memory_state_to_db(session_id, memory)
            except Exception as save_mem_err:
                print(f"ERROR saving memory state to DB for session {session_id}: {save_mem_err}")
        
        db_conn_ai_msg = None
        try:
            db_conn_ai_msg = database.get_db_connection()
            db_cursor_ai_msg = db_conn_ai_msg.cursor()
            db_cursor_ai_msg.execute(
                """INSERT INTO chat_messages (session_id, user_id, sender_name, sender_type, content, thinking_content, client_id_temp)
                   VALUES (?, ?, ?, ?, ?, ?, ?)""",
                (session_id, None, "AI", 'ai', full_response, thinking_content, client_js_id)
            )
            db_conn_ai_msg.commit()
        except Exception as db_err:
            print(f"DB ERROR saving AI message for session {session_id} (stream {stream_id}): {db_err}")
            if db_conn_ai_msg: db_conn_ai_msg.rollback()
        finally:
            if db_conn_ai_msg: db_conn_ai_msg.close()

    except Exception as chain_exc:
        error_msg = f"<ERROR>LLM Error: Processing your message failed. Details: {chain_exc}"
        print(f"LLM chain error for session {session_id} (stream {stream_id}): {chain_exc}")
        traceback.print_exc()
        if websocket.client_state == WebSocketState.CONNECTED:
            try:
                await websocket.send_text(error_msg)
                # Also send EOS after error to ensure frontend resets UI properly
                await websocket.send_text("<EOS>")
            except Exception as send_err:
                print(f"WS ERROR: Could not send LLM error/EOS to client {client_js_id} for stream {stream_id}: {send_err}")
    finally:
        # --- MODIFIED: Always unregister the stream ---
        if stream_id and stop_event: # Ensure stream_id was formed and event exists
            await state.unregister_ai_stream(stream_id)
            print(f"AI STREAM (handle_chat_message): Stream {stream_id} unregistered for session {session_id}")


@app.websocket("/ws/{session_id_ws}/{client_js_id}")
async def websocket_endpoint(
    websocket: WebSocket,
    session_id_ws: str = FastApiPath(..., title="Session ID", description="The ID of the chat session."),
    client_js_id: str = FastApiPath(..., title="Client JS ID", description="A unique ID generated by the client-side JavaScript.")
):
    """
    Handles WebSocket connections for chat, code execution, and AI stream stopping.
    """
    # Authenticate user via session cookie
    session_token_from_cookie = websocket.cookies.get(auth.SESSION_COOKIE_NAME)
    current_ws_user: Optional[Dict[str, Any]] = None
    if session_token_from_cookie:
        current_ws_user = await auth.get_user_by_session_token(session_token_from_cookie)

    ws_log_prefix_unauth = f"WS ({websocket.client.host}:{websocket.client.port}) session {session_id_ws}, client {client_js_id}:"
    if not current_ws_user:
        print(f"{ws_log_prefix_unauth} Authentication failed. Closing WebSocket.")
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return

    user_id = current_ws_user['id']
    user_email = current_ws_user.get('email', f'UserID_{user_id}')
    ws_log_prefix = f"WS (User: {user_email}, Session: {session_id_ws}, ClientJS: {client_js_id}):"
    print(f"{ws_log_prefix} User authenticated.")

    # Verify session existence and user participation (existing logic)
    conn_verify = None
    is_participant = False
    try:
        conn_verify = database.get_db_connection()
        cursor_verify = conn_verify.cursor()
        cursor_verify.execute("SELECT 1 FROM sessions WHERE id = ? AND is_active = 1", (session_id_ws,))
        if not cursor_verify.fetchone():
            print(f"{ws_log_prefix} Session not found or inactive. Closing.")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
            return
        cursor_verify.execute("SELECT 1 FROM session_participants WHERE session_id = ? AND user_id = ?", (session_id_ws, user_id))
        is_participant = cursor_verify.fetchone() is not None
        if not is_participant:
            print(f"{ws_log_prefix} User NOT participant. Closing.")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
            return
    except Exception as e:
        print(f"{ws_log_prefix} DB error verifying participation: {e}")
        traceback.print_exc()
        await websocket.close(code=status.WS_1011_INTERNAL_ERROR)
        return
    finally:
        if conn_verify: conn_verify.close()
    print(f"{ws_log_prefix} User confirmed participant.")

    try:
        await websocket.accept()
        print(f"{ws_log_prefix} WebSocket connection accepted.")
    except Exception as accept_err:
        print(f"{ws_log_prefix} Error accepting WebSocket: {accept_err}")
        return

    memory = state.get_memory_for_client(session_id_ws)
    def load_memory_for_current_session(_ignored_input_map=None):
        return memory.load_memory_variables({}).get("history", [])
    
    chain: Any
    try:
        chain = llm.create_chain(load_memory_for_current_session)
        print(f"{ws_log_prefix} LLM chain created.")
    except Exception as chain_init_error:
        print(f"{ws_log_prefix} ERROR creating LCEL chain: {chain_init_error}")
        traceback.print_exc()
        if websocket.client_state == WebSocketState.CONNECTED:
            await websocket.send_json({"type": "error", "payload": {"message": "Server error: Could not initialize chat."}})
        await websocket.close(code=status.WS_1011_INTERNAL_ERROR)
        return

    try:
        while True:
            if websocket.client_state != WebSocketState.CONNECTED:
                print(f"{ws_log_prefix} WebSocket no longer connected. Breaking loop.")
                break

            received_data = await websocket.receive_text()
            
            try:
                message_data = json.loads(received_data)
                message_type = message_data.get("type")
                payload = message_data.get("payload")

                if message_type == "chat_message" and payload: # Expect chat messages in this format
                    user_input = payload.get("user_input")
                    turn_id = payload.get("turn_id") # Get turn_id from payload
                    if user_input is not None and turn_id is not None:
                        print(f"{ws_log_prefix} Received 'chat_message' for turn {turn_id}.")
                        # Create a task for handle_chat_message so it doesn't block the receive loop
                        asyncio.create_task(
                            handle_chat_message(chain, memory, websocket, client_js_id, current_ws_user, session_id_ws, user_input, turn_id)
                        )
                    else:
                        print(f"{ws_log_prefix} Invalid 'chat_message' payload: {payload}")
                        if websocket.client_state == WebSocketState.CONNECTED:
                             await websocket.send_text("<ERROR>Invalid chat message payload from client.")
                             await websocket.send_text("<EOS>")


                elif message_type == "run_code" and payload and payload.get("code_block_id"):
                    language = payload.get("language")
                    code = payload.get("code")
                    code_block_id = payload.get("code_block_id")
                    print(f"{ws_log_prefix} Received 'run_code' for block {code_block_id}.")
                    if language and code is not None:
                        asyncio.create_task(docker_utils.run_code_in_docker_stream(websocket, client_js_id, code_block_id, language, code))
                    else:
                        print(f"{ws_log_prefix} Invalid 'run_code' payload for block {code_block_id}.")
                        if websocket.client_state == WebSocketState.CONNECTED: # Check connection before sending
                            await websocket.send_json({"type": "code_finished", "payload": {"code_block_id": code_block_id, "exit_code": -1, "error": "Invalid run_code payload."}})
                
                elif message_type == "stop_code" and payload and payload.get("code_block_id"):
                    code_block_id = payload.get("code_block_id")
                    print(f"{ws_log_prefix} Received 'stop_code' for block {code_block_id}.")
                    asyncio.create_task(docker_utils.stop_docker_container(code_block_id))

                # --- ADDED: Handler for stop_ai_stream ---
                elif message_type == "stop_ai_stream" and payload:
                    stop_client_id = payload.get("client_id") # This should match client_js_id
                    stop_session_id = payload.get("session_id") # This should match session_id_ws
                    stop_turn_id = payload.get("turn_id")

                    if stop_client_id == client_js_id and stop_session_id == session_id_ws and stop_turn_id is not None:
                        stream_id_to_stop = f"{stop_client_id}_{stop_turn_id}"
                        print(f"{ws_log_prefix} Received 'stop_ai_stream' for stream ID: {stream_id_to_stop}")
                        stopped = await state.signal_stop_ai_stream(stream_id_to_stop)
                        if stopped:
                            print(f"{ws_log_prefix} Successfully signaled stop for stream {stream_id_to_stop}.")
                            # The stream itself in handle_chat_message will break and not send further chunks.
                            # The frontend's finalizeTurnOnErrorOrClose already handles UI reset.
                            # Optionally, send an explicit <EOS> here if the stream might not have sent one
                            # due to abrupt stop, though frontend finalization should cover it.
                            # if websocket.client_state == WebSocketState.CONNECTED:
                            #     await websocket.send_text("<EOS>") # Consider if this is needed or causes double EOS
                        else:
                            print(f"{ws_log_prefix} Failed to signal stop or stream {stream_id_to_stop} not found.")
                    else:
                        print(f"{ws_log_prefix} Received 'stop_ai_stream' with mismatched IDs or missing turn_id: {payload}")
                # --- END OF ADDED ---
                
                else:
                    print(f"{ws_log_prefix} Received unknown JSON command type '{message_type}' or invalid payload.")
                    # Optionally send an error back to the client
                    if websocket.client_state == WebSocketState.CONNECTED:
                        await websocket.send_text(f"<ERROR>Unknown command type: {message_type}")
                        await websocket.send_text("<EOS>")


            except json.JSONDecodeError:
                # Handle plain text messages (old format, or if client sends non-JSON by mistake)
                # For simplicity, we might decide to phase out plain text and require JSON for chat.
                # If supporting plain text, you'd call handle_chat_message without a turn_id or generate one.
                print(f"{ws_log_prefix} Received non-JSON data, treating as legacy chat or error: {received_data[:100]}...")
                # For now, let's assume chat messages should be JSON. Send an error.
                if websocket.client_state == WebSocketState.CONNECTED:
                    await websocket.send_text("<ERROR>Invalid message format. Expected JSON.")
                    await websocket.send_text("<EOS>")
            
            except Exception as handler_exc:
                print(f"{ws_log_prefix} ERROR handling received message: {handler_exc}")
                traceback.print_exc()
                if websocket.client_state == WebSocketState.CONNECTED:
                    try:
                        await websocket.send_text(f"<ERROR>Server error processing your request: {handler_exc}")
                        await websocket.send_text("<EOS>") # Ensure UI resets
                    except Exception as send_err_inner:
                         print(f"{ws_log_prefix} ERROR sending error to client: {send_err_inner}")


    except WebSocketDisconnect:
        print(f"{ws_log_prefix} WebSocket disconnected by client.")
    except Exception as e:
        print(f"{ws_log_prefix} ERROR in WebSocket main loop: {e}")
        traceback.print_exc()
        if websocket.client_state == WebSocketState.CONNECTED:
            try: await websocket.close(code=status.WS_1011_INTERNAL_ERROR)
            except Exception: pass
    finally:
        print(f"{ws_log_prefix} Cleaning up resources...")
        # state.remove_memory_for_client(session_id_ws) # Memory is persisted per session, not removed on disconnect
        await docker_utils.cleanup_client_containers(client_js_id) # Cleanup Docker containers for this JS client instance
        
        # Ensure any AI streams specifically associated with this client_js_id are cleaned up
        # This is a more complex cleanup if multiple turns could be "active" for stopping.
        # For now, unregister_ai_stream is called in handle_chat_message's finally block.
        # A more robust cleanup might iterate through state.active_ai_streams if keys include client_js_id.

        if websocket.client_state == WebSocketState.CONNECTED:
            try: await websocket.close(code=status.WS_1000_NORMAL_CLOSURE)
            except Exception as final_close_err: print(f"{ws_log_prefix} Error during final WebSocket close: {final_close_err}")
        print(f"{ws_log_prefix} Cleanup complete.")

# --- API Routes for Sessions & Messages ---

@app.patch("/api/sessions/{session_id}", response_model=Dict[str, Any], tags=["Sessions"])
async def rename_session(
    session_id: str = FastApiPath(..., description="The ID of the session to rename."),
    update_data: models.SessionUpdateRequest = Body(...),
    user: Dict[str, Any] = Depends(auth.get_current_active_user)
):
    """Updates the name of a specific chat session."""
    if not user: raise HTTPException(status_code=401, detail="Not authenticated")
    user_id = user['id']; new_name = update_data.name.strip()
    if not new_name: raise HTTPException(status_code=400, detail="Session name cannot be empty.")
    conn = None
    try:
        conn = database.get_db_connection(); cursor = conn.cursor()
        # Verify user is participant in the active session
        cursor.execute(
            """SELECT s.id FROM sessions s JOIN session_participants sp ON s.id = sp.session_id
               WHERE s.id = ? AND sp.user_id = ? AND s.is_active = 1""",
            (session_id, user_id)
        )
        if not cursor.fetchone(): raise HTTPException(status_code=404, detail="Session not found or user lacks permission.")
        # Update the name
        cursor.execute("UPDATE sessions SET name = ? WHERE id = ?", (new_name, session_id))
        if cursor.rowcount == 0:
            conn.rollback(); raise HTTPException(status_code=404, detail="Session not found during update.")
        conn.commit()
        print(f"API: Renamed session {session_id} to '{new_name}' for user ID {user_id}")
        return {"id": session_id, "name": new_name, "message": "Session renamed successfully"}
    except sqlite3.Error as db_err:
        if conn: conn.rollback(); print(f"API ERROR (/api/sessions/{session_id} PATCH): DB error: {db_err}"); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Database error renaming session.")
    except HTTPException as http_exc: raise http_exc
    except Exception as e:
        if conn: conn.rollback(); print(f"API ERROR (/api/sessions/{session_id} PATCH): Unexpected error: {e}"); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Server error renaming session.")
    finally:
        if conn: conn.close()


@app.get("/api/sessions", response_model=List[Dict[str, Any]], tags=["Sessions"])
async def get_user_sessions(
    user: Dict[str, Any] = Depends(auth.get_current_active_user)
):
    """Fetches sessions the current user participates in, ordered by last active."""
    if not user: raise HTTPException(status_code=401, detail="Not authenticated")
    user_id = user['id']; sessions_list = []
    conn = None
    try:
        conn = database.get_db_connection(); cursor = conn.cursor()
        cursor.execute(
            """SELECT s.id, s.name, s.last_accessed_at AS last_active
               FROM sessions s JOIN session_participants sp ON s.id = sp.session_id
               WHERE sp.user_id = ? AND s.is_active = 1
               ORDER BY s.last_accessed_at DESC""",
            (user_id,)
        )
        rows = cursor.fetchall()
        for row in rows: sessions_list.append(dict(row))
        # print(f"API: Fetched {len(sessions_list)} sessions for user ID {user_id}") # Verbose
        return sessions_list
    except sqlite3.Error as db_err:
        print(f"API ERROR (/api/sessions): DB error for user {user_id}: {db_err}"); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Database error fetching sessions.")
    except Exception as e:
        print(f"API ERROR (/api/sessions): Unexpected error for user {user_id}: {e}"); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Server error fetching sessions.")
    finally:
        if conn: conn.close()


@app.get("/api/sessions/{session_id}/messages", response_model=List[Dict[str, Any]], tags=["Messages"])
async def get_chat_messages_for_session(
    session_id: str = FastApiPath(..., description="The ID of the session to fetch messages for."),
    user: Dict[str, Any] = Depends(auth.get_current_active_user)
):
    """Fetches all messages for a session the user participates in."""
    if not user: raise HTTPException(status_code=401, detail="Not authenticated")
    user_id = user['id']; messages_list = []
    conn = None
    try:
        conn = database.get_db_connection(); cursor = conn.cursor()
        # Verify session exists and user is participant
        cursor.execute("SELECT 1 FROM sessions WHERE id = ? AND is_active = 1", (session_id,))
        if not cursor.fetchone(): raise HTTPException(status_code=404, detail="Session not found or inactive.")
        cursor.execute("SELECT 1 FROM session_participants WHERE session_id = ? AND user_id = ?", (session_id, user_id))
        if not cursor.fetchone(): raise HTTPException(status_code=403, detail="Access denied to this session.")
        # Fetch messages
        cursor.execute(
            """SELECT id, session_id, user_id, sender_name, sender_type, content, client_id_temp, thinking_content, timestamp
               FROM chat_messages WHERE session_id = ? ORDER BY timestamp ASC""",
            (session_id,)
        )
        rows = cursor.fetchall()
        for row in rows: messages_list.append(dict(row))
        # print(f"API: Fetched {len(messages_list)} messages for session {session_id} for user ID {user_id}") # Verbose
        return messages_list
    except sqlite3.Error as db_err:
        print(f"API ERROR (/api/sessions/.../messages): DB error for user {user_id}, session {session_id}: {db_err}"); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Database error fetching messages.")
    except HTTPException as http_exc: raise http_exc
    except Exception as e:
        print(f"API ERROR (/api/sessions/.../messages): Unexpected error for user {user_id}, session {session_id}: {e}"); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Server error fetching messages.")
    finally:
        if conn: conn.close()


@app.delete("/api/sessions/{session_id}", status_code=status.HTTP_204_NO_CONTENT, tags=["Sessions"])
async def delete_session_route(
    session_id: str = FastApiPath(..., description="The ID of the session to delete."),
    user: Dict[str, Any] = Depends(auth.get_current_active_user)
):
    """Deletes a session if the user is the host."""
    if not user: raise HTTPException(status_code=401, detail="Not authenticated")
    user_id = user['id']; conn = None
    try:
        conn = database.get_db_connection(); cursor = conn.cursor()
        # Verify session exists, is active, and user is the host
        cursor.execute("SELECT host_user_id FROM sessions WHERE id = ? AND is_active = 1", (session_id,))
        session_row = cursor.fetchone()
        if not session_row: raise HTTPException(status_code=404, detail="Session not found or inactive.")
        if session_row["host_user_id"] != user_id: raise HTTPException(status_code=403, detail="Only the session host can delete it.")
        # Delete the session (cascades should handle participants, messages, memory)
        cursor.execute("DELETE FROM sessions WHERE id = ?", (session_id,))
        if cursor.rowcount == 0:
            conn.rollback(); raise HTTPException(status_code=404, detail="Session found but could not be deleted.")
        conn.commit()
        print(f"API: Deleted session {session_id} by host user ID {user_id}")
        return # Return None for 204 No Content status
    except sqlite3.Error as db_err:
        if conn: conn.rollback(); print(f"API ERROR (DELETE /api/sessions/{session_id}): DB error: {db_err}"); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Database error deleting session.")
    except HTTPException as http_exc:
        if conn: conn.rollback() # Rollback on permission errors etc. if transaction started
        raise http_exc
    except Exception as e:
        if conn: conn.rollback(); print(f"API ERROR (DELETE /api/sessions/{session_id}): Unexpected error: {e}"); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Server error deleting session.")
    finally:
        if conn: conn.close()


def start_server():
    """Configures and starts the Uvicorn server, attempting to open the browser."""
    host = os.getenv("HOST", "127.0.0.1")
    port = int(os.getenv("PORT", 8001))
    url = f"http://{host}:{port}"

    print("-" * 30)
    print(f"Tesseracs Chat Server Starting...")
    print(f"Access via: {url}/login")
    print(f"Using Config: Model='{config.MODEL_ID}', Ollama='{config.OLLAMA_BASE_URL}'")
    # Make sure dist_dir is defined or accessible if needed here, or remove this print
    # print(f"Static files from: {config.STATIC_DIR}, Bundles from: {dist_dir}") # dist_dir might not be in scope here
    print("-" * 30)

    # --- UNCOMMENTED THIS SECTION ---
    try:
        # Attempt to open the login page in the default web browser
        print(f"Attempting to open {url}/login in default browser...")
        webbrowser.open(f"{url}/login")
    except Exception as browser_err:
        # Log a warning if opening the browser fails, but continue starting the server
        print(f"Warning: Could not automatically open browser: {browser_err}")
    # --- END UNCOMMENTED SECTION ---

    # Start the Uvicorn server
    # reload=True is useful for development, consider removing for production
    uvicorn.run("app.main:app", host=host, port=port, log_level="info", reload=True)

if __name__ == "__main__":
    start_server()


=== app/models.py ===
# app/models.py
from pydantic import BaseModel, Field, EmailStr, StringConstraints # Removed constr, Added StringConstraints
from typing import Optional, List, Dict, Any, Pattern, Annotated # Added Annotated

# --- Authentication & User Models ---
class Token(BaseModel):
    access_token: str
    token_type: str
    user_id: Optional[int] = None
    user_name: Optional[str] = None
    user_email: Optional[EmailStr] = None

class UserResponseModel(BaseModel): # For /api/me
    id: int
    name: str
    email: EmailStr

class EmailCheckRequest(BaseModel):
    email: EmailStr

class EmailCheckResponse(BaseModel):
    exists: bool
    user_name: Optional[str] = None

class RegistrationRequest(BaseModel):
    email: EmailStr
    # Using Annotated with StringConstraints for Pydantic V2
    name: Annotated[str, StringConstraints(strip_whitespace=True, min_length=1, max_length=100)]

class RegistrationResponse(BaseModel):
    message: str

class ForgotPasswordRequest(BaseModel):
    email: EmailStr

class ForgotPasswordResponse(BaseModel):
    message: str

class UpdateNameRequest(BaseModel):
    # Correct Pydantic V2 way to apply string constraints
    new_name: Annotated[str, StringConstraints(strip_whitespace=True, min_length=1, max_length=100)]
    current_password: str = Field(..., min_length=1) # min_length for string fields is fine with Field

class UpdateNameResponse(BaseModel):
    message: str
    new_name: str

class RegeneratePasswordRequest(BaseModel):
    current_password: str = Field(..., min_length=1, description="The user's current password for verification.")

class RegeneratePasswordResponse(BaseModel):
    message: str # e.g., "Password regenerated successfully. An email has been sent with your new password. You will now be logged out."

# --- ADDED: Models for Update Email (User Settings) ---
class UpdateEmailRequest(BaseModel):
    new_email: EmailStr # Ensures the new email is in a valid format.
    current_password: str = Field(..., min_length=1, description="The user's current password for verification.")

class UpdateEmailResponse(BaseModel):
    message: str # e.g., "Email updated successfully. You will now be logged out."
    new_email: EmailStr
# --- END OF ADDED Models ---


# --- Session & Message Models (from app/main.py context) ---
class SessionUpdateRequest(BaseModel):
    # Correct Pydantic V2 way for name field here as well
    name: Annotated[str, StringConstraints(strip_whitespace=True, min_length=1, max_length=100)]

# If you have Pydantic models for session lists or message lists, they would go here too.
# For example, if you decide to type the response for /api/sessions:
class SessionListItem(BaseModel):
    id: str
    name: Optional[str] = None # Name can be None initially
    last_active: Optional[str] = None # Or datetime, adjust as per your DB/API response

class SessionListResponse(BaseModel): # Example, not currently used in main.py
    sessions: List[SessionListItem]

# Example for /api/sessions/{session_id}/messages response items
class MessageItem(BaseModel): # Example, not currently used in main.py
    id: int
    session_id: str
    user_id: Optional[int] = None
    sender_name: Optional[str] = None
    sender_type: str # 'user', 'ai', 'system', 'anon_user'
    content: str
    client_id_temp: Optional[str] = None
    thinking_content: Optional[str] = None
    timestamp: str # Or datetime

class MessageListResponse(BaseModel): # Example, not currently used in main.py
    messages: List[MessageItem]

# Add any other Pydantic models your application uses or will use.


=== app/state.py ===
# app/state.py

import asyncio
import json
import sqlite3
import datetime
from langchain.memory import ConversationBufferMemory
from langchain_core.messages import messages_from_dict, messages_to_dict
from typing import Dict, Any, Optional # Added Optional
from . import database

# In-memory storage for client-specific conversation memory
client_memory: Dict[str, ConversationBufferMemory] = {}

# --- MODIFIED: Global state for WebSocket Connections and Running Containers (from your original temp.py) ---
# This was for Docker code execution, ensure it's still relevant or adapt as needed.
# For AI stream stopping, we'll add a new structure.
running_containers: Dict[str, Dict[str, Any]] = {} # For Docker code execution
running_containers_lock = asyncio.Lock() # Lock for running_containers

# --- ADDED: For managing active AI streaming tasks ---
# Stores asyncio.Event objects for active AI streams, keyed by a unique stream ID (e.g., f"{client_js_id}_{turn_id}")
# Each event, when set, signals the corresponding AI stream to stop.
active_ai_streams: Dict[str, asyncio.Event] = {}
active_ai_streams_lock = asyncio.Lock() # Lock for safe concurrent access to active_ai_streams
# --- END OF ADDED ---


def get_memory_for_client(session_id: str) -> ConversationBufferMemory:
    """
    Retrieves or creates ConversationBufferMemory for a specific session_id.
    Loads from DB if available, otherwise creates a new one.
    """
    global client_memory
    if session_id in client_memory:
        return client_memory[session_id]

    # Attempt to load from database
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            "SELECT memory_state_json FROM session_memory_state WHERE session_id = ?",
            (session_id,)
        )
        row = cursor.fetchone()

        if row and row["memory_state_json"]:
            try:
                memory_data_list = json.loads(row["memory_state_json"]) # Expecting a list of message dicts
                if isinstance(memory_data_list, list):
                    # Create a new memory instance
                    memory_instance = ConversationBufferMemory(
                        return_messages=True, 
                        memory_key="history"
                    )
                    # Load messages into the new instance
                    loaded_messages = messages_from_dict(memory_data_list)
                    memory_instance.chat_memory.messages = loaded_messages
                    
                    client_memory[session_id] = memory_instance
                    print(f"STATE: Memory loaded from DB for session {session_id}")
                    return memory_instance
                else:
                    print(f"STATE WARNING: Memory data for session {session_id} is not a list. Creating new memory.")
            except (json.JSONDecodeError, TypeError, Exception) as e:
                # Catch TypeError if messages_from_dict fails, or other errors
                print(f"STATE ERROR: Failed to load/parse memory for session {session_id} from DB: {e}. Creating new memory.")
                # Fall through to create new memory
    except sqlite3.Error as db_err:
        print(f"STATE DB ERROR: Could not query session_memory_state for session {session_id}: {db_err}")
        # Fall through to create new memory
    finally:
        if conn:
            conn.close()

    # If not found in cache or DB, or if loading failed, create new memory
    print(f"STATE: Creating new memory for session {session_id}")
    new_memory = ConversationBufferMemory(return_messages=True, memory_key="history")
    client_memory[session_id] = new_memory
    return new_memory

def save_memory_state_to_db(session_id: str, memory: Optional[ConversationBufferMemory]):
    """
    Saves the current state of the ConversationBufferMemory to the database for a given session_id.
    """
    if not memory:
        print(f"STATE WARNING: Attempted to save null memory for session {session_id}. Skipping.")
        return

    conn = None
    try:
        # Get messages from memory and convert to a list of dictionaries
        messages = memory.chat_memory.messages
        memory_state_list = messages_to_dict(messages) # Should return List[Dict[str, Any]]
        memory_state_json = json.dumps(memory_state_list) # Serialize the list of dicts
        
        current_time_utc = datetime.datetime.now(datetime.timezone.utc).isoformat()

        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            """
            INSERT OR REPLACE INTO session_memory_state 
            (session_id, memory_state_json, updated_at) 
            VALUES (?, ?, ?)
            """,
            (session_id, memory_state_json, current_time_utc)
        )
        conn.commit()
        # print(f"STATE: Memory saved to DB for session {session_id}") # Can be verbose
    except (json.JSONDecodeError, sqlite3.Error, Exception) as e:
        # Catch potential errors during serialization or DB operation
        print(f"STATE ERROR: Failed to save memory state to DB for session {session_id}: {e}")
        if conn:
            conn.rollback()
    finally:
        if conn:
            conn.close()

def remove_memory_for_client(session_id: str):
    """Removes memory for a specific session_id from the in-memory cache."""
    global client_memory
    if session_id in client_memory:
        del client_memory[session_id]
        print(f"STATE: Memory removed from cache for session {session_id}")

# --- ADDED: Functions to manage AI stream stop events ---
async def register_ai_stream(stream_id: str) -> asyncio.Event:
    """
    Registers a new AI stream and returns an event to signal its stopping.
    """
    async with active_ai_streams_lock:
        if stream_id in active_ai_streams:
            # This case should ideally be handled (e.g., stop previous before starting new)
            # or ensure stream_ids are unique enough (e.g., include a UUID).
            print(f"STATE WARNING: Stream ID {stream_id} already registered. Overwriting stop event.")
        stop_event = asyncio.Event()
        active_ai_streams[stream_id] = stop_event
        print(f"STATE: AI stream {stream_id} registered for stopping.")
        return stop_event

async def unregister_ai_stream(stream_id: str):
    """
    Unregisters an AI stream, typically when it finishes or is stopped.
    """
    async with active_ai_streams_lock:
        if stream_id in active_ai_streams:
            del active_ai_streams[stream_id]
            print(f"STATE: AI stream {stream_id} unregistered.")
        else:
            print(f"STATE WARNING: Attempted to unregister non-existent AI stream {stream_id}.")

async def signal_stop_ai_stream(stream_id: str):
    """
    Sets the stop event for a given AI stream ID, if it exists.
    """
    async with active_ai_streams_lock:
        stop_event = active_ai_streams.get(stream_id)
        if stop_event:
            stop_event.set()
            print(f"STATE: Stop signal sent to AI stream {stream_id}.")
            return True
        else:
            print(f"STATE WARNING: Attempted to signal stop for non-existent AI stream {stream_id}.")
            return False
# --- END OF ADDED ---


=== app/utils.py ===
# app/utils.py
import json
import traceback
from fastapi import WebSocket, WebSocketDisconnect
from fastapi.websockets import WebSocketState

async def send_ws_message(websocket: WebSocket, message_type: str, payload: dict):
    """Safely sends a JSON message over the WebSocket."""
    # Check state before sending (no change needed here)
    if websocket.client_state != WebSocketState.CONNECTED:
        print(f"[utils] WebSocket not connected, cannot send {message_type} for {payload.get('code_block_id', 'N/A')}")
        return
    try:
        await websocket.send_json({"type": message_type, "payload": payload})
    except WebSocketDisconnect:
        print(f"[utils] WebSocket disconnected while trying to send {message_type} for {payload.get('code_block_id', 'N/A')}")
    except Exception as e:
        # Catch other potential errors like Runtime Error if connection closed during send
        print(f"[utils] Error sending WebSocket message ({message_type}) for {payload.get('code_block_id', 'N/A')}: {e}")
        # traceback.print_exc() # Optional: uncomment for more detail

=== app/static/_sidebar.html ===
<div class="p-4 border-b border-gray-700 flex items-center justify-between">
    <h2 class="text-xl font-semibold text-white">Tesseracs</h2>
    <a href="/" title="Home" class="text-gray-400 hover:text-white">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path></svg>
    </a>
</div>

<nav class="flex-1 p-4 space-y-2 sidebar-scrollable">
    <form action="/sessions/create" method="POST" class="mb-4" id="new-chat-form-sidebar">
        <button type="submit" class="w-full flex items-center justify-center px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-md text-white font-medium transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
            New Chat
        </button>
    </form>

    <div class="text-sm text-gray-400 uppercase tracking-wider mb-2">Sessions</div>
    <ul id="session-list" class="space-y-1">
        <li class="px-3 py-1 text-gray-400 italic text-sm">Loading sessions...</li>
    </ul>

    <div class="mt-auto pt-4 border-t border-gray-700">
        <a href="/settings" id="settings-link-sidebar" class="flex items-center px-3 py-2 text-gray-300 hover:bg-gray-700 hover:text-white rounded-md text-sm">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826 3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
            Settings
        </a>
    </div>
</nav>

<div class="p-4 border-t border-gray-700">
    <a href="/logout" id="logout-link-sidebar" class="flex items-center justify-center w-full px-4 py-2 border border-gray-600 hover:bg-gray-700 rounded-md text-sm font-medium text-gray-300 hover:text-white transition duration-150 ease-in-out">
        Logout
    </a>
</div>


=== app/static/chat-session.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tesseracs Chat Session</title>
    <link rel="stylesheet" href="/dist/input.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        .sidebar-scrollable { overflow-y: auto; scrollbar-width: thin; scrollbar-color: #a0aec0 #edf2f7; }
        .sidebar-scrollable::-webkit-scrollbar { width: 6px; }
        .sidebar-scrollable::-webkit-scrollbar-track { background: #edf2f7; border-radius: 3px; }
        .sidebar-scrollable::-webkit-scrollbar-thumb { background-color: #a0aec0; border-radius: 3px; border: 1px solid #edf2f7; }
        
        /* Style for the Stop button */
        #stop-ai-button {
            background-color: #ef4444; /* Tailwind red-500 */
            color: white;
            padding: 0.5rem 1rem; /* py-2 px-4 */
            border-radius: 0.5rem; /* rounded-lg */
            font-weight: bold;
            transition: background-color 0.15s ease-in-out;
            margin-left: 0.5rem; /* space-x-2 equivalent */
        }
        #stop-ai-button:hover {
            background-color: #dc2626; /* Tailwind red-600 */
        }
        #stop-ai-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body class="font-sans bg-gray-100 text-gray-800">

    <div class="flex h-screen overflow-hidden">
        <aside id="sidebar-loader-target" class="w-64 bg-gray-800 text-gray-200 flex flex-col overflow-hidden">
            </aside>

        <main class="flex-1 flex flex-col overflow-hidden">
            <header class="bg-white border-b border-gray-200 p-4 shadow-sm">
                <h1 id="chat-session-title" class="text-lg font-semibold text-gray-800">Chat Session</h1>
            </header>
            <div id="chat-history" class="flex-1 overflow-y-auto p-4 space-y-4 bg-white shadow-inner m-4 rounded-lg">
                </div>
            <footer class="p-4 bg-gray-200 border-t border-gray-300">
                <form id="chat-form" class="flex items-center space-x-2">
                    <div class="think-checkbox-container flex items-center text-sm text-gray-600 mr-2">
                        <input type="checkbox" id="think-checkbox" class="mr-1 h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 cursor-pointer">
                        <label for="think-checkbox" class="cursor-pointer select-none">Think</label>
                    </div>
                    <input type="text" id="message-input" placeholder="Type your message..." autocomplete="off" required
                           class="flex-1 p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                    <button type="submit" id="send-button"
                            class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                        Send
                    </button>
                    <button type="button" id="stop-ai-button" class="hidden">
                        <svg class="w-5 h-5 inline-block mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1zm4 0a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                        Stop
                    </button>
                </form>
            </footer>
        </main>
    </div>

    <script type="module">
        import { loadSidebarHTML, populateSessionList } from '/static/js/app-ui.js';

        document.addEventListener('DOMContentLoaded', async () => {
            console.log("Chat Session Page: DOMContentLoaded. Attempting to load UI components.");
            const sidebarLoaded = await loadSidebarHTML('/static/_sidebar.html', 'sidebar-loader-target');
            if (sidebarLoaded) {
                await populateSessionList('/api/sessions', 'session-list', '/chat/');
            } else {
                console.error("Chat Session Page: Sidebar loading failed, session list will not be populated by app-ui.js.");
            }
        });
    </script>
    <script src="/dist/script.js" defer></script> 
</body>
</html>


=== app/static/input.css ===
--- CONTENT EXCLUDED (listed in exclude_files) ---


=== app/static/login.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Login - Tesseracs Chat</title>
    <link rel="stylesheet" href="/dist/input.css">
    <style>
        /* Simple class to hide elements */
        .hidden-field {
            display: none !important; /* Use !important to ensure override if other styles conflict */
        }
        /* Style for the forgot password link */
        .forgot-password-link {
            display: block; /* Make it block to appear below the password field */
            text-align: right;
            font-size: 0.875rem; /* text-sm */
            color: #4b5563; /* text-gray-600 */
            text-decoration: none;
            margin-top: 0.5rem; /* Add some space above the link */
            margin-bottom: 1.25rem; /* Keep bottom margin for spacing below */
        }
        .forgot-password-link:hover {
            color: #1d4ed8; /* hover:text-blue-700 */
            text-decoration: underline;
        }
        /* Style for the "Change Email" button */
        .change-email-button {
            display: block;
            width: auto; /* Fit content */
            margin-top: 0.75rem; /* Space above */
            margin-left: auto; /* Align to the right if container allows */
            margin-right: auto; /* Center if container is flex/grid and justifies center */
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            color: #4b5563; /* text-gray-600 */
            background-color: #f3f4f6; /* Tailwind gray-100 */
            border: 1px solid #d1d5db; /* Tailwind gray-300 */
            border-radius: 0.375rem; /* rounded-md */
            cursor: pointer;
            text-align: center;
        }
        .change-email-button:hover {
            background-color: #e5e7eb; /* Tailwind gray-200 */
        }
    </style>
</head>
<body class="flex flex-col justify-center items-center min-h-screen bg-gray-100 font-sans p-4">
    <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-md">
        <h1 class="text-center mb-6 text-2xl font-semibold text-gray-900">Tesseracs Chat</h1>

        <div id="message-area" class="p-3 rounded-md text-sm text-center mb-4" style="display: none;"></div>

        <form id="auth-form" class="mt-4">
            <div class="mb-5">
                <label for="email" class="block mb-2 text-sm font-medium text-gray-700">Email:</label>
                <input type="email" id="email" name="email" required autocomplete="email" class="block w-full py-2.5 px-3 border border-gray-300 rounded-md text-sm transition-colors duration-200 ease-in-out focus:border-blue-600 focus:ring-2 focus:ring-blue-300 focus:outline-none">
            </div>

            <div id="password-field-container" class="mb-5 hidden-field">
                <label for="password" class="block mb-2 text-sm font-medium text-gray-700">Password:</label>
                <input type="password" id="password" name="password" autocomplete="current-password" class="block w-full py-2.5 px-3 border border-gray-300 rounded-md text-sm transition-colors duration-200 ease-in-out focus:border-blue-600 focus:ring-2 focus:ring-blue-300 focus:outline-none">
                <a href="#" id="forgot-password-link" class="forgot-password-link">Forgot Password?</a>
            </div>

            <div id="name-field-container" class="mb-5 hidden-field">
                <label for="name" class="block mb-2 text-sm font-medium text-gray-700">Full Name:</label>
                <input type="text" id="name" name="name" autocomplete="name" class="block w-full py-2.5 px-3 border border-gray-300 rounded-md text-sm transition-colors duration-200 ease-in-out focus:border-blue-600 focus:ring-2 focus:ring-blue-300 focus:outline-none">
            </div>

            <button type="submit" id="submit-button" class="w-full py-3 bg-blue-600 text-white rounded-md text-sm font-medium cursor-pointer transition-colors duration-200 ease-in-out hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed">Continue</button>

            <button type="button" id="change-email-button" class="change-email-button hidden-field">Change Email / Start Over</button>
        </form>

        <p id="form-instructions" class="text-xs text-center mt-6 text-gray-500">
            Enter your email to log in or create an account.
        </p>
    </div>

    <script>
        // --- DOM Element References ---
        const authForm = document.getElementById('auth-form');
        const emailInput = document.getElementById('email');
        const nameInput = document.getElementById('name');
        const passwordInput = document.getElementById('password');
        const nameFieldContainer = document.getElementById('name-field-container');
        const passwordFieldContainer = document.getElementById('password-field-container');
        const submitButton = document.getElementById('submit-button');
        const messageArea = document.getElementById('message-area');
        const formInstructions = document.getElementById('form-instructions');
        const forgotPasswordLink = document.getElementById('forgot-password-link');
        const changeEmailButton = document.getElementById('change-email-button');

        // --- State Management ---
        // Possible states: 'initial_email', 'login_password', 'register_name', 'forgot_password_prompt', 'login_after_registration', 'login_after_password_reset'
        let formState = 'initial_email';
        let cachedEmail = ''; // Used for pre-filling email after registration or password reset

        // --- UI Update Function ---
        function updateUIForState() {
            // Reset fields visibility and requirements first
            passwordFieldContainer.classList.add('hidden-field');
            nameFieldContainer.classList.add('hidden-field');
            forgotPasswordLink.classList.add('hidden-field'); // Hide by default
            changeEmailButton.classList.add('hidden-field'); // Hide by default

            passwordInput.required = false;
            nameInput.required = false;
            emailInput.readOnly = false; // Make email editable by default
            submitButton.disabled = false; // Enable button by default, specific states will adjust

            switch (formState) {
                case 'initial_email':
                    emailInput.value = '';
                    passwordInput.value = '';
                    nameInput.value = '';
                    cachedEmail = ''; // Clear cached email
                    submitButton.textContent = 'Continue';
                    formInstructions.textContent = 'Enter your email to log in or create an account.';
                    submitButton.disabled = emailInput.value.trim() === '';
                    emailInput.focus();
                    break;
                case 'login_password':
                    passwordFieldContainer.classList.remove('hidden-field');
                    forgotPasswordLink.classList.remove('hidden-field');
                    changeEmailButton.classList.remove('hidden-field');
                    passwordInput.required = true;
                    emailInput.readOnly = true;
                    submitButton.textContent = 'Login';
                    formInstructions.textContent = 'Enter your password to log in.';
                    passwordInput.value = '';
                    submitButton.disabled = true; // Password field is empty
                    passwordInput.focus();
                    break;
                case 'register_name':
                    nameFieldContainer.classList.remove('hidden-field');
                    changeEmailButton.classList.remove('hidden-field');
                    nameInput.required = true;
                    emailInput.readOnly = true;
                    submitButton.textContent = 'Create Account & Send Password';
                    formInstructions.textContent = 'This email is not registered. Enter your name to create an account. A password will be emailed to you.';
                    nameInput.value = '';
                    submitButton.disabled = nameInput.value.trim() === '';
                    nameInput.focus();
                    break;
                case 'forgot_password_prompt':
                    emailInput.readOnly = false;
                    emailInput.value = ''; // Clear email for forgot password
                    submitButton.textContent = 'Send Reset Email';
                    formInstructions.textContent = 'Enter your email address to receive a password reset email.';
                    changeEmailButton.classList.remove('hidden-field');
                    submitButton.disabled = emailInput.value.trim() === '';
                    emailInput.focus();
                    break;
                case 'login_after_registration':
                case 'login_after_password_reset': // This state will share UI with login_after_registration
                    emailInput.value = cachedEmail; // Pre-fill with cached email
                    emailInput.readOnly = true;
                    passwordFieldContainer.classList.remove('hidden-field');
                    // forgotPasswordLink remains hidden for these states
                    changeEmailButton.classList.remove('hidden-field');
                    passwordInput.required = true;
                    submitButton.textContent = 'Login';
                    // Instructions are set by the submit handler based on which flow it was
                    if (formState === 'login_after_registration') {
                        formInstructions.textContent = 'Account created! Please check your email for the password and enter it below.';
                    } else { // login_after_password_reset
                        // The message area will show the "If an account exists..." message from the server.
                        // We can add a generic instruction here or rely on the message area.
                        formInstructions.textContent = 'Please check your email for the new password and enter it below.';
                    }
                    passwordInput.value = '';
                    submitButton.disabled = true; // Password field is empty
                    passwordInput.focus();
                    break;
            }
        }

        // --- Event Listeners ---
        emailInput.addEventListener('input', function() {
            if (formState === 'initial_email' || formState === 'forgot_password_prompt') {
                submitButton.disabled = emailInput.value.trim() === '';
            }
        });

        nameInput.addEventListener('input', function() {
            if (formState === 'register_name') {
                submitButton.disabled = nameInput.value.trim() === '';
            }
        });

        passwordInput.addEventListener('input', function() {
            if (formState === 'login_password' || formState === 'login_after_registration' || formState === 'login_after_password_reset') {
                submitButton.disabled = passwordInput.value.trim() === '';
            }
        });

        forgotPasswordLink.addEventListener('click', (event) => {
            event.preventDefault();
            formState = 'forgot_password_prompt';
            updateUIForState();
            messageArea.style.display = 'none'; // Clear previous messages
            messageArea.textContent = '';
        });

        changeEmailButton.addEventListener('click', (event) => {
            event.preventDefault();
            formState = 'initial_email';
            updateUIForState();
            messageArea.style.display = 'none'; // Clear previous messages
            messageArea.textContent = '';
        });

        authForm.addEventListener('submit', async function(event) {
            event.preventDefault();
            // Do not hide messageArea here if we want to preserve the "If an account exists..." message for forgot password.
            // messageArea.style.display = 'none';
            // messageArea.textContent = '';
            messageArea.className = 'p-3 rounded-md text-sm text-center mb-4 border'; // Reset message classes
            submitButton.disabled = true;

            const email = emailInput.value.trim().toLowerCase();

            if (formState === 'initial_email') {
                submitButton.textContent = 'Checking Email...';
                try {
                    const response = await fetch('/check_email', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ email: email })
                    });
                    const result = await response.json();
                    if (response.ok) {
                        cachedEmail = email; // Cache email for potential next steps
                        formState = result.exists ? 'login_password' : 'register_name';
                        updateUIForState();
                    } else {
                        showMessage(result.detail || 'Error checking email.', 'error');
                        submitButton.textContent = 'Continue';
                        submitButton.disabled = emailInput.value.trim() === '';
                    }
                } catch (error) {
                    console.error('Email check error:', error);
                    showMessage('Network error checking email.', 'error');
                    submitButton.textContent = 'Continue';
                    submitButton.disabled = emailInput.value.trim() === '';
                }
            }
            else if (formState === 'login_password' || formState === 'login_after_registration' || formState === 'login_after_password_reset') {
                submitButton.textContent = 'Logging In...';
                const password = passwordInput.value;
                const formData = new FormData();
                formData.append('username', email); // Server expects 'username'
                formData.append('password', password);
                try {
                    const response = await fetch('/token', { method: 'POST', body: formData });
                    const result = await response.json();
                    if (response.ok) {
                        showMessage('Login successful! Redirecting...', 'success');
                        setTimeout(() => { window.location.href = '/'; }, 1500);
                    } else {
                        // Generic login failure message
                        showMessage('Incorrect email or password.', 'error');
                        submitButton.textContent = 'Login';
                        submitButton.disabled = passwordInput.value.trim() === '';
                    }
                } catch (error) {
                    console.error('Login error:', error);
                    showMessage('Network error during login.', 'error');
                    submitButton.textContent = 'Login';
                    submitButton.disabled = passwordInput.value.trim() === '';
                }
            }
            else if (formState === 'register_name') {
                submitButton.textContent = 'Creating Account...';
                const name = nameInput.value.trim();
                try {
                    const response = await fetch('/register', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ email: email, name: name })
                    });
                    const result = await response.json();
                    if (response.ok) {
                        showMessage(result.message, 'success'); // Show "Account created! Your password has been sent..."
                        cachedEmail = email; // Email is already cached from 'initial_email' check, but good to be explicit
                        formState = 'login_after_registration';
                        updateUIForState();
                    } else {
                        showMessage(result.detail || 'Registration failed.', 'error');
                        submitButton.textContent = 'Create Account & Send Password';
                        submitButton.disabled = nameInput.value.trim() === '';
                    }
                } catch (error) {
                    console.error('Registration error:', error);
                    showMessage('Network error during registration.', 'error');
                    submitButton.textContent = 'Create Account & Send Password';
                    submitButton.disabled = nameInput.value.trim() === '';
                }
            }
            else if (formState === 'forgot_password_prompt') {
                submitButton.textContent = 'Sending Reset Email...';
                try {
                    const response = await fetch('/forgot_password', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ email: email })
                    });
                    const result = await response.json();
                    // Always show the server's success message for forgot password for privacy
                    showMessage(result.message, 'success');
                    if (response.ok) {
                        cachedEmail = email; // Cache the email used for reset
                        formState = 'login_after_password_reset'; // New state for this flow
                        updateUIForState();
                    } else {
                        // Even on error, the message from server (if any) is shown.
                        // If no specific error detail, the generic success message is still shown.
                        // Reset button text and enable based on email field.
                        submitButton.textContent = 'Send Reset Email';
                        submitButton.disabled = emailInput.value.trim() === '';
                    }
                } catch (error) {
                    console.error('Forgot password error:', error);
                    // Show a generic success-like message even on network error for privacy,
                    // but log the actual error.
                    showMessage('If an account with this email exists, a password reset email has been sent.', 'success');
                    submitButton.textContent = 'Send Reset Email';
                    submitButton.disabled = emailInput.value.trim() === '';
                }
            }
        });

        function showMessage(message, type = 'info') {
            messageArea.textContent = message;
            messageArea.className = 'p-3 rounded-md text-sm text-center mb-4 border';
            if (type === 'error') {
                messageArea.classList.add('text-red-700', 'bg-red-100', 'border-red-300');
            } else if (type === 'success') {
                messageArea.classList.add('text-green-700', 'bg-green-100', 'border-green-300');
            } else { // info
                messageArea.classList.add('text-blue-700', 'bg-blue-100', 'border-blue-300');
            }
            messageArea.style.display = 'block';
        }

        updateUIForState();
    </script>
</body>
</html>


=== app/static/script.js ===
// --- JS Imports ---
import { marked } from 'marked';
import katex from 'katex';
import Prism from 'prismjs';

// --- Prism Components ---

import 'prismjs/components/prism-clike';
import 'prismjs/components/prism-python';
import 'prismjs/components/prism-javascript';
import 'prismjs/components/prism-css';
import 'prismjs/components/prism-bash';
import 'prismjs/components/prism-json';
import 'prismjs/components/prism-yaml';
import 'prismjs/components/prism-sql';
import 'prismjs/components/prism-java';
import 'prismjs/components/prism-csharp';
import 'prismjs/components/prism-go';
import 'prismjs/components/prism-rust';
import 'prismjs/components/prism-docker';
import 'prismjs/components/prism-typescript';
import 'prismjs/components/prism-c';
import 'prismjs/components/prism-cpp';
// import 'prismjs/components/prism-php'; // not working
// import 'prismjs/components/prism-ruby'; // not working
// --------------------------

// --- Constants and Variables ---
const chatHistory = document.getElementById('chat-history');
const chatForm = document.getElementById('chat-form');
const messageInput = document.getElementById('message-input');
const sendButton = document.getElementById('send-button');
const thinkCheckbox = document.getElementById('think-checkbox');
const stopAiButton = document.getElementById('stop-ai-button');

let websocket;
const clientId = `web-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
let currentTurnId = 0;

const MODE_ANSWER = 'MODE_ANSWER';
const MODE_SEEKING_CODE_LANGUAGE = 'MODE_SEEKING_CODE_LANGUAGE';
const MODE_INSIDE_CODE_BLOCK = 'MODE_INSIDE_CODE_BLOCK';
const MODE_KATEX_BUFFERING_INLINE = 'MODE_KATEX_BUFFERING_INLINE';
const MODE_KATEX_BUFFERING_DISPLAY = 'MODE_KATEX_BUFFERING_DISPLAY';
const MODE_MAYBE_START_DISPLAY_KATEX = 'MODE_MAYBE_START_DISPLAY_KATEX';
const MODE_SEEKING_TAG = 'MODE_SEEKING_TAG';
const MODE_INSIDE_THINK = 'MODE_INSIDE_THINK';
const MODE_MAYBE_END_THINK = 'MODE_MAYBE_END_THINK';
const MODE_SEEKING_CODE_START_FENCE = 'MODE_SEEKING_CODE_START_FENCE';
const MODE_SEEKING_CODE_END_FENCE = 'MODE_SEEKING_CODE_END_FENCE';

let currentProcessingMode = MODE_ANSWER;
let langBuffer = '';
let currentCodeBlockLang = ''; // Stores the language name (e.g., 'python')
let currentCodeBlockElement = null; // The <code> element
let currentCodeBlockPreElement = null; // The <pre> element wrapping the code
let katexBuffer = '';
let currentKatexMarkerId = null;
let thinkBuffer = '';
let tagBuffer = '';
let fenceBuffer = ''; // Added for fence detection
let currentAiTurnContainer = null;
let currentAnswerElement = null;
let currentThinkingArea = null;
let currentThinkingPreElement = null;
let currentCodeBlocksArea = null;
let codeBlockCounterThisTurn = 0;
let thinkingRequestedForCurrentTurn = false;
let accumulatedAnswerText = '';
let lastAppendedNode = null;
let hasThinkingContentArrivedThisTurn = false;
let firstAnswerTokenReceived = false;
var currentUserInfo = null

const FENCE = '```';
const THINK_START_TAG = '<think>';
const THINK_END_TAG = '</think>';
const KATEX_PLACEHOLDER_PREFIX = '%%KATEX_PLACEHOLDER_';
const KATEX_RENDERED_ATTR = 'data-katex-rendered';
const NO_THINK_PREFIX = "\\no_think"
const THINK_PREFIX = "\\think"

/**
 * Extracts the session ID from the current URL path.
 * Assumes URL is like /chat/SESSION_ID/...
 * Returns the session ID string or null if not found or invalid.
 */
function getSessionIdFromPath() {
    const pathName = window.location.pathname; // Get the path part of the URL (e.g., "/chat/some-session-id")
    const pathParts = pathName.split('/');    // Split the path by "/"
                                            // For "/chat/some-session-id", pathParts will be ["", "chat", "some-session-id"]

    // Check if the path structure is as expected:
    // 1. pathParts.length >= 3 (e.g., "", "chat", "session_id")
    // 2. pathParts[1] is exactly "chat"
    if (pathParts.length >= 3 && pathParts[1] === 'chat') {
        const sessionId = pathParts[2]; // The session ID is the third part
        if (sessionId && sessionId.trim() !== "") { // Ensure it's not empty
            // console.log("Extracted session ID:", sessionId); // Keep for debugging if needed
            return sessionId;
        } else {
            console.error("Session ID extracted from path is empty or invalid.");
            return null;
        }
    }

    // console.log("Not on a chat page or session ID invalid:", pathName); // Keep for debugging if needed
    return null; // Return null if the path doesn't match the expected structure
}

// --- Utility Functions ---

function scrollToBottom(behavior = 'auto') {
    const isNearBottom = chatHistory.scrollHeight - chatHistory.scrollTop - chatHistory.clientHeight < 100;
    if (isNearBottom) {
        requestAnimationFrame(() => {
            chatHistory.scrollTo({ top: chatHistory.scrollHeight, behavior: behavior });
        });
    }
}

// --- Utility Functions --- 
// (debounce function is here)

function throttle(func, limit) {
    let lastFunc;
    let lastRan;
    return function throttledFunction(...args) {
      const context = this; // Capture the context
      if (!lastRan) {
        // If it hasn't run yet, run it immediately
        func.apply(context, args);
        lastRan = Date.now();
      } else {
        clearTimeout(lastFunc); // Clear any previously scheduled run
        // Schedule the next run after the limit has passed
        lastFunc = setTimeout(function() {
          // Check if enough time has passed since the last execution
          if ((Date.now() - lastRan) >= limit) {
            func.apply(context, args);
            lastRan = Date.now(); // Update the time it last ran
          }
        }, limit - (Date.now() - lastRan)); // Calculate remaining time needed
      }
    };
  }
  
  // (debouncedStreamHighlight definition will be replaced next)
  // (Rest of your utility functions)

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
};

function getCursorPosition(parentElement) {
    const selection = window.getSelection();
    if (selection.rangeCount === 0) return -1;

    const range = selection.getRangeAt(0);
    if (!parentElement.contains(range.startContainer)) {
        return -1;
    }

    const preSelectionRange = range.cloneRange();
    preSelectionRange.selectNodeContents(parentElement);
    try {
        preSelectionRange.setEnd(range.startContainer, range.startOffset);
    } catch (e) {
        console.error("Error setting preSelectionRange end:", e, "Range:", range);
        return -1;
    }
    return preSelectionRange.toString().length;
}

function setCursorPosition(parentElement, offset) {
    const selection = window.getSelection();
    if (!selection) return;

    const range = document.createRange();
    let charCount = 0;
    let foundStart = false;

    function findNodeAndOffset(node) {
        if (foundStart) return;

        if (node.nodeType === Node.TEXT_NODE) {
            const nextCharCount = charCount + node.length;
            if (!foundStart && offset >= charCount && offset <= nextCharCount) {
                try {
                    const offsetInNode = offset - charCount;
                    range.setStart(node, offsetInNode);
                    foundStart = true;
                } catch (e) {
                    console.error("Error setting range start:", e, "Node:", node, "Offset:", offsetInNode);
                }
            }
            charCount = nextCharCount;
        } else {
            for (let i = 0; i < node.childNodes.length; i++) {
                findNodeAndOffset(node.childNodes[i]);
                if (foundStart) break;
            }
        }
    }

    findNodeAndOffset(parentElement);

    if (foundStart) {
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
    } else {
        range.selectNodeContents(parentElement);
        range.collapse(false);
        selection.removeAllRanges();
        selection.addRange(range);
        console.warn(`Could not set cursor precisely at offset ${offset}. Placed at end.`);
    }
    parentElement.focus();
}

/**
 * Fetches the list of user sessions from the API and displays them in the sidebar.
 */
async function fetchAndDisplaySessions() {
    console.log("[fetchAndDisplaySessions] Function called."); // Log: Start of function

    const sessionListElement = document.getElementById('session-list');
    const chatSessionTitle = document.getElementById('chat-session-title');

    if (!sessionListElement) {
        console.log("[fetchAndDisplaySessions] Session list element (#session-list) not found. Exiting.");
        return;
    }

    console.log("[fetchAndDisplaySessions] Setting loading state.");
    sessionListElement.innerHTML = '<li class="px-3 py-1 text-gray-400 italic text-sm">Loading sessions...</li>';

    try {
        console.log("[fetchAndDisplaySessions] Making fetch request to /api/sessions...");
        const response = await fetch('/api/sessions');
        console.log(`[fetchAndDisplaySessions] Fetch response status: ${response.status}`); // Log: Response status

        if (!response.ok) {
            let errorDetail = `HTTP error ${response.status}`;
            try {
                const errorJson = await response.json();
                errorDetail = errorJson.detail || errorDetail;
            } catch (e) { /* Ignore */ }
            console.error(`[fetchAndDisplaySessions] Error fetching sessions: ${errorDetail}`);
            sessionListElement.innerHTML = `<li class="px-3 py-1 text-red-400 italic text-sm">Error loading sessions</li>`;
            return;
        }

        const sessions = await response.json();
        console.log("[fetchAndDisplaySessions] Received sessions:", sessions); // Log: The received data

        sessionListElement.innerHTML = ''; // Clear loading/error

        if (sessions.length === 0) {
            console.log("[fetchAndDisplaySessions] No sessions found. Displaying message.");
            sessionListElement.innerHTML = '<li class="px-3 py-1 text-gray-400 italic text-sm">No sessions yet</li>';
        } else {
            console.log(`[fetchAndDisplaySessions] Processing ${sessions.length} sessions...`);
            const activeSessionId = getSessionIdFromPath(); // Assumes getSessionIdFromPath() exists and works
            console.log(`[fetchAndDisplaySessions] Current active session ID from path: ${activeSessionId}`);

            sessions.forEach((session, index) => {
                // console.log(`[fetchAndDisplaySessions] Adding session ${index + 1}: ID=${session.id}, Name=${session.name}`); // Optional: Log each session
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = `/chat/${session.id}`;
                a.classList.add('block', 'px-3', 'py-2', 'rounded-md', 'text-sm', 'text-gray-300', 'hover:bg-gray-700', 'hover:text-white', 'truncate');

                if (session.id === activeSessionId) {
                    // console.log(`[fetchAndDisplaySessions] Highlighting active session: ${session.id}`);
                    a.classList.add('bg-gray-900', 'text-white');
                    a.setAttribute('aria-current', 'page');
                    if (chatSessionTitle) {
                        chatSessionTitle.textContent = session.name || `Chat Session ${session.id.substring(0, 4)}`;
                    }
                }

                a.textContent = session.name || `Session ${session.id.substring(0, 8)}`;
                a.title = session.name || `Session ${session.id}`;

                // Placeholder for Rename/Delete buttons
                // const iconsSpan = document.createElement('span');
                // iconsSpan.innerHTML = `...`;
                // a.appendChild(iconsSpan);

                li.appendChild(a);
                sessionListElement.appendChild(li);
            });
            console.log("[fetchAndDisplaySessions] Finished processing sessions.");
        }

    } catch (error) {
        console.error("[fetchAndDisplaySessions] Failed to fetch or display sessions:", error);
        sessionListElement.innerHTML = `<li class="px-3 py-1 text-red-400 italic text-sm">Error loading sessions</li>`;
    }
}

function addUserMessage(text) {
    // Ensure chatHistory and messageInput elements exist to prevent errors
    const chatHistory = document.getElementById('chat-history'); // Re-fetch or ensure it's a reliable global
    const messageInput = document.getElementById('message-input'); // Re-fetch or ensure it's a reliable global

    if (!chatHistory) {
        console.error("addUserMessage: chatHistory element not found.");
        return;
    }
    // messageInput might be null if called from a context where it's not relevant,
    // but usually it's good to have it for checks if needed.

    const messageElement = document.createElement('div');
    messageElement.classList.add('message', 'user-message', 'p-3', 'rounded-lg', 'max-w-xl', 'mb-2', 'break-words', 'flex', 'flex-col', 'bg-emerald-100', 'self-end', 'ml-auto');
    messageElement.setAttribute('data-sender', 'user');

    const senderElem = document.createElement('p');
    senderElem.classList.add('font-semibold', 'text-sm', 'mb-1', 'text-emerald-700');
    let userName = 'User'; // Default user name

    // Check for globally available user info
    if (typeof window.currentUserInfo === 'object' && window.currentUserInfo !== null && window.currentUserInfo.name) {
        userName = window.currentUserInfo.name;
    }
    senderElem.textContent = escapeHTML(userName); // Assumes escapeHTML is defined
    messageElement.appendChild(senderElem);

    const contentElem = document.createElement('div');
    contentElem.classList.add('text-gray-800', 'text-sm', 'message-content');
    
    let displayedText = text; // The raw text received by the function

    // Strip prefixes for display purposes
    // Check for NO_THINK_PREFIX first
    if (typeof NO_THINK_PREFIX === 'string' && displayedText.startsWith(NO_THINK_PREFIX)) {
         displayedText = displayedText.substring(NO_THINK_PREFIX.length);
    } 
    // Then check for THINK_PREFIX, in case the user somehow typed it
    // (though the submit logic should prevent sending THINK_PREFIX if NO_THINK_PREFIX was intended)
    else if (typeof THINK_PREFIX === 'string' && displayedText.startsWith(THINK_PREFIX)) {
         displayedText = displayedText.substring(THINK_PREFIX.length);
    }

    contentElem.textContent = displayedText; // Display the cleaned text
    messageElement.appendChild(contentElem);

    const timestampElem = document.createElement('p');
    timestampElem.classList.add('text-xs', 'text-slate-500', 'mt-1', 'text-right');
    timestampElem.textContent = new Date().toLocaleString();
    messageElement.appendChild(timestampElem);

    chatHistory.appendChild(messageElement);
    
    // Ensure scrollToBottom is defined and handles potential null chatHistory
    if (typeof scrollToBottom === 'function') {
        setTimeout(() => scrollToBottom('smooth'), 50);
    }
}




function addSystemMessage(text) {
   const messageElement = document.createElement('div');
   messageElement.classList.add('system-message');
   messageElement.textContent = text;
   chatHistory.appendChild(messageElement);
   setTimeout(() => scrollToBottom('smooth'), 50);
}

function addErrorMessage(text) {
   console.error("[UI ERROR] ", text);
   const messageElement = document.createElement('div');
   messageElement.classList.add('error-message');
   messageElement.textContent = `Error: ${text}`;
   if(currentAiTurnContainer) {
       const target = currentAnswerElement || currentCodeBlocksArea || currentAiTurnContainer;
       target.appendChild(messageElement);
   } else { chatHistory.appendChild(messageElement); }
   setTimeout(() => scrollToBottom('smooth'), 50);
}

// --- UI State Management ---
function setInputDisabledState(inputsDisabled, aiResponding) {
    if (messageInput) messageInput.disabled = inputsDisabled;
    if (sendButton) sendButton.disabled = inputsDisabled;
    if (thinkCheckbox) thinkCheckbox.disabled = inputsDisabled;

    if (stopAiButton) {
        if (aiResponding) {
            stopAiButton.classList.remove('hidden');
            stopAiButton.disabled = false;
            // Set to default "Stop" state when becoming visible, in case it was "Stopping..."
            stopAiButton.innerHTML = `
                <svg class="w-5 h-5 inline-block mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1zm4 0a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                Stop`;
            if (sendButton) sendButton.classList.add('hidden');
        } else {
            stopAiButton.classList.add('hidden');
            stopAiButton.disabled = true;
            // Reset to default "Stop" state when hidden
            stopAiButton.innerHTML = `
                <svg class="w-5 h-5 inline-block mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1zm4 0a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                Stop`;
            if (sendButton) sendButton.classList.remove('hidden');
        }
    }
}

/**
 * Sets up the DOM structure for a new turn from the AI, including thinking area,
 * answer bubble (with sender name), and code blocks area.
 */
function setupNewAiTurn() {
    currentTurnId++;
    codeBlockCounterThisTurn = 0;
    accumulatedAnswerText = '';
    lastAppendedNode = null;
    thinkBuffer = '';
    hasThinkingContentArrivedThisTurn = false;
    firstAnswerTokenReceived = false;

    currentAiTurnContainer = null;
    currentThinkingArea = null;
    currentThinkingPreElement = null;
    currentAnswerElement = null;
    currentCodeBlocksArea = null;

    console.log(`[setupNewAiTurn] Starting setup for Turn ID: ${currentTurnId}. thinkingRequestedForCurrentTurn is: ${thinkingRequestedForCurrentTurn}`);

    currentAiTurnContainer = document.createElement('div');
    currentAiTurnContainer.classList.add('ai-turn-container');
    currentAiTurnContainer.dataset.turnId = currentTurnId;

    // --- Thinking Area Setup (remains the same) ---
    currentThinkingArea = document.createElement('div');
    currentThinkingArea.classList.add('thinking-area');
    currentThinkingArea.dataset.turnId = currentTurnId;
    if (!thinkingRequestedForCurrentTurn) {
        currentThinkingArea.style.display = 'none';
    }
    const details = document.createElement('details');
    details.id = `thinking-details-${currentTurnId}`;
    const summary = document.createElement('summary');
    summary.classList.add('thinking-summary');
    const summaryTextSpan = document.createElement('span');
    summaryTextSpan.classList.add('text');
    summaryTextSpan.textContent = 'Show Thinking';
    const summaryDotsSpan = document.createElement('span');
    summaryDotsSpan.classList.add('dots');
    summary.appendChild(summaryTextSpan);
    summary.appendChild(summaryDotsSpan);
    currentThinkingPreElement = document.createElement('pre');
    details.appendChild(summary);
    details.appendChild(currentThinkingPreElement);
    currentThinkingArea.appendChild(details);
    currentAiTurnContainer.appendChild(currentThinkingArea);
    details.addEventListener('toggle', (event) => {
        const textSpan = event.target.querySelector('.thinking-summary .text');
        if (!textSpan) return;
        textSpan.textContent = event.target.open ? 'Hide Thinking' : 'Show Thinking';
    });
    // --- End Thinking Area Setup ---

    // --- Answer Element (AI Message Bubble) Setup ---
    currentAnswerElement = document.createElement('div');
    currentAnswerElement.classList.add('message', 'ai-message');
    // Add styling classes similar to historical AI messages for consistency
    currentAnswerElement.classList.add('p-3', 'rounded-lg', 'max-w-xl', 'mb-2', 'break-words', 'flex', 'flex-col', 'bg-sky-100', 'self-start', 'mr-auto');


    // **NEW**: Add Sender Name ("AI") to the live answer bubble
    const senderElem = document.createElement('p');
    senderElem.classList.add('font-semibold', 'text-sm', 'mb-1', 'text-sky-700');
    senderElem.textContent = 'AI'; // Or a dynamic AI name if available
    currentAnswerElement.appendChild(senderElem); // Prepend or append as preferred; prepending here

    // Div to hold the actual streaming content (will be populated by appendToAnswer/formatAnswerBubbleFinal)
    // This is effectively the 'message-content' part of the bubble.
    // We create a dedicated div for it so the sender name and timestamp can be siblings.
    const liveContentDiv = document.createElement('div');
    liveContentDiv.classList.add('text-gray-800', 'text-sm', 'message-content', 'live-ai-content-area'); // Added a specific class
    currentAnswerElement.appendChild(liveContentDiv);


    if (thinkingRequestedForCurrentTurn) {
        currentAnswerElement.style.display = 'none'; // Hide bubble if thinking is shown first
    } else {
        // Show answer bubble immediately with loading dots if no thinking display
        const loadingSpan = document.createElement('span');
        loadingSpan.classList.add('loading-dots');
        liveContentDiv.appendChild(loadingSpan); // Add loading dots to the content area
    }
    currentAiTurnContainer.appendChild(currentAnswerElement);

    // --- Code Blocks Area Setup (remains the same) ---
    currentCodeBlocksArea = document.createElement('div');
    currentCodeBlocksArea.classList.add('code-blocks-area');
    currentAiTurnContainer.appendChild(currentCodeBlocksArea);
    // --- End Code Blocks Area Setup ---

    chatHistory.appendChild(currentAiTurnContainer);
    console.log(`[setupNewAiTurn] Finished setup for Turn ID: ${currentTurnId}.`);
}

// You'll also need to adjust `appendToAnswer` and `formatAnswerBubbleFinal`
// to target the `liveContentDiv` within `currentAnswerElement` for the actual message content,
// instead of `currentAnswerElement` directly, to keep the sender name and future timestamp separate.

// Example adjustment for appendToAnswer (conceptual):
// Original: currentAnswerElement.appendChild(node);
// New: const targetContentArea = currentAnswerElement.querySelector('.live-ai-content-area');
//      if (targetContentArea) targetContentArea.appendChild(node); else currentAnswerElement.appendChild(node);
// Similar logic for text nodes and for formatAnswerBubbleFinal's innerHTML operations.


function appendRawTextToThinkingArea(text) {
    if (text && text.trim().length > 0) {
        // console.log(`[appendRawTextToThinkingArea] Received non-empty raw think text: "${text}" (length: ${text?.length})`);
    } else if (text !== null) {
        // console.log(`[appendRawTextToThinkingArea] Received empty or whitespace raw think text (length: ${text?.length})`);
    }

    // console.log(`[appendRawTextToThinkingArea] Checking condition: !thinkingRequestedForCurrentTurn is ${!thinkingRequestedForCurrentTurn} (value: ${thinkingRequestedForCurrentTurn})`);
    if (!thinkingRequestedForCurrentTurn) {
        // console.log("[appendRawTextToThinkingArea] Condition met (!thinkingRequested). Returning early. Should NOT display thinking.");
        return;
    }

    // console.log("[appendRawTextToThinkingArea] Proceeding because thinking was requested.");

    if (!currentThinkingArea || !currentThinkingPreElement || text.length === 0) {
        return;
    }

    if (!hasThinkingContentArrivedThisTurn) {
        if (currentThinkingArea.style.display === 'none') {
            // console.log("[appendRawTextToThinkingArea] First think chunk (and requested). Making area visible NOW. Display style was: " + currentThinkingArea.style.display);
            currentThinkingArea.style.display = '';
        }
        hasThinkingContentArrivedThisTurn = true;
    }

    try {
        currentThinkingPreElement.appendChild(document.createTextNode(text));
    } catch (appendError) {
         console.error("[appendRawTextToThinkingArea] Error appending text node:", appendError, "Pre Element:", currentThinkingPreElement, "Text:", text);
        return;
    }

    const detailsElement = currentThinkingPreElement.closest('details');
    if (detailsElement && detailsElement.open) {
         const isNearBottom = currentThinkingPreElement.scrollHeight - currentThinkingPreElement.scrollTop - currentThinkingPreElement.clientHeight < 50;
         if(isNearBottom) {
             requestAnimationFrame(() => { currentThinkingPreElement.scrollTop = currentThinkingPreElement.scrollHeight; });
         }
    }
}

function appendCodeReference() {
    if (!currentAnswerElement) {
        console.error("Attempted to append code reference to null answer bubble!");
        return;
    }
    if (codeBlockCounterThisTurn > 0) {
         const refSpan = document.createElement('span');
         refSpan.classList.add('code-reference');
         refSpan.textContent = `[Code ${codeBlockCounterThisTurn}]`;
         currentAnswerElement.appendChild(refSpan);
         lastAppendedNode = refSpan;
    } else {
        console.warn("appendCodeReference called but codeBlockCounterThisTurn is 0.");
    }
}

/**
 * Finalizes the AI answer bubble content with Markdown and KaTeX processing.
 * Targets the specific content div within the answer bubble.
 */
function formatAnswerBubbleFinal() {
    if (!currentAnswerElement) {
        console.warn("[formatAnswerBubbleFinal] Skipping: currentAnswerElement is null.");
        accumulatedAnswerText = ''; lastAppendedNode = null; firstAnswerTokenReceived = false; return;
    }

    // **MODIFIED**: Target the dedicated content area
    const targetContentArea = currentAnswerElement.querySelector('.live-ai-content-area');
    if (!targetContentArea) {
        console.error("[formatAnswerBubbleFinal] '.live-ai-content-area' not found. Cannot format content.");
        // Fallback: if somehow the structure is missing, try to use currentAnswerElement directly
        // but this will mix with sender name. This is mostly a safeguard.
        if (accumulatedAnswerText.trim().length > 0) {
             currentAnswerElement.innerHTML += marked.parse(accumulatedAnswerText, { mangle: false, headerIds: false, gfm: true, breaks: true, sanitize: false });
        }
        accumulatedAnswerText = ''; lastAppendedNode = null; firstAnswerTokenReceived = false; return;
    }
    
    // Original logic from formatAnswerBubbleFinal, but operating on `targetContentArea`

    // Ensure the main answer bubble is visible if it has content or accumulated text
    if (currentAnswerElement.style.display === 'none' && (targetContentArea.hasChildNodes() || accumulatedAnswerText.trim().length > 0)) {
        currentAnswerElement.style.display = ''; // Show the whole bubble
        const loadingDots = targetContentArea.querySelector('.loading-dots'); // Dots are inside targetContentArea
        if (loadingDots) loadingDots.remove();
    }

    const hasVisualContent = targetContentArea.hasChildNodes() && !targetContentArea.querySelector('.loading-dots');
    const hasAccumulatedContent = accumulatedAnswerText.trim().length > 0;

    if (!hasVisualContent && !hasAccumulatedContent) {
        const loadingDots = targetContentArea.querySelector('.loading-dots');
        if (loadingDots) loadingDots.remove();
        accumulatedAnswerText = '';
        lastAppendedNode = null;
        // firstAnswerTokenReceived should remain true if it was set, or handle as needed
        return;
    }

    try {
        const storedKatexNodes = {};
        let placeholderIndex = 0;
        let textForMarkdown = accumulatedAnswerText; // Start with accumulated text

        // Find KaTeX spans already rendered by the live streaming logic within targetContentArea
        const katexSpans = Array.from(targetContentArea.children).filter(el => el.matches(`span[${KATEX_RENDERED_ATTR}="true"]`));

        if (katexSpans.length > 0) {
            katexSpans.forEach((el) => {
                if (!el.parentNode) return; // Should be targetContentArea
                const placeholder = `${KATEX_PLACEHOLDER_PREFIX}${placeholderIndex++}`; // KATEX_PLACEHOLDER_PREFIX is global
                storedKatexNodes[placeholder] = el.cloneNode(true);
                try {
                    // Replace the KaTeX span with a text node placeholder
                    el.parentNode.replaceChild(document.createTextNode(placeholder), el);
                } catch (replaceError) {
                    console.error(`[formatAnswerBubbleFinal] Error replacing KaTeX node with placeholder ${placeholder}:`, replaceError, "Node:", el);
                    try { el.parentNode.removeChild(el); } catch (removeError) { console.error("Failed to remove problematic KaTeX node:", removeError); }
                }
            });
            // After replacement, the innerHTML of targetContentArea contains text and placeholders
            textForMarkdown = targetContentArea.innerHTML;
        } else {
             // If no KaTeX spans but there was visual content (e.g. just text nodes from appendToAnswer)
             // and also accumulated text, we should clear the visual DOM and use accumulated text.
            if (hasVisualContent && hasAccumulatedContent) {
                targetContentArea.innerHTML = ''; // Clear existing simple text nodes
            } else if (!hasAccumulatedContent && hasVisualContent) {
                // Only visual content (e.g. from appendToAnswer(null, node) where node was not KaTeX)
                // and no accumulated text. Use existing innerHTML.
                textForMarkdown = targetContentArea.innerHTML;
            }
            // If only accumulated text, textForMarkdown is already set.
        }
        
        if (textForMarkdown.trim().length === 0 && Object.keys(storedKatexNodes).length === 0) {
             // No text to parse and no KaTeX to reinsert.
        } else {
            // Parse the potentially modified innerHTML or accumulated text
            const markdownHtml = marked.parse(textForMarkdown, {
                mangle: false, headerIds: false, gfm: true, breaks: true, sanitize: false
            });
            targetContentArea.innerHTML = markdownHtml; // Set the parsed HTML into the content area
        }


        // Reinsert KaTeX nodes if any were stored
        if (Object.keys(storedKatexNodes).length > 0) {
            const walker = document.createTreeWalker(targetContentArea, NodeFilter.SHOW_TEXT);
            let node;
            const textNodesContainingPlaceholders = [];
            while (node = walker.nextNode()) {
                if (node.nodeValue && node.nodeValue.includes(KATEX_PLACEHOLDER_PREFIX)) {
                    textNodesContainingPlaceholders.push(node);
                }
            }

            textNodesContainingPlaceholders.forEach(textNode => {
                let currentNodeValue = textNode.nodeValue;
                let parent = textNode.parentNode;
                if (!parent) return; // Should be within targetContentArea

                const fragment = document.createDocumentFragment();
                let lastSplitEnd = 0;
                const placeholderScanRegex = new RegExp(`(${KATEX_PLACEHOLDER_PREFIX}\\d+)`, 'g');
                let placeholderMatch;

                while((placeholderMatch = placeholderScanRegex.exec(currentNodeValue)) !== null) {
                    const placeholder = placeholderMatch[1];
                    const matchIndex = placeholderMatch.index;
                    if (matchIndex > lastSplitEnd) {
                        fragment.appendChild(document.createTextNode(currentNodeValue.substring(lastSplitEnd, matchIndex)));
                    }
                    if (storedKatexNodes[placeholder]) {
                        fragment.appendChild(storedKatexNodes[placeholder].cloneNode(true));
                    } else {
                        fragment.appendChild(document.createTextNode(placeholder)); // Fallback
                    }
                    lastSplitEnd = placeholderScanRegex.lastIndex;
                }
                if (lastSplitEnd < currentNodeValue.length) {
                    fragment.appendChild(document.createTextNode(currentNodeValue.substring(lastSplitEnd)));
                }
                parent.replaceChild(fragment, textNode);
            });
        }
    } catch (error) {
        console.error("Error during final Markdown/KaTeX formatting in live AI bubble:", error);
        addErrorMessage("Failed to perform final message formatting for AI response.");
        if (targetContentArea && accumulatedAnswerText.trim().length > 0) {
            targetContentArea.textContent = accumulatedAnswerText; // Fallback to raw accumulated text
        }
    }
    accumulatedAnswerText = ''; // Clear after processing
    lastAppendedNode = null; // Reset for the next stream
    // firstAnswerTokenReceived remains true.
}


function resetStreamingState() {
    // console.log("[DEBUG] Resetting streaming state.");
    currentProcessingMode = MODE_ANSWER;
    langBuffer = ''; currentCodeBlockLang = '';
    currentCodeBlockElement = null; currentCodeBlockPreElement = null;
    katexBuffer = ''; currentKatexMarkerId = null;
    thinkBuffer = ''; tagBuffer = ''; fenceBuffer = ''; // Reset fenceBuffer
    lastAppendedNode = null;
    thinkingRequestedForCurrentTurn = false;
}

function renderAndReplaceKatex(isDisplay, markerId) {

    if (!currentAnswerElement || !markerId || katexBuffer === null || katexBuffer === undefined) {
        console.error("[KaTeX Replace Marker] Error: Invalid state (element, markerId, or buffer). MarkerID:", markerId, "Buffer:", katexBuffer);
        if (markerId && currentAnswerElement) {
             try {
                 const strayMarker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);
                 if (strayMarker?.parentNode) strayMarker.parentNode.removeChild(strayMarker);
             } catch (e) { console.error("Error cleaning stray marker:", e); }
        }
        katexBuffer = '';
        return false;
    }

    const trimmedKatexBuffer = katexBuffer.trim();

    try {
        const stringToRender = trimmedKatexBuffer.length > 0 ? trimmedKatexBuffer : " ";
        const katexHtml = katex.renderToString(stringToRender, {
            displayMode: isDisplay,
            throwOnError: false,
            output: "html",
            strict: false
        });

        if (katexHtml.includes('katex-error') && trimmedKatexBuffer.length > 0) {
            console.warn(`[KaTeX Replace Marker] KaTeX reported a rendering error for buffer: "${trimmedKatexBuffer}". Marker ID: ${markerId}. Raw text will remain.`);
             try {
                 const marker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);
                 if (marker?.parentNode) marker.parentNode.removeChild(marker);
                 else console.warn("Couldn't find marker to clean up after render error.");
             } catch (cleanupError) { console.error("Error during marker cleanup after render error:", cleanupError); }
            katexBuffer = '';
            return false;
        }

        const startMarker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);

        if (!startMarker) {
            console.error(`[KaTeX Replace Marker] Error: Cannot find start marker span with ID: ${markerId}. Aborting replacement. Content might be inconsistent.`);
            katexBuffer = '';
            return false;
        }

        if (!startMarker.parentNode) {
             console.error(`[KaTeX Replace Marker] Error: Start marker span with ID ${markerId} found but has no parent (already removed?). Aborting.`);
             katexBuffer = '';
             return false;
        }

        const parent = startMarker.parentNode;
        let nodesToRemove = [];
        let currentNode = startMarker.nextSibling;

        while (currentNode) {
            nodesToRemove.push(currentNode);
            if (nodesToRemove.length > 1000) {
                console.error("[KaTeX Replace Marker] Error: Excessive node collection limit reached (1000). Aborting replacement.");
                 try { parent.removeChild(startMarker); } catch(e){}
                 katexBuffer = '';
                 return false;
            }
            currentNode = currentNode.nextSibling;
        }

        const katexSpan = document.createElement('span');
        katexSpan.setAttribute(KATEX_RENDERED_ATTR, 'true');
        katexSpan.innerHTML = katexHtml;

        parent.insertBefore(katexSpan, startMarker);
        parent.removeChild(startMarker);

        nodesToRemove.forEach(node => {
            if (node.parentNode === parent) {
                parent.removeChild(node);
            } else {
                console.warn("[KaTeX Replace Marker] Node parent changed or node removed unexpectedly during collection, skipping removal:", node);
            }
        });

        appendToAnswer(null, katexSpan);
        katexBuffer = '';
        return true;

    } catch (error) {
        console.error("[KaTeX Replace Marker] General error during marker-based replacement:", error);
        try {
            const marker = currentAnswerElement?.querySelector(`span[data-katex-start-id="${markerId}"]`);
            if (marker?.parentNode) marker.parentNode.removeChild(marker);
        } catch (cleanupError) { console.error("Error during marker cleanup after general error:", cleanupError); }
        katexBuffer = '';
        return false;
    }
}

function finalizeTurnOnErrorOrClose() {
    console.log("[DEBUG] finalizeTurnOnErrorOrClose called."); // Keep user's debug log
    if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK && currentCodeBlockElement) {
        console.warn("Stream ended unexpectedly inside code block. Finalizing highlight.");
        try { finalizeCodeBlock(true); } catch (e) { console.error("Prism highlight error on close:", e); }
    }
    // --- Incorporate user's KaTeX and Think finalization ---
    if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE ||
        currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY ||
        currentProcessingMode === MODE_MAYBE_START_DISPLAY_KATEX) {
        console.warn("Stream ended unexpectedly inside KaTeX block. Processing raw text.");
        if (currentKatexMarkerId && typeof renderAndReplaceKatex === 'function') { // Check if function exists
            renderAndReplaceKatex(currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY, currentKatexMarkerId);
            currentKatexMarkerId = null;
        } else if (katexBuffer) { // Fallback if renderAndReplaceKatex isn't available or no marker
            appendToAnswer((currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY ? "$$" : "$") + katexBuffer + (currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY ? "$$" : "$"));
            katexBuffer = '';
        }
    }
    if (currentProcessingMode === MODE_INSIDE_THINK || currentProcessingMode === MODE_MAYBE_END_THINK || currentProcessingMode === MODE_SEEKING_TAG) {
        console.warn("Stream ended unexpectedly inside/seeking Think tags. Finishing think buffer:", thinkBuffer);
        if (currentThinkingArea && currentThinkingArea.style.display !== 'none' && currentThinkingPreElement && typeof appendRawTextToThinkingArea === 'function') {
            appendRawTextToThinkingArea("\n--- (Stream ended unexpectedly during thinking) ---");
        } else if (tagBuffer) { // If not in thinking mode but had a tag buffer
            appendToAnswer(tagBuffer); // Append incomplete tag as text
        }
        // thinkBuffer itself is typically appended by appendRawTextToThinkingArea during streaming
    }
    // --- End of incorporated logic ---

    if (typeof formatAnswerBubbleFinal === 'function') {
        formatAnswerBubbleFinal(); 
    }
    if (typeof resetStreamingState === 'function') {
        resetStreamingState();     
    }
    if (typeof setInputDisabledState === 'function') {
        setInputDisabledState(false, false); // Correctly re-enables inputs and hides stop button
    }
    // --- Focus logic remains ---
    if (messageInput && messageInput.offsetParent !== null) { // Check if visible
        messageInput.focus();
    }
}

/**
 * Creates the DOM structure for a new, live code block being streamed.
 * Hides the run button for unsupported languages.
 * @param {string} language - The language specified after the opening ``` fence.
 */
function createCodeBlockStructure(language) {
    if (!currentCodeBlocksArea) {
        console.error("createCodeBlockStructure: Code blocks area is null!");
        return;
    }
    codeBlockCounterThisTurn++;
    const currentCodeNumber = codeBlockCounterThisTurn;
    const blockId = `code-block-turn${currentTurnId}-${currentCodeNumber}`;
    const safeLanguage = (language || '').trim().toLowerCase() || 'plaintext';

    // Language aliases and Prism language determination (as before)
    const langAlias = { /* ... keep your existing aliases ... */
        'python': 'python', 'py': 'python', 'javascript': 'javascript', 'js': 'javascript',
        'html': 'markup', 'xml': 'markup', 'svg': 'markup', 'css': 'css', 'bash': 'bash',
        'sh': 'bash', 'shell': 'bash', 'json': 'json', 'yaml': 'yaml', 'yml': 'yaml',
        'markdown': 'markdown', 'md': 'markdown', 'sql': 'sql', 'java': 'java', 'c': 'c',
        'cpp': 'cpp', 'c++': 'cpp', 'csharp': 'csharp', 'cs': 'csharp', 'go': 'go',
        'rust': 'rust', 'php': 'php', 'ruby': 'ruby', 'rb': 'ruby',
        'dockerfile': 'docker', 'docker': 'docker', 'typescript': 'typescript', 'ts': 'typescript',
        'plaintext': 'plain', 'text': 'plain',
    };
    const prismLang = langAlias[safeLanguage] || safeLanguage;
    const displayLang = safeLanguage; // Use the cleaned-up language name for checks/display
    currentCodeBlockLang = prismLang; // Store the Prism language used

    // --- ADD: List of languages supported by the backend Docker execution ---
    const supportedExecutionLanguages = [
        "python", "javascript", "cpp", "csharp", "typescript", "java", "go", "rust"
        // Add or remove languages based on your config.py SUPPORTED_LANGUAGES keys
    ];
    const isLanguageSupported = supportedExecutionLanguages.includes(displayLang);
    // --- END OF ADD ---

    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;

    const container = document.createElement('div');
    container.classList.add('code-block-container');
    container.id = blockId;
    container.dataset.language = displayLang; // Store the display language

    const codeHeader = document.createElement('div');
    codeHeader.classList.add('code-block-header');

    const codeButtonsDiv = document.createElement('div');
    codeButtonsDiv.classList.add('code-block-buttons');

    // Create buttons (as before)
    const runStopBtn = document.createElement('button');
    runStopBtn.classList.add('run-code-btn', 'code-action-btn');
    runStopBtn.dataset.status = 'idle';
    runStopBtn.innerHTML = playIconSvg;
    runStopBtn.title = 'Run Code';
    runStopBtn.addEventListener('click', handleRunStopCodeClick);

    const toggleCodeBtn = document.createElement('button');
    toggleCodeBtn.classList.add('toggle-code-btn', 'code-action-btn');
    toggleCodeBtn.textContent = 'Hide';
    toggleCodeBtn.title = 'Show/Hide Code';

    const copyCodeBtn = document.createElement('button');
    copyCodeBtn.classList.add('copy-code-btn', 'code-action-btn');
    copyCodeBtn.textContent = 'Copy';
    copyCodeBtn.title = 'Copy Code';

    // --- ADD: Conditionally hide run button ---
    if (!isLanguageSupported) {
        runStopBtn.style.display = 'none'; // Hide the button entirely
        runStopBtn.title = `Run Code (language '${displayLang}' not supported for execution)`; // Update title even if hidden
        console.log(`Hiding run button for unsupported language: ${displayLang}`); // Optional log
    }
    // --- END OF ADD ---

    // Add buttons to their container (run button is added even if hidden, simplifies layout logic)
    codeButtonsDiv.appendChild(runStopBtn);
    codeButtonsDiv.appendChild(toggleCodeBtn);
    codeButtonsDiv.appendChild(copyCodeBtn);

    // Code block title (as before)
    const codeTitle = document.createElement('span');
    codeTitle.classList.add('code-block-title');
    codeTitle.textContent = `Code ${currentCodeNumber} (${displayLang})`;
    codeTitle.style.flexGrow = '1';
    codeTitle.style.textAlign = 'left';

    // Assemble header (as before)
    codeHeader.appendChild(codeButtonsDiv);
    codeHeader.appendChild(codeTitle);

    // Create pre/code elements (as before)
    const preElement = document.createElement('pre');
    preElement.classList.add('manual');
    const codeElement = document.createElement('code');
    codeElement.className = `language-${prismLang}`;
    codeElement.setAttribute('contenteditable', 'true'); // Live code is editable
    codeElement.setAttribute('spellcheck', 'false');

    // Assign to global state variables for streaming (as before)
    currentCodeBlockPreElement = preElement;
    currentCodeBlockElement = codeElement;

    // Create output area structure (as before)
    const outputHeader = document.createElement('div');
    outputHeader.classList.add('code-output-header');
    outputHeader.style.display = 'none';
    // ... (rest of output header setup: buttons, title, status span) ...
    const outputButtonsDiv = document.createElement('div');
    outputButtonsDiv.classList.add('code-block-buttons');
    const placeholderSpan = document.createElement('span');
    placeholderSpan.classList.add('output-header-button-placeholder');
    outputButtonsDiv.appendChild(placeholderSpan);
    const toggleOutputBtn = document.createElement('button');
    toggleOutputBtn.classList.add('toggle-output-btn', 'code-action-btn');
    toggleOutputBtn.textContent = 'Hide';
    toggleOutputBtn.title = 'Show/Hide Output';
    const copyOutputBtn = document.createElement('button');
    copyOutputBtn.classList.add('copy-output-btn', 'code-action-btn');
    copyOutputBtn.textContent = 'Copy';
    copyOutputBtn.title = 'Copy Output';
    outputButtonsDiv.appendChild(toggleOutputBtn);
    outputButtonsDiv.appendChild(copyOutputBtn);
    const outputTitle = document.createElement('span');
    outputTitle.classList.add('output-header-title');
    outputTitle.textContent = `Output Code ${currentCodeNumber}`;
    const codeStatusSpan = document.createElement('span');
    codeStatusSpan.classList.add('code-status-span');
    codeStatusSpan.textContent = 'Idle';
    outputHeader.appendChild(outputButtonsDiv);
    outputHeader.appendChild(outputTitle);
    outputHeader.appendChild(codeStatusSpan);

    const outputConsoleDiv = document.createElement('div');
    outputConsoleDiv.classList.add('code-output-console');
    outputConsoleDiv.style.display = 'none';
    const outputPre = document.createElement('pre');
    outputConsoleDiv.appendChild(outputPre);

    // Assemble the full block (as before)
    preElement.appendChild(codeElement);
    container.appendChild(codeHeader);
    container.appendChild(preElement);
    container.appendChild(outputHeader);
    container.appendChild(outputConsoleDiv);

    // Add event listeners (as before)
    // Toggle code listener
    toggleCodeBtn.addEventListener('click', () => {
        const isHidden = preElement.classList.toggle('hidden');
        toggleCodeBtn.textContent = isHidden ? 'Show' : 'Hide';
    });
    // Copy code listener
    copyCodeBtn.addEventListener('click', async () => {
        if (!codeElement) return;
        try {
            await navigator.clipboard.writeText(codeElement.textContent || '');
            copyCodeBtn.textContent = 'Copied!';
            copyCodeBtn.classList.add('copied');
            setTimeout(() => { copyCodeBtn.textContent = 'Copy'; copyCodeBtn.classList.remove('copied'); }, 1500);
        } catch (err) {
            console.error('Failed to copy code: ', err);
            copyCodeBtn.textContent = 'Error';
            setTimeout(() => { copyCodeBtn.textContent = 'Copy'; }, 1500);
        }
    });
    // Run button listener is already attached above
    // Debounced highlight listener for editable code (as before)
    const debouncedHighlight = debounce(() => {
        const savedPosition = getCursorPosition(codeElement);
        if (savedPosition === -1) { console.warn("Could not save cursor position or cursor not in element. Highlight may cause cursor jump."); }
        try {
            const currentText = codeElement.textContent;
            codeElement.innerHTML = ''; 
            codeElement.textContent = currentText; 
            Prism.highlightElement(codeElement);
            if (savedPosition !== -1) { setCursorPosition(codeElement, savedPosition); }
        } catch (e) {
            console.error("Error during debounced highlighting:", e);
            if (savedPosition !== -1) { setCursorPosition(codeElement, savedPosition); }
        }
    }, 500);
    codeElement.addEventListener('input', debouncedHighlight);
    codeElement.addEventListener('paste', (e) => { setTimeout(debouncedHighlight, 100); });
    // Output area listeners (as before)
    toggleOutputBtn.addEventListener('click', () => {
        const isHidden = outputConsoleDiv.classList.toggle('hidden');
        toggleOutputBtn.textContent = isHidden ? 'Show' : 'Hide';
    });
    copyOutputBtn.addEventListener('click', async () => {
        if (!outputPre) return;
        try {
            await navigator.clipboard.writeText(outputPre.textContent || '');
            copyOutputBtn.textContent = 'Copied!';
            copyOutputBtn.classList.add('copied');
            setTimeout(() => { copyOutputBtn.textContent = 'Copy'; copyOutputBtn.classList.remove('copied'); }, 1500);
        } catch (err) {
            console.error('Failed to copy output: ', err);
            copyOutputBtn.textContent = 'Error';
            setTimeout(() => { copyOutputBtn.textContent = 'Copy'; }, 1500);
        }
    });

    // Append to DOM and reset state (as before)
    currentCodeBlocksArea.appendChild(container);
    lastAppendedNode = null; // Reset last appended node for main answer bubble
}

async function handleRunStopCodeClick(event) {
    const button = event.currentTarget;
    const container = button.closest('.code-block-container');
    if (!container) return;

    const codeBlockId = container.id;
    const language = container.dataset.language;
    const codeElement = container.querySelector('code');
    const outputHeader = container.querySelector('.code-output-header');
    const outputConsoleDiv = container.querySelector('.code-output-console');
    const outputPre = outputConsoleDiv ? outputConsoleDiv.querySelector('pre') : null;
    const statusSpan = outputHeader ? outputHeader.querySelector('.code-status-span') : null;

    if (!language || !codeElement || !outputHeader || !outputConsoleDiv || !outputPre || !statusSpan) {
        console.error(`Missing elements for code block ${codeBlockId}`);
        addErrorMessage(`Cannot run code block ${codeBlockId}: Internal UI error.`);
        return;
    }

    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;
    const stopIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><rect width="100" height="100" rx="15"/></svg>`;
    const stoppingIconSvg = `<svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: block;"><path d="M12 2V6M12 18V22M6 12H2M22 12H18M19.0711 4.92893L16.2426 7.75736M7.75736 16.2426L4.92893 19.0711M19.0711 19.0711L16.2426 16.2426M7.75736 7.75736L4.92893 4.92893" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;

    const code = codeElement.textContent || '';
    const currentStatus = button.dataset.status;

    if (!websocket || websocket.readyState !== WebSocket.OPEN) {
        console.warn("WebSocket not open. Cannot run/stop code.");
        statusSpan.textContent = 'Error: Disconnected';
        statusSpan.className = 'code-status-span error';
        outputHeader.style.display = 'flex';
        addErrorMessage("Cannot run/stop code: Not connected to server.");
        return;
    }

    if (currentStatus === 'idle') {
        console.log(`Requesting run for block ${codeBlockId} (${language})`);
        button.dataset.status = 'running';
        button.innerHTML = stopIconSvg;
        button.title = 'Stop Execution';

        outputPre.innerHTML = '';
        outputHeader.style.display = 'flex';
        outputConsoleDiv.style.display = 'block';
        outputConsoleDiv.classList.remove('hidden');
        const toggleOutputBtn = outputHeader.querySelector('.toggle-output-btn');
        if (toggleOutputBtn) toggleOutputBtn.textContent = 'Hide';

        statusSpan.textContent = 'Running...';
        statusSpan.className = 'code-status-span running';

        websocket.send(JSON.stringify({
            type: 'run_code',
            payload: { code_block_id: codeBlockId, language: language, code: code }
        }));

    } else if (currentStatus === 'running') {
        console.log(`Requesting stop for block ${codeBlockId}`);
        button.dataset.status = 'stopping';
        button.innerHTML = stoppingIconSvg;
        button.title = 'Stopping...';
        button.disabled = true;

        statusSpan.textContent = 'Stopping...';
        statusSpan.className = 'code-status-span stopping';

        websocket.send(JSON.stringify({
            type: 'stop_code',
            payload: { code_block_id: codeBlockId }
        }));
    } else if (currentStatus === 'stopping') {
        console.log(`Already stopping block ${codeBlockId}`);
    }
}

function addCodeOutput(outputPreElement, streamType, text) {
    if (!outputPreElement || !text) return;

    const span = document.createElement('span');
    span.classList.add(streamType === 'stderr' ? 'stderr-output' : 'stdout-output');
    span.textContent = text;
    outputPreElement.appendChild(span);
    outputPreElement.scrollTop = outputPreElement.scrollHeight;
}

/**
 * Appends text content to the currently active code block element 
 * and triggers debounced syntax highlighting.
 * @param {string} text - The text chunk to append.
 */
function appendToCodeBlock(text) {
    // Ensure we have a target code element to append to
    if (currentCodeBlockElement) {
        // Append the raw text node to the <code> element
        currentCodeBlockElement.appendChild(document.createTextNode(text));
        
        // Auto-scroll the code block's <pre> container if it's visible
        // currentCodeBlockPreElement is the parent <pre> element
        if(currentCodeBlockPreElement && !currentCodeBlockPreElement.classList.contains('hidden')) {
            // Check if the scroll position is near the bottom
            const isNearCodeBottom = currentCodeBlockPreElement.scrollHeight - currentCodeBlockPreElement.scrollTop - currentCodeBlockPreElement.clientHeight < 50; // Threshold of 50px
            if(isNearCodeBottom) {
                // Use requestAnimationFrame for smoother scrolling after the DOM update
                requestAnimationFrame(() => { 
                    // Check again inside animation frame as state might change rapidly
                    if(currentCodeBlockPreElement) { 
                       currentCodeBlockPreElement.scrollTop = currentCodeBlockPreElement.scrollHeight; 
                    }
                });
            }
        }

        // --- THIS IS THE SPECIFIC CHANGE FOR THIS STEP ---
        // Trigger the debounced highlighter every time text is appended
        throttledStreamHighlight()
        // --- END OF SPECIFIC CHANGE ---

    } else {
        // Log an error if we try to append but no code block is active
        console.error("Attempted to append to null code block element!");
    }
}

/**
 * Appends text or a DOM node to the current AI's answer area.
 * Targets the specific content div within the answer bubble.
 * @param {string | null} text - Text to append.
 * @param {Node | null} node - DOM node to append.
 */
function appendToAnswer(text = null, node = null) {
    if (!currentAnswerElement) {
        console.error("[appendToAnswer] currentAnswerElement is null. Cannot append.");
        return;
    }

    // **MODIFIED**: Target the dedicated content area within the AI message bubble
    const targetContentArea = currentAnswerElement.querySelector('.live-ai-content-area');
    if (!targetContentArea) {
        console.error("[appendToAnswer] '.live-ai-content-area' not found in currentAnswerElement. Appending to currentAnswerElement directly as fallback.");
        // Fallback to old behavior if somehow the structure is missing, though this shouldn't happen with the updated setupNewAiTurn
        const fallbackTarget = currentAnswerElement; 
        
        // Logic from original appendToAnswer, but using fallbackTarget
        let isMeaningfulContentFallback = (text && text.trim().length > 0) ||
                                   (node && node.nodeType !== Node.COMMENT_NODE && (!node.textContent || node.textContent.trim().length > 0));

        if (!firstAnswerTokenReceived && isMeaningfulContentFallback) {
            if (fallbackTarget.style.display === 'none') {
                fallbackTarget.style.display = '';
            }
            const loadingDotsFallback = fallbackTarget.querySelector('.loading-dots');
            if (loadingDotsFallback) {
                loadingDotsFallback.remove();
            }
            firstAnswerTokenReceived = true;
        }

        if (node) {
            if (!node.classList || !node.classList.contains('loading-dots')) {
                fallbackTarget.appendChild(node);
                lastAppendedNode = node; // Keep track of last appended node relative to its parent
            }
        } else if (text !== null && text.length > 0) {
            accumulatedAnswerText += text; // Still accumulate globally for formatAnswerBubbleFinal
            if (lastAppendedNode && lastAppendedNode.nodeType === Node.TEXT_NODE && lastAppendedNode.parentNode === fallbackTarget) {
                lastAppendedNode.nodeValue += text;
            } else {
                const textNode = document.createTextNode(text);
                fallbackTarget.appendChild(textNode);
                lastAppendedNode = textNode;
            }
        }
        return; // End of fallback logic
    }


    // --- Main logic using targetContentArea ---
    let isMeaningfulContent = (text && text.trim().length > 0) ||
                              (node && node.nodeType !== Node.COMMENT_NODE && (!node.textContent || node.textContent.trim().length > 0));

    if (!firstAnswerTokenReceived && isMeaningfulContent) {
        // This logic primarily handles making the *overall* currentAnswerElement visible
        // if it was hidden (e.g., due to thinkingRequestedForCurrentTurn).
        // The loading dots are inside targetContentArea.
        if (currentAnswerElement.style.display === 'none') {
            currentAnswerElement.style.display = ''; // Show the whole bubble
        }
        const loadingDots = targetContentArea.querySelector('.loading-dots');
        if (loadingDots) {
            loadingDots.remove();
        }
        firstAnswerTokenReceived = true;
    }

    if (node) {
        // Don't append loading dots if they are the node (they are handled above)
        if (!node.classList || !node.classList.contains('loading-dots')) {
            targetContentArea.appendChild(node);
            // lastAppendedNode should refer to nodes within targetContentArea for text concatenation logic
            lastAppendedNode = (targetContentArea.contains(node)) ? node : null;
        }
    } else if (text !== null && text.length > 0) {
        accumulatedAnswerText += text; // Global accumulation for final formatting
        // Smart text node concatenation within targetContentArea
        if (lastAppendedNode && lastAppendedNode.nodeType === Node.TEXT_NODE && lastAppendedNode.parentNode === targetContentArea) {
            lastAppendedNode.nodeValue += text;
        } else {
            const textNode = document.createTextNode(text);
            targetContentArea.appendChild(textNode);
            lastAppendedNode = textNode;
        }
    }
}


/**
 * Finalizes the currently active code block, performing a final, 
 * non-debounced syntax highlight to ensure completeness.
 * Resets code block streaming state variables.
 * @param {boolean} isTruncated - Indicates if the stream ended unexpectedly (e.g., via EOS).
 */
function finalizeCodeBlock(isTruncated = false) {
    // Check if there is an active code block element being processed
    if (currentCodeBlockElement) {
        const blockContainer = currentCodeBlockElement.closest('.code-block-container');
        const blockId = blockContainer ? blockContainer.id : 'unknown';
        const langClass = currentCodeBlockElement.className; // e.g., "language-python"
        
        // Log the finalization attempt
        console.log(`[finalizeCodeBlock] Finalizing highlight for block ${blockId} (lang class: ${langClass}). Stream truncated: ${isTruncated}`);

        try {
            // Normalizing the text nodes within the <code> element can sometimes help 
            // Prism handle unusual spacing or fragmented text nodes correctly.
            currentCodeBlockElement.normalize(); 
            
            // --- THIS IS THE SPECIFIC CHANGE FOR THIS STEP ---
            // Perform an immediate, final highlight on the entire code block element.
            // This ensures the complete code is highlighted, catching any parts potentially 
            // missed by the last debounced call if the stream ended abruptly.
            if (typeof Prism !== 'undefined' && typeof Prism.highlightElement === 'function') {
                Prism.highlightElement(currentCodeBlockElement);
                console.log(`[finalizeCodeBlock] Final highlighting applied successfully for ${blockId}.`);
            } else {
                 console.warn(`[finalizeCodeBlock] Prism.js or highlightElement not available for final highlight on block ${blockId}.`);
            }
            // --- END OF SPECIFIC CHANGE ---

            // Optional: Cancel any pending debounced highlight call.
            // This requires your debounce implementation to have a .cancel() method.
            // If it doesn't, you can omit this block.
            // if (debouncedStreamHighlight && typeof debouncedStreamHighlight.cancel === 'function') {
            //     console.log(`[finalizeCodeBlock] Cancelling pending debounced highlight for block ${blockId}.`);
            //     debouncedStreamHighlight.cancel();
            // }

        } catch (e) {
            // Log any errors during the final highlighting process
            console.error(`Prism highlight error on finalizeCodeBlock (lang '${currentCodeBlockLang}', block ${blockId}):`, e);
        }
    } else {
         // Log a warning if this function is called when no code block is active
         console.warn("[finalizeCodeBlock] Called but currentCodeBlockElement is null.");
    }
    
    // Reset the global state variables related to the code block stream AFTER processing.
    currentCodeBlockElement = null;    // Reference to the <code> element
    currentCodeBlockPreElement = null; // Reference to the parent <pre> element
    currentCodeBlockLang = '';         // Language identifier (e.g., 'python')
    // fenceBuffer should also be reset if it's tracked globally and related
    // fenceBuffer = ''; 
}


function resetAllCodeButtonsOnErrorOrClose() {
    console.log("Resetting all code run/stop buttons and statuses due to connection issue.");
    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;

    document.querySelectorAll('.code-block-container').forEach(container => {
        const button = container.querySelector('.run-code-btn');
        const outputHeader = container.querySelector('.code-output-header');
        const statusSpan = outputHeader ? outputHeader.querySelector('.code-status-span') : null;

        if (button && button.dataset.status !== 'idle') {
            button.dataset.status = 'idle';
            button.innerHTML = playIconSvg;
            button.title = 'Run Code';
            button.disabled = false;
        }
        if (statusSpan) {
             if (!statusSpan.classList.contains('idle') && !statusSpan.classList.contains('success')) {
                 if (outputHeader) outputHeader.style.display = 'flex';
                 statusSpan.textContent = 'Error: Disconnected';
                 statusSpan.className = 'code-status-span error';
             }
        }
    });
}

function connectWebSocket() {

    let sessionId = null;
    const pathParts = window.location.pathname.split('/');
    // Example: /chat/ef7a41e6-2ba7-4882-b9bb-91c03edb25ac
    // pathParts would be ["", "chat", "ef7a41e6-2ba7-4882-b9bb-91c03edb25ac"]
    if (pathParts.length >= 3 && pathParts[1] === 'chat') {
        sessionId = pathParts[2]; // This should be the session_id
        if (!sessionId || sessionId.trim() === "") {
             console.error("Session ID extracted from path is empty.");
             sessionId = null; // Treat empty ID as invalid
        }
    }

    if (!sessionId) {
        console.error("Could not extract valid session ID from URL path:", window.location.pathname);
        // Use your existing addErrorMessage function if available
        if (typeof addErrorMessage === 'function') {
             addErrorMessage("Cannot connect to chat: Invalid session ID in URL.");
        } else {
             alert("Cannot connect to chat: Invalid session ID in URL.");
        }
        // Use your existing setInputDisabledState function if available
        if (typeof setInputDisabledState === 'function') {
             setInputDisabledState(true);
        }
        return; // Stop connection attempt
    }
    // --- END: Added logic to get session ID from URL path ---

    // Use your existing global clientId variable
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    // Construct the URL with the extracted sessionId and existing clientId
    const wsUrl = `${wsProtocol}//${window.location.host}/ws/${sessionId}/${clientId}`; // Corrected URL format

    console.log(`[DEBUG] Attempting to connect to WebSocket: ${wsUrl}`);

    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`; // Keep this if used elsewhere, otherwise remove

    try {
        // Use the corrected wsUrl
        const ws = new WebSocket(wsUrl);
        console.log('connectWebSocket: Creating WebSocket object...');

        ws.onopen = (event) => {
            console.log("[DEBUG] WebSocket connection opened. ws object:", ws);
            websocket = ws; // Assign to your global websocket variable

            // Check for your actual helper functions
            if (typeof addSystemMessage !== 'function' || typeof setupNewAiTurn !== 'function' || typeof appendToAnswer !== 'function' || typeof formatAnswerBubbleFinal !== 'function' || typeof resetStreamingState !== 'function' || typeof setInputDisabledState !== 'function') {
                console.error("CRITICAL ERROR: One or more required helper functions are not defined when ws.onopen is called. Check script order.");
                alert("Chat initialization failed. Please refresh the page. (Error: Helpers undefined)");
                if (typeof setInputDisabledState === 'function') setInputDisabledState(true);
                return;
            }

            if (typeof setInputDisabledState === 'function') setInputDisabledState(false);
            if (typeof addSystemMessage === 'function') addSystemMessage("Connected to the chat server.");

            // thinkingRequestedForCurrentTurn = false; // Assuming this is a global/accessible variable
            // setupNewAiTurn(); // Your existing function
            // const welcomeMessage = "Hello! How can I help you today?";
            // appendToAnswer(welcomeMessage); // Your existing function
            // formatAnswerBubbleFinal(); // Your existing function
            // console.log("[DEBUG ws.onopen] Resetting state after welcome message.");
            // resetStreamingState(); // Your existing function

            if(messageInput && messageInput.offsetParent !== null) messageInput.focus();
        };

        ws.onmessage = (event) => {
            // This is the full onmessage logic from your provided script
            let isJsonMessage = false;
            let messageData = null;
            try {
                if (typeof event.data === 'string' && event.data.startsWith('{')) {
                    messageData = JSON.parse(event.data);
                    if (messageData && messageData.type && messageData.payload && messageData.payload.code_block_id) {
                        isJsonMessage = true;
                    }
                }
            } catch (e) {
                isJsonMessage = false;
            }

            if (isJsonMessage) {
                // console.log("%c[ws.onmessage] Code Execution JSON received:", "color: blue;", messageData);
                const { type, payload } = messageData;
                const { code_block_id } = payload;
                const container = document.getElementById(code_block_id);

                if (!container) {
                    console.warn(`Received message for unknown code block ID: ${code_block_id}`, payload);
                    return;
                }

                const outputHeader = container.querySelector('.code-output-header');
                const outputConsoleDiv = container.querySelector('.code-output-console');
                const outputPre = outputConsoleDiv ? outputConsoleDiv.querySelector('pre') : null;
                const runStopBtn = container.querySelector('.run-code-btn');
                const statusSpan = outputHeader ? outputHeader.querySelector('.code-status-span') : null;

                if (!outputHeader || !outputPre || !runStopBtn || !statusSpan) {
                        console.error(`Missing elements for code block ${code_block_id}. Cannot process message.`);
                        return;
                }

                switch (type) {
                    case 'code_output':
                        const { stream, data } = payload;
                        if (outputHeader.style.display === 'none') {
                            // console.log(`Showing output header for ${code_block_id} on first output.`);
                            outputHeader.style.display = 'flex';
                        }
                        if (outputConsoleDiv.style.display === 'none') {
                            // console.log(`Showing output console for ${code_block_id} on first output.`);
                            outputConsoleDiv.style.display = 'block';
                            outputConsoleDiv.classList.remove('hidden');
                                const toggleOutputBtn = outputHeader.querySelector('.toggle-output-btn');
                                if (toggleOutputBtn) toggleOutputBtn.textContent = 'Hide';
                        }
                        if (runStopBtn.dataset.status === 'idle'){
                                const stopIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><rect width="100" height="100" rx="15"/></svg>`;
                                console.warn(`Received code output for ${code_block_id} while button was idle. Forcing state to running.`);
                                runStopBtn.dataset.status = 'running';
                                runStopBtn.innerHTML = stopIconSvg;
                                runStopBtn.title = 'Stop Execution';
                                runStopBtn.disabled = false;
                                statusSpan.textContent = 'Running...';
                                statusSpan.className = 'code-status-span running';
                        }
                        addCodeOutput(outputPre, stream, data); // Your existing function
                        break;

                    case 'code_finished':
                        if (outputHeader.style.display === 'none') {
                            // console.log(`Showing output header for ${code_block_id} on finish.`);
                            outputHeader.style.display = 'flex';
                        }
                            if (outputConsoleDiv.style.display === 'none') {
                            // console.log(`Showing output console for ${code_block_id} on finish.`);
                            outputConsoleDiv.style.display = 'block';
                            outputConsoleDiv.classList.remove('hidden');
                                const toggleOutputBtn = outputHeader.querySelector('.toggle-output-btn');
                                if (toggleOutputBtn) toggleOutputBtn.textContent = 'Hide';
                        }

                        const { exit_code, error } = payload;
                        let finishMessage = '';
                        let statusClass = '';

                        if (error) {
                            if (error === "Execution stopped by user.") {
                                finishMessage = 'Stopped'; statusClass = 'stopped';
                            } else if (error.startsWith("Execution timed out")) {
                                    finishMessage = 'Timeout'; statusClass = 'error';
                            } else {
                                    finishMessage = `Error (${exit_code !== undefined ? exit_code : 'N/A'})`; statusClass = 'error';
                                    console.error(`Execution error for ${code_block_id}:`, error);
                            }
                        } else {
                            finishMessage = `Finished (Exit: ${exit_code})`;
                            statusClass = exit_code === 0 ? 'success' : 'error';
                        }

                        statusSpan.textContent = finishMessage;
                        statusSpan.className = `code-status-span ${statusClass}`;

                        runStopBtn.dataset.status = 'idle';
                        // Use the playIconSvg defined earlier or redefine it if needed
                        runStopBtn.innerHTML = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;
                        runStopBtn.title = 'Run Code';
                        runStopBtn.disabled = false;
                        break;

                    default:
                        console.warn(`Received unknown code execution message type: ${type}`, payload);
                }

            } else {
                // console.log("%c[ws.onmessage] RAW chat data received:", "color: magenta;", event.data);
                let chunk = event.data;
                const currentTurnIdForMsg = currentTurnId; // Assuming currentTurnId is global/accessible

                // Inside your connectWebSocket -> ws.onmessage -> else (raw chat data) -> if (chunk === "<EOS>") block:

                if (chunk === "<EOS>") {
                    const currentTurnIdForMsg = currentTurnId; // Capture currentTurnId for logging context
                    console.log(`%c[ws.onmessage] Turn ${currentTurnIdForMsg}: Received <EOS>. Finalizing turn.`, 'color: green; font-weight: bold;');

                    // Handle cases where EOS is received unexpectedly in the middle of processing
                    if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly inside a code block. Appending any fence buffer and finalizing code block.`);
                        if (fenceBuffer && fenceBuffer.length > 0) {
                            appendToCodeBlock(fenceBuffer); // Append any partial fence characters
                        }
                        try {
                            finalizeCodeBlock(true); // true indicates truncation
                        } catch (e) {
                            console.error(`Error finalizing code block on EOS for Turn ${currentTurnIdForMsg}:`, e);
                        }
                    } else if (currentProcessingMode === MODE_SEEKING_CODE_END_FENCE) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly while seeking code end fence. Treating fence buffer '${fenceBuffer}' as part of the code.`);
                        appendToCodeBlock(fenceBuffer); // Treat buffered fence characters as code content
                        try {
                            finalizeCodeBlock(true); // true indicates truncation
                        } catch (e) {
                            console.error(`Error finalizing code block on EOS (seeking end fence) for Turn ${currentTurnIdForMsg}:`, e);
                        }
                    } else if (currentProcessingMode === MODE_SEEKING_CODE_LANGUAGE && langBuffer && langBuffer.length > 0) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly while seeking code language. Treating '${FENCE}${langBuffer}' as plain text.`);
                        appendToAnswer(FENCE + langBuffer); // Append the incomplete fence and language buffer as text
                    } else if (currentProcessingMode === MODE_SEEKING_CODE_START_FENCE && fenceBuffer && fenceBuffer.length > 0) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly while seeking code start fence. Treating '${fenceBuffer}' as plain text.`);
                        appendToAnswer(fenceBuffer); // Append the incomplete fence buffer as text
                    } else if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE || currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly inside a KaTeX block. Attempting to render buffered content: "${katexBuffer}"`);
                        if (currentKatexMarkerId) {
                            renderAndReplaceKatex(currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY, currentKatexMarkerId);
                            currentKatexMarkerId = null; // Reset marker ID
                        } else {
                             // If no marker, append raw buffer as text to avoid losing it
                            appendToAnswer((currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY ? "$$" : "$") + katexBuffer);
                        }
                    } else if (currentProcessingMode === MODE_MAYBE_START_DISPLAY_KATEX) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly after a '$'. Treating as plain text.`);
                        appendToAnswer('$'); // Append the single dollar sign
                    } else if (currentProcessingMode === MODE_INSIDE_THINK || currentProcessingMode === MODE_MAYBE_END_THINK || currentProcessingMode === MODE_SEEKING_TAG) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly while in mode '${currentProcessingMode}'. Buffered tag: "${tagBuffer}", Buffered think: "${thinkBuffer}"`);
                        if (thinkingRequestedForCurrentTurn && currentThinkingArea && currentThinkingPreElement) {
                            if (tagBuffer) appendRawTextToThinkingArea(tagBuffer); // Append any partial tag
                            // thinkBuffer should have already been appended incrementally by appendRawTextToThinkingArea
                            appendRawTextToThinkingArea("\n--- (End of stream during thinking process) ---");
                        } else if (tagBuffer) { // If not in thinking mode but had a tag buffer
                            appendToAnswer(tagBuffer);
                        }
                    }
                    // Any other modes might just proceed to formatAnswerBubbleFinal with existing accumulatedAnswerText

                    formatAnswerBubbleFinal(); // Process and finalize the main answer content

                    // Add Timestamp to the live AI answer bubble
                    if (currentAnswerElement) {
                        const timestampElem = document.createElement('p');
                        timestampElem.classList.add('text-xs', 'text-slate-500', 'mt-1', 'text-left'); // Consistent styling
                        timestampElem.textContent = new Date().toLocaleString(); // Time when EOS is received
                        currentAnswerElement.appendChild(timestampElem); // Append to the main bubble, after content div
                    }

                    resetStreamingState(); // Reset all streaming state variables for the next turn
                    
                    // Re-enable input fields
                    if (typeof setInputDisabledState === 'function') {
                        setInputDisabledState(false);
                    }
                    
                    // Focus on the message input if it's visible
                    if (messageInput && messageInput.offsetParent !== null) {
                        messageInput.focus();
                    }
                    
                    // Scroll to the bottom of the chat history
                    setTimeout(() => scrollToBottom('smooth'), 50); 
                    
                    return; // Important to exit after handling EOS
                }

                if (chunk.startsWith("<ERROR>")) {
                    const errorMessage = chunk.substring(7);
                    console.error(`[ws.onmessage] Turn ${currentTurnIdForMsg}: Received <ERROR>:`, errorMessage);
                    if (typeof addErrorMessage === 'function') addErrorMessage(errorMessage);
                    finalizeTurnOnErrorOrClose(); // Your existing function
                    resetAllCodeButtonsOnErrorOrClose(); // Your existing function
                    setTimeout(() => scrollToBottom('smooth'), 50);
                    return;
                }

                if (chunk.length === 0) {
                        return;
                }

                if (!currentAiTurnContainer) { // Assuming global/accessible
                    if (chunk.trim().length > 0) {
                        console.warn(`%c[ws.onmessage] Turn ${currentTurnIdForMsg}: First non-empty chat chunk received, but turn container not set up? Forcing setup.`, 'color: red; font-weight: bold;');
                        setupNewAiTurn(); // Your existing function
                    } else {
                        return;
                    }
                }

                // Your existing complex state machine logic to process the chunk
                let currentPos = 0;
                while (currentPos < chunk.length) {
                    const char = chunk[currentPos];
                    let incrementPos = true;
                    let previousMode = currentProcessingMode; // Assuming global/accessible

                    if (char === '\\' && currentPos + 1 < chunk.length) {
                        const nextChar = chunk[currentPos + 1];
                        const escapableChars = '$`*\\<>';
                        if (escapableChars.includes(nextChar)) {
                            if (currentProcessingMode === MODE_INSIDE_THINK) { appendRawTextToThinkingArea(nextChar); }
                            else if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE || currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY) { katexBuffer += nextChar; appendToAnswer(nextChar); } // Assuming katexBuffer is global/accessible
                            else if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK) { appendToCodeBlock(nextChar); } // Your existing function
                            else { appendToAnswer(nextChar); } // Your existing function
                            currentPos += 2;
                            incrementPos = false;
                            continue;
                        }
                    }

                    switch (currentProcessingMode) { // Assuming global/accessible
                        case MODE_ANSWER:
                            if (char === FENCE[0]) {
                                if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                katexBuffer = ''; currentKatexMarkerId = null;
                                fenceBuffer = char; // Assuming fenceBuffer is global/accessible
                                currentProcessingMode = MODE_SEEKING_CODE_START_FENCE;
                            } else if (char === '$') {
                                if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                currentProcessingMode = MODE_MAYBE_START_DISPLAY_KATEX;
                            } else if (char === '<') {
                                    if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                tagBuffer = char; // Assuming tagBuffer is global/accessible
                                currentProcessingMode = MODE_SEEKING_TAG;
                            } else {
                                if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                appendToAnswer(char);
                            }
                            break;
                        // ... include all your other cases from the state machine ...
                        case MODE_SEEKING_CODE_START_FENCE:
                            if (char === FENCE[fenceBuffer.length]) {
                                fenceBuffer += char;
                                if (fenceBuffer === FENCE) {
                                    fenceBuffer = ''; langBuffer = ''; // Assuming langBuffer is global/accessible
                                    currentProcessingMode = MODE_SEEKING_CODE_LANGUAGE;
                                }
                            } else {
                                appendToAnswer(fenceBuffer);
                                fenceBuffer = '';
                                currentProcessingMode = MODE_ANSWER;
                                incrementPos = false;
                            }
                            break;
                        case MODE_SEEKING_CODE_LANGUAGE:
                                if (char === '\n') {
                                    currentCodeBlockLang = langBuffer.trim(); // Assuming global/accessible
                                    createCodeBlockStructure(currentCodeBlockLang); // Your existing function
                                    appendCodeReference(); // Your existing function
                                    langBuffer = '';
                                    currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                                } else if (langBuffer.length > 50) {
                                    console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: Code language line too long. Treating as text.`);
                                    appendToAnswer(FENCE + langBuffer + char);
                                    langBuffer = ''; fenceBuffer = '';
                                    currentProcessingMode = MODE_ANSWER;
                                } else {
                                    langBuffer += char;
                                }
                                break;
                        case MODE_INSIDE_CODE_BLOCK:
                            if (char === FENCE[0]) {
                                fenceBuffer = char;
                                currentProcessingMode = MODE_SEEKING_CODE_END_FENCE;
                            } else {
                                appendToCodeBlock(char);
                            }
                            break;
                        case MODE_SEEKING_CODE_END_FENCE:
                            if (char === FENCE[fenceBuffer.length]) {
                                fenceBuffer += char;
                                if (fenceBuffer === FENCE) {
                                    finalizeCodeBlock(); // Your existing function
                                    fenceBuffer = '';
                                    currentProcessingMode = MODE_ANSWER;
                                    lastAppendedNode = null; // Assuming global/accessible
                                    if (currentPos + 1 < chunk.length && chunk[currentPos + 1] === '\n') {
                                        currentPos++;
                                        incrementPos = true;
                                    }
                                }
                            } else {
                                appendToCodeBlock(fenceBuffer);
                                fenceBuffer = '';
                                currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                                incrementPos = false;
                            }
                            break;
                        case MODE_MAYBE_START_DISPLAY_KATEX:
                            if (char === '$') {
                                currentKatexMarkerId = `katex-marker-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
                                const startMarkerDisp = document.createElement('span');
                                startMarkerDisp.setAttribute('data-katex-start-id', currentKatexMarkerId);
                                startMarkerDisp.style.display = 'none';
                                appendToAnswer(null, startMarkerDisp);
                                appendToAnswer('$$');
                                currentProcessingMode = MODE_KATEX_BUFFERING_DISPLAY;
                                katexBuffer = '';
                            } else {
                                currentKatexMarkerId = `katex-marker-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
                                const startMarkerInline = document.createElement('span');
                                startMarkerInline.setAttribute('data-katex-start-id', currentKatexMarkerId);
                                startMarkerInline.style.display = 'none';
                                appendToAnswer(null, startMarkerInline);
                                appendToAnswer('$');
                                appendToAnswer(char);
                                currentProcessingMode = MODE_KATEX_BUFFERING_INLINE;
                                katexBuffer = char;
                            }
                            break;
                        case MODE_KATEX_BUFFERING_INLINE:
                            if (char === '$') {
                                appendToAnswer('$');
                                if (currentKatexMarkerId) { renderAndReplaceKatex(false, currentKatexMarkerId); currentKatexMarkerId = null; }
                                else { console.error(`Attempted end inline KaTeX Turn ${currentTurnIdForMsg} no marker ID!`); }
                                currentProcessingMode = MODE_ANSWER;
                            } else { katexBuffer += char; appendToAnswer(char); }
                            break;
                        case MODE_KATEX_BUFFERING_DISPLAY:
                                if (char === '$' && currentPos + 1 < chunk.length && chunk[currentPos + 1] === '$') {
                                    appendToAnswer('$$');
                                    if (currentKatexMarkerId) { renderAndReplaceKatex(true, currentKatexMarkerId); currentKatexMarkerId = null; }
                                    else { console.error(`Attempted end display KaTeX Turn ${currentTurnIdForMsg} no marker ID!`); }
                                    currentProcessingMode = MODE_ANSWER; currentPos++;
                                } else { katexBuffer += char; appendToAnswer(char); }
                                break;
                        case MODE_SEEKING_TAG:
                            tagBuffer += char;
                            const lowerTag = tagBuffer.toLowerCase();
                            if (lowerTag === THINK_START_TAG) {
                                thinkBuffer = ''; currentProcessingMode = MODE_INSIDE_THINK; tagBuffer = ''; lastAppendedNode = null; // Assuming thinkBuffer is global/accessible
                            } else if (THINK_START_TAG.startsWith(lowerTag)) { /* Keep buffering */ }
                            else {
                                appendToAnswer(tagBuffer); currentProcessingMode = MODE_ANSWER; tagBuffer = ''; incrementPos = false;
                            }
                            if (tagBuffer.length > 20) {
                                    console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: Tag buffer excessive, treating as text: ${tagBuffer}`);
                                    appendToAnswer(tagBuffer); currentProcessingMode = MODE_ANSWER; tagBuffer = ''; incrementPos = false;
                            }
                            break;
                        case MODE_INSIDE_THINK:
                                if (char === '<') {
                                    tagBuffer = char; currentProcessingMode = MODE_MAYBE_END_THINK;
                                } else { appendRawTextToThinkingArea(char); } // Your existing function
                                break;
                        case MODE_MAYBE_END_THINK:
                                tagBuffer += char;
                                const lowerEndTag = tagBuffer.toLowerCase();
                                if (lowerEndTag === THINK_END_TAG) {
                                    thinkBuffer = ''; tagBuffer = ''; currentProcessingMode = MODE_ANSWER; lastAppendedNode = null;
                                } else if (THINK_END_TAG.startsWith(lowerEndTag)) { /* Keep buffering */ }
                                else {
                                    appendRawTextToThinkingArea(tagBuffer);
                                    currentProcessingMode = MODE_INSIDE_THINK; tagBuffer = ''; incrementPos = false;
                                }
                                if (tagBuffer.length > 20) {
                                        console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: End tag buffer excessive, treating as think text: ${tagBuffer}`);
                                        appendRawTextToThinkingArea(tagBuffer); currentProcessingMode = MODE_INSIDE_THINK; tagBuffer = ''; incrementPos = false;
                                }
                                break;
                        default:
                            console.error(`Unknown processing mode: ${currentProcessingMode} in Turn ${currentTurnIdForMsg}`);
                            appendToAnswer(char);
                            currentProcessingMode = MODE_ANSWER;
                    }

                    if (incrementPos) { currentPos++; }
                }
                scrollToBottom(); // Your existing function
            }
        };

        ws.onerror = (event) => {
            // This is the full onerror logic from your provided script
            console.error("WebSocket error observed:", event);
            if (typeof addErrorMessage === 'function') addErrorMessage("WebSocket connection error. Please check the server or try refreshing. See console for details.");
            if (typeof finalizeTurnOnErrorOrClose === 'function') finalizeTurnOnErrorOrClose();
            if (typeof resetAllCodeButtonsOnErrorOrClose === 'function') resetAllCodeButtonsOnErrorOrClose();
            if (typeof setInputDisabledState === 'function') setInputDisabledState(true);
        };

        ws.onclose = (event) => {
            // This is the full onclose logic from your provided script
            console.log("WebSocket connection closed.", event);
            if (typeof addSystemMessage === 'function') addSystemMessage(`Connection closed: ${event.reason || 'Normal closure'} (Code: ${event.code})`);
            if (typeof finalizeTurnOnErrorOrClose === 'function') finalizeTurnOnErrorOrClose();
            if (typeof resetAllCodeButtonsOnErrorOrClose === 'function') resetAllCodeButtonsOnErrorOrClose();
            if (event.code !== 1000 && event.code !== 1005) {
                console.log("Unexpected WebSocket closure. Attempting to reconnect WebSocket in 3 seconds...");
                if (typeof addSystemMessage === 'function') addSystemMessage("Attempting to reconnect...");
                if (typeof setInputDisabledState === 'function') setInputDisabledState(true);
                setTimeout(() => { websocket = null; if (typeof resetStreamingState === 'function') resetStreamingState(); currentAiTurnContainer = null; connectWebSocket(); }, 3000); // Assuming currentAiTurnContainer is global/accessible
            } else { if (typeof setInputDisabledState === 'function') setInputDisabledState(true); }
        };
        // -----------------------------------------------------------------------------------------

        console.log("[DEBUG] WebSocket object created and handlers assigned.");

    } catch (error) {
        console.error("[DEBUG] CRITICAL Error creating WebSocket object:", error);
        if (typeof addErrorMessage === 'function') { addErrorMessage(`WebSocket Creation Error: ${error.message}. Please check server and refresh.`); }
        else { alert(`WebSocket Creation Error: ${error.message}. Please check server and refresh.`); }
        if (typeof setInputDisabledState === 'function') setInputDisabledState(true);
    }
}

// --- Utility Functions --- 
// (debounce function)
// (throttle function defined above)

// Throttled function for highlighting the streaming code block
let throttledStreamHighlight = throttle(() => {
    // Optional: Keep logs to verify throttling
    console.log(">>> throttledStreamHighlight: Attempting highlight..."); 
    console.log(`>>> throttledStreamHighlight: currentProcessingMode = ${currentProcessingMode}`);
    console.log(">>> throttledStreamHighlight: currentCodeBlockElement =", currentCodeBlockElement);

    if (currentCodeBlockElement && currentProcessingMode === MODE_INSIDE_CODE_BLOCK) {
        console.log(">>> throttledStreamHighlight: Conditions met."); 
        try {
            if (typeof Prism !== 'undefined' && typeof Prism.highlightElement === 'function') {
                console.log(">>> throttledStreamHighlight: Calling Prism.highlightElement..."); 
                Prism.highlightElement(currentCodeBlockElement);
                console.log(">>> throttledStreamHighlight: Prism.highlightElement call completed."); 
            } else {
                console.warn(">>> throttledStreamHighlight: Prism.js or highlightElement not available!");
            }
        } catch (e) {
            console.error(">>> throttledStreamHighlight: Error during highlight:", e, currentCodeBlockElement);
        }
    } else {
         console.log(">>> throttledStreamHighlight: Conditions NOT met. Skipping highlight."); 
    }
// Throttle limit in milliseconds (e.g., run at most once every 250ms)
}, 250); // Adjust limit as needed (e.g., 200-500ms) 

// --- End Utility Functions ---

let debouncedStreamHighlight = debounce(() => {
    // --- ADDED LOGGING ---
    console.log(">>> debouncedStreamHighlight: Fired!"); 
    console.log(`>>> debouncedStreamHighlight: currentProcessingMode = ${currentProcessingMode}`);
    console.log(">>> debouncedStreamHighlight: currentCodeBlockElement =", currentCodeBlockElement);
    // --- END OF ADDED LOGGING ---

    // Check if we are currently inside a code block being streamed
    if (currentCodeBlockElement && currentProcessingMode === MODE_INSIDE_CODE_BLOCK) {
        console.log(">>> debouncedStreamHighlight: Conditions met. Attempting highlight."); // Log attempt
        try {
            // Check if Prism and highlightElement are available
            if (typeof Prism !== 'undefined' && typeof Prism.highlightElement === 'function') {
                console.log(">>> debouncedStreamHighlight: Prism.highlightElement found. Calling..."); // Log before call
                Prism.highlightElement(currentCodeBlockElement);
                console.log(">>> debouncedStreamHighlight: Prism.highlightElement call completed."); // Log after call
            } else {
                console.warn(">>> debouncedStreamHighlight: Prism.js or Prism.highlightElement not available!");
            }
        } catch (e) {
            console.error(">>> debouncedStreamHighlight: Error during highlight:", e, currentCodeBlockElement);
        }
    } else {
         console.log(">>> debouncedStreamHighlight: Conditions NOT met. Skipping highlight."); 
    }
}, 300); // Keep your debounce delay (e.g., 300ms)

// Helper function to escape HTML to prevent XSS where markdown is not intended.
function escapeHTML(str) {
    if (str === null || str === undefined) return '';
    return str.toString()
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}

/**
 * Renders a single message object (from history) into the chat history UI.
 * Handles user, system, and AI messages, including complex rendering for AI messages
 * (thinking area, code blocks, KaTeX, and Markdown).
 * Strips NO_THINK_PREFIX from historical user messages.
 * @param {object} msg - The message object from the database.
 * @param {HTMLElement} chatHistoryDiv - The main chat history container element.
 * @param {boolean} isHistory - Flag indicating if the message is from loaded history.
 */
function renderSingleMessage(msg, chatHistoryDiv, isHistory = false) {
    // Ensure essential parameters and libraries are available
    if (!chatHistoryDiv || !msg) {
        console.warn("[RenderMessage] Missing chatHistoryDiv or message object. Message:", msg);
        return;
    }
    if (typeof marked === 'undefined') {
        console.error("[RenderMessage] marked.js library is not loaded. Cannot render markdown content.");
        const plainTextDiv = document.createElement('div');
        plainTextDiv.classList.add('message-item', 'p-3', 'rounded-lg', 'max-w-xl', 'mb-2', 'break-words', 'bg-red-100', 'text-red-700');
        plainTextDiv.textContent = `Error: Markdown library not found. Raw content: ${msg.content || 'N/A'}`;
        chatHistoryDiv.appendChild(plainTextDiv);
        return;
    }
    if (typeof katex === 'undefined') {
        console.warn("[RenderMessage] KaTeX library not found. Math expressions may not render correctly.");
    }


    const senderType = msg.sender_type;
    let originalMessageContent = msg.content || ''; // Raw content from DB
    // Use sender_name from DB if available, otherwise determine default based on type
    const senderName = msg.sender_name || (senderType === 'ai' ? 'AI' : (senderType === 'user' ? 'User' : 'System'));
    const timestamp = msg.timestamp;
    const historicalThinkingContent = msg.thinking_content; // For AI messages

    const KATEX_PLACEHOLDER_PREFIX_HISTORICAL = '%%HISTORICAL_KATEX_PLACEHOLDER_';

    // --- Handle User and System Messages (Simpler Rendering) ---
    if (senderType === 'user' || senderType === 'system') {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message-item', 'p-3', 'rounded-lg', 'max-w-xl', 'mb-2', 'break-words', 'flex', 'flex-col');
        messageDiv.setAttribute('data-sender', senderType);
        if (msg.id) { messageDiv.setAttribute('data-message-id', String(msg.id)); }
        if (msg.client_id_temp && isHistory) { messageDiv.setAttribute('data-client-id-temp', msg.client_id_temp); }

        if (senderType === 'user') {
            messageDiv.classList.add('bg-emerald-100', 'self-end', 'ml-auto');
        } else { // System message
            messageDiv.classList.add('bg-slate-200', 'self-center', 'mx-auto', 'text-xs', 'italic');
        }

        const senderElem = document.createElement('p');
        senderElem.classList.add('font-semibold', 'text-sm', 'mb-1');
        if (senderType === 'user') senderElem.classList.add('text-emerald-700');
        else senderElem.classList.add('text-slate-600');
        // Use the senderName determined earlier (from DB or default)
        senderElem.textContent = escapeHTML(senderName); // escapeHTML should be defined
        messageDiv.appendChild(senderElem);

        const contentElem = document.createElement('div');
        contentElem.classList.add('text-gray-800', 'text-sm', 'message-content');

        // --- ADDED: Strip NO_THINK_PREFIX for historical user messages ---
        let displayedContent = originalMessageContent;
        if (senderType === 'user' && typeof NO_THINK_PREFIX === 'string' && NO_THINK_PREFIX.length > 0 && displayedContent.startsWith(NO_THINK_PREFIX)) {
            displayedContent = displayedContent.substring(NO_THINK_PREFIX.length);
            // console.log(`[RenderMessage] Stripped NO_THINK_PREFIX from historical user message ID: ${msg.id}`); // Optional log
        }
        // --- END OF ADDED CHANGE ---

        // For user/system, content is parsed as Markdown (after potential prefix stripping for user)
        contentElem.innerHTML = marked.parse(displayedContent);
        messageDiv.appendChild(contentElem);

        if (timestamp) {
            const timestampElem = document.createElement('p');
            timestampElem.classList.add('text-xs', 'text-slate-500', 'mt-1');
            if (senderType === 'user') timestampElem.classList.add('text-right');
            else timestampElem.classList.add('text-center');
            try {
                timestampElem.textContent = new Date(timestamp).toLocaleString();
            } catch (e) {
                timestampElem.textContent = String(timestamp); // Fallback for invalid date
            }
            messageDiv.appendChild(timestampElem);
        }
        chatHistoryDiv.appendChild(messageDiv);

    // --- Handle AI Messages (Complex Rendering - Assumed Correct from Previous Steps) ---
    } else if (senderType === 'ai') {
        // ... (Keep the complex AI message rendering logic from the previous version) ...
        // ... (This includes thinking area, code block extraction/rendering, KaTeX processing) ...
        
        // For brevity, the full AI rendering logic is omitted here, but it should be the
        // same as the one in the previous complete 'renderSingleMessage' function.
        // Ensure the following steps are performed on originalMessageContent:
        // 1. Extract code blocks, render them using createHistoricalCodeBlockDisplay, replace with placeholders.
        // 2. Extract KaTeX, render using katex.renderToString, replace with placeholders.
        // 3. Parse the remaining content with marked.parse().
        // 4. Reinsert the rendered KaTeX HTML.
        // 5. Assemble the full ai-turn-container with thinking, answer bubble, and code blocks area.

        // --- Start of AI Message Rendering Logic (Copied from previous complete version) ---
        const turnIdSuffix = msg.id ? String(msg.id) : `hist-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
        const aiTurnContainer = document.createElement('div');
        aiTurnContainer.classList.add('ai-turn-container');
        aiTurnContainer.setAttribute('data-sender', 'ai');
        if (msg.id) { aiTurnContainer.setAttribute('data-message-id', String(msg.id)); }
        if (msg.client_id_temp && isHistory) { aiTurnContainer.setAttribute('data-client-id-temp', msg.client_id_temp); }
        aiTurnContainer.dataset.turnId = `historical-${turnIdSuffix}`;

        // --- 1. Thinking Area Setup ---
        const thinkingArea = document.createElement('div');
        thinkingArea.classList.add('thinking-area');
        thinkingArea.dataset.turnId = `historical-${turnIdSuffix}`; 
        const details = document.createElement('details');
        details.id = `thinking-details-historical-${turnIdSuffix}`;
        const summary = document.createElement('summary');
        summary.classList.add('thinking-summary');
        const summaryTextSpan = document.createElement('span');
        summaryTextSpan.classList.add('text');
        summaryTextSpan.textContent = 'Show Thinking';
        const summaryDotsSpan = document.createElement('span'); 
        summaryDotsSpan.classList.add('dots');
        summary.appendChild(summaryTextSpan);
        summary.appendChild(summaryDotsSpan);
        const thinkingPreElement = document.createElement('pre');
        if (historicalThinkingContent && historicalThinkingContent.trim() !== "") {
            thinkingPreElement.textContent = historicalThinkingContent;
        } else {
            thinkingPreElement.textContent = '(No historical thinking data available for this AI message)';
            thinkingArea.style.display = 'none'; 
        }
        details.appendChild(summary);
        details.appendChild(thinkingPreElement);
        thinkingArea.appendChild(details);
        aiTurnContainer.appendChild(thinkingArea);
        details.addEventListener('toggle', (event) => {
            const textSpan = event.target.querySelector('.thinking-summary .text');
            if (!textSpan) return;
            textSpan.textContent = event.target.open ? 'Hide Thinking' : 'Show Thinking';
        });

        // --- Main Answer Bubble & Code Blocks Area ---
        const answerElement = document.createElement('div');
        answerElement.classList.add('message', 'ai-message', 'p-3', 'rounded-lg', 'max-w-xl', 'mb-2', 'break-words', 'flex', 'flex-col', 'bg-sky-100', 'self-start', 'mr-auto');
        const codeBlocksArea = document.createElement('div');
        codeBlocksArea.classList.add('code-blocks-area');
        let contentForProcessing = originalMessageContent;

        // --- 2. Extract and Render Code Blocks ---
        let historicalCodeBlockCounter = 0;
        const codeBlockRegex = /```(\w*)\n([\s\S]*?)\n```/g; 
        let matchCode;
        const extractedCodeBlocks = [];
        let tempContentForCodeExtraction = contentForProcessing;
        let contentAfterCodeExtraction = "";
        let lastCodeMatchEndIndex = 0;
        while ((matchCode = codeBlockRegex.exec(tempContentForCodeExtraction)) !== null) {
            historicalCodeBlockCounter++;
            const language = matchCode[1] || 'plaintext'; 
            const code = matchCode[2];
            const placeholder = `%%HISTORICAL_CODE_BLOCK_${historicalCodeBlockCounter}%%`;
            extractedCodeBlocks.push({ language, code, placeholder, index: historicalCodeBlockCounter });
            contentAfterCodeExtraction += tempContentForCodeExtraction.substring(lastCodeMatchEndIndex, matchCode.index);
            contentAfterCodeExtraction += placeholder;
            lastCodeMatchEndIndex = codeBlockRegex.lastIndex; 
        }
        contentAfterCodeExtraction += tempContentForCodeExtraction.substring(lastCodeMatchEndIndex);
        contentForProcessing = contentAfterCodeExtraction; 
        extractedCodeBlocks.forEach(block => {
            if (typeof createHistoricalCodeBlockDisplay === 'function') {
                createHistoricalCodeBlockDisplay(block.language, block.code, turnIdSuffix, block.index, codeBlocksArea);
            } else {
                console.warn('createHistoricalCodeBlockDisplay function is not defined. Cannot render historical code block fully.');
                 const fallbackDiv = document.createElement('div'); 
                 fallbackDiv.textContent = `[Code ${block.index} (${block.language}) - Full display unavailable]`;
                 codeBlocksArea.appendChild(fallbackDiv);
            }
            const referenceText = ` [Code ${block.index}] `;
            contentForProcessing = contentForProcessing.replace(block.placeholder, referenceText);
        });

        // --- 3. Pre-process for KaTeX ---
        const storedHistoricalKatex = {}; 
        let katexPlaceholderIndex = 0;
        const katexRegexGlobal = /(?<!\\)\$\$([\s\S]+?)(?<!\\)\$\$|(?<!\\)\$((?:\\\$|[^$])+?)(?<!\\)\$/g;
        let textForMarkdownParsing = contentForProcessing.replace(katexRegexGlobal, (match, displayContent, inlineContent) => {
            const isDisplayMode = !!displayContent; 
            const katexString = displayContent || inlineContent;
            const cleanedKatexString = katexString.replace(/\\([$])/g, '$1');
            let katexHtml = '';
            if (typeof katex !== 'undefined' && typeof katex.renderToString === 'function') {
                try {
                    katexHtml = katex.renderToString(cleanedKatexString, {
                        displayMode: isDisplayMode, throwOnError: false, output: "html", strict: false 
                    });
                } catch (e) {
                    console.error("Error rendering historical KaTeX:", e, "Original string:", match);
                    katexHtml = `<span class="katex-error" title="${escapeHTML(e.toString())}">${escapeHTML(match)}</span>`;
                }
            } else {
                return match; 
            }
            const placeholderId = `${KATEX_PLACEHOLDER_PREFIX_HISTORICAL}${katexPlaceholderIndex++}`;
            storedHistoricalKatex[placeholderId] = katexHtml; 
            return placeholderId; 
        });

        // --- 4. Markdown Parsing ---
        const senderElemAI = document.createElement('p'); // Use different var name to avoid conflict
        senderElemAI.classList.add('font-semibold', 'text-sm', 'mb-1', 'text-sky-700');
        senderElemAI.textContent = escapeHTML(senderName); // Use senderName which is 'AI' here
        answerElement.appendChild(senderElemAI);
        const contentElemAI = document.createElement('div'); // Use different var name
        contentElemAI.classList.add('text-gray-800', 'text-sm', 'message-content');
        contentElemAI.innerHTML = marked.parse(textForMarkdownParsing); 
        answerElement.appendChild(contentElemAI);

        // --- 5. KaTeX Post-processing ---
        if (Object.keys(storedHistoricalKatex).length > 0) {
            const walker = document.createTreeWalker(contentElemAI, NodeFilter.SHOW_TEXT, null, false);
            let node;
            const textNodesToModify = []; 
            while (node = walker.nextNode()) {
                if (node.nodeValue && node.nodeValue.includes(KATEX_PLACEHOLDER_PREFIX_HISTORICAL)) {
                    textNodesToModify.push(node);
                }
            }
            textNodesToModify.forEach(textNode => {
                let currentTextValue = textNode.nodeValue;
                const parent = textNode.parentNode;
                if (!parent) return;
                const fragment = document.createDocumentFragment(); 
                let lastSplitEnd = 0;
                const placeholderScanRegex = new RegExp(`(${KATEX_PLACEHOLDER_PREFIX_HISTORICAL}\\d+)`, 'g');
                let placeholderMatch;
                while((placeholderMatch = placeholderScanRegex.exec(currentTextValue)) !== null) {
                    const placeholderId = placeholderMatch[1]; 
                    const matchStartIndex = placeholderMatch.index;
                    if (matchStartIndex > lastSplitEnd) {
                        fragment.appendChild(document.createTextNode(currentTextValue.substring(lastSplitEnd, matchStartIndex)));
                    }
                    if (storedHistoricalKatex[placeholderId]) {
                        const katexWrapperSpan = document.createElement('span');
                        katexWrapperSpan.innerHTML = storedHistoricalKatex[placeholderId];
                        if (katexWrapperSpan.childNodes.length === 1 && katexWrapperSpan.firstChild.nodeType === Node.ELEMENT_NODE) {
                             fragment.appendChild(katexWrapperSpan.firstChild);
                        } else {
                             fragment.appendChild(katexWrapperSpan);
                        }
                    } else {
                        fragment.appendChild(document.createTextNode(placeholderId));
                    }
                    lastSplitEnd = placeholderScanRegex.lastIndex; 
                }
                if (lastSplitEnd < currentTextValue.length) {
                    fragment.appendChild(document.createTextNode(currentTextValue.substring(lastSplitEnd)));
                }
                parent.replaceChild(fragment, textNode);
            });
        }

        // --- Timestamp and Final Assembly ---
        if (timestamp) {
            const timestampElemAI = document.createElement('p'); // Use different var name
            timestampElemAI.classList.add('text-xs', 'text-slate-500', 'mt-1', 'text-left');
            try {
                timestampElemAI.textContent = new Date(timestamp).toLocaleString();
            } catch (e) {
                timestampElemAI.textContent = String(timestamp);
            }
            answerElement.appendChild(timestampElemAI);
        }
        aiTurnContainer.appendChild(answerElement); 
        aiTurnContainer.appendChild(codeBlocksArea);  
        chatHistoryDiv.appendChild(aiTurnContainer); 
        // --- End of AI Message Rendering Logic ---
    }
}




/**
 * Fetches chat history for the current session and displays it.
 * @param {string} sessionId - The ID of the current chat session.
 */
async function loadAndDisplayChatHistory(sessionId) {
    const chatHistoryDiv = document.getElementById('chat-history');
    if (!chatHistoryDiv) {
        console.error("Chat history container 'chat-history' not found.");
        return;
    }

    // Update chat session title - assuming it's available via an API or could be fetched.
    // For now, we'll set a generic one or rely on existing logic if it sets the title.
    // const chatSessionTitleElement = document.getElementById('chat-session-title');
    // if (chatSessionTitleElement) chatSessionTitleElement.textContent = `Chat: ${sessionId.substring(0,8)}...`;


    chatHistoryDiv.innerHTML = '<p class="text-center text-gray-500 p-4">Loading history...</p>'; 

    try {
        const response = await fetch(`/api/sessions/${sessionId}/messages`);
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ detail: "Failed to load chat history." }));
            console.error(`Error fetching chat history for session ${sessionId}:`, response.status, errorData.detail);
            chatHistoryDiv.innerHTML = `<p class="text-center text-red-500 p-4">Error loading history: ${escapeHTML(errorData.detail || response.statusText)}</p>`;
            return;
        }

        const messages = await response.json();
        chatHistoryDiv.innerHTML = ''; // Clear loading indicator

        if (messages.length === 0) {
            chatHistoryDiv.innerHTML = '<p class="text-center text-gray-500 p-4">No messages in this session yet. Start chatting!</p>';
        } else {
            messages.forEach(msg => {
                // Use the new renderSingleMessage function
                renderSingleMessage(msg, chatHistoryDiv, true);
            });
            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight; 
        }
        console.log(`Successfully loaded ${messages.length} messages for session ${sessionId}.`);

    } catch (error) {
        console.error(`Failed to fetch or display chat history for session ${sessionId}:`, error);
        chatHistoryDiv.innerHTML = `<p class="text-center text-red-500 p-4">An unexpected error occurred while loading history. Check console.</p>`;
    }
}



/**
 * Creates and appends a display structure for a historical code block,
 * making the code editable, re-highlighting on input, and hiding the
 * run button for unsupported languages.
 * @param {string} language - The language of the code.
 * @param {string} codeContent - The actual code string.
 * @param {string} turnIdSuffix - A unique suffix for element IDs within this historical turn.
 * @param {number} codeBlockIndex - The 1-based index of this code block within the AI turn.
 * @param {HTMLElement} codeBlocksAreaElement - The parent DOM element to append this code block to.
 */
function createHistoricalCodeBlockDisplay(language, codeContent, turnIdSuffix, codeBlockIndex, codeBlocksAreaElement) {
    // Ensure the target area for code blocks exists
    if (!codeBlocksAreaElement) {
        console.error("createHistoricalCodeBlockDisplay: Code blocks area element is null! Cannot append code block.");
        return;
    }

    const blockId = `historical-code-block-turn${turnIdSuffix}-${codeBlockIndex}`;
    const safeLanguage = (language || '').trim().toLowerCase() || 'plaintext';

    // Language aliases and Prism language determination (as before)
    const langAlias = { /* ... keep your existing aliases ... */
        'python': 'python', 'py': 'python', 'javascript': 'javascript', 'js': 'javascript',
        'html': 'markup', 'xml': 'markup', 'svg': 'markup', 'css': 'css', 'bash': 'bash',
        'sh': 'bash', 'shell': 'bash', 'json': 'json', 'yaml': 'yaml', 'yml': 'yaml',
        'markdown': 'markdown', 'md': 'markdown', 'sql': 'sql', 'java': 'java', 'c': 'c',
        'cpp': 'cpp', 'c++': 'cpp', 'csharp': 'csharp', 'cs': 'csharp', 'go': 'go',
        'rust': 'rust', 'php': 'php', 'ruby': 'ruby', 'rb': 'ruby',
        'dockerfile': 'docker', 'docker': 'docker', 'typescript': 'typescript', 'ts': 'typescript',
        'plaintext': 'plain', 'text': 'plain',
     };
    const prismLang = langAlias[safeLanguage] || safeLanguage;
    const displayLang = safeLanguage; // Use the cleaned-up language name for checks/display

    // --- ADD: List of languages supported by the backend Docker execution ---
    // Make sure this list matches the one in createCodeBlockStructure
    const supportedExecutionLanguages = [
        "python", "javascript", "cpp", "csharp", "typescript", "java", "go", "rust"
        // Add or remove languages based on your config.py SUPPORTED_LANGUAGES keys
    ];
    const isLanguageSupported = supportedExecutionLanguages.includes(displayLang);
    // --- END OF ADD ---


    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;

    const container = document.createElement('div');
    container.classList.add('code-block-container', 'historical-code-block');
    container.id = blockId;
    container.dataset.language = displayLang;

    const codeHeader = document.createElement('div');
    codeHeader.classList.add('code-block-header');

    const codeButtonsDiv = document.createElement('div');
    codeButtonsDiv.classList.add('code-block-buttons');

    // Create buttons (as before)
    const runStopBtn = document.createElement('button');
    runStopBtn.classList.add('run-code-btn', 'code-action-btn');
    runStopBtn.innerHTML = playIconSvg;
    runStopBtn.title = 'Run Code';
    runStopBtn.dataset.status = 'idle';
    runStopBtn.addEventListener('click', handleRunStopCodeClick);

    const toggleCodeBtn = document.createElement('button');
    toggleCodeBtn.classList.add('toggle-code-btn', 'code-action-btn');
    toggleCodeBtn.textContent = 'Hide';
    toggleCodeBtn.title = 'Show/Hide Code';

    const copyCodeBtn = document.createElement('button');
    copyCodeBtn.classList.add('copy-code-btn', 'code-action-btn');
    copyCodeBtn.textContent = 'Copy';
    copyCodeBtn.title = 'Copy Code';

    // --- ADD: Conditionally hide run button ---
    if (!isLanguageSupported) {
        runStopBtn.style.display = 'none'; // Hide the button entirely
        runStopBtn.title = `Run Code (language '${displayLang}' not supported for execution)`; // Update title
    }
    // --- END OF ADD ---

    // Add buttons to their container
    codeButtonsDiv.appendChild(runStopBtn);
    codeButtonsDiv.appendChild(toggleCodeBtn);
    codeButtonsDiv.appendChild(copyCodeBtn);

    // Code block title (as before)
    const codeTitle = document.createElement('span');
    codeTitle.classList.add('code-block-title');
    codeTitle.textContent = `Code ${codeBlockIndex} (${displayLang})`;
    codeTitle.style.flexGrow = '1';
    codeTitle.style.textAlign = 'left';

    // Assemble header (as before)
    codeHeader.appendChild(codeButtonsDiv);
    codeHeader.appendChild(codeTitle);

    // Create pre/code elements (as before)
    const preElement = document.createElement('pre');
    preElement.classList.add('manual');
    const codeElement = document.createElement('code');
    codeElement.className = `language-${prismLang}`;
    codeElement.setAttribute('contenteditable', 'true'); // Historical code editable
    codeElement.setAttribute('spellcheck', 'false');
    codeElement.textContent = codeContent;

    // Assemble code display area (as before)
    preElement.appendChild(codeElement);
    container.appendChild(codeHeader);
    container.appendChild(preElement);

    // Create output area structure (as before)
    const outputHeader = document.createElement('div');
    outputHeader.classList.add('code-output-header');
    outputHeader.style.display = 'none';
    // ... (rest of output header setup: buttons, title, status span) ...
    const outputButtonsDiv = document.createElement('div');
    outputButtonsDiv.classList.add('code-block-buttons');
    const placeholderSpan = document.createElement('span');
    placeholderSpan.classList.add('output-header-button-placeholder');
    outputButtonsDiv.appendChild(placeholderSpan);
    const toggleOutputBtn = document.createElement('button');
    toggleOutputBtn.classList.add('toggle-output-btn', 'code-action-btn');
    toggleOutputBtn.textContent = 'Hide';
    toggleOutputBtn.title = 'Show/Hide Output';
    const copyOutputBtn = document.createElement('button');
    copyOutputBtn.classList.add('copy-output-btn', 'code-action-btn');
    copyOutputBtn.textContent = 'Copy';
    copyOutputBtn.title = 'Copy Output';
    outputButtonsDiv.appendChild(toggleOutputBtn);
    outputButtonsDiv.appendChild(copyOutputBtn);
    const outputTitle = document.createElement('span');
    outputTitle.classList.add('output-header-title');
    outputTitle.textContent = `Output Code ${codeBlockIndex}`;
    const codeStatusSpan = document.createElement('span');
    codeStatusSpan.classList.add('code-status-span');
    codeStatusSpan.textContent = 'Idle';
    outputHeader.appendChild(outputButtonsDiv);
    outputHeader.appendChild(outputTitle);
    outputHeader.appendChild(codeStatusSpan);

    const outputConsoleDiv = document.createElement('div');
    outputConsoleDiv.classList.add('code-output-console');
    outputConsoleDiv.style.display = 'none';
    const outputPre = document.createElement('pre');
    outputConsoleDiv.appendChild(outputPre);

    // Append output area to container (as before)
    container.appendChild(outputHeader);
    container.appendChild(outputConsoleDiv);

    // Add event listeners (as before)
    // Toggle code listener
    toggleCodeBtn.addEventListener('click', () => {
        const isHidden = preElement.classList.toggle('hidden');
        toggleCodeBtn.textContent = isHidden ? 'Show' : 'Hide';
    });
    // Copy code listener
    copyCodeBtn.addEventListener('click', async () => {
        try {
            await navigator.clipboard.writeText(codeElement.textContent || '');
            copyCodeBtn.textContent = 'Copied!';
            copyCodeBtn.classList.add('copied');
            setTimeout(() => { copyCodeBtn.textContent = 'Copy'; copyCodeBtn.classList.remove('copied'); }, 1500);
        } catch (err) {
            console.error('Failed to copy historical code: ', err);
            copyCodeBtn.textContent = 'Error';
            setTimeout(() => { copyCodeBtn.textContent = 'Copy'; }, 1500);
        }
    });
    // Run button listener is already attached above
    // Debounced highlight listener for editable historical code (as before)
    const debouncedHistoricalHighlight = debounce(() => {
        const savedPosition = getCursorPosition(codeElement);
        if (savedPosition === -1) { console.warn(`Could not save cursor position for historical block ${blockId}. Highlight may cause cursor jump.`); }
        try {
            const currentText = codeElement.textContent;
            codeElement.innerHTML = ''; 
            codeElement.textContent = currentText; 
            Prism.highlightElement(codeElement); 
            if (savedPosition !== -1) { setCursorPosition(codeElement, savedPosition); }
        } catch (e) {
            console.error(`Error during debounced highlighting for historical block ${blockId}:`, e);
            if (savedPosition !== -1) { setCursorPosition(codeElement, savedPosition); }
        }
    }, 500); 
    codeElement.addEventListener('input', debouncedHistoricalHighlight);
    codeElement.addEventListener('paste', (e) => { setTimeout(debouncedHistoricalHighlight, 100); });
    // Output area listeners (as before)
    toggleOutputBtn.addEventListener('click', () => {
        const isHidden = outputConsoleDiv.classList.toggle('hidden');
        toggleOutputBtn.textContent = isHidden ? 'Show' : 'Hide';
    });
    copyOutputBtn.addEventListener('click', async () => {
        if (!outputPre) return;
        try {
            await navigator.clipboard.writeText(outputPre.textContent || '');
            copyOutputBtn.textContent = 'Copied!';
            copyOutputBtn.classList.add('copied');
            setTimeout(() => { copyOutputBtn.textContent = 'Copy'; copyOutputBtn.classList.remove('copied'); }, 1500);
        } catch (err) {
            console.error('Failed to copy historical output: ', err);
            copyOutputBtn.textContent = 'Error';
            setTimeout(() => { copyOutputBtn.textContent = 'Copy'; }, 1500);
        }
    });

    // Apply initial Prism highlighting (as before)
    if (typeof Prism !== 'undefined' && typeof Prism.highlightElement === 'function') {
        try {
            Prism.highlightElement(codeElement);
        } catch (e) {
            console.error(`Prism highlight error on initial historical code block (lang '${prismLang}', ID: ${blockId}):`, e, codeElement);
        }
    } else {
        console.warn("Prism.js or Prism.highlightElement not available. Historical code will not be highlighted.");
    }

    // Append the fully constructed code block to the designated area
    codeBlocksAreaElement.appendChild(container);
}


// --- User Info Initialization ---
async function initializeCurrentUser() {
    try {
        const response = await fetch('/api/me');
        if (response.ok) {
            const userData = await response.json();
            if (userData && userData.name) {
                window.currentUserInfo = {
                    name: userData.name,
                    email: userData.email,
                    id: userData.id
                };
            } else {
                window.currentUserInfo = null;
            }
        } else {
            window.currentUserInfo = null;
        }
    } catch (error) {
        window.currentUserInfo = null;
    }
}

// --- DOMContentLoaded Event Listener ---
document.addEventListener('DOMContentLoaded', async () => {
    await initializeCurrentUser();

    // const listElementCheck = document.getElementById('session-list'); // Not used here

    if (typeof setInputDisabledState === 'function') {
        setInputDisabledState(true, false); 
    }

    if (typeof marked !== 'undefined' && typeof marked.setOptions === 'function') {
        marked.setOptions({
            gfm: true, breaks: true, sanitize: false, smartLists: true, smartypants: false,
        });
    }

    if (chatForm && messageInput && sendButton && stopAiButton) {
        chatForm.addEventListener('submit', (event) => {
            event.preventDefault();
            const userMessage = messageInput.value.trim();
            if (!userMessage) return;
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                if (typeof addErrorMessage === 'function') addErrorMessage("Not connected to the server.");
                return;
            }
            try {
                if (typeof addUserMessage === 'function') addUserMessage(userMessage);
                thinkingRequestedForCurrentTurn = thinkCheckbox ? thinkCheckbox.checked : false;
                let messageTextForPayload;
                if (thinkingRequestedForCurrentTurn) {
                    messageTextForPayload = THINK_PREFIX + userMessage.replace(NO_THINK_PREFIX, '').replace(THINK_PREFIX, '');
                } else {
                    messageTextForPayload = NO_THINK_PREFIX + userMessage.replace(NO_THINK_PREFIX, '').replace(THINK_PREFIX, '');
                }
                if (typeof setupNewAiTurn === 'function') setupNewAiTurn();
                
                const messagePayload = {
                    type: "chat_message",
                    payload: {
                        user_input: messageTextForPayload,
                        turn_id: currentTurnId 
                    }
                };
                websocket.send(JSON.stringify(messagePayload));
                
                messageInput.value = '';
                if (typeof setInputDisabledState === 'function') {
                    setInputDisabledState(true, true); 
                }
            } catch (sendError) {
                if (typeof addErrorMessage === 'function') addErrorMessage(`Failed to send message: ${sendError.message}`);
            }
        });

        stopAiButton.addEventListener('click', () => {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                if (typeof addErrorMessage === 'function') addErrorMessage("Cannot stop: Not connected.");
                return;
            }
            const sessionId = (typeof getSessionIdFromPath === 'function') ? getSessionIdFromPath() : null;
            if (!sessionId) {
                if (typeof addErrorMessage === 'function') addErrorMessage("Cannot stop: Session ID not found.");
                return;
            }
            websocket.send(JSON.stringify({
                type: "stop_ai_stream",
                payload: {
                    client_id: clientId,
                    session_id: sessionId,
                    turn_id: currentTurnId 
                }
            }));
            stopAiButton.disabled = true;
            stopAiButton.innerHTML = `
                <svg class="animate-spin h-5 w-5 mr-1 text-white inline-block" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                  <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Stopping...`;
            
            if (typeof finalizeTurnOnErrorOrClose === 'function') {
                finalizeTurnOnErrorOrClose();
            }
        });

    } else {
        if (window.location.pathname.includes("/chat/")) {
            if (typeof addErrorMessage === 'function') addErrorMessage("Initialization Error: Chat input components missing.");
        }
    }

    const currentSessionId = (typeof getSessionIdFromPath === 'function') ? getSessionIdFromPath() : null;
    if (currentSessionId) {
        if (typeof loadAndDisplayChatHistory === 'function') { 
            // await loadAndDisplayChatHistory(currentSessionId); // Assuming this function exists
        }
        if (typeof connectWebSocket === 'function') {
            connectWebSocket();
        } else {
            if (typeof addErrorMessage === 'function') addErrorMessage("Error: Cannot connect to chat server.");
        }
    } else {
        if (messageInput && typeof setInputDisabledState === 'function') {
             setInputDisabledState(true, false); 
        }
    }
});

=== app/static/session-choice.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to Tesseracs Chat</title>
    <link rel="stylesheet" href="/dist/input.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        .sidebar-scrollable { overflow-y: auto; scrollbar-width: thin; scrollbar-color: #a0aec0 #edf2f7; }
        .sidebar-scrollable::-webkit-scrollbar { width: 6px; }
        .sidebar-scrollable::-webkit-scrollbar-track { background: #edf2f7; border-radius: 3px; }
        .sidebar-scrollable::-webkit-scrollbar-thumb { background-color: #a0aec0; border-radius: 3px; border: 1px solid #edf2f7; }
    </style>
</head>
<body class="font-sans bg-gray-100 text-gray-800">

    <div class="flex h-screen overflow-hidden">
        <aside id="sidebar-loader-target" class="w-64 bg-gray-800 text-gray-200 flex flex-col overflow-hidden">
            </aside>

        <main id="session-choice-content" class="flex-1 flex flex-col p-6 overflow-y-auto items-center justify-center">
            <div class="bg-white p-8 rounded-lg shadow-xl text-center max-w-lg">
                <h1 class="text-3xl font-bold text-gray-800 mb-4">Welcome to Tesseracs Chat!</h1>
                <p class="text-gray-600 mb-6">
                    Select an existing session from the sidebar to continue your conversations,
                    or click "New Chat" in the sidebar to start a fresh one.
                </p>
                <p class="text-gray-500 text-sm">
                    Engage in dynamic chat sessions, powered by advanced AI. Your discussions are saved and can be revisited anytime.
                </p>
            </div>
            <div class="mt-10 text-center">
                <h2 class="text-xl font-semibold text-gray-700 mb-3">About Tesseracs</h2>
                <p class="text-gray-600">
                    Tesseracs Chat is designed for seamless and intelligent conversations. <br/>
                    Manage your chat sessions efficiently and collaborate with AI.
                </p>
            </div>
        </main>
    </div>

    <script type="module">
        import { loadSidebarHTML, populateSessionList } from '/static/js/app-ui.js';

        document.addEventListener('DOMContentLoaded', async () => {
            console.log("Session Choice Page (Welcome Page): DOMContentLoaded. Attempting to load UI components.");
            
            const sidebarLoaded = await loadSidebarHTML('/static/_sidebar.html', 'sidebar-loader-target');
            
            if (sidebarLoaded) {
                // Use '/chat/' as the base URL, so links become /chat/SESSION_ID
                await populateSessionList('/api/sessions', 'session-list', '/chat/');
            } else {
                console.error("Session Choice Page: Sidebar loading failed, session list will not be populated by app-ui.js.");
            }
        });
    </script>
</body>
</html>

=== app/static/settings.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>User Settings - Tesseracs Chat</title>
    <link rel="stylesheet" href="/dist/input.css"> <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Styles for sidebar scrolling, consistent with other pages */
        .sidebar-scrollable { overflow-y: auto; scrollbar-width: thin; scrollbar-color: #a0aec0 #edf2f7; }
        .sidebar-scrollable::-webkit-scrollbar { width: 6px; }
        .sidebar-scrollable::-webkit-scrollbar-track { background: #edf2f7; border-radius: 3px; }
        .sidebar-scrollable::-webkit-scrollbar-thumb { background-color: #a0aec0; border-radius: 3px; border: 1px solid #edf2f7; }

        /* Additional styles for the settings page content */
        .settings-card {
            background-color: white;
            padding: 2rem; /* 32px */
            border-radius: 0.5rem; /* 8px */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            max-width: 600px;
            width: 100%;
        }
        .form-input {
            width: 100%;
            padding: 0.75rem 1rem; /* 12px 16px */
            border: 1px solid #d1d5db; /* Tailwind gray-300 */
            border-radius: 0.375rem; /* 6px */
            font-size: 0.875rem; /* 14px */
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .form-input:focus {
            border-color: #2563eb; /* Tailwind blue-600 */
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3); /* Tailwind blue-300 with opacity */
            outline: none;
        }
        .submit-button {
            padding: 0.75rem 1.5rem;
            background-color: #2563eb; /* Tailwind blue-600 */
            color: white;
            border-radius: 0.375rem;
            font-weight: 500;
            font-size: 0.875rem;
            transition: background-color 0.2s ease-in-out;
            cursor: pointer;
        }
        .submit-button:hover {
            background-color: #1d4ed8; /* Tailwind blue-700 */
        }
        .submit-button:disabled {
            background-color: #9ca3af; /* Tailwind gray-400 */
            cursor: not-allowed;
        }
        .message-area { /* For success/error messages */
            padding: 0.75rem 1rem;
            border-radius: 0.375rem;
            text-align: center;
            margin-bottom: 1rem;
            font-size: 0.875rem;
        }
        .message-success {
            background-color: #d1fae5; /* Tailwind green-100 */
            color: #065f46; /* Tailwind green-800 */
            border: 1px solid #6ee7b7; /* Tailwind green-300 */
        }
        .message-error {
            background-color: #fee2e2; /* Tailwind red-100 */
            color: #991b1b; /* Tailwind red-800 */
            border: 1px solid #fca5a5; /* Tailwind red-300 */
        }
        .section-divider {
            margin-top: 2rem; /* 32px */
            padding-top: 1.5rem; /* 24px */
            border-top: 1px solid #e5e7eb; /* Tailwind gray-200 */
        }
    </style>
</head>
<body class="font-sans bg-gray-100 text-gray-800">

    <div class="flex h-screen overflow-hidden">
        <aside id="sidebar-loader-target" class="w-64 bg-gray-800 text-gray-200 flex flex-col overflow-hidden">
            </aside>

        <main class="flex-1 flex flex-col overflow-y-auto p-6 items-center">
            <div class="settings-card">
                <h1 class="text-2xl font-semibold text-gray-900 mb-6 border-b pb-4">User Settings</h1>

                <div id="settings-message-area" class="message-area" style="display: none;"></div>

                <section id="account-settings">
                    <h2 class="text-xl font-medium text-gray-700 mb-4">Account Settings</h2>

                    <form id="update-name-form" class="space-y-4">
                        <div>
                            <label for="current-name" class="block text-sm font-medium text-gray-700 mb-1">Current Name</label>
                            <input type="text" id="current-name" name="current-name" readonly
                                   class="form-input bg-gray-100 cursor-not-allowed"
                                   placeholder="Loading...">
                        </div>
                        <div>
                            <label for="new-name" class="block text-sm font-medium text-gray-700 mb-1">New Name</label>
                            <input type="text" id="new-name" name="new-name" required
                                   class="form-input"
                                   minlength="1" maxlength="100">
                        </div>
                        <div>
                            <label for="current-password-for-name" class="block text-sm font-medium text-gray-700 mb-1">Current Password (to confirm name change)</label>
                            <input type="password" id="current-password-for-name" name="current-password-for-name" required
                                   class="form-input">
                        </div>
                        <div>
                            <button type="submit" id="update-name-button" class="submit-button">
                                Update Name
                            </button>
                        </div>
                    </form>
                    <div class="section-divider">
                        <h3 class="text-lg font-medium text-gray-700 mb-3">Change Email</h3>
                         <p class="text-sm text-gray-500 mb-3">
                            Your email address is used for login and notifications.
                            You will be logged out after changing your email.
                        </p>
                        <form id="update-email-form" class="space-y-4">
                            <div>
                                <label for="current-email" class="block text-sm font-medium text-gray-700 mb-1">Current Email</label>
                                <input type="email" id="current-email" name="current-email" readonly
                                       class="form-input bg-gray-100 cursor-not-allowed"
                                       placeholder="Loading...">
                            </div>
                            <div>
                                <label for="new-email" class="block text-sm font-medium text-gray-700 mb-1">New Email Address</label>
                                <input type="email" id="new-email" name="new-email" required
                                       class="form-input">
                            </div>
                            <div>
                                <label for="current-password-for-email" class="block text-sm font-medium text-gray-700 mb-1">Current Password (to confirm email change)</label>
                                <input type="password" id="current-password-for-email" name="current-password-for-email" required
                                       class="form-input">
                            </div>
                            <div>
                                <button type="submit" id="update-email-button" class="submit-button">
                                    Update Email Address
                                </button>
                            </div>
                        </form>
                    </div>
                    <div class="section-divider">
                        <h3 class="text-lg font-medium text-gray-700 mb-3">Regenerate Password</h3>
                        <p class="text-sm text-gray-500 mb-3">
                            This will generate a new password for your account and email it to you.
                            You will be logged out after regenerating your password.
                        </p>
                        <form id="regenerate-password-form" class="space-y-4">
                            <div>
                                <label for="current-password-for-regen" class="block text-sm font-medium text-gray-700 mb-1">Current Password (to confirm regeneration)</label>
                                <input type="password" id="current-password-for-regen" name="current-password-for-regen" required
                                       class="form-input">
                            </div>
                            <div>
                                <button type="submit" id="regenerate-password-button" class="submit-button">
                                    Regenerate Password & Send Email
                                </button>
                            </div>
                        </form>
                    </div>
                    </section>
            </div>
        </main>
    </div>

    <script type="module">
        // Import sidebar loading functions from app-ui.js
        import { loadSidebarHTML, populateSessionList } from '/static/js/app-ui.js';

        document.addEventListener('DOMContentLoaded', async () => {
            console.log("Settings Page: DOMContentLoaded.");

            // Load the sidebar
            const sidebarLoaded = await loadSidebarHTML('/static/_sidebar.html', 'sidebar-loader-target');
            if (sidebarLoaded) {
                await populateSessionList('/api/sessions', 'session-list', '/chat/');
            } else {
                console.error("Settings Page: Sidebar loading failed.");
            }

            // --- General DOM Elements ---
            const settingsMessageArea = document.getElementById('settings-message-area');

            // Function to display messages
            function showSettingsMessage(message, type = 'info', duration = 0) {
                settingsMessageArea.textContent = message;
                settingsMessageArea.className = 'message-area'; // Reset classes
                if (type === 'success') {
                    settingsMessageArea.classList.add('message-success');
                } else if (type === 'error') {
                    settingsMessageArea.classList.add('message-error');
                } else { 
                    settingsMessageArea.classList.add('bg-blue-100', 'text-blue-700', 'border-blue-300');
                }
                settingsMessageArea.style.display = 'block';

                if (duration > 0) {
                    setTimeout(() => {
                        settingsMessageArea.style.display = 'none';
                    }, duration);
                }
            }

            // --- User Info Fetching ---
            const currentNameInput = document.getElementById('current-name');
            const currentEmailInput = document.getElementById('current-email'); // For Change Email form

            async function fetchCurrentUser() {
                try {
                    const response = await fetch('/api/me');
                    if (response.ok) {
                        const userData = await response.json();
                        if (currentNameInput) {
                            currentNameInput.value = userData.name;
                        }
                        if (currentEmailInput) { // Populate current email field
                            currentEmailInput.value = userData.email;
                        }
                        window.currentUserDetails = userData; 
                    } else {
                        console.error('Failed to fetch current user details:', response.status);
                        if (currentNameInput) currentNameInput.value = 'Error loading name';
                        if (currentEmailInput) currentEmailInput.value = 'Error loading email';
                        showSettingsMessage('Could not load your current user details.', 'error');
                    }
                } catch (error) {
                    console.error('Error fetching current user details:', error);
                    if (currentNameInput) currentNameInput.value = 'Error loading name';
                    if (currentEmailInput) currentEmailInput.value = 'Error loading email';
                    showSettingsMessage('An error occurred while loading your details.', 'error');
                }
            }
            await fetchCurrentUser(); 

            // --- Update Name Functionality ---
            const updateNameForm = document.getElementById('update-name-form');
            const newNameInput = document.getElementById('new-name');
            const currentPasswordForNameInput = document.getElementById('current-password-for-name');
            const updateNameButton = document.getElementById('update-name-button');

            if (updateNameForm) {
                updateNameForm.addEventListener('submit', async (event) => {
                    event.preventDefault();
                    settingsMessageArea.style.display = 'none'; 
                    updateNameButton.disabled = true;
                    updateNameButton.textContent = 'Updating...';
                    // ... (rest of update name logic as before) ...
                    const newName = newNameInput.value;
                    const currentPassword = currentPasswordForNameInput.value;

                    if (!newName.trim() || !currentPassword) {
                        showSettingsMessage('New name and current password are required.', 'error');
                        updateNameButton.disabled = false;
                        updateNameButton.textContent = 'Update Name';
                        return;
                    }
                    try {
                        const response = await fetch('/api/me/update-name', {
                            method: 'PATCH',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                new_name: newName,
                                current_password: currentPassword
                            })
                        });
                        const result = await response.json();
                        if (response.ok) {
                            showSettingsMessage(result.message || 'Name updated successfully!', 'success', 3000);
                            if (currentNameInput) currentNameInput.value = result.new_name;
                            currentPasswordForNameInput.value = '';
                            newNameInput.value = ''; 
                            // No need to call fetchCurrentUser() again just for name, it's updated locally.
                        } else {
                            showSettingsMessage(result.detail || 'Failed to update name.', 'error');
                        }
                    } catch (error) {
                        console.error('Error updating name:', error);
                        showSettingsMessage('An error occurred. Please try again.', 'error');
                    } finally {
                        updateNameButton.disabled = false;
                        updateNameButton.textContent = 'Update Name';
                    }
                });
            }

            // --- Update Email Functionality ---
            const updateEmailForm = document.getElementById('update-email-form');
            const newEmailInput = document.getElementById('new-email');
            const currentPasswordForEmailInput = document.getElementById('current-password-for-email');
            const updateEmailButton = document.getElementById('update-email-button');

            if (updateEmailForm) {
                updateEmailForm.addEventListener('submit', async (event) => {
                    event.preventDefault();
                    settingsMessageArea.style.display = 'none';
                    updateEmailButton.disabled = true;
                    updateEmailButton.textContent = 'Updating Email...';

                    const newEmail = newEmailInput.value;
                    const currentPassword = currentPasswordForEmailInput.value;

                    if (!newEmail.trim() || !currentPassword) {
                        showSettingsMessage('New email and current password are required.', 'error');
                        updateEmailButton.disabled = false;
                        updateEmailButton.textContent = 'Update Email Address';
                        return;
                    }

                    try {
                        const response = await fetch('/api/me/update-email', {
                            method: 'PATCH',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                new_email: newEmail,
                                current_password: currentPassword
                            })
                        });
                        const result = await response.json();

                        if (response.ok) {
                            showSettingsMessage(result.message || 'Email updated. Logging out...', 'success');
                            // Clear fields
                            newEmailInput.value = '';
                            currentPasswordForEmailInput.value = '';
                            // Redirect to logout after a delay
                            setTimeout(() => {
                                window.location.href = '/logout';
                            }, 4000); // 4 seconds delay
                        } else {
                            showSettingsMessage(result.detail || 'Failed to update email.', 'error');
                            updateEmailButton.disabled = false;
                            updateEmailButton.textContent = 'Update Email Address';
                        }
                    } catch (error) {
                        console.error('Error updating email:', error);
                        showSettingsMessage('An error occurred while updating your email. Please try again.', 'error');
                        updateEmailButton.disabled = false;
                        updateEmailButton.textContent = 'Update Email Address';
                    }
                    // Note: Button remains disabled on success because user will be logged out.
                });
            }


            // --- Regenerate Password Functionality ---
            const regeneratePasswordForm = document.getElementById('regenerate-password-form');
            const currentPasswordForRegenInput = document.getElementById('current-password-for-regen');
            const regeneratePasswordButton = document.getElementById('regenerate-password-button');

            if (regeneratePasswordForm) {
                regeneratePasswordForm.addEventListener('submit', async (event) => {
                    event.preventDefault();
                    settingsMessageArea.style.display = 'none';
                    regeneratePasswordButton.disabled = true;
                    regeneratePasswordButton.textContent = 'Regenerating...';
                    // ... (rest of regenerate password logic as before) ...
                    const currentPassword = currentPasswordForRegenInput.value;

                    if (!currentPassword) {
                        showSettingsMessage('Current password is required to regenerate.', 'error');
                        regeneratePasswordButton.disabled = false;
                        regeneratePasswordButton.textContent = 'Regenerate Password & Send Email';
                        return;
                    }
                    try {
                        const response = await fetch('/api/me/regenerate-password', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ current_password: currentPassword })
                        });
                        const result = await response.json();
                        if (response.ok) {
                            showSettingsMessage(result.message || 'Password regenerated. Check email. Logging out...', 'success');
                            currentPasswordForRegenInput.value = '';
                            setTimeout(() => {
                                window.location.href = '/logout'; 
                            }, 4000); 
                        } else {
                            showSettingsMessage(result.detail || 'Failed to regenerate password.', 'error');
                            regeneratePasswordButton.disabled = false;
                            regeneratePasswordButton.textContent = 'Regenerate Password & Send Email';
                        }
                    } catch (error) {
                        console.error('Error regenerating password:', error);
                        showSettingsMessage('An error occurred while regenerating password. Please try again.', 'error');
                        regeneratePasswordButton.disabled = false;
                        regeneratePasswordButton.textContent = 'Regenerate Password & Send Email';
                    }
                });
            }
        });
    </script>
</body>
</html>


=== app/static/email_templates/password_reset_email.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Password Reset - Tesseracs Chat</title>
    <style>
        body {
            font-family: 'Inter', Arial, sans-serif;
            line-height: 1.6;
            color: #333333;
            margin: 0;
            padding: 0;
            background-color: #f7fafc;
        }
        .email-container {
            width: 100%;
            max-width: 600px;
            margin: 20px auto;
            background-color: #ffffff;
            padding: 25px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }
        .header {
            text-align: center;
            padding-bottom: 20px;
            border-bottom: 1px solid #edf2f7;
        }
        .header h2 {
            color: #2c5282;
            margin: 0;
            font-size: 24px;
            font-weight: 600;
        }
        .content {
            padding-top: 10px;
        }
        .content p {
            margin: 18px 0;
            font-size: 16px;
            color: #4a5568;
        }
        .content strong {
            color: #2b6cb0;
            font-weight: 500;
        }
        .password-display-container {
            margin: 25px 0;
            text-align: center;
        }
        .password-label {
            font-size: 16px;
            color: #4a5568;
            margin-bottom: 8px;
            display: block;
        }
        .password-value {
            background-color: #edf2f7;
            padding: 15px 20px;
            border-radius: 6px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.2em;
            text-align: center;
            color: #1a202c;
            border: 1px solid #cbd5e0;
            display: inline-block;
            letter-spacing: 1px;
            word-break: break-all;
        }
        .login-button-container {
            text-align: center;
            margin: 30px 0;
        }
        .login-button {
            display: inline-block;
            background-color: #3182ce;
            color: #ffffff !important;
            padding: 14px 28px;
            text-decoration: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.2s ease-in-out;
        }
        .login-button:hover {
            background-color: #2b6cb0;
        }
        .footer {
            text-align: center;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #edf2f7;
            font-size: 0.875em;
            color: #718096;
        }
        .link {
            color: #3182ce;
            text-decoration: none;
        }
        .link:hover {
            text-decoration: underline;
        }
        .url-display { /* Style for displaying the URL as text */
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            color: #718096; /* Tailwind gray-600 */
            word-break: break-all;
        }
    </style>
</head>
<body>
    <div class="email-container">
        <div class="header">
            <h2>Password Reset for Tesseracs Chat</h2>
        </div>
        <div class="content">
            <p>Hello {{ recipient_name }},</p>
            <p>As requested, your password for Tesseracs Chat has been reset.</p>
            <p>Your email: <strong>{{ email }}</strong></p>
            <div class="password-display-container">
                <span class="password-label">Your new password is:</span>
                <div class="password-value">{{ password }}</div>
            </div>
            <p>Please use this new password to log in. You can log in here:</p>
            <div class="login-button-container">
                <a href="{{ login_url }}" class="login-button">Log In to Tesseracs Chat</a>
            </div>
            <p>If the button doesn't work, you can also <a href="{{ login_url }}" class="link">click here to log in</a> or copy and paste the following URL into your browser: <br><span class="url-display">{{ login_url }}</span></p>
            <p>If you did not request a password reset, please contact support or secure your account immediately.</p>
        </div>
        <div class="footer">
            <p>Thanks,<br>The Tesseracs Chat Team</p>
            <p><small>This is an automated message. Please do not reply directly to this email.</small></p>
        </div>
    </div>
</body>
</html>


=== app/static/email_templates/registration_email.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to Tesseracs Chat</title>
    <style>
        body {
            font-family: 'Inter', Arial, sans-serif;
            line-height: 1.6;
            color: #333333;
            margin: 0;
            padding: 0;
            background-color: #f7fafc; /* Tailwind gray-100 */
        }
        .email-container {
            width: 100%;
            max-width: 600px;
            margin: 20px auto;
            background-color: #ffffff;
            padding: 25px;
            border: 1px solid #e2e8f0; /* Tailwind gray-300 */
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }
        .header {
            text-align: center;
            padding-bottom: 20px;
            border-bottom: 1px solid #edf2f7; /* Tailwind gray-200 */
        }
        .header h2 {
            color: #2c5282; /* Tailwind blue-800 */
            margin: 0;
            font-size: 24px;
            font-weight: 600;
        }
        .content {
            padding-top: 10px;
        }
        .content p {
            margin: 18px 0;
            font-size: 16px;
            color: #4a5568; /* Tailwind gray-700 */
        }
        .content strong {
            color: #2b6cb0; /* Tailwind blue-700 */
            font-weight: 500;
        }
        .password-display-container {
            margin: 25px 0;
            text-align: center;
        }
        .password-label {
            font-size: 16px;
            color: #4a5568; /* Tailwind gray-700 */
            margin-bottom: 8px;
            display: block;
        }
        .password-value {
            background-color: #edf2f7; /* Tailwind gray-200 */
            padding: 15px 20px;
            border-radius: 6px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.2em;
            text-align: center;
            color: #1a202c; /* Tailwind gray-900 */
            border: 1px solid #cbd5e0; /* Tailwind gray-400 */
            display: inline-block;
            letter-spacing: 1px;
            word-break: break-all;
        }
        .login-button-container {
            text-align: center;
            margin: 30px 0;
        }
        .login-button {
            display: inline-block;
            background-color: #3182ce; /* Tailwind blue-500 */
            color: #ffffff !important;
            padding: 14px 28px;
            text-decoration: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.2s ease-in-out;
        }
        .login-button:hover {
            background-color: #2b6cb0; /* Tailwind blue-600 */
        }
        .footer {
            text-align: center;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #edf2f7; /* Tailwind gray-200 */
            font-size: 0.875em; /* text-sm */
            color: #718096; /* Tailwind gray-600 */
        }
        .link {
            color: #3182ce; /* Tailwind blue-500 */
            text-decoration: none;
        }
        .link:hover {
            text-decoration: underline;
        }
        .url-display { /* Style for displaying the URL as text */
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            color: #718096; /* Tailwind gray-600 */
            word-break: break-all;
        }
    </style>
</head>
<body>
    <div class="email-container">
        <div class="header">
            <h2>Welcome to Tesseracs Chat, {{ recipient_name }}!</h2>
        </div>
        <div class="content">
            <p>Your account has been successfully created.</p>
            <p>Your email: <strong>{{ email }}</strong></p>
            <div class="password-display-container">
                <span class="password-label">Your password is:</span>
                <div class="password-value">{{ password }}</div>
            </div>
            <p>Please use this password to log in. You can log in here:</p>
            <div class="login-button-container">
                <a href="{{ login_url }}" class="login-button">Log In to Tesseracs Chat</a>
            </div>
            <p>If the button doesn't work, you can also <a href="{{ login_url }}" class="link">click here to log in</a> or copy and paste the following URL into your browser: <br><span class="url-display">{{ login_url }}</span></p>
            <p>Please keep this password secure. Currently, there is no option to change this password.</p>
            <p>If you did not request this account, please ignore this email.</p>
        </div>
        <div class="footer">
            <p>Thanks,<br>The Tesseracs Chat Team</p>
            <p><small>This is an automated message. Please do not reply directly to this email.</small></p>
        </div>
    </div>
</body>
</html>


=== app/static/js/app-ui.js ===
// static/js/app-ui.js

export async function loadSidebarHTML(sidebarHtmlPath = '_sidebar.html', targetElementId = 'sidebar-loader-target') {
    const sidebarTarget = document.getElementById(targetElementId);
    if (!sidebarTarget) {
        console.error(`Sidebar target element with ID '${targetElementId}' not found.`);
        return false;
    }
    try {
        const response = await fetch(sidebarHtmlPath);
        if (!response.ok) {
            console.error(`Failed to fetch sidebar HTML from ${sidebarHtmlPath}. Status: ${response.status}`);
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const sidebarHTML = await response.text();
        sidebarTarget.innerHTML = sidebarHTML;
        console.log(`Sidebar HTML successfully loaded from ${sidebarHtmlPath} into #${targetElementId}`);
        return true;
    } catch (error) {
        console.error('Could not load sidebar:', error);
        sidebarTarget.innerHTML = '<p class="p-4 text-red-400">Error loading sidebar content.</p>';
        return false;
    }
}

async function handleDeleteSession(sessionId, sessionName, apiEndpoint, listElementId, chatPageBaseUrl) {
    if (!window.confirm(`Are you sure you want to delete the session "${sessionName}"? This action cannot be undone.`)) {
        return;
    }

    console.log(`Attempting to delete session: ${sessionId}`);
    try {
        const response = await fetch(`/api/sessions/${sessionId}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ detail: "Failed to delete session. Server error." }));
            console.error(`Failed to delete session ${sessionId}. Status: ${response.status}`, errorData);
            alert(`Error deleting session: ${errorData.detail || response.statusText}`);
            return;
        }

        console.log(`Session ${sessionId} successfully deleted from server.`);
        
        const currentPath = window.location.pathname;
        // Ensure chatPageBaseUrl ends with a slash if not already
        const base = chatPageBaseUrl.endsWith('/') ? chatPageBaseUrl : chatPageBaseUrl + '/';
        const deletedSessionPath = `${base}${sessionId}`;

        if (currentPath === deletedSessionPath || currentPath === `${deletedSessionPath}/`) {
            window.location.href = '/'; 
        } else {
            await populateSessionList(apiEndpoint, listElementId, chatPageBaseUrl);
        }

    } catch (error) {
        console.error('Error during delete session request:', error);
        alert('An error occurred while trying to delete the session. Please check the console.');
    }
}

export async function populateSessionList(apiEndpoint = '/api/sessions', listElementId = 'session-list', chatPageBaseUrl = '/chat/') {
    const sessionListElement = document.getElementById(listElementId);
    if (!sessionListElement) {
        console.error(`Session list element with ID '${listElementId}' not found.`);
        return;
    }
    sessionListElement.innerHTML = '<li class="px-3 py-1 text-gray-400 italic text-sm">Loading sessions...</li>';

    try {
        console.log(`Workspaceing sessions from: ${apiEndpoint}`);
        const response = await fetch(apiEndpoint);

        if (!response.ok) {
            const errorText = await response.text();
            console.error(`Failed to fetch sessions from ${apiEndpoint}. Status: ${response.status}. Response: ${errorText}`);
            throw new Error(`HTTP error! status: ${response.status}. Message: ${errorText}`);
        }
        const sessions = await response.json();
        if (!Array.isArray(sessions)) {
            console.error(`Data from ${apiEndpoint} is not an array:`, sessions);
            throw new Error(`Expected an array of sessions from ${apiEndpoint}, but received other type.`);
        }

        if (sessions.length === 0) {
            sessionListElement.innerHTML = '<li class="px-3 py-1 text-gray-400 text-sm">No active sessions found.</li>';
        } else {
            sessionListElement.innerHTML = '';
            sessions.forEach(session => {
                if (!session.id || !session.name) {
                    console.warn('Session object is missing id or name:', session);
                    return;
                }

                const listItem = document.createElement('li');
                listItem.className = 'flex items-center justify-between pr-2 group hover:bg-gray-750 rounded-md'; // Added group and hover effect for item

                const link = document.createElement('a');
                const base = chatPageBaseUrl.endsWith('/') ? chatPageBaseUrl : chatPageBaseUrl + '/';
                link.href = `${base}${session.id}`; 
                
                link.className = 'block pl-3 pr-1 py-2 text-gray-300 group-hover:text-white rounded-l-md text-sm truncate flex-grow';
                
                let lastActiveDisplay = "Never";
                if (session.last_active) {
                    try {
                        lastActiveDisplay = new Date(session.last_active).toLocaleString();
                    } catch (e) {
                        console.warn("Could not parse last_active date:", session.last_active);
                        lastActiveDisplay = session.last_active; // show raw if parsing fails
                    }
                }
                link.title = `${session.name}\nLast active: ${lastActiveDisplay}`;
                link.textContent = session.name;
                
                const currentPath = window.location.pathname;
                if (currentPath === link.pathname) { 
                    link.classList.add('bg-gray-700', 'text-white', 'font-semibold');
                    listItem.classList.add('bg-gray-700'); // Also highlight the whole li item
                }


                const deleteButton = document.createElement('button');
                deleteButton.innerHTML = '&#x2715;'; 
                deleteButton.className = 'ml-2 p-1 text-gray-500 hover:text-red-400 focus:outline-none rounded-full hover:bg-gray-600 transition-colors duration-150 ease-in-out text-xs opacity-0 group-hover:opacity-100 focus:opacity-100 flex-shrink-0'; 
                deleteButton.title = `Delete session: ${session.name}`;
                
                deleteButton.onclick = (event) => {
                    event.stopPropagation(); // Prevent triggering link navigation
                    handleDeleteSession(session.id, session.name, apiEndpoint, listElementId, base);
                };

                listItem.appendChild(link);
                listItem.appendChild(deleteButton);
                sessionListElement.appendChild(listItem);
            });
        }
        console.log(`Session list successfully populated from ${apiEndpoint} with ${sessions.length} sessions.`);

    } catch (error) {
        console.error('Error populating session list:', error);
        sessionListElement.innerHTML = `<li class="px-3 py-1 text-red-400 text-sm">Could not load sessions. Error: ${error.message}</li>`;
    }
}

