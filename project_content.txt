=== Project Directory Structure ===
Root: C:\Users\viktor.jonsson\OneDrive - CellMax Technologies AB\Documents\Repositories\svenviktorjonsson\tesseracs-chat
Relevant files and folders (excluding specified patterns):

.
├── Readme.md
├── change_names.py
├── check_database.py
├── fetch_assets.py
├── generate_secret_key.py
├── package.json
├── postcss.config.js
├── project_content.txt
├── pyproject.toml
├── tailwind.config.js
├── write_project_content_to_file.py
├── app/
│   ├── __init__.py
│   ├── auth.py
│   ├── config.py
│   ├── database.py
│   ├── docker_utils.py
│   ├── email_utils.py
│   ├── encryption_utils.py
│   ├── main.py
│   ├── models.py
│   ├── state.py
│   ├── utils.py
│   ├── static/
│   │   ├── _sidebar.html
│   │   ├── chat-session.html
│   │   ├── languages.json
│   │   ├── login.html
│   │   ├── script.js
│   │   ├── session-choice.html
│   │   ├── settings.html
│   │   ├── email_templates/
│   │   │   ├── password_reset_email.html
│   │   │   ├── registration_email.html
│   │   ├── js/
│   │   │   ├── app-ui.js
│   │   │   ├── settings.js
│   │   │   ├── temp.js
├── tests/
│   ├── test_coding.py


=== File Contents ===

=== Readme.md ===
Readme


=== change_names.py ===
#!/usr/bin/env python3
"""
CSS Class Name Replacer Script
Replaces old CSS class names with new unified block class names throughout the project.
"""

import os
import re
from pathlib import Path

# Define the replacement mappings
REPLACEMENTS = {
    # Container classes
    'code-block-container': 'block-container',
    'output-block-container': 'block-container',
    
    # Header classes
    'code-block-header': 'block-header',
    'code-output-header': 'block-header',
    
    # Button and UI classes
    'code-block-buttons': 'block-buttons',
    'code-block-title': 'block-title',
    'code-status-span': 'block-status',
    'code-action-btn': 'block-action-btn',
    
    # Console class
    'code-output-console': 'block-output-console',
    
    # Title classes
    'output-header-title': 'block-title',
}

# Files to process
FILES_TO_PROCESS = [
    'app/static/script.js',
    'app/static/input.css',
    'app/static/chat-session.html',
    'app/static/_sidebar.html',
    'app/static/session-choice.html',
    'app/static/settings.html',
    'app/static/login.html',
    'app/static/js/app-ui.js',
    'app/static/js/settings.js',
    'app/static/js/temp.js',
]

def replace_in_file(file_path, replacements, dry_run=False):
    """Replace class names in a single file."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        original_content = content
        changes_made = []
        
        for old_class, new_class in replacements.items():
            # Pattern to match class names in various contexts
            patterns = [
                # CSS selectors: .class-name
                (rf'\.{re.escape(old_class)}\b', f'.{new_class}'),
                
                # JavaScript/HTML class strings: 'class-name' or "class-name"
                (rf"'{re.escape(old_class)}'", f"'{new_class}'"),
                (rf'"{re.escape(old_class)}"', f'"{new_class}"'),
                
                # classList operations: addClass('class-name'), removeClass('class-name')
                (rf"(addClass|removeClass|contains|toggle)\s*\(\s*['\"]({re.escape(old_class)})['\"]", 
                 lambda m: f"{m.group(1)}('{new_class}'"),
                
                # querySelector operations: querySelector('.class-name')
                (rf"(querySelector|querySelectorAll)\s*\(\s*['\"]\.({re.escape(old_class)})['\"]",
                 lambda m: f"{m.group(1)}('.{new_class}'"),
                
                # HTML class attributes: class="class-name"
                (rf'class\s*=\s*["\']([^"\']*\b){re.escape(old_class)}\b([^"\']*)["\']',
                 lambda m: f'class="{m.group(1)}{new_class}{m.group(2)}"'),
            ]
            
            for pattern, replacement in patterns:
                if callable(replacement):
                    new_content = re.sub(pattern, replacement, content)
                else:
                    new_content = re.sub(pattern, replacement, content)
                
                if new_content != content:
                    changes_made.append(f"  {old_class} → {new_class}")
                    content = new_content
        
        if content != original_content:
            if not dry_run:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                print(f"✓ Updated {file_path}")
                for change in changes_made:
                    print(change)
            else:
                print(f"Would update {file_path}:")
                for change in changes_made:
                    print(change)
        else:
            print(f"- No changes needed in {file_path}")
            
    except FileNotFoundError:
        print(f"⚠ File not found: {file_path}")
    except Exception as e:
        print(f"✗ Error processing {file_path}: {e}")

def main():
    """Main function to process all files."""
    print("CSS Class Name Replacer")
    print("=" * 50)
    
    # Check if we're in the right directory
    if not os.path.exists('app/static/script.js'):
        print("Error: Please run this script from the project root directory.")
        print("Expected to find 'app/static/script.js' from current directory.")
        return
    
    # Ask for confirmation
    print("This script will replace the following class names:")
    for old, new in REPLACEMENTS.items():
        print(f"  {old} → {new}")
    
    print(f"\nFiles to be processed:")
    for file_path in FILES_TO_PROCESS:
        if os.path.exists(file_path):
            print(f"  ✓ {file_path}")
        else:
            print(f"  ⚠ {file_path} (not found)")
    
    response = input("\nProceed with replacements? (y/N): ").strip().lower()
    if response != 'y':
        print("Operation cancelled.")
        return
    
    # Optional dry run
    dry_run_response = input("Do a dry run first? (Y/n): ").strip().lower()
    dry_run = dry_run_response != 'n'
    
    if dry_run:
        print("\n" + "=" * 50)
        print("DRY RUN - No files will be modified")
        print("=" * 50)
        
        for file_path in FILES_TO_PROCESS:
            if os.path.exists(file_path):
                replace_in_file(file_path, REPLACEMENTS, dry_run=True)
        
        real_run_response = input("\nProceed with actual replacements? (y/N): ").strip().lower()
        if real_run_response != 'y':
            print("Operation cancelled.")
            return
    
    print("\n" + "=" * 50)
    print("PROCESSING FILES")
    print("=" * 50)
    
    # Process each file
    for file_path in FILES_TO_PROCESS:
        if os.path.exists(file_path):
            replace_in_file(file_path, REPLACEMENTS, dry_run=False)
    
    print("\n" + "=" * 50)
    print("REPLACEMENT COMPLETE!")
    print("=" * 50)
    print("\nNext steps:")
    print("1. Replace your input.css with the new unified CSS")
    print("2. Test the application to ensure everything works")
    print("3. Update your JavaScript selectors to use '.block-header' for sticky functionality")

if __name__ == "__main__":
    main()

=== check_database.py ===
import sqlite3
from pathlib import Path

# Assuming the database is in the project root
DATABASE_PATH = Path("tesseracs_chat.db")

def check_database():
    if not DATABASE_PATH.exists():
        print(f"Database not found at {DATABASE_PATH}")
        return
    
    conn = sqlite3.connect(DATABASE_PATH)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    print("=== Recent AI Messages ===")
    cursor.execute("""
        SELECT id, turn_id, session_id, content, timestamp 
        FROM chat_messages 
        WHERE sender_type = 'ai' 
        ORDER BY id DESC 
        LIMIT 5
    """)
    
    ai_messages = cursor.fetchall()
    for msg in ai_messages:
        print(f"ID: {msg['id']}, Turn ID: {msg['turn_id']}, Session: {msg['session_id'][:8]}...")
        print(f"Content preview: {msg['content'][:50]}...")
        print(f"Timestamp: {msg['timestamp']}")
        print("-" * 50)
    
    print("\n=== Code Execution Results ===")
    cursor.execute("""
        SELECT code_block_id, session_id, language, exit_code, executed_at
        FROM code_execution_results 
        ORDER BY executed_at DESC 
        LIMIT 5
    """)
    
    code_results = cursor.fetchall()
    for result in code_results:
        print(f"Block ID: {result['code_block_id']}")
        print(f"Session: {result['session_id'][:8]}...")
        print(f"Language: {result['language']}, Exit Code: {result['exit_code']}")
        print(f"Executed: {result['executed_at']}")
        print("-" * 50)
    
    print("\n=== Checking Turn ID vs Code Block ID Matches ===")
    cursor.execute("""
        SELECT cm.id, cm.turn_id, cm.session_id, cer.code_block_id
        FROM chat_messages cm
        LEFT JOIN code_execution_results cer ON cm.session_id = cer.session_id
        WHERE cm.sender_type = 'ai' AND cer.code_block_id IS NOT NULL
        ORDER BY cm.id DESC
        LIMIT 5
    """)
    
    matches = cursor.fetchall()
    for match in matches:
        expected_block_id = f"code-block-turn{match['turn_id']}-1"
        actual_block_id = match['code_block_id']
        matches_expected = expected_block_id == actual_block_id
        
        print(f"Message ID: {match['id']}, Turn ID: {match['turn_id']}")
        print(f"Expected Block ID: {expected_block_id}")
        print(f"Actual Block ID: {actual_block_id}")
        print(f"Match: {matches_expected}")
        print("-" * 50)
    
    conn.close()

if __name__ == "__main__":
    check_database()

=== fetch_assets.py ===
import os
import requests
import sys

# --- Configuration ---
# Get the directory where the script is located
script_dir = os.path.dirname(os.path.abspath(__file__))
print(f"DEBUG: Script is running from directory: {script_dir}") # <-- Added Debug Print

# Define paths relative to the script's location
static_dir = os.path.join(script_dir, 'app', 'static')
assets_dir = os.path.join(static_dir, 'assets')
css_dir = os.path.join(assets_dir, 'css')
fonts_dir = os.path.join(assets_dir, 'fonts') # Define fonts dir for creation

# Print the calculated target directories for verification
print(f"DEBUG: Target static directory: {static_dir}")
print(f"DEBUG: Target assets directory: {assets_dir}")
print(f"DEBUG: Target CSS directory: {css_dir}")
print(f"DEBUG: Target fonts directory: {fonts_dir}") # <-- Added Debug Print

# List of CSS files to download
css_files_to_download = [
    {
        'name': 'katex.min.css',
        'url': 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css',
        'dest': os.path.join(css_dir, 'katex.min.css')
    },
    {
        'name': 'prism-tomorrow.min.css',
        'url': 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css',
        'dest': os.path.join(css_dir, 'prism-tomorrow.min.css')
    }
]

# --- Helper Functions ---
def ensure_dir_exists(dir_path):
    """Creates a directory if it doesn't exist."""
    if not os.path.exists(dir_path):
        print(f"Creating directory: {dir_path}")
        try:
            os.makedirs(dir_path, exist_ok=True)
        except OSError as e:
            print(f"Error creating directory {dir_path}: {e}", file=sys.stderr)
            sys.exit(1) # Exit if directory creation fails

def download_file(url, destination_path):
    """Downloads a file from a URL to a destination path."""
    print(f"Attempting to download {os.path.basename(destination_path)} to {destination_path} from {url}...") # <-- Added Debug Print
    try:
        response = requests.get(url, stream=True, timeout=30) # Added timeout
        response.raise_for_status() # Raise an exception for bad status codes (4xx or 5xx)

        with open(destination_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
        print(f"Successfully downloaded: {os.path.basename(destination_path)}")
        return True
    except requests.exceptions.RequestException as e:
        print(f"Error downloading {url}: {e}", file=sys.stderr)
        # Clean up partially downloaded file if it exists
        if os.path.exists(destination_path):
            try:
                os.remove(destination_path)
                print(f"Removed partially downloaded file: {os.path.basename(destination_path)}")
            except OSError as remove_error:
                print(f"Error removing partial file {destination_path}: {remove_error}", file=sys.stderr)
        return False
    except Exception as e:
        print(f"An unexpected error occurred during download of {url}: {e}", file=sys.stderr)
        return False


# --- Main Execution ---
def main():
    print("Starting Python asset fetching process...")

    # 1. Ensure directories exist
    print("Ensuring necessary directories exist...")
    ensure_dir_exists(static_dir)
    ensure_dir_exists(assets_dir)
    ensure_dir_exists(css_dir)
    ensure_dir_exists(fonts_dir) # Also create fonts dir
    print("Directory check complete.")

    # 2. Download CSS files
    print("\nDownloading CSS files...")
    success_count = 0
    failure_count = 0
    for file_info in css_files_to_download:
        # Print the destination path before downloading
        print(f"DEBUG: Calculated destination for {file_info['name']}: {file_info['dest']}") # <-- Added Debug Print
        if download_file(file_info['url'], file_info['dest']):
            success_count += 1
        else:
            failure_count += 1

    print(f"\nDownload summary: {success_count} succeeded, {failure_count} failed.")

    if failure_count > 0:
        print("\nOne or more downloads failed. Please check the errors above.", file=sys.stderr)
        sys.exit(1) # Exit with error code if any download failed
    else:
        print("\nPython asset fetching process completed successfully.")
        print("CSS files downloaded to:", css_dir)
        print("Ensure font files are placed in:", fonts_dir)

if __name__ == "__main__":
    main()


=== generate_secret_key.py ===
import secrets
key = secrets.token_urlsafe(32)  # Generates a 32-byte random string, URL-safe
print(key)

=== package.json ===
{
  "name": "tesseracs-chat",
  "version": "1.0.0",
  "description": "Readme",
  "main": "temp.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "node build.js",
    "watch:css": "tailwindcss -i ./app/static/input.css -o ./app/static/dist/input.css --watch",
    "watch:js": "esbuild app/static/script.js --bundle --outfile=app/static/dist/script.js --watch",
    "dev": "concurrently \"npm:watch:*\""
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/svenviktorjonsson/tesseracs-chat.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/svenviktorjonsson/tesseracs-chat/issues"
  },
  "homepage": "https://github.com/svenviktorjonsson/tesseracs-chat#readme",
  "devDependencies": {
    "autoprefixer": "^10.4.21",
    "concurrently": "^9.2.0",
    "esbuild": "^0.25.4",
    "esbuild-style-plugin": "^1.6.3",
    "postcss": "^8.5.3",
    "tailwindcss": "^3.4.17"
  },
  "dependencies": {
    "katex": "^0.16.22",
    "marked": "^15.0.11",
    "prismjs": "^1.29.0"
  }
}


=== postcss.config.js ===
// postcss.config.js
module.exports = {
  plugins: {
    'tailwindcss': {}, // Use 'tailwindcss' for v3
    'autoprefixer': {},
  },
}

=== project_content.txt ===
=== Project Directory Structure ===
Root: C:\Users\viktor.jonsson\OneDrive - CellMax Technologies AB\Documents\Repositories\svenviktorjonsson\tesseracs-chat
Relevant files and folders (excluding specified patterns):

.
├── Readme.md
├── change_names.py
├── check_database.py
├── fetch_assets.py
├── generate_secret_key.py
├── package.json
├── postcss.config.js
├── project_content.txt
├── pyproject.toml
├── tailwind.config.js
├── write_project_content_to_file.py
├── app/
│   ├── __init__.py
│   ├── auth.py
│   ├── config.py
│   ├── database.py
│   ├── docker_utils.py
│   ├── email_utils.py
│   ├── encryption_utils.py
│   ├── main.py
│   ├── models.py
│   ├── state.py
│   ├── utils.py
│   ├── static/
│   │   ├── _sidebar.html
│   │   ├── chat-session.html
│   │   ├── languages.json
│   │   ├── login.html
│   │   ├── script.js
│   │   ├── session-choice.html
│   │   ├── settings.html
│   │   ├── email_templates/
│   │   │   ├── password_reset_email.html
│   │   │   ├── registration_email.html
│   │   ├── js/
│   │   │   ├── app-ui.js
│   │   │   ├── settings.js
│   │   │   ├── temp.js
├── tests/
│   ├── test_coding.py


=== File Contents ===

=== Readme.md ===
Readme


=== change_names.py ===
#!/usr/bin/env python3
"""
CSS Class Name Replacer Script
Replaces old CSS class names with new unified block class names throughout the project.
"""

import os
import re
from pathlib import Path

# Define the replacement mappings
REPLACEMENTS = {
    # Container classes
    'code-block-container': 'block-container',
    'output-block-container': 'block-container',
    
    # Header classes
    'code-block-header': 'block-header',
    'code-output-header': 'block-header',
    
    # Button and UI classes
    'code-block-buttons': 'block-buttons',
    'code-block-title': 'block-title',
    'code-status-span': 'block-status',
    'code-action-btn': 'block-action-btn',
    
    # Console class
    'code-output-console': 'block-output-console',
    
    # Title classes
    'output-header-title': 'block-title',
}

# Files to process
FILES_TO_PROCESS = [
    'app/static/script.js',
    'app/static/input.css',
    'app/static/chat-session.html',
    'app/static/_sidebar.html',
    'app/static/session-choice.html',
    'app/static/settings.html',
    'app/static/login.html',
    'app/static/js/app-ui.js',
    'app/static/js/settings.js',
    'app/static/js/temp.js',
]

def replace_in_file(file_path, replacements, dry_run=False):
    """Replace class names in a single file."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        original_content = content
        changes_made = []
        
        for old_class, new_class in replacements.items():
            # Pattern to match class names in various contexts
            patterns = [
                # CSS selectors: .class-name
                (rf'\.{re.escape(old_class)}\b', f'.{new_class}'),
                
                # JavaScript/HTML class strings: 'class-name' or "class-name"
                (rf"'{re.escape(old_class)}'", f"'{new_class}'"),
                (rf'"{re.escape(old_class)}"', f'"{new_class}"'),
                
                # classList operations: addClass('class-name'), removeClass('class-name')
                (rf"(addClass|removeClass|contains|toggle)\s*\(\s*['\"]({re.escape(old_class)})['\"]", 
                 lambda m: f"{m.group(1)}('{new_class}'"),
                
                # querySelector operations: querySelector('.class-name')
                (rf"(querySelector|querySelectorAll)\s*\(\s*['\"]\.({re.escape(old_class)})['\"]",
                 lambda m: f"{m.group(1)}('.{new_class}'"),
                
                # HTML class attributes: class="class-name"
                (rf'class\s*=\s*["\']([^"\']*\b){re.escape(old_class)}\b([^"\']*)["\']',
                 lambda m: f'class="{m.group(1)}{new_class}{m.group(2)}"'),
            ]
            
            for pattern, replacement in patterns:
                if callable(replacement):
                    new_content = re.sub(pattern, replacement, content)
                else:
                    new_content = re.sub(pattern, replacement, content)
                
                if new_content != content:
                    changes_made.append(f"  {old_class} → {new_class}")
                    content = new_content
        
        if content != original_content:
            if not dry_run:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                print(f"✓ Updated {file_path}")
                for change in changes_made:
                    print(change)
            else:
                print(f"Would update {file_path}:")
                for change in changes_made:
                    print(change)
        else:
            print(f"- No changes needed in {file_path}")
            
    except FileNotFoundError:
        print(f"⚠ File not found: {file_path}")
    except Exception as e:
        print(f"✗ Error processing {file_path}: {e}")

def main():
    """Main function to process all files."""
    print("CSS Class Name Replacer")
    print("=" * 50)
    
    # Check if we're in the right directory
    if not os.path.exists('app/static/script.js'):
        print("Error: Please run this script from the project root directory.")
        print("Expected to find 'app/static/script.js' from current directory.")
        return
    
    # Ask for confirmation
    print("This script will replace the following class names:")
    for old, new in REPLACEMENTS.items():
        print(f"  {old} → {new}")
    
    print(f"\nFiles to be processed:")
    for file_path in FILES_TO_PROCESS:
        if os.path.exists(file_path):
            print(f"  ✓ {file_path}")
        else:
            print(f"  ⚠ {file_path} (not found)")
    
    response = input("\nProceed with replacements? (y/N): ").strip().lower()
    if response != 'y':
        print("Operation cancelled.")
        return
    
    # Optional dry run
    dry_run_response = input("Do a dry run first? (Y/n): ").strip().lower()
    dry_run = dry_run_response != 'n'
    
    if dry_run:
        print("\n" + "=" * 50)
        print("DRY RUN - No files will be modified")
        print("=" * 50)
        
        for file_path in FILES_TO_PROCESS:
            if os.path.exists(file_path):
                replace_in_file(file_path, REPLACEMENTS, dry_run=True)
        
        real_run_response = input("\nProceed with actual replacements? (y/N): ").strip().lower()
        if real_run_response != 'y':
            print("Operation cancelled.")
            return
    
    print("\n" + "=" * 50)
    print("PROCESSING FILES")
    print("=" * 50)
    
    # Process each file
    for file_path in FILES_TO_PROCESS:
        if os.path.exists(file_path):
            replace_in_file(file_path, REPLACEMENTS, dry_run=False)
    
    print("\n" + "=" * 50)
    print("REPLACEMENT COMPLETE!")
    print("=" * 50)
    print("\nNext steps:")
    print("1. Replace your input.css with the new unified CSS")
    print("2. Test the application to ensure everything works")
    print("3. Update your JavaScript selectors to use '.block-header' for sticky functionality")

if __name__ == "__main__":
    main()

=== check_database.py ===


=== pyproject.toml ===
# pyproject.toml

# Standard project metadata (PEP 621)
[project]
name = "tesseracs-chat"
version = "1.0.1"
description = "Web chat interface for Ollama using FastAPI and LangChain"
readme = "README.md"
authors = [
    {name = "Viktor Jonsson", email = "viktor.jonsson@tesseracs.com"},
]

# Poetry-specific tool configuration
[tool.poetry]
packages = [
    { include = "app" },
]

# Project Dependencies
[tool.poetry.dependencies]
python = "^3.9"
fastapi = "^0.110.0"
uvicorn = {extras = ["standard"], version = "^0.29.0"}
langchain = "^0.2.0"
langchain-core = "^0.2.0"
langchain-community = "^0.2.0"
langchain-ollama = "^0.1.0"
langchain-openai = "^0.1.0"
langchain-anthropic = "^0.1.0"
langchain-google-genai = "^1.0.0" 
websockets = "^12.0"
python-dotenv = "^1.0.1"
aiofiles = "^23.2.1"
docker = "^7.1.0"
requests = "^2.32.3"
python-multipart = "^0.0.20"
fastapi-mail = "^1.4.2"
certifi = "^2024.7.4" # Corrected from "^2025.4.26", which is not a valid version.
pydantic = "^2.11.4"
cryptography = ">=43.0,<44.0"
passlib = {extras = ["bcrypt"], version = "^1.7.4"}
bcrypt = "==4.0.1"
fastapi-csrf-protect = "^1.0.3"

# Build System Definition

[tool.poetry.group.dev.dependencies]
pytest = "^8.4.1"
pytest-asyncio = "^1.1.0"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

=== tailwind.config.js ===
/** @type {import('tailwindcss').Config} */
module.exports = {
    safelist: [
        'js-sticky',
    ],
    content: [
      "./app/static/**/*.html", // Scan HTML files in static
      "./app/static/**/*.js",   // Scan JS files in static
    ],
    theme: {
      extend: {},
    },
    plugins: [],
  }

=== write_project_content_to_file.py ===
import os
import sys

# --- Configuration ---

# Set the starting directory (e.g., "." for current directory)
root = "."


import os

# --- Configuration ---

# !!! CHANGE THIS VARIABLE TO THE DESIRED STARTING DIRECTORY !!!
# Example: root = "/path/to/your/project" or root = "src"
root = fr"./"

# Extensions to include
extensions = ('.py', '.html', '.css', '.js', '.json', '.md', '.txt', '.yaml', '.yml', '.toml')

# Directories to completely exclude (will not be walked)
exclude_dirs = (
    '.git',
    '__pycache__',
    '.pytest_cache',
    'node_modules',
    'build',
    'old2',
    'testing-bundles', # Exclude this directory name wherever it appears
    '.venv',           # Common virtual environment folder
    'venv',
    'env',
    '.env',
    'dist',
    "assets"
)

# Files to list in the tree but exclude their *content*
exclude_exact_filenames = (
    'package-lock.json',
    'yarn.lock',
    'katex.min.css',
    'katex.min.js',
    'build.js',
    'docker_utils.js',
    'llm.py',
    'input.css'
    # Add other large or irrelevant files by name here
)

# Files to exclude from the tree and content if their name contains any of these strings
exclude_filename_patterns = ('lock',)

# Specific files to list in the tree but exclude their *content* from the output
exclude_files = (
    'session.json',
    'cm_logo.ico',
)

# Output file name
output_filename = "project_content.txt"

# --- Script Logic ---

# Normalize the root path and make it absolute for reliable comparisons
root = os.path.abspath(root)

print(f"Starting directory: {root}")
print(f"Output file: {output_filename}")

# The instructions to be added at the end of the file
llm_instructions = """
=== LLM Instructions ===
Now please just read the project and the rules for writing code and just wait for instructions.

Here are the rules:
1. DONT write comments, placeholders or docstrings if not explicitely told.
2. Write functions with the correct initial indentation so that if the function is indented so is your code that you write.
3. DO NOT USE NON-TERMINATED SPACES. MAKE SURE TO FOLLOW THIS! ITS SUPER IMPORTANT AND YOU SEEM TO BREAK IT, PLEASE!!!
4. For changes that require multiple replacements please tell me what to replace with what instead of rewriting large portions of text. You can use vscode valid regexp for instance.
5. For small functions less than 100 lines of code please rewrite the full function. For larger functions please only write complete control statements if/while/case.
6. Never omit/change working logic if not explicitely statet that it should be removed/change
7. DONT use the CANVAS TOOL where code is written in artifacts.
8. Write only functions that are new seperately from functions that needs updates.
9. Make sure to write what has been change where to place/what to replace for each code snippet.
"""


try:
    # Using "w" mode ensures the file is overwritten if it exists
    with open(output_filename, "w", encoding="utf-8") as outfile:
        # === Add Directory Structure ===
        outfile.write("=== Project Directory Structure ===\n")
        outfile.write(f"Root: {root}\n")
        outfile.write("Relevant files and folders (excluding specified patterns):\n\n")

        start_level = root.count(os.sep)
        for current_root, dirs, files in os.walk(root, topdown=True):
            dirs[:] = [d for d in dirs if d not in exclude_dirs and not d.startswith('.')]
            rel_path_from_start = os.path.relpath(current_root, root)
            level = current_root.count(os.sep) - start_level

            if rel_path_from_start != '.':
                path_components = os.path.normpath(rel_path_from_start).split(os.sep)
                if any(comp in exclude_dirs or comp.startswith('.') for comp in path_components):
                    continue

                indent = '│   ' * (level - 1) + '├── ' if level > 0 else ''
                outfile.write(f"{indent}{os.path.basename(current_root)}/\n")
            else:
                outfile.write(".\n")

            file_indent = '│   ' * level + '├── '
            files.sort()
            for file in files:
                # Apply all file exclusion rules
                if (file.endswith(extensions) and
                    not file.startswith('.') and
                    file not in exclude_exact_filenames and
                    not any(p in file for p in exclude_filename_patterns)):
                        outfile.write(f"{file_indent}{file}\n")

        outfile.write("\n\n=== File Contents ===\n\n")

        # === Add File Contents ===
        for current_root, dirs, files in os.walk(root, topdown=True):
            dirs[:] = [d for d in dirs if d not in exclude_dirs and not d.startswith('.')]
            rel_path_from_start = os.path.relpath(current_root, root)
            if rel_path_from_start != '.':
                path_components = os.path.normpath(rel_path_from_start).split(os.sep)
                if any(comp in exclude_dirs or comp.startswith('.') for comp in path_components):
                    continue

            files.sort()
            for file in files:
                # Apply all file exclusion rules again for content processing
                if (file.endswith(extensions) and
                    not file.startswith('.') and
                    file not in exclude_exact_filenames and
                    not any(p in file for p in exclude_filename_patterns)):
                        file_path = os.path.join(current_root, file)
                        relative_path = os.path.relpath(file_path, root)
                        display_path = relative_path.replace(os.sep, '/')
                        outfile.write(f"=== {display_path} ===\n")

                        if file in exclude_files:
                            outfile.write("--- CONTENT EXCLUDED (listed in exclude_files) ---\n")
                        else:
                            try:
                                try:
                                    with open(file_path, "r", encoding="utf-8") as infile:
                                        outfile.write(infile.read())
                                except UnicodeDecodeError:
                                    try:
                                        with open(file_path, "r", encoding="latin-1") as infile:
                                            outfile.write(infile.read())
                                        outfile.write("\n--- (Warning: Read using latin-1 encoding) ---\n")
                                    except Exception as inner_e:
                                        outfile.write(f"--- Error reading file (fallback failed): {inner_e} ---\n")
                            except Exception as e:
                                outfile.write(f"--- Error reading file: {e} ---\n")
                        outfile.write("\n\n")

        # === Add LLM Instructions at the end of the file ===
        outfile.write(llm_instructions)

    print("Successfully generated project content file.")

except Exception as e:
    print(f"An error occurred: {e}")

=== app/__init__.py ===


=== app/auth.py ===
# app/auth.py
import os
import secrets
import sqlite3
import traceback # Added from earlier version
from datetime import datetime, timedelta, timezone
from typing import Optional, Dict, Any

from fastapi import Depends, HTTPException, status, Response, Request # Added Request
from fastapi.security import APIKeyCookie, OAuth2PasswordBearer # Added APIKeyCookie

from passlib.context import CryptContext

# Assuming your project structure allows these relative imports
from . import models # For type hinting if needed (e.g., User model for return types)
from . import config
# Import necessary functions from database.py
from .database import get_db_connection, generate_secure_token, hash_value as hash_session_token

# Password Hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# --- Constants ---
SESSION_COOKIE_NAME = "tesseracs_session_token"
SESSION_DURATION_DAYS = 7 # From earlier version

# OAuth2 scheme for API endpoints (if you use Bearer tokens for some APIs)
# This is for FastAPI's dependency injection to get token from Authorization header
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/token") # tokenUrl points to your login endpoint

# Dependency for getting the session token from the cookie
cookie_scheme = APIKeyCookie(name=SESSION_COOKIE_NAME, auto_error=False)


# --- Password Utilities ---
def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifies a plain password against a stored hash using passlib."""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Hashes a plain password using passlib (for user passwords)."""
    return pwd_context.hash(password)

# --- User Authentication (Database Interaction for login) ---
def authenticate_user_from_db(
    conn: sqlite3.Connection, email: str, password: str
) -> Optional[Dict[str, Any]]:
    """
    Authenticates a user by fetching from DB and verifying password.
    This is typically called by the /token login route.

    Args:
        conn: Active SQLite database connection (passed from the route).
        email: User's email.
        password: User's plain text password.

    Returns:
        A dictionary containing user details if successful, otherwise None.
    """
    if not conn:
        print("ERROR (auth.authenticate_user_from_db): Database connection is None.")
        return None
    
    try:
        cursor = conn.cursor()
        # Ensure email is normalized (e.g., lowercased) for lookup
        normalized_email = email.lower().strip()
        cursor.execute(
            "SELECT id, name, email, password_hash, is_active FROM users WHERE email = ?",
            (normalized_email,)
        )
        user_row = cursor.fetchone()

        if not user_row:
            print(f"DEBUG (auth.authenticate_user_from_db): User not found for email: {normalized_email}")
            return None 

        user_data = dict(user_row)
        stored_password_hash = user_data.get("password_hash")

        if not stored_password_hash or not verify_password(password, stored_password_hash):
            print(f"DEBUG (auth.authenticate_user_from_db): Password verification failed for email: {normalized_email}")
            return None

        # Return relevant user details, excluding the password hash
        return {
            "id": user_data["id"],
            "name": user_data["name"],
            "email": user_data["email"],
            "is_active": user_data["is_active"],
        }
    except sqlite3.Error as e:
        print(f"ERROR (auth.authenticate_user_from_db): Database error - {e}")
        traceback.print_exc()
        return None
    except Exception as e: # Catch any other unexpected errors
        print(f"ERROR (auth.authenticate_user_from_db): Unexpected error - {e}")
        traceback.print_exc()
        return None


# --- Session Token Management (Database-backed sessions) ---
async def create_user_session(response: Response, user_id: int) -> str:
    """
    Creates a new session token, stores its HASH in the database,
    and sets the RAW token as an HttpOnly cookie in the response.
    Uses `hash_session_token` (from database.py) for session tokens.
    """
    session_token_raw = generate_secure_token(32) # Generate a new raw token
    # Use the specific hash function for session tokens (e.g., SHA256 from database.py)
    session_token_hashed = hash_session_token(session_token_raw) 
    
    expires_delta = timedelta(days=SESSION_DURATION_DAYS)
    expires_at = datetime.now(timezone.utc) + expires_delta
    
    conn = None
    try:
        conn = get_db_connection() # Get a new connection
        cursor = conn.cursor()
        cursor.execute(
            """INSERT INTO auth_tokens (user_id, token_hash, token_type, created_at, expires_at)
               VALUES (?, ?, ?, datetime('now', 'utc'), ?)""",
            (user_id, session_token_hashed, 'session', expires_at.isoformat())
        )
        conn.commit()
        
        response.set_cookie(
            key=SESSION_COOKIE_NAME,
            value=session_token_raw, # Set the RAW token in the cookie
            httponly=True,
            max_age=int(expires_delta.total_seconds()),
            expires=expires_at,
            samesite="Lax",
            secure=config.BASE_URL.startswith("https://"), # Secure cookie if served over HTTPS
            path="/"
        )
        print(f"AUTH: Session cookie '{SESSION_COOKIE_NAME}' set for user_id {user_id}. Expires: {expires_at.isoformat()}")
        return session_token_raw # Return the raw token (e.g., for /token response model)
        
    except sqlite3.Error as e:
        print(f"ERROR (auth.create_user_session): Database error - {e}")
        traceback.print_exc()
        if conn: conn.rollback()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Could not create user session due to a database issue.")
    except Exception as e:
        print(f"ERROR (auth.create_user_session): Unexpected error - {e}")
        traceback.print_exc()
        if conn: conn.rollback()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Could not create user session due to an unexpected server error.")
    finally:
        if conn:
            conn.close()

async def get_user_by_session_token_internal(token_raw: Optional[str]) -> Optional[Dict[str, Any]]:
    """
    Internal helper: Retrieves user details based on a RAW session token.
    Hashes the raw token and verifies it against hashed tokens in the database.
    Uses `hash_session_token` (from database.py).
    """
    if not token_raw:
        return None
    
    session_token_hashed = hash_session_token(token_raw) # Hash the raw token for DB lookup
    conn = None
    try:
        conn = get_db_connection() # Get a new connection
        cursor = conn.cursor()
        now_utc_iso = datetime.now(timezone.utc).isoformat()
        
        cursor.execute(
            """SELECT u.id, u.name, u.email, u.is_active
               FROM users u JOIN auth_tokens at ON u.id = at.user_id
               WHERE at.token_hash = ? AND at.token_type = 'session' 
               AND at.expires_at > ? AND at.used_at IS NULL
            """, (session_token_hashed, now_utc_iso)
        )
        user_row = cursor.fetchone()

        if user_row:
            user_data = dict(user_row)
            return {
                "id": user_data["id"],
                "name": user_data["name"],
                "email": user_data["email"],
                "is_active": user_data["is_active"]
            }
        return None
        
    except sqlite3.Error as e:
        print(f"ERROR (auth.get_user_by_session_token_internal): Database error - {e}")
        traceback.print_exc()
        return None
    except Exception as e:
        print(f"ERROR (auth.get_user_by_session_token_internal): Unexpected error - {e}")
        traceback.print_exc()
        return None
    finally:
        if conn:
            conn.close()

# This `get_current_user` is for cookie-based authentication (Optional user)
async def get_current_user(
    session_token_raw: Optional[str] = Depends(cookie_scheme)
) -> Optional[Dict[str, Any]]:
    """
    FastAPI Dependency: Retrieves the current authenticated user based on the
    session token from the cookie. Returns user dict or None if not authenticated/active.
    Does not raise HTTPException, allowing routes to handle optional authentication.
    """
    if not session_token_raw:
        return None
    
    user = await get_user_by_session_token_internal(session_token_raw)
    if user and user.get("is_active"):
        return user
    return None


# This `get_current_active_user` is for cookie-based authentication (Required active user)
async def get_current_active_user(
    session_token_raw: Optional[str] = Depends(cookie_scheme)
) -> Dict[str, Any]:
    """
    FastAPI Dependency: Retrieves the current authenticated AND active user.
    Raises HTTPException if not authenticated or user is inactive.
    This is typically used for routes that require a logged-in, active user.
    """
    if not session_token_raw:
        # This case might be hit if cookie_scheme's auto_error=False and cookie is missing
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated (no session cookie)",
            headers={"WWW-Authenticate": "Session"}, 
        )
    
    user = await get_user_by_session_token_internal(session_token_raw)
    
    if not user:
        # Consider how to handle invalid cookie (e.g., if main.py should clear it on redirect)
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired session token",
            headers={"WWW-Authenticate": "Session"},
        )
    if not user.get("is_active"):
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="User account is inactive")
    
    return user


# This `get_current_user_bearer` is a placeholder for API Bearer token authentication
# It uses oauth2_scheme, which looks for "Authorization: Bearer <token>" header.
async def get_current_user_bearer(token: str = Depends(oauth2_scheme)) -> Optional[Dict[str, Any]]:
    """
    Dependency to get the current user from a Bearer token (for API calls).
    This is an example if you were using JWTs or other Bearer tokens.
    It's kept separate from cookie-based session authentication.
    """
    if not token:
        return None
    # In a real scenario, you would:
    # 1. Decode the JWT token (if it's a JWT).
    # 2. Validate its signature, issuer, audience, expiry.
    # 3. Extract user identifier (e.g., user_id or sub) from token claims.
    # 4. Fetch user from database based on that identifier.
    # For now, this is a placeholder and returns None.
    print(f"DEBUG (auth.get_current_user_bearer): Received Bearer token: {token[:15]}...")
    # Example: user_id = my_jwt_decode_function(token).get("sub")
    # user = await fetch_user_from_db_by_id(user_id)
    # return user
    return None # Replace with actual Bearer token validation and user lookup


async def logout_user(response: Response, session_token_raw: Optional[str]):
    """
    Logs out the user by invalidating their session token in the database
    (if provided) and clearing the session cookie from the browser.
    Uses `hash_session_token` for session tokens.
    """
    if session_token_raw:
        session_token_hashed = hash_session_token(session_token_raw)
        conn = None
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            now_utc_iso = datetime.now(timezone.utc).isoformat()
            # Mark the specific token as used by setting used_at and making it expire immediately
            cursor.execute(
                """UPDATE auth_tokens 
                   SET used_at = ?, expires_at = ?
                   WHERE token_hash = ? AND token_type = 'session'""",
                (now_utc_iso, now_utc_iso, session_token_hashed)
            )
            conn.commit()
            print(f"AUTH: Session token (hash starting {session_token_hashed[:10]}...) marked as used/expired in DB for logout.")
        except sqlite3.Error as e:
            print(f"ERROR (auth.logout_user): Database error invalidating token - {e}")
            traceback.print_exc()
            if conn: conn.rollback()
            # Proceed with cookie deletion even if DB update fails
        except Exception as e:
            print(f"ERROR (auth.logout_user): Unexpected error invalidating token - {e}")
            traceback.print_exc()
            if conn: conn.rollback()
        finally:
            if conn:
                conn.close()

    # Always attempt to delete the cookie from the browser
    response.delete_cookie(
        SESSION_COOKIE_NAME,
        httponly=True,
        secure=config.BASE_URL.startswith("https://"), # Match secure attribute used when setting
        samesite="Lax", # Match samesite attribute
        path="/"
    )
    print(f"AUTH: Session cookie '{SESSION_COOKIE_NAME}' cleared from browser response.")


=== app/config.py ===
# app/config.py
import os
import sys
from pathlib import Path
from dotenv import load_dotenv
from typing import Optional, List, Dict, Any
import json

# Load environment variables from a .env file if it exists
load_dotenv()

# --- Application Base URL ---
BASE_URL = os.getenv("BASE_URL", "http://localhost:8001")

CSRF_PROTECT_SECRET_KEY = os.getenv("CSRF_PROTECT_SECRET_KEY")

DEBUG_MODE = os.getenv("DEBUG_MODE", "False").lower() in ('true', '1', 't', 'yes')
DATABASE_PATH = Path(os.getenv("DATABASE_PATH","./tesseracs_chat.db")) # Corrected typo from DATABSE_PATH
# --- Secret Key for Encryption ---
APP_SECRET_KEY = os.getenv("APP_SECRET_KEY")
if not APP_SECRET_KEY:
    print("CRITICAL WARNING: APP_SECRET_KEY is not set in the environment. "
          "User-specific API keys will not be securely stored. This is a major security risk. "
          "Please set this environment variable to a strong, random string. "
          "For development, the application will proceed, but encryption will be disabled if this key is missing.")
elif len(APP_SECRET_KEY) < 32:
    print(f"WARNING: APP_SECRET_KEY is set but may not be strong enough (length: {len(APP_SECRET_KEY)}). "
          "Ensure it's a Fernet-compatible key (32 url-safe base64-encoded bytes).")


# --- LLM Configuration ---

ENV_DEFAULT_OLLAMA_MODEL_ID = os.getenv("DEFAULT_OLLAMA_MODEL_ID", "qwen3:8B")
ENV_DEFAULT_OLLAMA_MODEL_DISPLAY_NAME = os.getenv("DEFAULT_OLLAMA_MODEL_DISPLAY_NAME", "Qwen3 8B (Local Default)")
ENV_DEFAULT_OLLAMA_MODEL_CONTEXT_WINDOW = int(os.getenv("DEFAULT_OLLAMA_MODEL_CONTEXT_WINDOW", 32768))

LLM_PROVIDERS: Dict[str, Dict[str, Any]] = {
    "ollama_local": {
        "display_name": "Ollama (Local)",
        "type": "ollama",
        "base_url_env_var": "OLLAMA_BASE_URL",
        "api_key_env_var": None, # Ollama does not use API keys in this manner
        "available_models": [
            {
                "model_id": ENV_DEFAULT_OLLAMA_MODEL_ID,
                "display_name": ENV_DEFAULT_OLLAMA_MODEL_DISPLAY_NAME,
                "context_window": ENV_DEFAULT_OLLAMA_MODEL_CONTEXT_WINDOW
            },
        ],
    },
    "google_gemini": {
        "display_name": "Google Gemini",
        "type": "google_genai",
        "base_url_env_var": None, # Google SDK handles the endpoint
        "api_key_env_var": "GOOGLE_API_KEY", # User's original: None, changed to GOOGLE_API_KEY to align with get_provider_config usage
        "available_models": [
            {
                "model_id": "gemini-2.5-pro", # User's original model ID
                "display_name": "Gemini 2.5 Pro", 
                "context_window": 1048576 
            },
            {
                "model_id": "gemini-2.5-flash", # User's original model ID
                "display_name": "Gemini 2.5 Flash", 
                "context_window": 1048576 
            }

        ],
    },
    "anthropic_claude": {
        "display_name": "Anthropic Claude",
        "type": "anthropic",
        "base_url_env_var": None, # Anthropic SDK handles the endpoint
        "api_key_env_var": "ANTHROPIC_API_KEY", # User's original: None, changed to ANTHROPIC_API_KEY
        "available_models": [
            {
                "model_id": "claude-sonnet-4-20250514", # User's original model ID
                "display_name": "Claude 4.0 Sonnet", 
                "context_window": 200000 
            }
        ],
    },
    "openai_compatible_server": {
        "display_name": "OpenAI-Compatible API",
        "type": "openai_compatible",
        "base_url_env_var": "OPENAI_COMPATIBLE_BASE_URL",
        "api_key_env_var": "OPENAI_COMPATIBLE_API_KEY", # User's original: None, changed to OPENAI_COMPATIBLE_API_KEY
        "available_models": [
            {
                "model_id": "gpt-4o-2024-08-06", 
                "display_name": "GPT 4o",
                "context_window": 128000
            }
        ],
    },
}

# --- Default LLM Selection ---
DEFAULT_LLM_PROVIDER_ID: str = os.getenv("DEFAULT_LLM_PROVIDER_ID", "ollama_local") # User's original default
# Logic to set DEFAULT_LLM_MODEL_ID based on DEFAULT_LLM_PROVIDER_ID and its available models
_default_provider_config_for_model_fallback = LLM_PROVIDERS.get(DEFAULT_LLM_PROVIDER_ID, {})
_default_provider_models_for_fallback = _default_provider_config_for_model_fallback.get("available_models", [])
_default_model_id_env_candidate = os.getenv("DEFAULT_LLM_MODEL_ID")

if _default_model_id_env_candidate and any(m["model_id"] == _default_model_id_env_candidate for m in _default_provider_models_for_fallback):
    DEFAULT_LLM_MODEL_ID: str = _default_model_id_env_candidate
elif _default_provider_models_for_fallback:
    DEFAULT_LLM_MODEL_ID: str = _default_provider_models_for_fallback[0]["model_id"]
else:
    DEFAULT_LLM_MODEL_ID: str = "qwen3:8B" # Fallback to user's original hardcoded default if provider/models not found
    if DEFAULT_LLM_PROVIDER_ID == "ollama_local":
        DEFAULT_LLM_MODEL_ID = ENV_DEFAULT_OLLAMA_MODEL_ID # Ensure it uses the ollama default if provider is ollama
    print(f"WARNING: Could not determine a valid DEFAULT_LLM_MODEL_ID for provider '{DEFAULT_LLM_PROVIDER_ID}' from its 'available_models'. Using '{DEFAULT_LLM_MODEL_ID}'.")


# --- Provider Characteristics ---
# ADDED THESE AS THEY WERE MISSING AND CAUSING AttributeErrors
PROVIDERS_TYPICALLY_USING_API_KEYS = {
    "google_gemini",
    "anthropic_claude",
    "openai_compatible_server"
    # Add "openai" here if you add a direct OpenAI provider definition
}

PROVIDERS_ALLOWING_USER_KEYS_EVEN_IF_SYSTEM_CONFIGURED = {
    "google_gemini",                # User might want to use their own project quota/key
    "anthropic_claude",             # User might want to use their own key
    "openai_compatible_server"      # For this type, user often provides key and base_url
}


# --- Helper function to get a provider's configuration ---
def get_provider_config(provider_id: str) -> Optional[Dict[str, Any]]:
    provider_info_template = LLM_PROVIDERS.get(provider_id)
    if not provider_info_template:
        return None

    runtime_config = provider_info_template.copy()

    base_url_env_name = provider_info_template.get("base_url_env_var")
    resolved_base_url = None # Initialize
    if base_url_env_name:
        resolved_base_url = os.getenv(base_url_env_name)
    
    # Specific handling for Ollama's common OLLAMA_BASE_URL if its own provider-specific env var isn't set
    if provider_info_template.get("type") == "ollama" and not resolved_base_url:
        resolved_base_url = os.getenv("OLLAMA_BASE_URL", "http://localhost:11434")
    
    runtime_config["base_url"] = resolved_base_url if resolved_base_url else provider_info_template.get("base_url") # Fallback to static base_url in template if any

    # This key in runtime_config is what main.py's list_llm_providers expects
    runtime_config["api_key_env_var_name"] = provider_info_template.get("api_key_env_var")

    if "available_models" not in runtime_config or not isinstance(runtime_config["available_models"], list):
        runtime_config["available_models"] = []
    return runtime_config

# --- Ollama Base URL (General fallback if not specified per provider) ---
OLLAMA_BASE_URL = os.getenv("OLLAMA_BASE_URL", "http://localhost:11434")

# --- Chat Behavior Prefixes ---
NO_THINK_PREFIX = "\\no_think"
THINK_PREFIX = "\\think"


# --- Static Files Configuration ---
APP_DIR = Path(__file__).resolve().parent 
PROJECT_ROOT = APP_DIR.parent
STATIC_DIR_IN_APP = APP_DIR / "static"
STATIC_DIR_AT_ROOT_LEVEL = PROJECT_ROOT / "static"
STATIC_DIR: Optional[Path] = None 

if STATIC_DIR_IN_APP.is_dir():
    STATIC_DIR = STATIC_DIR_IN_APP
elif STATIC_DIR_AT_ROOT_LEVEL.is_dir() and (PROJECT_ROOT / "pyproject.toml").exists(): 
    STATIC_DIR = STATIC_DIR_AT_ROOT_LEVEL
else:
    current_working_dir = Path.cwd()
    if (current_working_dir / "app" / "static").is_dir(): 
        STATIC_DIR = current_working_dir / "app" / "static"
    elif (current_working_dir / "static").is_dir(): 
        STATIC_DIR = current_working_dir / "static"
    
    if not STATIC_DIR or not STATIC_DIR.is_dir(): 
        print(f"CRITICAL ERROR: Static directory not found. Checked standard locations relative to {APP_DIR}, {PROJECT_ROOT}, and {current_working_dir}. Application may not serve frontend assets.")
        # sys.exit(1) # Consider if exiting is appropriate or just log error

# --- Docker Configuration ---
LANGUAGES_CONFIG_PATH = APP_DIR / "static" / "languages.json"
try:
    with open(LANGUAGES_CONFIG_PATH, "r", encoding="utf-8") as f:
        SUPPORTED_LANGUAGES = json.load(f)
    print(f"DEBUG config: Successfully loaded {len(SUPPORTED_LANGUAGES)} languages from {LANGUAGES_CONFIG_PATH}")
except Exception as e:
    print(f"CRITICAL ERROR: Could not load or parse languages.json: {e}")
    # Fallback to an empty dict if the file is missing or corrupt
    SUPPORTED_LANGUAGES = {}

DOCKER_TIMEOUT_SECONDS = int(os.getenv("DOCKER_TIMEOUT_SECONDS", 30))
DOCKER_MEM_LIMIT = os.getenv("DOCKER_MEM_LIMIT", "128m")


# --- Email Configuration ---
MAIL_CONFIG = {
    "MAIL_USERNAME": os.getenv("MAIL_USERNAME"),
    "MAIL_PASSWORD": os.getenv("MAIL_PASSWORD"),
    "MAIL_FROM": os.getenv("MAIL_FROM"),
    "MAIL_PORT": int(os.getenv("MAIL_PORT", 465)),
    "MAIL_SERVER": os.getenv("MAIL_SERVER"),
    "MAIL_FROM_NAME": os.getenv("MAIL_FROM_NAME", "Tesseracs Chat"),
    "MAIL_STARTTLS": os.getenv("MAIL_STARTTLS", 'False').lower() in ('true', '1', 't', 'yes'),
    "MAIL_SSL_TLS": os.getenv("MAIL_SSL_TLS", 'True').lower() in ('true', '1', 't', 'yes'),
    "USE_CREDENTIALS": True,
    "VALIDATE_CERTS": os.getenv("MAIL_VALIDATE_CERTS", 'True').lower() in ('true', '1', 't', 'yes')
}

if not all([MAIL_CONFIG["MAIL_USERNAME"], MAIL_CONFIG["MAIL_PASSWORD"], MAIL_CONFIG["MAIL_SERVER"], MAIL_CONFIG["MAIL_FROM"]]):
    print("WARNING: Essential email configuration (USERNAME, PASSWORD, SERVER, FROM) missing in .env file. Email functionalities will likely fail.")

# --- Rate Limiting Configuration ---
FORGOT_PASSWORD_ATTEMPT_LIMIT = int(os.getenv("FORGOT_PASSWORD_ATTEMPT_LIMIT", 3)) # User's original
FORGOT_PASSWORD_ATTEMPT_WINDOW_HOURS = int(os.getenv("FORGOT_PASSWORD_ATTEMPT_WINDOW_HOURS", 24)) # User's original

# --- Debug Logging for Configuration ---
print(f"DEBUG config: Application DEBUG_MODE: {DEBUG_MODE}")
print(f"DEBUG config: Application BASE_URL is set to: {BASE_URL}")
if STATIC_DIR:
    print(f"DEBUG config: Static files directory resolved to: {STATIC_DIR.resolve()}")
else:
     print("DEBUG config: Static files directory NOT RESOLVED.")
print(f"DEBUG config: Email VALIDATE_CERTS: {MAIL_CONFIG['VALIDATE_CERTS']}, SSL_TLS: {MAIL_CONFIG['MAIL_SSL_TLS']}, STARTTLS: {MAIL_CONFIG['MAIL_STARTTLS']}")
print(f"DEBUG config: Default LLM Provider ID (system default): {DEFAULT_LLM_PROVIDER_ID}")
print(f"DEBUG config: Default LLM Model ID (system default): {DEFAULT_LLM_MODEL_ID}")

default_provider_runtime_details = get_provider_config(DEFAULT_LLM_PROVIDER_ID)
if default_provider_runtime_details:
    print(f"DEBUG config: Default Provider Type: {default_provider_runtime_details.get('type')}")
    print(f"DEBUG config: Default Provider Resolved Base URL: {default_provider_runtime_details.get('base_url')}")
    print(f"DEBUG config: Default Provider API Key Env Var Name (from LLM_PROVIDERS 'api_key_env_var'): {default_provider_runtime_details.get('api_key_env_var_name')}")
else:
    print(f"WARNING config: Default LLM Provider '{DEFAULT_LLM_PROVIDER_ID}' could not be resolved by get_provider_config.")

if not CSRF_PROTECT_SECRET_KEY:
     print("WARNING config: CSRF_PROTECT_SECRET_KEY is not set in environment. main.py will use a fallback (insecure for production).")
    
print("-" * 50)
print(f"DEBUG: APP_SECRET_KEY loaded in config.py: {APP_SECRET_KEY}")
print("-" * 50)


=== app/database.py ===
# app/database.py
import sqlite3
import os
from pathlib import Path
import hashlib # For password hashing
import secrets # For generating secure tokens
import datetime # For timestamps

# Determine the project root directory based on the location of this file
# Assuming this file is app/database.py
APP_DIR = Path(__file__).parent
PROJECT_ROOT = APP_DIR.parent
DATABASE_NAME = "tesseracs_chat.db" # Name of the SQLite database file
DATABASE_PATH = PROJECT_ROOT / DATABASE_NAME # Full path to the database file

def get_code_execution_results(session_id):
    conn = get_db_connection()
    cursor = conn.cursor()
    
    try:
        cursor.execute("""
            SELECT code_block_id, language, code_content, output_content, 
                   html_content, exit_code, error_message, execution_status, 
                   executed_at, turn_id
            FROM code_execution_results 
            WHERE session_id = ? 
            ORDER BY executed_at ASC
        """, (session_id,))
        
        results = []
        for row in cursor.fetchall():
            results.append({
                'code_block_id': row['code_block_id'],
                'language': row['language'],
                'code_content': row['code_content'],
                'output_content': row['output_content'],
                'html_content': row['html_content'],
                'exit_code': row['exit_code'],
                'error_message': row['error_message'],
                'execution_status': row['execution_status'],
                'executed_at': row['executed_at'],
                'turn_id': row['turn_id']
            })
        
        return results
    except Exception as e:
        print(f"Error retrieving code execution results for session {session_id}: {e}")
        return []
    finally:
        conn.close()

def delete_code_block_data(session_id, code_block_id):
    """
    Deletes code block data from both edited_code_blocks and code_execution_results tables.
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    
    try:
        # Delete from edited_code_blocks table
        cursor.execute(
            "DELETE FROM edited_code_blocks WHERE session_id = ? AND code_block_id = ?",
            (session_id, code_block_id)
        )
        
        # Delete from code_execution_results table
        cursor.execute(
            "DELETE FROM code_execution_results WHERE session_id = ? AND code_block_id = ?",
            (session_id, code_block_id)
        )
        
        conn.commit()
        print(f"Successfully deleted data for code block {code_block_id} in session {session_id}")
        return True
    except Exception as e:
        conn.rollback()
        print(f"Error deleting code block data for {code_block_id}: {e}")
        return False
    finally:
        conn.close()

def save_code_execution_result(session_id, code_block_id, language, code_content, 
                             output_content=None, html_content=None, exit_code=None, 
                             error_message=None, execution_status='completed', turn_id=None):
    conn = get_db_connection()
    cursor = conn.cursor()
    
    try:
        cursor.execute("DELETE FROM code_execution_results WHERE code_block_id = ?", (code_block_id,))
        
        cursor.execute("""
            INSERT INTO code_execution_results 
            (session_id, code_block_id, language, code_content, output_content, 
             html_content, exit_code, error_message, execution_status, turn_id, executed_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now', 'utc'))
        """, (session_id, code_block_id, language, code_content, output_content, 
              html_content, exit_code, error_message, execution_status, turn_id))
        
        conn.commit()
        return True
    except Exception as e:
        conn.rollback()
        print(f"Error saving code execution result for {code_block_id}: {e}")
        return False
    finally:
        conn.close()

def get_db_connection():
    """
    Establishes a connection to the SQLite database.
    Enables row_factory for column access by name and foreign key constraints.
    """
    # print(f"Attempting to connect to database at: {DATABASE_PATH}") # Uncomment for debugging path issues
    conn = sqlite3.connect(DATABASE_PATH)
    conn.row_factory = sqlite3.Row # Allows accessing columns by name (e.g., row['email'])
    conn.execute("PRAGMA foreign_keys = ON;") # Enforce foreign key constraints for this connection
    return conn

def init_db():
    """
    Initializes the database schema.
    Creates tables if they don't exist and attempts to add missing columns
    to existing tables to support schema evolution.
    """
    print(f"Initializing database schema at {DATABASE_PATH}...")
    conn = get_db_connection()
    cursor = conn.cursor()

    # --- Users Table ---
    # Defines user accounts, their credentials, and LLM preferences.
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        email TEXT UNIQUE NOT NULL,
        password_hash TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- Added for tracking updates
        is_active BOOLEAN DEFAULT TRUE NOT NULL,
        selected_llm_provider_id TEXT,      -- User's chosen LLM provider ID
        selected_llm_model_id TEXT,         -- User's chosen LLM model ID for the selected provider
        user_llm_api_key_encrypted TEXT,    -- User's encrypted API key (if they provide their own)
        selected_llm_base_url TEXT          -- User's custom base URL for compatible LLM providers (e.g., OpenAI-compatible servers)
    );
    """)
    print("Ensured 'users' table exists.")

    # Add new columns to 'users' table if they don't exist (for existing databases)
    user_table_columns_to_add = {
        "selected_llm_provider_id": "TEXT",
        "selected_llm_model_id": "TEXT",
        "user_llm_api_key_encrypted": "TEXT",
        "selected_llm_base_url": "TEXT",
        "updated_at": "TIMESTAMP DEFAULT CURRENT_TIMESTAMP" # Ensure updated_at can be added
    }
    cursor.execute("PRAGMA table_info(users)")
    existing_user_columns = [col[1] for col in cursor.fetchall()]

    for col_name, col_definition in user_table_columns_to_add.items():
        if col_name not in existing_user_columns:
            try:
                cursor.execute(f"ALTER TABLE users ADD COLUMN {col_name} {col_definition}")
                print(f"Added '{col_name}' column to 'users' table.")
            except sqlite3.OperationalError as e:
                print(f"Could not add column '{col_name}' to 'users' table: {e}. It might already exist or there's a schema issue.")

    # --- Auth Tokens Table ---
    # Stores various authentication tokens (e.g., session tokens, password reset tokens).
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS auth_tokens (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,                   -- Foreign key to the users table
        token_hash TEXT UNIQUE NOT NULL,            -- Hashed value of the token
        token_type TEXT NOT NULL CHECK(token_type IN ('magic_login', 'session', 'password_reset')), -- Type of token
        expires_at TIMESTAMP NOT NULL,              -- Expiration timestamp for the token
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- When the token was created
        used_at TIMESTAMP,                          -- When the token was used (if applicable, e.g., for one-time tokens)
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE -- If a user is deleted, their tokens are also deleted
    );
    """)
    print("Ensured 'auth_tokens' table exists.")

    # --- Sessions Table ---
    # Represents individual chat sessions.
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS sessions (
        id TEXT PRIMARY KEY,                        -- Unique ID for the session (e.g., UUID)
        host_user_id INTEGER NOT NULL,              -- User who created/hosts the session
        name TEXT,                                  -- User-defined or auto-generated name for the session
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- When the session was created
        last_accessed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- When the session was last accessed or had activity
        is_active BOOLEAN DEFAULT TRUE NOT NULL,    -- Whether the session is currently active or soft-deleted
        FOREIGN KEY (host_user_id) REFERENCES users (id) ON DELETE CASCADE -- If host user is deleted, their sessions are deleted
    );
    """)
    print("Ensured 'sessions' table exists.")

    # --- Session Participants Table ---
    # Manages which users are part of which sessions (for multi-user scenarios, or just the host).
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS session_participants (
        session_id TEXT NOT NULL,                   -- Foreign key to the sessions table
        user_id INTEGER NOT NULL,                   -- Foreign key to the users table
        joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- When the user joined the session
        PRIMARY KEY (session_id, user_id),          -- Composite primary key
        FOREIGN KEY (session_id) REFERENCES sessions (id) ON DELETE CASCADE, -- If session is deleted, participation records are deleted
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE      -- If user is deleted, their participation records are deleted
    );
    """)
    print("Ensured 'session_participants' table exists.")

    # --- Chat Messages Table ---
    # Stores all messages within chat sessions.
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS chat_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id TEXT NOT NULL,                   -- Foreign key to the sessions table
        user_id INTEGER,                            -- Foreign key to users table (NULL if AI/system message)
        sender_name TEXT,                           -- Display name of the sender (e.g., user's name, "AI")
        sender_type TEXT NOT NULL CHECK(sender_type IN ('user', 'ai', 'system', 'anon_user')), -- Type of sender
        content TEXT NOT NULL,                      -- The actual message content
        client_id_temp TEXT,                        -- Optional temporary ID from client for optimistic UI updates
        turn_id INTEGER,                            -- Groups related user and AI messages in a conversational turn
        thinking_content TEXT,                      -- Stores AI's "thinking" process or intermediate thoughts
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- When the message was recorded
        model_provider_id TEXT,                     -- For AI messages: which LLM provider was used
        model_id TEXT,                              -- For AI messages: which specific LLM model was used
        FOREIGN KEY (session_id) REFERENCES sessions (id) ON DELETE CASCADE, -- If session is deleted, its messages are deleted
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE SET NULL    -- If user is deleted, messages remain but user_id becomes NULL
    );
    """)
    print("Ensured 'chat_messages' table exists.")

    cursor.execute("""
    CREATE TABLE IF NOT EXISTS edited_code_blocks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id TEXT NOT NULL,                   
        code_block_id TEXT NOT NULL,               
        language TEXT NOT NULL,                     
        edited_content TEXT NOT NULL,               
        edited_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(session_id, code_block_id),          
        FOREIGN KEY (session_id) REFERENCES sessions (id) ON DELETE CASCADE 
    );
    """)
    print("Ensured 'edited_code_blocks' table exists.")

    # Add new columns to 'chat_messages' if they don't exist
    chat_messages_columns_to_add = {
        "model_provider_id": "TEXT",
        "model_id": "TEXT"
    }
    cursor.execute("PRAGMA table_info(chat_messages)")
    existing_chat_columns = [col[1] for col in cursor.fetchall()]

    for col_name, col_type in chat_messages_columns_to_add.items():
        if col_name not in existing_chat_columns:
            try:
                cursor.execute(f"ALTER TABLE chat_messages ADD COLUMN {col_name} {col_type}")
                print(f"Added '{col_name}' column to 'chat_messages' table.")
            except sqlite3.OperationalError as e:
                print(f"Could not add column '{col_name}' to 'chat_messages' table: {e}. It might already exist.")

    # --- Session Memory State Table ---
    # Stores serialized conversation memory for LLMs, allowing sessions to be resumed with context.
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS session_memory_state (
        session_id TEXT PRIMARY KEY,                -- Foreign key to the sessions table
        memory_state_json TEXT NOT NULL,            -- Serialized memory state (e.g., JSON string)
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- When this memory state was last updated
        FOREIGN KEY (session_id) REFERENCES sessions (id) ON DELETE CASCADE -- If session is deleted, its memory state is deleted
    );
    """)
    print("Ensured 'session_memory_state' table exists.")

    # --- Password Reset Attempts Table ---
    # Logs attempts to reset passwords, useful for rate limiting and security auditing.
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS password_reset_attempts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        email TEXT NOT NULL,                        -- Email for which the reset was attempted
        ip_address TEXT,                            -- Optional: IP address of the requester
        attempted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP -- Timestamp of the reset attempt
    );
    """)
    print("Ensured 'password_reset_attempts' table exists.")


    cursor.execute("""
    CREATE TABLE IF NOT EXISTS code_execution_results (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id TEXT NOT NULL,                   
        code_block_id TEXT NOT NULL,               
        language TEXT NOT NULL,                     
        code_content TEXT NOT NULL,                 
        output_content TEXT,                        
        html_content TEXT,                          
        exit_code INTEGER,                          
        error_message TEXT,                         
        execution_status TEXT NOT NULL DEFAULT 'completed' CHECK(execution_status IN ('completed', 'error', 'timeout')), 
        executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 
        turn_id INTEGER,                            
        FOREIGN KEY (session_id) REFERENCES sessions (id) ON DELETE CASCADE 
    );
    """)
    print("Ensured 'code_execution_results' table exists.")



    # --- Indexes for Performance ---
    # These indexes help speed up common queries.
    print("Ensuring database indexes exist...")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_users_email ON users (email);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_auth_tokens_token_hash ON auth_tokens (token_hash);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_auth_tokens_user_id ON auth_tokens (user_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_sessions_host_user_id ON sessions (host_user_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_session_participants_session_id ON session_participants (session_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_session_participants_user_id ON session_participants (user_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_chat_messages_session_id ON chat_messages (session_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_chat_messages_timestamp ON chat_messages (timestamp);") # For ordering messages
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_session_memory_state_session_id ON session_memory_state (session_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_password_reset_attempts_email_time ON password_reset_attempts (email, attempted_at);")
    print("Ensured all indexes exist.")

    conn.commit() # Save all schema changes
    conn.close()
    print("Database initialization process complete.")

# --- Utility Functions ---

def hash_value(value: str) -> str:
    """
    Hashes a string value (e.g., for storing tokens securely) using SHA256.
    """
    return hashlib.sha256(value.encode('utf-8')).hexdigest()

def generate_secure_token(length: int = 32) -> str:
    """
    Generates a cryptographically secure, URL-safe text string.
    Useful for session tokens, password reset tokens, etc.
    """
    return secrets.token_urlsafe(length)

def save_edited_code_content(session_id, code_block_id, language, code_content):
    conn = get_db_connection()
    cursor = conn.cursor()
    
    try:
        cursor.execute("""
            INSERT OR REPLACE INTO edited_code_blocks 
            (session_id, code_block_id, language, edited_content, edited_at)
            VALUES (?, ?, ?, ?, datetime('now', 'utc'))
        """, (session_id, code_block_id, language, code_content))
        
        conn.commit()
        return True
    except Exception as e:
        conn.rollback()
        print(f"Error saving edited code content for {code_block_id}: {e}")
        return False
    finally:
        conn.close()

# This allows the script to be run directly to initialize the database
# e.g., `python -m app.database` from the project root directory.
if __name__ == "__main__":
    print(f"Running database script directly. Current Working Directory: {Path.cwd()}")
    print(f"Project Root (expected): {PROJECT_ROOT}")
    print(f"Database will be created/checked at: {DATABASE_PATH}")
    
    # Ensure the parent directory for the database file exists before trying to create/connect to it
    DATABASE_PATH.parent.mkdir(parents=True, exist_ok=True)
    
    init_db()

=== app/docker_utils.py ===
# app/docker_utils.py
import asyncio
import tempfile
import traceback
from pathlib import Path
import docker
from docker.errors import DockerException, ImageNotFound, APIError, NotFound
from docker.models.containers import Container
from fastapi import WebSocket
import time
import socket

# Import pywintypes if on Windows, otherwise ignore
try:
    import pywintypes
    PIPE_ENDED_ERROR = pywintypes.error
except ImportError:
    # Create a dummy exception class for non-Windows platforms
    class DummyPipeEndedError(Exception):
        pass
    PIPE_ENDED_ERROR = DummyPipeEndedError

from . import config
from . import state
from .utils import send_ws_message

docker_client = None
try:
    docker_client = docker.from_env()
    docker_client.ping()
    print("Successfully connected to Docker daemon.")
except DockerException as e:
    print(f"CRITICAL WARNING: Could not connect to Docker daemon: {e}")
    print("Code execution via Docker will be unavailable.")
    docker_client = None

def get_docker_client():
    return docker_client

async def read_from_socket_and_stream(
    loop: asyncio.AbstractEventLoop,
    websocket: WebSocket,
    code_block_id: str,
    container: Container,
    socket: socket.socket
):
    """
    Reads from the container's interactive socket, decodes the Docker stream
    protocol, buffers output to detect prompts, and forwards to the WebSocket.
    """
    import struct

    line_buffer = ""
    try:
        while True:
            # 1. Read the 8-byte header from the Docker stream
            try:
                header_bytes = await asyncio.to_thread(socket.recv, 8)
            except PIPE_ENDED_ERROR as e:
                # This is normal when the container finishes - not an error
                print(f"[SocketStreamer-{code_block_id}] Container finished normally (pipe ended)")
                break
            except (ConnectionResetError, BrokenPipeError, OSError) as e:
                print(f"[SocketStreamer-{code_block_id}] Connection closed: {e}")
                break
                
            if not header_bytes:
                print(f"[SocketStreamer-{code_block_id}] No more data, container finished")
                break
            if len(header_bytes) < 8:
                print(f"[SocketStreamer-{code_block_id}] Incomplete header received, closing stream.")
                break

            # 2. Unpack the header to get stream type and content size
            stream_type, size = struct.unpack('>BxxxL', header_bytes)
            
            # 3. Read the exact amount of data specified in the header
            payload_bytes = b''
            bytes_to_read = size
            while bytes_to_read > 0:
                try:
                    chunk = await asyncio.to_thread(socket.recv, bytes_to_read)
                except PIPE_ENDED_ERROR:
                    print(f"[SocketStreamer-{code_block_id}] Container finished while reading payload")
                    break
                    
                if not chunk:
                    print(f"[SocketStreamer-{code_block_id}] Socket closed unexpectedly while reading payload")
                    break
                payload_bytes += chunk
                bytes_to_read -= len(chunk)

            if bytes_to_read > 0:
                # Didn't read all expected data, container likely finished
                break

            stream_name = 'stdout' if stream_type == 1 else 'stderr'
            chunk_str = payload_bytes.decode('utf-8', 'replace')

            # Send the output to WebSocket
            await send_ws_message(websocket, "code_output", {
                "code_block_id": code_block_id, "stream": stream_name, "data": chunk_str
            })

            # Check for input prompts only on stdout
            if stream_name == 'stdout':
                line_buffer += chunk_str
                if '\n' in line_buffer or '\r' in line_buffer:
                    line_buffer = ""
                    continue
                
                prompt_indicators = [':', '?', '>', 'input', 'enter']
                line_lower = line_buffer.lower().strip()
                if line_lower and any(indicator in line_lower for indicator in prompt_indicators):
                    print(f"[SocketStreamer-{code_block_id}] Detected input prompt: '{line_buffer}'")
                    await send_ws_message(websocket, "code_waiting_input", {"code_block_id": code_block_id, "prompt": line_buffer})
                    line_buffer = ""

    except Exception as e:
        print(f"[SocketStreamer-{code_block_id}] Unexpected error in stream: {e}")
        traceback.print_exc()
    finally:
        print(f"[SocketStreamer-{code_block_id}] Stream finished - entering finally block")
        try:
            # Check if container is still running before waiting
            print(f"[SocketStreamer-{code_block_id}] Reloading container to check status...")
            await asyncio.to_thread(container.reload)
            container_status = container.status
            print(f"[SocketStreamer-{code_block_id}] Container status: {container_status}")
            
            if container_status == 'running':
                print(f"[SocketStreamer-{code_block_id}] Container still running, getting state without waiting...")
                # Don't wait for running containers, just send completion with exit code 0
                result = {"StatusCode": 0, "Error": None}
            else:
                # Container already finished, get its exit code
                print(f"[SocketStreamer-{code_block_id}] Container already finished, getting exit code...")
                container_state = container.attrs.get('State', {})
                exit_code = container_state.get('ExitCode', 0)
                error_detail = container_state.get('Error')
                result = {"StatusCode": exit_code, "Error": error_detail}
                print(f"[SocketStreamer-{code_block_id}] Exit code: {exit_code}, Error: {error_detail}")
                
            exit_code = result.get("StatusCode", 0)
            error_msg = result.get("Error")
            
            print(f"[SocketStreamer-{code_block_id}] About to send code_finished with exit_code: {exit_code}")
            
            # Check WebSocket state before sending
            if websocket.client_state.name != 'CONNECTED':
                print(f"[SocketStreamer-{code_block_id}] WARNING: WebSocket not connected (state: {websocket.client_state.name})")
            
            await send_ws_message(websocket, "code_finished", {
                "code_block_id": code_block_id, 
                "exit_code": exit_code, 
                "error": error_msg
            })
            print(f"[SocketStreamer-{code_block_id}] ✓ code_finished message sent successfully")
            
        except Exception as e:
            print(f"[SocketStreamer-{code_block_id}] ERROR in finally block: {e}")
            traceback.print_exc()
            # Send a completion message anyway to unblock the UI
            try:
                await send_ws_message(websocket, "code_finished", {
                    "code_block_id": code_block_id, 
                    "exit_code": 0, 
                    "error": None  # Don't include the cleanup error in the UI
                })
                print(f"[SocketStreamer-{code_block_id}] ✓ Fallback code_finished message sent")
            except Exception as fallback_error:
                print(f"[SocketStreamer-{code_block_id}] ✗ Even fallback message failed: {fallback_error}")
        
        try:
            socket.close()
            print(f"[SocketStreamer-{code_block_id}] Socket closed")
        except Exception as socket_error:
            print(f"[SocketStreamer-{code_block_id}] Error closing socket: {socket_error}")

async def run_code_in_docker_stream(websocket: WebSocket, client_id: str, code_block_id: str, language: str, code: str):
    print(f"[DockerRun-{code_block_id}] === STARTING DOCKER CODE EXECUTION ===")
    
    local_docker_client = get_docker_client()
    if not local_docker_client:
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": "Docker service is unavailable."})
        return

    lang_config = config.SUPPORTED_LANGUAGES.get(language.lower())
    if not lang_config:
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": f"Language '{language}' not supported."})
        return

    tmpdir_obj = tempfile.TemporaryDirectory()
    tmp_path = Path(tmpdir_obj.name)
    container = None

    try:
        (tmp_path / lang_config["filename"]).write_text(code, encoding="utf-8")
        
        is_interactive = lang_config.get("interactive", True)
        
        container = local_docker_client.containers.run(
            image=lang_config["image"],
            command=lang_config["command"],
            volumes={str(tmp_path): {'bind': '/app', 'mode': 'rw'}},
            working_dir='/app',
            mem_limit=config.DOCKER_MEM_LIMIT,
            stdin_open=True,
            tty=False,
            detach=True,
            remove=False
        )

        if is_interactive:
            params = {'stdin': 1, 'stdout': 1, 'stderr': 1, 'stream': 1}
            # On Windows, this is an NpipeSocket; on Linux, a regular socket.
            # We use it directly without accessing ._sock
            interactive_socket = container.attach_socket(params=params)

            async with state.running_containers_lock:
                state.running_containers[code_block_id] = {
                    "container": container, "client_id": client_id, "socket": interactive_socket
                }

            loop = asyncio.get_running_loop()
            reader_task = loop.create_task(
                read_from_socket_and_stream(loop, websocket, code_block_id, container, interactive_socket)
            )
            await asyncio.wait_for(reader_task, timeout=config.DOCKER_TIMEOUT_SECONDS)

        else: # Batch mode for non-interactive
            result = container.wait(timeout=config.DOCKER_TIMEOUT_SECONDS)
            exit_code = result.get("StatusCode", 0)
            error_msg = result.get("Error")
            output = container.logs(stdout=True, stderr=True).decode('utf-8', errors='replace')
            await send_ws_message(websocket, "code_output", {"code_block_id": code_block_id, "stream": "stdout", "data": output})
            await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": exit_code, "error": error_msg})

    except asyncio.TimeoutError:
        print(f"[DockerRun-{code_block_id}] Session timed out after {config.DOCKER_TIMEOUT_SECONDS}s.")
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": 137, "error": "Execution timed out."})
    except Exception as e:
        error_payload = f"Server Execution Error: {e}"
        print(f"[DockerRun-{code_block_id}] CRITICAL ERROR: {error_payload}")
        traceback.print_exc()
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_payload})
    finally:
        print(f"[DockerRun-{code_block_id}] === CLEANUP PHASE ===")
        await stop_docker_container(code_block_id)
        if tmpdir_obj:
            try:
                tmpdir_obj.cleanup()
            except Exception as e:
                print(f"[DockerRun-{code_block_id}] Error cleaning temp directory: {e}")
        
        print(f"[DockerRun-{code_block_id}] === DOCKER EXECUTION COMPLETE ===")

async def send_input_to_container(code_block_id: str, user_input: str):
    """
    Finds the interactive socket for a container and sends user input to it.
    """
    async with state.running_containers_lock:
        container_info = state.running_containers.get(code_block_id)
        if container_info and (socket := container_info.get("socket")):
            try:
                # Use a thread to send data on the blocking socket
                await asyncio.to_thread(socket.sendall, user_input.encode('utf-8'))
                print(f"Sent input to {code_block_id}: {user_input.strip()}")
            except Exception as e:
                print(f"Error sending input via socket: {e}")
        else:
            print(f"Send input failed: No active container or socket for {code_block_id}")

async def stop_docker_container(code_block_id: str):
    container_info = None
    async with state.running_containers_lock:
        container_info = state.running_containers.pop(code_block_id, None)
    
    if not container_info:
        return

    if socket := container_info.get("socket"):
        try:
            socket.close()
            print(f"Socket for {code_block_id} closed.")
        except Exception as e_sock:
            print(f"Error closing socket for {code_block_id}: {e_sock}")

    if container := container_info.get("container"):
        try:
            # Check if container is still running before trying to kill it
            await asyncio.to_thread(container.reload)
            if container.status == 'running':
                await asyncio.to_thread(container.kill)
                print(f"Container for {code_block_id} killed.")
            else:
                print(f"Container for {code_block_id} already stopped (status: {container.status}).")
            
            # Always try to remove the container
            await asyncio.to_thread(container.remove, force=True)
            print(f"Container for {code_block_id} removed.")
        except Exception as e:
            print(f"Error stopping/removing container for {code_block_id}: {e}")

async def cleanup_client_containers(client_id: str):
    async with state.running_containers_lock:
        ids_for_client = [cb_id for cb_id, info in state.running_containers.items() if info.get("client_id") == client_id]
    
    if ids_for_client:
        await asyncio.gather(*[stop_docker_container(cb_id) for cb_id in ids_for_client], return_exceptions=True)

=== app/email_utils.py ===
# app/email_utils.py
from fastapi_mail import FastMail, MessageSchema, ConnectionConfig
from pathlib import Path
import traceback
from . import config # Import your config module

# --- Email Configuration ---
# Create the ConnectionConfig using settings from config.py
# This configuration is used to connect to the email server.
conf = ConnectionConfig(
    MAIL_USERNAME=config.MAIL_CONFIG.get("MAIL_USERNAME"),
    MAIL_PASSWORD=config.MAIL_CONFIG.get("MAIL_PASSWORD"),
    MAIL_FROM=config.MAIL_CONFIG.get("MAIL_FROM"),
    MAIL_PORT=config.MAIL_CONFIG.get("MAIL_PORT", 587), # Default to 587 if not in config
    MAIL_SERVER=config.MAIL_CONFIG.get("MAIL_SERVER"),
    MAIL_FROM_NAME=config.MAIL_CONFIG.get("MAIL_FROM_NAME"),
    MAIL_STARTTLS=config.MAIL_CONFIG.get("MAIL_STARTTLS", True), # Default to True
    MAIL_SSL_TLS=config.MAIL_CONFIG.get("MAIL_SSL_TLS", False),   # Default to False
    USE_CREDENTIALS=config.MAIL_CONFIG.get("USE_CREDENTIALS", True),
    VALIDATE_CERTS=config.MAIL_CONFIG.get("VALIDATE_CERTS", True) # Default to True
)

# Initialize FastMail instance with the configuration
fm = FastMail(conf)

# Define the base path for email templates
# config.APP_DIR should point to the 'app' directory.
EMAIL_TEMPLATES_DIR = config.APP_DIR / "static" / "email_templates"

async def send_registration_password_email(
    recipient_email: str,
    recipient_name: str,
    generated_password: str,
    login_url: str
) -> bool:
    """
    Sends the generated password to a new user using an HTML template.
    The password sent is the user's actual password.
    """
    # Basic check for essential mail server configuration
    if not conf.MAIL_FROM or not conf.MAIL_SERVER:
        print("EMAIL ERROR: Mail configuration (MAIL_FROM, MAIL_SERVER) is incomplete. Cannot send registration password email.")
        return False

    template_path = EMAIL_TEMPLATES_DIR / "registration_email.html"
    subject = "Welcome to Tesseracs Chat - Your Account Details"

    try:
        # Read the HTML template from file
        with open(template_path, "r", encoding="utf-8") as f:
            html_template = f.read()

        # Replace placeholders in the template
        # Ensure all placeholders match those in the HTML template
        html_body = html_template.replace("{{ recipient_name }}", recipient_name)
        html_body = html_body.replace("{{ email }}", recipient_email) # Changed from {{ recipient_email }} for consistency
        html_body = html_body.replace("{{ password }}", generated_password)
        html_body = html_body.replace("{{ login_url }}", login_url)

    except FileNotFoundError:
        print(f"EMAIL ERROR: Registration email template not found at {template_path}")
        return False
    except Exception as e:
        print(f"EMAIL ERROR: Failed to read or process registration email template: {e}")
        traceback.print_exc()
        return False

    # Create the email message schema
    message = MessageSchema(
        subject=subject,
        recipients=[recipient_email],
        body=html_body,
        subtype="html"
    )

    try:
        # Attempt to send the email
        print(f"EMAIL: Attempting to send registration password to {recipient_email} via {conf.MAIL_SERVER}:{conf.MAIL_PORT}")
        await fm.send_message(message)
        print(f"EMAIL: Registration password email successfully sent to {recipient_email}.")
        return True  # Indicate success
    except Exception as e:
        # Log any errors during email sending
        print(f"EMAIL ERROR: Failed to send registration password email to {recipient_email}")
        print(f"EMAIL ERROR DETAILS: {type(e).__name__} - {e}")
        traceback.print_exc()
        return False # Indicate failure

async def send_password_reset_email(
    recipient_email: str,
    recipient_name: str,
    new_password: str,
    login_url: str
) -> bool:
    """
    Sends an email containing a newly generated password after a reset request,
    using an HTML template.
    """
    # Basic check for essential mail server configuration
    if not conf.MAIL_FROM or not conf.MAIL_SERVER:
        print("EMAIL ERROR: Mail configuration (MAIL_FROM, MAIL_SERVER) is incomplete. Cannot send password reset email.")
        return False

    template_path = EMAIL_TEMPLATES_DIR / "password_reset_email.html"
    subject = "Your Tesseracs Chat Password Has Been Reset"

    try:
        # Read the HTML template from file
        with open(template_path, "r", encoding="utf-8") as f:
            html_template = f.read()

        # Replace placeholders in the template
        # Ensure all placeholders match those in the HTML template
        html_body = html_template.replace("{{ recipient_name }}", recipient_name)
        html_body = html_body.replace("{{ email }}", recipient_email) # Changed from {{ recipient_email }} for consistency
        html_body = html_body.replace("{{ password }}", new_password)
        html_body = html_body.replace("{{ login_url }}", login_url)

    except FileNotFoundError:
        print(f"EMAIL ERROR: Password reset email template not found at {template_path}")
        return False
    except Exception as e:
        print(f"EMAIL ERROR: Failed to read or process password reset email template: {e}")
        traceback.print_exc()
        return False

    # Create the email message schema
    message = MessageSchema(
        subject=subject,
        recipients=[recipient_email],
        body=html_body,
        subtype="html"
    )

    try:
        # Attempt to send the email
        print(f"EMAIL: Attempting to send password reset to {recipient_email} via {conf.MAIL_SERVER}:{conf.MAIL_PORT}")
        await fm.send_message(message)
        print(f"EMAIL: Password reset email successfully sent to {recipient_email}.")
        return True # Indicate success
    except Exception as e:
        # Log any errors during email sending
        print(f"EMAIL ERROR: Failed to send password reset email to {recipient_email}")
        print(f"EMAIL ERROR DETAILS: {type(e).__name__} - {e}")
        traceback.print_exc()
        return False # Indicate failure


=== app/encryption_utils.py ===
# app/encryption_utils.py
import os
from cryptography.fernet import Fernet, InvalidToken
# Import config from the current package
from . import config 
from typing import Optional

# Global variable to hold the Fernet instance, initialized once
_fernet_instance: Optional[Fernet] = None

def _get_fernet() -> Fernet:
    """
    Initializes and returns the Fernet instance for encryption/decryption.
    Raises ValueError if APP_SECRET_KEY is not configured or invalid.
    """
    global _fernet_instance
    if _fernet_instance is None:
        if not config.APP_SECRET_KEY:
            print("CRITICAL ERROR: APP_SECRET_KEY is not configured in the environment. "
                  "Cannot perform encryption/decryption of sensitive data.")
            raise ValueError("APP_SECRET_KEY is not configured. Encryption services are unavailable.")
        
        try:
            # APP_SECRET_KEY must be a URL-safe base64-encoded 32-byte key.
            key_bytes = config.APP_SECRET_KEY.encode('utf-8')
            _fernet_instance = Fernet(key_bytes)
            print("Fernet encryption service initialized successfully.")
        except Exception as e:
            # This can happen if the key is not correctly formatted (e.g., wrong length, not base64)
            print(f"CRITICAL ERROR: Failed to initialize Fernet with APP_SECRET_KEY: {e}. "
                  "Ensure APP_SECRET_KEY is a valid Fernet key (URL-safe base64 encoded 32-byte key). "
                  "You can generate one using: python -c \"from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())\"")
            raise ValueError(f"Invalid APP_SECRET_KEY format for Fernet encryption: {e}") from e
            
    return _fernet_instance

def encrypt_data(data: str) -> Optional[str]:
    """
    Encrypts a string using the configured Fernet instance.

    Args:
        data: The string data to encrypt.

    Returns:
        The encrypted string, or None if encryption fails or data is empty.
    """
    if not data:
        return None # Do not encrypt empty strings, return None or empty as per policy
    
    try:
        fernet_cipher = _get_fernet()
        encrypted_bytes = fernet_cipher.encrypt(data.encode('utf-8'))
        return encrypted_bytes.decode('utf-8') # Store the encrypted data as a string
    except ValueError as ve: # Raised by _get_fernet if APP_SECRET_KEY is not set/invalid
        print(f"Encryption failed due to configuration issue: {ve}")
        # Depending on policy, you might re-raise or return a specific error indicator.
        # For now, returning None as the operation could not be completed.
        return None
    except Exception as e:
        print(f"Error during data encryption: {e}")
        # import traceback
        # traceback.print_exc() # Uncomment for detailed stack trace during development
        return None

def decrypt_data(encrypted_data: str) -> Optional[str]:
    """
    Decrypts a string using the configured Fernet instance.

    Args:
        encrypted_data: The encrypted string data.

    Returns:
        The decrypted string, or None if decryption fails (e.g., invalid token, key mismatch, or data corruption)
        or if the input is empty.
    """
    if not encrypted_data:
        return None
    
    try:
        fernet_cipher = _get_fernet()
        decrypted_bytes = fernet_cipher.decrypt(encrypted_data.encode('utf-8'))
        return decrypted_bytes.decode('utf-8')
    except InvalidToken:
        # This is a common error if the token is tampered with, the key is wrong,
        # or the data is not valid Fernet-encrypted data.
        print("Error during data decryption: Invalid token. Data might be corrupted or key mismatch.")
        return None
    except ValueError as ve: # Raised by _get_fernet if APP_SECRET_KEY is not set/invalid
        print(f"Decryption failed due to configuration issue: {ve}")
        return None
    except Exception as e:
        print(f"An unexpected error occurred during data decryption: {e}")
        # import traceback
        # traceback.print_exc() # Uncomment for detailed stack trace during development
        return None

# Example usage (for testing purposes, typically not run directly like this in production)
if __name__ == '__main__':
    # This block will only run if the script is executed directly.
    # It requires APP_SECRET_KEY to be set in the environment or .env file.
    print("Running encryption_utils.py for testing...")
    if not config.APP_SECRET_KEY:
        print("Skipping tests: APP_SECRET_KEY is not set in environment.")
    else:
        try:
            # Ensure Fernet can be initialized
            _get_fernet() 
            print("Fernet instance obtained successfully for testing.")

            original_text = "This is a super secret API key!"
            print(f"Original text: '{original_text}'")

            encrypted = encrypt_data(original_text)
            if encrypted:
                print(f"Encrypted text: '{encrypted}'")
                
                decrypted = decrypt_data(encrypted)
                if decrypted:
                    print(f"Decrypted text: '{decrypted}'")
                    assert original_text == decrypted, "Decryption did not match original!"
                    print("Encryption and decryption test successful!")
                else:
                    print("Decryption FAILED.")
            else:
                print("Encryption FAILED.")
            
            print("\nTesting with empty string:")
            encrypted_empty = encrypt_data("")
            print(f"Encrypting empty string: {encrypted_empty}")
            decrypted_empty_from_none = decrypt_data(None) # type: ignore
            print(f"Decrypting None: {decrypted_empty_from_none}")

            print("\nTesting decryption of invalid token:")
            invalid_decryption = decrypt_data("this_is_not_a_valid_fernet_token")
            print(f"Decrypting invalid token: {invalid_decryption}")

        except ValueError as e:
            print(f"Test failed due to ValueError (likely APP_SECRET_KEY issue): {e}")
        except Exception as e:
            print(f"An unexpected error occurred during testing: {e}")



=== app/main.py ===
# In app/main.py

# Ensure your imports at the top of app/main.py look like this:
import os
import sys
import traceback
from pathlib import Path
import asyncio
import json
import sqlite3
import uuid
from urllib.parse import urlparse
import datetime
from typing import Optional, Dict, Any, List, Union # Ensure List and Union are here if used elsewhere

from fastapi import (
    FastAPI,
    Request,
    HTTPException,
    WebSocket,
    WebSocketDisconnect,
    Form,
    Depends,
    Response as FastAPIResponse, # This is an alias, not the Response class itself for type hinting
    Path as FastApiPath,
    Body,
    status
)
from fastapi.responses import (
    HTMLResponse,
    RedirectResponse,
    JSONResponse,
    FileResponse,
    Response  # *** ADDED Response here ***
)
from fastapi.security import OAuth2PasswordRequestForm
from fastapi.staticfiles import StaticFiles
from fastapi.websockets import WebSocketState

from pydantic import HttpUrl

from fastapi_csrf_protect import CsrfProtect
from fastapi_csrf_protect.exceptions import CsrfProtectError

# Assuming your local modules are imported like this:
from . import config
from . import state
from . import llm
from . import docker_utils
from . import utils
from . import database
from . import auth
from . import email_utils
from . import models
from . import encryption_utils

app = FastAPI(title="Tesseracs Chat CSRF Example")

# CSRF Configuration Loader
@CsrfProtect.load_config
def get_csrf_config():
    loaded_secret_from_config = getattr(config, 'CSRF_PROTECT_SECRET_KEY', None)
    final_csrf_secret = None
    # IMPORTANT: This default fallback secret is INSECURE for production.
    # It MUST be overridden by a strong, unique secret in your environment/config.
    default_fallback_secret = "a_very_secure_fallback_secret_key_must_be_at_least_32_bytes_long_0123456789"

    if isinstance(loaded_secret_from_config, str) and len(loaded_secret_from_config) >= 32:
        final_csrf_secret = loaded_secret_from_config
        print(f"DEBUG CSRF: Using configured CSRF_PROTECT_SECRET_KEY (first 5 chars): '{final_csrf_secret[:5]}...'.")
    else:
        if loaded_secret_from_config is None:
            print("WARNING CSRF: CSRF_PROTECT_SECRET_KEY not found in config. Using a placeholder DEMO secret key. THIS IS INSECURE FOR PRODUCTION.")
        elif not isinstance(loaded_secret_from_config, str):
            print(f"CRITICAL CSRF ERROR: CSRF_PROTECT_SECRET_KEY from config is not a string (type: {type(loaded_secret_from_config).__name__}). Using placeholder. THIS IS INSECURE FOR PRODUCTION.")
        elif len(loaded_secret_from_config) < 32:
            print(f"WARNING CSRF: CSRF_PROTECT_SECRET_KEY from config is too short (length: {len(loaded_secret_from_config)}, requires >=32). Using placeholder. THIS IS INSECURE FOR PRODUCTION.")
        final_csrf_secret = default_fallback_secret
        print(f"WARNING CSRF: Using placeholder DEMO secret key (first 5 chars): '{final_csrf_secret[:5]}...'. Ensure CSRF_PROTECT_SECRET_KEY is correctly set and is at least 32 bytes long in your production environment/config.")
    
    print("CSRF CONFIG: Using list-based configuration to explicitly set all parameters.")
    return [
        ("secret_key", final_csrf_secret),
        ("cookie_key", "fastapi-csrf-token"),      # Name of the CSRF token cookie
        ("header_name", "X-CSRF-Token"),          # Name of the CSRF token header for AJAX
        ("httponly", True),                      # CSRF cookie should be HttpOnly
    ]

# CSRF Exception Handler
@app.exception_handler(CsrfProtectError)
async def csrf_protect_exception_handler(request: Request, exc: CsrfProtectError):
    print(f"---- CSRF EXCEPTION HANDLER: Caught CsrfProtectError ----")
    print(f"---- CSRF EXCEPTION HANDLER: Request URL: {request.url}")
    print(f"---- CSRF EXCEPTION HANDLER: Request Method: {request.method}")
    print(f"---- CSRF EXCEPTION HANDLER: Exception message: {exc.message}") 
    print(f"---- CSRF EXCEPTION HANDLER: Exception status code: {exc.status_code}")
    relevant_headers = {
        "content-type": request.headers.get("content-type"),
        "x-csrf-token": request.headers.get("x-csrf-token"), 
        "referer": request.headers.get("referer"),
    }
    print(f"---- CSRF EXCEPTION HANDLER: Relevant Request Headers: {relevant_headers}")
    try:
        form_data = await request.form()
        print(f"---- CSRF EXCEPTION HANDLER: Form Data at time of exception: {dict(form_data)}")
    except Exception as e_form_log:
        print(f"---- CSRF EXCEPTION HANDLER: Could not log form data at time of exception: {e_form_log}")

    return JSONResponse(
        status_code=exc.status_code, 
        content={"detail": exc.message if exc.message else "CSRF Validation Failed"}
    )
# Helper function to serve HTML files with CSRF token injection for JavaScript
async def serve_html_with_csrf(
    file_path: Path,
    request: Request,
    csrf_protect: CsrfProtect,
    replacements: Optional[Dict[str, str]] = None
) -> HTMLResponse:
    if not file_path.is_file():
        print(f"---- SERVER LOG: HTML SERVER - CRITICAL ERROR: HTML file not found at '{file_path}'")
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Resource {file_path.name} not found.")

    html_content_original = ""
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            html_content_original = f.read()
        print(f"---- SERVER LOG: HTML SERVER - '{file_path.name}' content (length: {len(html_content_original)}) read successfully.")
    except Exception as e:
        print(f"---- SERVER LOG: HTML SERVER - ERROR reading '{file_path.name}': {e}")
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Error loading content for {file_path.name}.")

    _raw_token_csrf, signed_token_for_cookie = csrf_protect.generate_csrf_tokens()
    if not _raw_token_csrf or not signed_token_for_cookie:
        print(f"---- SERVER LOG: HTML SERVER ('{file_path.name}') - CRITICAL ERROR: Failed to generate CSRF tokens.")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="CSRF token generation failed on server.")

    print(f"---- SERVER LOG: HTML SERVER ('{file_path.name}') - Raw CSRF token generated for JS: '{_raw_token_csrf[:10]}...'")

    html_content_processed = html_content_original
    
    # Standard CSRF token replacement for JavaScript variable `window.csrfTokenRaw`
    csrf_placeholder = "%%CSRF_TOKEN_RAW%%"
    if csrf_placeholder in html_content_processed:
        html_content_processed = html_content_processed.replace(csrf_placeholder, _raw_token_csrf)
        if csrf_placeholder in html_content_processed: # Check if replacement failed
             print(f"---- SERVER LOG: HTML SERVER ('{file_path.name}') - CRITICAL FAILURE: Placeholder '{csrf_placeholder}' replacement had no effect. Token: '{_raw_token_csrf}'.")
        else:
            print(f"---- SERVER LOG: HTML SERVER ('{file_path.name}') - SUCCESS: Placeholder '{csrf_placeholder}' replaced for JS.")
    else:
        print(f"---- SERVER LOG: HTML SERVER ('{file_path.name}') - INFO: Placeholder '{csrf_placeholder}' NOT FOUND in HTML. Token not directly injected for 'window.csrfTokenRaw'.")

    # Apply additional dynamic replacements if any
    if replacements:
        for key, value in replacements.items():
            if key in html_content_processed:
                html_content_processed = html_content_processed.replace(key, str(value)) # Ensure value is string
                print(f"---- SERVER LOG: HTML SERVER ('{file_path.name}') - Replaced placeholder '{key}'.")
            else:
                print(f"---- SERVER LOG: HTML SERVER ('{file_path.name}') - INFO: Additional placeholder '{key}' not found.")

    response = HTMLResponse(content=html_content_processed)
    try:
        csrf_protect.set_csrf_cookie(response=response, csrf_signed_token=signed_token_for_cookie)
        print(f"---- SERVER LOG: HTML SERVER ('{file_path.name}') - CSRF cookie set in response.")
    except Exception as e:
        print(f"---- SERVER LOG: HTML SERVER ('{file_path.name}') - ERROR during CSRF cookie setting: {e}")
        traceback.print_exc()
        # Not raising HTTPException here as content is ready, but cookie setting failed. Client might still work if old cookie is valid.

    return response

# --- Authentication & Page Routes ---

@app.get("/login", response_class=HTMLResponse, name="get_login_page_route", tags=["Pages"])
async def get_login_page_route(
    request: Request,
    # CRITICAL: This route MUST use `auth.get_current_user` for OPTIONAL authentication.
    # This allows unauthenticated users (like new users) to access the login page.
    # `auth.get_current_user` returns the user dict if authenticated, or None otherwise,
    # and importantly, it does NOT raise an HTTPException if the user is not authenticated.
    user: Optional[Dict[str, Any]] = Depends(auth.get_current_user), 
    csrf_protect: CsrfProtect = Depends() # Ensure CsrfProtect is correctly imported
) -> Response: # MODIFIED: Changed return type hint to Response
    """
    Serves the login page.
    If the user is already authenticated, it redirects them to the session choice page.
    Otherwise, it displays the login form.
    """
    print("---- SERVER LOG: GET /login - Route entered ----")
    
    # Log the state of the user object obtained from the optional dependency.
    # For a new, unauthenticated user, 'user' should be None here.
    if user is None:
        print("---- SERVER LOG: GET /login - `auth.get_current_user` returned None (User is not authenticated). This is expected for new users.")
    else:
        print(f"---- SERVER LOG: GET /login - `auth.get_current_user` returned a user object. Email: '{user.get('email')}'.")

    if user:
        # User is already authenticated (auth.get_current_user returned user data).
        # Redirect them away from the login page.
        print(f"---- SERVER LOG: GET /login - User '{user.get('email')}' already authenticated. Redirecting to session choice page...")
        try:
            # Ensure you have a route named 'get_session_choice_page'
            # This name should match the 'name' parameter in the @app.get("/") decorator for your session choice page.
            session_choice_url = request.url_for("get_session_choice_page")
        except Exception as e:
            # Fallback if the named route isn't found (should not happen in a well-configured app)
            print(f"---- SERVER LOG: GET /login - CRITICAL ERROR: Could not find route named 'get_session_choice_page'. Defaulting to '/'. Error: {e}")
            session_choice_url = "/" 
        return RedirectResponse(url=str(session_choice_url), status_code=status.HTTP_302_FOUND)

    # If 'user' is None, the user is not authenticated. Proceed to show the login page.
    print("---- SERVER LOG: GET /login - Proceeding to serve login page for unauthenticated user.")
    
    # Ensure config.STATIC_DIR is correctly defined and points to your static files directory
    if not config.STATIC_DIR or not (config.STATIC_DIR / "login.html").is_file():
        print(f"---- SERVER LOG: GET /login - CRITICAL ERROR: login.html not found at {config.STATIC_DIR / 'login.html' if config.STATIC_DIR else 'configured STATIC_DIR'}.")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Login page resource is missing on the server.")
        
    login_html_path = config.STATIC_DIR / "login.html"
    
    # Assuming serve_html_with_csrf is your helper function to read HTML, inject CSRF, and set cookies
    # serve_html_with_csrf should return an HTMLResponse
    html_response_content = await serve_html_with_csrf(login_html_path, request, csrf_protect)
    return html_response_content # This is already an HTMLResponse



@app.get("/", response_class=HTMLResponse, name="get_session_choice_page", tags=["Pages"])
async def get_session_choice_page_route( # Renamed function to avoid conflict if you had another
    request: Request,
    # Use the OPTIONAL user dependency here
    user: Optional[Dict[str, Any]] = Depends(auth.get_current_user),
    csrf_protect: CsrfProtect = Depends()
) -> Response: # Can return HTMLResponse or RedirectResponse
    """
    Serves the session choice page if the user is authenticated.
    If the user is not authenticated, redirects them to the login page.
    """
    print("---- SERVER LOG: GET / (get_session_choice_page) - Route entered ----")

    if user is None:
        # User is not authenticated, redirect to the login page.
        print("---- SERVER LOG: GET / (get_session_choice_page) - User not authenticated. Redirecting to /login.")
        try:
            login_url = request.url_for("get_login_page_route")
        except Exception as e:
            print(f"---- SERVER LOG: GET / (get_session_choice_page) - CRITICAL ERROR: Could not find route named 'get_login_page_route'. Defaulting to '/login'. Error: {e}")
            login_url = "/login" # Fallback
        return RedirectResponse(url=str(login_url), status_code=status.HTTP_302_FOUND)

    # User is authenticated, proceed to show the session choice page.
    print(f"---- SERVER LOG: GET / (get_session_choice_page) - User '{user.get('email')}' authenticated. Serving session-choice page.")
    
    if not config.STATIC_DIR or not (config.STATIC_DIR / "session-choice.html").is_file():
        print(f"---- SERVER LOG: GET / (get_session_choice_page) - CRITICAL ERROR: session-choice.html not found.")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Session choice page resource is missing.")
        
    session_choice_html_path = config.STATIC_DIR / "session-choice.html"
    replacements = {"[User Name]": user.get("name", "User")} # Ensure this placeholder exists in session-choice.html
    
    # Assuming serve_html_with_csrf is your helper function
    return await serve_html_with_csrf(session_choice_html_path, request, csrf_protect, replacements=replacements)

@app.get("/chat/{session_id}", response_class=HTMLResponse, name="get_chat_page_for_session", tags=["Pages"])
async def get_chat_page_for_session(
    request: Request,
    session_id: str = FastApiPath(..., description="The ID of the chat session to load."),
    user: Dict[str, Any] = Depends(auth.get_current_active_user), # Ensure this is the correct auth dependency
    csrf_protect: CsrfProtect = Depends()
):
    print(f"---- SERVER LOG: GET /chat/{session_id} - Route entered ----")
    if not user: # Should be handled by Depends
        print(f"---- SERVER LOG: GET /chat/{session_id} - No active user, redirecting to login.")
        # Ensure get_login_page_route is correctly named if you use url_for
        login_url = request.url_for("get_login_page_route") if "get_login_page_route" in request.app.router.routes else "/login"
        return RedirectResponse(url=str(login_url), status_code=status.HTTP_302_FOUND)

    user_id = user['id']
    session_name_for_html = "Chat Session" # Default name
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        
        # Fetch session details
        cursor.execute("SELECT id, name FROM sessions WHERE id = ? AND is_active = 1", (session_id,))
        session_row = cursor.fetchone()
        
        if not session_row:
            print(f"---- SERVER LOG: GET /chat/{session_id} - Session not found or inactive.")
            raise HTTPException(status_code=404, detail="Chat session not found or is inactive.")
        
        session_name_for_html = session_row["name"] # This is your "May 16, 2025..." string

        # Verify user has access to this session
        cursor.execute("SELECT 1 FROM session_participants WHERE session_id = ? AND user_id = ?", (session_id, user_id))
        if not cursor.fetchone():
            print(f"---- SERVER LOG: GET /chat/{session_id} - User {user_id} lacks access.")
            raise HTTPException(status_code=403, detail="You do not have access to this chat session.")

        # Update last_accessed_at for the session
        current_time_utc_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        cursor.execute("UPDATE sessions SET last_accessed_at = ? WHERE id = ?", (current_time_utc_iso, session_id))
        conn.commit()
        print(f"---- SERVER LOG: GET /chat/{session_id} - Access granted for user {user_id}. Session last_accessed_at updated.")

    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc() # It's good to have traceback for unexpected errors
        raise HTTPException(status_code=500, detail="Error verifying session access for chat page.")
    finally:
        if conn: conn.close()

    chat_html_path = config.STATIC_DIR / "chat-session.html"
    if not chat_html_path.is_file():
        print(f"---- SERVER LOG: GET /chat/{session_id} - CRITICAL ERROR: chat-session.html not found at {chat_html_path}")
        raise HTTPException(status_code=500, detail="Chat page resource is missing on the server.")

    # *** CORRECTED REPLACEMENTS ***
    # Define a specific placeholder that you will use in your chat-session.html
    # For example, let's use "%%SESSION_NAME_PLACEHOLDER%%"
    replacements = {
        "%%SESSION_NAME_PLACEHOLDER%%": utils.escape_html(session_name_for_html)
    }
    
    return await serve_html_with_csrf(chat_html_path, request, csrf_protect, replacements=replacements)


@app.get("/settings", response_class=HTMLResponse, name="get_settings_page", tags=["Pages"])
async def get_settings_page(
    request: Request,
    user: Dict[str, Any] = Depends(auth.get_current_active_user),
    csrf_protect: CsrfProtect = Depends()
):
    print("---- SERVER LOG: GET /settings - Route entered ----")
    if not user: # Should be caught by Depends(auth.get_current_active_user)
        print("---- SERVER LOG: GET /settings - No active user, redirecting to login (unexpected).")
        login_url = request.url_for("get_login_page_route")
        return RedirectResponse(url=str(login_url), status_code=status.HTTP_302_FOUND)

    settings_html_path = config.STATIC_DIR / "settings.html"
    # Add any specific replacements for settings.html if needed
    # e.g. replacements = {"": utils.escape_html(user.get("email", ""))}
    return await serve_html_with_csrf(settings_html_path, request, csrf_protect) # Add replacements if any

@app.post("/check_email", response_model=models.EmailCheckResponse, tags=["Authentication"])
async def check_email_exists_route(
    request: Request,
    request_data: models.EmailCheckRequest,
    csrf_protect: CsrfProtect = Depends()
):
    print(f"---- SERVER LOG: POST /check_email - Route entered for email: {request_data.email} ----")
    # CSRF token is expected in the X-CSRF-Token header for AJAX by default
    await csrf_protect.validate_csrf(request)
    print(f"---- SERVER LOG: POST /check_email - CSRF validation PASSED for email: {request_data.email} ----")

    email_to_check = request_data.email.lower().strip()
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM users WHERE email = ? AND is_active = 1", (email_to_check,))
        user_row = cursor.fetchone()
        if user_row:
            user_name = user_row["name"]
            return models.EmailCheckResponse(exists=True, user_name=user_name)
        else:
            return models.EmailCheckResponse(exists=False, user_name=None)
    except sqlite3.Error as e:
        print(f"---- SERVER LOG: POST /check_email - Database error: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error checking email.")
    except Exception as e:
        print(f"---- SERVER LOG: POST /check_email - Unexpected error: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Unexpected error checking email.")
    finally:
        if conn: conn.close()

@app.post("/token", response_model=models.Token, tags=["Authentication"])
async def login_for_access_token(
    request: Request,
    response: FastAPIResponse,
    form_data: OAuth2PasswordRequestForm = Depends(),
    csrf_protect: CsrfProtect = Depends()
):
    print("---- SERVER LOG: POST /token - Route entered ----")
    # For form submissions, fastapi-csrf-protect checks the form field "csrf_token" by default.
    await csrf_protect.validate_csrf(request)
    print("---- SERVER LOG: POST /token - CSRF validation PASSED ----")

    email = form_data.username.lower().strip()
    password = form_data.password
    conn = None
    print(f"---- SERVER LOG: POST /token - Attempting login for email: {email}")
    try:
        conn = database.get_db_connection()
        user_dict = auth.authenticate_user_from_db(conn, email, password) # Refactored to auth module potentially
        if not user_dict: # Covers user not found or password mismatch
            print(f"---- SERVER LOG: POST /token - Authentication failed for email: {email}")
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect email or password.")
        
        if not user_dict["is_active"]:
            print(f"---- SERVER LOG: POST /token - Login FAILED: Account inactive for email: {email}")
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Account is inactive.")
        
        print(f"---- SERVER LOG: POST /token - Login SUCCESSFUL for user ID: {user_dict['id']}. Creating session...")
        session_token_raw = await auth.create_user_session(response=response, user_id=user_dict["id"]) # Sets session cookie
        
        # After successful login, new CSRF tokens should be set on the response for the new authenticated context.
        _raw_token_new, signed_token_for_cookie_new = csrf_protect.generate_csrf_tokens()
        csrf_protect.set_csrf_cookie(response=response, csrf_signed_token=signed_token_for_cookie_new)
        print(f"---- SERVER LOG: POST /token - New CSRF cookie set in response. Raw part of new token: {_raw_token_new[:10]}...")
        
        return models.Token(
            access_token=session_token_raw, 
            token_type="bearer", # This is for API access, session cookie is for browser
            user_id=user_dict["id"], 
            user_name=user_dict["name"], 
            user_email=user_dict["email"]
            # The client JS after login will typically redirect or refresh,
            # and the new page served via serve_html_with_csrf will get its %%CSRF_TOKEN_RAW%%
        )
    except HTTPException as http_exc:
        raise http_exc # Re-raise known HTTP exceptions
    except sqlite3.Error as db_err:
        print(f"---- SERVER LOG: POST /token - Database error for {email}: {db_err}")
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error during login process.")
    except Exception as e:
        print(f"---- SERVER LOG: POST /token - Unexpected server error during login for {email}: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Unexpected server error during login.")
    finally:
        if conn: conn.close()

@app.post("/sessions/create", status_code=status.HTTP_303_SEE_OTHER, tags=["Sessions"])
async def create_new_session_route(
    request: Request, 
    user: Dict[str, Any] = Depends(auth.get_current_active_user),
    csrf_protect: CsrfProtect = Depends()
):
    print("---- SERVER LOG: POST /sessions/create - Route entered ----")

    # Let CsrfProtect handle reading the form data internally.
    # With csrf_form_field_name explicitly set in config, it should prioritize this.
    try:
        await csrf_protect.validate_csrf(request)
        print("---- SERVER LOG: POST /sessions/create - CSRF validation PASSED ----")
    except CsrfProtectError as e_csrf: 
        print(f"---- SERVER LOG: POST /sessions/create - CSRF validation FAILED (CsrfProtectError). Message: {e_csrf.message}")
        raise 
    except Exception as e_csrf_val: 
        print(f"---- SERVER LOG: POST /sessions/create - CSRF validation FAILED (Unexpected Exception). Error type: {type(e_csrf_val).__name__}, Message: {e_csrf_val}")
        traceback.print_exc() 
        raise 

    if not user: 
        print("---- SERVER LOG: POST /sessions/create - User not authenticated (should have been caught by Depends).")
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated for session creation.")

    new_session_id = str(uuid.uuid4())
    host_user_id = user["id"]
    conn = None
    default_session_name = ""
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute(
            """INSERT INTO sessions (id, host_user_id, name, is_active, created_at, last_accessed_at) 
               VALUES (?, ?, ?, ?, datetime('now', 'utc'), datetime('now', 'utc'))""",
            (new_session_id, host_user_id, None, True) 
        )
        cursor.execute("SELECT created_at FROM sessions WHERE id = ?", (new_session_id,))
        session_row = cursor.fetchone()
        
        if not session_row or not session_row["created_at"]:
            default_session_name = f"Session ({new_session_id[:4]})"
            print(f"---- SERVER LOG: POST /sessions/create - Warning: Could not retrieve created_at for session {new_session_id}. Using fallback name: {default_session_name}")
        else:
            try:
                created_at_str = session_row["created_at"]
                if isinstance(created_at_str, str):
                     created_at_str = created_at_str.replace('Z', '+00:00') 
                created_dt = datetime.datetime.fromisoformat(created_at_str)
                if created_dt.tzinfo is None: 
                    created_dt = created_dt.replace(tzinfo=datetime.timezone.utc)
                default_session_name = created_dt.strftime("%b %d, %Y %I:%M %p UTC")
            except (ValueError, TypeError) as parse_err:
                print(f"---- SERVER LOG: POST /sessions/create - Error parsing created_at '{session_row['created_at']}': {parse_err}. Using fallback name.")
                default_session_name = f"Session ({new_session_id[:4]})"
        
        cursor.execute("UPDATE sessions SET name = ? WHERE id = ?", (default_session_name, new_session_id))
        
        cursor.execute(
            "INSERT INTO session_participants (session_id, user_id) VALUES (?, ?)",
            (new_session_id, host_user_id)
        )
        conn.commit()
        print(f"---- SERVER LOG: POST /sessions/create - New session '{new_session_id}' ('{default_session_name}') created by user '{host_user_id}'.")
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error: Could not create new session.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Server error: Could not create new session.")
    finally:
        if conn: conn.close()
    
    try:
        chat_url = request.url_for("get_chat_page_for_session", session_id=new_session_id)
    except Exception as url_for_err:
        print(f"---- SERVER LOG: POST /sessions/create - Error generating URL for 'get_chat_page_for_session': {url_for_err}. Defaulting redirect.")
        chat_url = f"/chat/{new_session_id}" 

    response = RedirectResponse(url=str(chat_url), status_code=status.HTTP_303_SEE_OTHER)
    return response




@app.post("/register", response_model=models.RegistrationResponse, tags=["Authentication"])
async def register_new_user(
    request_data: models.RegistrationRequest,
    request: Request,
    csrf_protect: CsrfProtect = Depends()
):
    print(f"---- SERVER LOG: POST /register - Attempting registration for email: {request_data.email} ----")
    await csrf_protect.validate_csrf(request) # Expects X-CSRF-Token for JSON request
    print(f"---- SERVER LOG: POST /register - CSRF validation PASSED for email: {request_data.email} ----")

    email = request_data.email.lower().strip()
    name = request_data.name.strip()

    if not name:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Name cannot be empty.")
    if not utils.is_valid_email(email): # Assuming utils.is_valid_email exists
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid email format.")

    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT id FROM users WHERE email = ?", (email,))
        if cursor.fetchone():
            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="This email address is already registered.")
        
        plain_password = database.generate_secure_token(12) # Or from config.PASSWORD_LENGTH
        hashed_password = auth.get_password_hash(plain_password)
        
        cursor.execute(
            "INSERT INTO users (name, email, password_hash, is_active, created_at, updated_at) VALUES (?, ?, ?, ?, datetime('now'), datetime('now'))",
            (name, email, hashed_password, True) # is_active usually True on registration
        )
        user_id = cursor.lastrowid
        if not user_id: # Should not happen if insert is successful and table has autoincrement PK
            conn.rollback()
            print(f"---- SERVER LOG: POST /register - CRITICAL: Failed to get lastrowid after user insertion for {email}.")
            raise sqlite3.Error("User insertion failed to return an ID.")

        login_url_from_fastapi = str(request.url_for('get_login_page_route'))
        # Construct a robust login_page_url
        parsed_base_url = urlparse(config.BASE_URL)
        parsed_login_route_url = urlparse(login_url_from_fastapi)
        login_page_url = parsed_base_url._replace(path=parsed_login_route_url.path, query=parsed_login_route_url.query, fragment=parsed_login_route_url.fragment).geturl()
        
        email_sent = await email_utils.send_registration_password_email(
            recipient_email=email, recipient_name=name, generated_password=plain_password, login_url=login_page_url
        )
        
        if not email_sent:
            # Account is created, but email failed. This is a critical issue for user experience.
            # Log this error clearly.
            # Commit user creation but inform about email failure.
            conn.commit() # Commit the user anway
            print(f"---- SERVER LOG: POST /register - User '{email}' registered (ID: {user_id}), BUT FAILED to send password email.")
            raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail="Account created, but there was an issue sending your password email. Please try the 'Forgot Password' option or contact support.")
        
        conn.commit()
        print(f"---- SERVER LOG: POST /register - User '{email}' (ID: {user_id}) registered successfully. Password email sent.")
        return models.RegistrationResponse(message="Account created successfully! Your password has been sent to your email address.")

    except HTTPException as http_exc: # Re-raise known HTTP exceptions
        if conn: conn.rollback() # Ensure rollback on handled errors too
        raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="A database error occurred during registration.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred during registration.")
    finally:
        if conn: conn.close()

@app.post("/forgot_password", response_model=models.ForgotPasswordResponse, tags=["Authentication"])
async def handle_forgot_password(
    request_data: models.ForgotPasswordRequest,
    request: Request,
    csrf_protect: CsrfProtect = Depends()
):
    print(f"---- SERVER LOG: POST /forgot_password - Request for email: {request_data.email} ----")
    await csrf_protect.validate_csrf(request) # Expects X-CSRF-Token for JSON
    print(f"---- SERVER LOG: POST /forgot_password - CSRF validation PASSED for email: {request_data.email} ----")

    email = request_data.email.lower().strip()
    if not utils.is_valid_email(email): # Assuming utils.is_valid_email
        # Still return generic message to prevent email enumeration
        return models.ForgotPasswordResponse(message="If an account with this email exists and is active, a password reset email has been sent.")

    client_ip = request.client.host if request.client else "unknown_ip"
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()

        # Always log the attempt for auditing and rate limiting analysis
        cursor.execute(
            "INSERT INTO password_reset_attempts (email, ip_address, attempted_at) VALUES (?, ?, datetime('now'))",
            (email, client_ip)
        )
        # Don't commit yet, commit at the end of successful operations or before returning generic message

        # Rate limiting check (after logging the current attempt)
        time_window_start = datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(hours=config.FORGOT_PASSWORD_ATTEMPT_WINDOW_HOURS)
        cursor.execute(
            "SELECT COUNT(*) FROM password_reset_attempts WHERE email = ? AND attempted_at >= ?",
            (email, time_window_start.isoformat())
        )
        attempt_count_row = cursor.fetchone()
        recent_attempts = attempt_count_row[0] if attempt_count_row else 0

        if recent_attempts > config.FORGOT_PASSWORD_ATTEMPT_LIMIT: # Use > because current attempt is already logged
            conn.commit() # Commit the logged attempt
            print(f"---- SERVER LOG: POST /forgot_password - Rate limit exceeded for {email}. Attempts: {recent_attempts}.")
            return models.ForgotPasswordResponse(message="If an account with this email exists and is active, a password reset email has been sent.")

        cursor.execute("SELECT id, name FROM users WHERE email = ? AND is_active = 1", (email,))
        user_row = cursor.fetchone()

        if not user_row:
            conn.commit() # Commit the logged attempt
            print(f"---- SERVER LOG: POST /forgot_password - No active user found for {email}.")
            return models.ForgotPasswordResponse(message="If an account with this email exists and is active, a password reset email has been sent.")

        user_dict = dict(user_row)
        user_id = user_dict["id"]
        user_name = user_dict["name"]

        new_plain_password = database.generate_secure_token(12)
        new_hashed_password = auth.get_password_hash(new_plain_password)

        cursor.execute("UPDATE users SET password_hash = ?, updated_at = datetime('now') WHERE id = ?", (new_hashed_password, user_id))
        if cursor.rowcount == 0: # Should not happen if user_row was found
            conn.rollback() # Rollback the attempt log as well if this fails
            print(f"---- SERVER LOG: POST /forgot_password - ERROR: Failed to update password hash for user {email} (ID: {user_id}) though user was found.")
            # Return generic message, but this is a server issue.
            return models.ForgotPasswordResponse(message="If an account with this email exists and is active, a password reset email has been sent.")

        login_url_from_fastapi = str(request.url_for('get_login_page_route'))
        parsed_base_url = urlparse(config.BASE_URL)
        parsed_login_route_url = urlparse(login_url_from_fastapi)
        login_page_url = parsed_base_url._replace(path=parsed_login_route_url.path, query=parsed_login_route_url.query, fragment=parsed_login_route_url.fragment).geturl()
        
        email_sent = await email_utils.send_password_reset_email(
            recipient_email=email, recipient_name=user_name, new_password=new_plain_password, login_url=login_page_url
        )

        if not email_sent:
            conn.rollback() # Rollback password change AND the attempt log if email fails critically
            print(f"---- SERVER LOG: POST /forgot_password - Password for {email} was reset in DB, but email sending FAILED. Transaction rolled back.")
            # Still return generic message to the user.
            return models.ForgotPasswordResponse(message="If an account with this email exists and is active, a password reset email has been sent.")
            # Server-side, this might be a 502 error if you want to be more explicit about failure.

        conn.commit() # Commit password change and the successful attempt log
        print(f"---- SERVER LOG: POST /forgot_password - Password reset email successfully sent for user {email} (ID: {user_id}).")
        return models.ForgotPasswordResponse(message="If an account with this email exists and is active, a password reset email has been sent.")

    except sqlite3.Error as db_err:
        if conn: conn.rollback() # Rollback any partial changes
        traceback.print_exc()
        print(f"---- SERVER LOG: POST /forgot_password - Database error for {email}: {db_err}")
        # Return generic message to prevent leaking information
        return models.ForgotPasswordResponse(message="An error occurred while processing your request. Please try again.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        print(f"---- SERVER LOG: POST /forgot_password - Unexpected error for {email}: {e}")
        return models.ForgotPasswordResponse(message="An unexpected error occurred. Please try again.")
    finally:
        if conn: conn.close()


# --- User Account Management API Routes (/api/me/*) ---
# These routes can be called by client-side JavaScript using fetch (likely with Bearer token)
# OR from a settings page form (potentially with session cookie + CSRF token).
# The `auth.get_current_active_user` dependency handles Bearer token auth primarily.
# We add `csrf_protect` and a check to enforce CSRF if not a Bearer call.

async def _ensure_csrf_for_cookie_auth(request: Request, csrf_protect: CsrfProtect):
    """Helper to validate CSRF if the request is not using Bearer token auth."""
    auth_header = request.headers.get("authorization")
    is_bearer_auth = auth_header and auth_header.lower().startswith("bearer ")
    if not is_bearer_auth:
        print(f"---- CSRF CHECK: Path '{request.url.path}' is not Bearer auth, validating CSRF token.")
        await csrf_protect.validate_csrf(request)
        print(f"---- CSRF CHECK: Path '{request.url.path}' CSRF token validated for cookie-based request.")
    else:
        print(f"---- CSRF CHECK: Path '{request.url.path}' is Bearer auth, skipping CSRF token validation.")


@app.put("/api/me/llm-settings", response_model=models.UserLLMSettingsResponse, tags=["User Account Management", "LLM Configuration"])
async def update_user_llm_settings(
    request: Request,
    settings_update: models.UserLLMSettingsUpdateRequest,
    current_user: Dict[str, Any] = Depends(auth.get_current_active_user), # Handles Bearer token
    csrf_protect: CsrfProtect = Depends() # For CSRF validation if not Bearer
):
    await _ensure_csrf_for_cookie_auth(request, csrf_protect)
    user_id = current_user["id"]
    conn = None

    # Validate provider and model IDs against config
    if settings_update.selected_llm_provider_id:
        provider_config_info = config.LLM_PROVIDERS.get(settings_update.selected_llm_provider_id)
        if not provider_config_info:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"Invalid provider ID: {settings_update.selected_llm_provider_id}")
        
        available_models_for_provider = provider_config_info.get("available_models", [])
        if settings_update.selected_llm_model_id:
            model_found = any(
                model.get("model_id") == settings_update.selected_llm_model_id
                for model in available_models_for_provider
            )
            if not model_found:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail=f"Model ID '{settings_update.selected_llm_model_id}' not found or not valid for provider '{settings_update.selected_llm_provider_id}'."
                )
        elif available_models_for_provider: # Provider has models, but none selected in update
             # If a provider is selected that has defined models, a model must also be selected.
             # If the user intends to clear the model, they should also clear the provider or select a provider with no predefined models.
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"A model ID must be selected for provider '{settings_update.selected_llm_provider_id}'.")

    encrypted_api_key_to_store: Optional[str] = None
    if settings_update.user_llm_api_key is not None: # Field is present in the request
        if settings_update.user_llm_api_key == "": # User explicitly wants to clear the key
            encrypted_api_key_to_store = None
        else:
            if not config.APP_SECRET_KEY:
                print("CRITICAL ERROR: APP_SECRET_KEY is not set. Cannot encrypt user API key.")
                raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Server configuration error: API key encryption service is unavailable.")
            encrypted_api_key_to_store = encryption_utils.encrypt_data(settings_update.user_llm_api_key)
            if not encrypted_api_key_to_store: # Should only happen if encryption fails unexpectedly
                raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to secure API key.")
    
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            "SELECT selected_llm_provider_id, selected_llm_model_id, user_llm_api_key_encrypted, selected_llm_base_url FROM users WHERE id = ?",
            (user_id,)
        )
        current_db_settings = cursor.fetchone()
        if not current_db_settings: # Should not happen for an active authenticated user
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User settings record not found.")

        # Determine final values: if a field is in settings_update, use it; otherwise, keep DB value.
        final_provider_id = settings_update.selected_llm_provider_id if settings_update.selected_llm_provider_id is not None else current_db_settings["selected_llm_provider_id"]
        final_model_id = settings_update.selected_llm_model_id if settings_update.selected_llm_model_id is not None else current_db_settings["selected_llm_model_id"]
        
        if settings_update.user_llm_api_key is not None: # API key was part of the update request
            final_api_key_encrypted = encrypted_api_key_to_store
        else: # API key was not in the update request, keep existing
            final_api_key_encrypted = current_db_settings["user_llm_api_key_encrypted"]

        final_base_url_str: Optional[str] = None
        if settings_update.selected_llm_base_url is not None: # Base URL was part of the update
            if not settings_update.selected_llm_base_url: # Explicitly empty (e.g., empty string from form)
                final_base_url_str = None
            else:
                final_base_url_str = str(settings_update.selected_llm_base_url) # Convert HttpUrl to string
        else: # Base URL not in update, keep existing
            final_base_url_str = current_db_settings["selected_llm_base_url"]

        # Logic to clear dependent fields if provider is cleared or fundamentally changed
        if final_provider_id is None:
            final_model_id = None
            final_api_key_encrypted = None # Clearing provider implies clearing user-specific key for it
            final_base_url_str = None    # Clearing provider implies clearing user-specific base URL
        elif final_provider_id != current_db_settings["selected_llm_provider_id"]:
            # If provider changed, re-evaluate if existing API key/base URL are still relevant
            # For simplicity here, if provider changes, and user didn't explicitly send new key/URL,
            # we might clear them if the new provider type suggests it (e.g. ollama often doesn't need user key).
            # This logic can be more nuanced based on provider types.
            new_provider_config_details = config.get_provider_config(final_provider_id)
            if new_provider_config_details and new_provider_config_details.get("type") == "ollama":
                if settings_update.user_llm_api_key is None: # If user didn't send a new key for ollama
                    final_api_key_encrypted = None
                if settings_update.selected_llm_base_url is None: # If user didn't send a new base_url for ollama
                    final_base_url_str = None # Default to system config for ollama base URL unless user specifies
        
        # Ensure model is compatible with provider
        if final_provider_id and final_model_id:
            prov_info = config.LLM_PROVIDERS.get(final_provider_id)
            if not prov_info or not any(m.get("model_id") == final_model_id for m in prov_info.get("available_models", [])):
                # This case implies an inconsistency, possibly model was valid for old provider but not new one
                # Or user cleared model without clearing provider that requires one.
                # Safest might be to clear model if it's not valid for the final_provider_id
                final_model_id = None 
                # If the provider requires a model, this state (provider set, model None) might be an issue later.
                # The initial validation should catch "provider selected, model required but not provided".

        cursor.execute(
            """UPDATE users SET
                selected_llm_provider_id = ?,
                selected_llm_model_id = ?,
                user_llm_api_key_encrypted = ?,
                selected_llm_base_url = ?,
                updated_at = datetime('now')
                WHERE id = ?""",
            (final_provider_id, final_model_id, final_api_key_encrypted, final_base_url_str, user_id)
        )
        conn.commit()

        has_user_api_key_after_update = False
        if final_api_key_encrypted and config.APP_SECRET_KEY:
            try:
                decrypted_check = encryption_utils.decrypt_data(final_api_key_encrypted)
                has_user_api_key_after_update = bool(decrypted_check and decrypted_check.strip())
            except Exception:
                has_user_api_key_after_update = False 
                print(f"WARNING: User {user_id} LLM settings update - could not decrypt stored API key for verification.")
        elif final_api_key_encrypted and not config.APP_SECRET_KEY:
            has_user_api_key_after_update = True # Assume it's present but unverified
            print(f"WARNING: User {user_id} LLM settings update - APP_SECRET_KEY not set, cannot verify has_user_api_key status accurately.")
        
        updated_base_url_obj: Optional[HttpUrl] = None
        if final_base_url_str:
            try:
                updated_base_url_obj = HttpUrl(final_base_url_str)
            except ValueError:
                print(f"WARNING: User {user_id} LLM settings - stored base_url '{final_base_url_str}' is invalid.")
                pass # Keep it None
        
        return models.UserLLMSettingsResponse(
            selected_llm_provider_id=final_provider_id,
            selected_llm_model_id=final_model_id,
            has_user_api_key=has_user_api_key_after_update,
            selected_llm_base_url=updated_base_url_obj
        )
    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error occurred while updating LLM settings.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred while updating LLM settings.")
    finally:
        if conn: conn.close()

@app.post("/api/me/regenerate-password", response_model=models.RegeneratePasswordResponse, tags=["User Account Management"])
async def regenerate_user_password(
    request: Request,
    payload: models.RegeneratePasswordRequest = Body(...),
    current_user: Dict[str, Any] = Depends(auth.get_current_active_user),
    csrf_protect: CsrfProtect = Depends()
):
    await _ensure_csrf_for_cookie_auth(request, csrf_protect)
    user_id = current_user.get("id")
    user_email = current_user.get("email")
    user_name = current_user.get("name", "User") # Ensure name is available

    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT password_hash FROM users WHERE id = ? AND email = ?", (user_id, user_email))
        user_record = cursor.fetchone()
        if not user_record:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User record not found. Please try logging out and back in.")
        
        stored_password_hash = user_record["password_hash"]
        if not stored_password_hash:
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Cannot verify password due to an account data issue. Please contact support.")

        if not auth.verify_password(payload.current_password, stored_password_hash):
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect current password.")

        new_plain_password = database.generate_secure_token(12) # Or from config
        new_hashed_password = auth.get_password_hash(new_plain_password)
        
        cursor.execute("UPDATE users SET password_hash = ?, updated_at = datetime('now') WHERE id = ?", (new_hashed_password, user_id))
        if cursor.rowcount == 0:
            conn.rollback()
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to update password due to a server error.")

        login_url_from_fastapi = str(request.url_for('get_login_page_route'))
        parsed_base_url = urlparse(config.BASE_URL)
        parsed_login_route_url = urlparse(login_url_from_fastapi)
        login_page_url = parsed_base_url._replace(path=parsed_login_route_url.path, query=parsed_login_route_url.query, fragment=parsed_login_route_url.fragment).geturl()
        
        email_sent = await email_utils.send_password_reset_email( # Re-using this, or create a dedicated one
            recipient_email=user_email, recipient_name=user_name, new_password=new_plain_password, login_url=login_page_url
        )
        if not email_sent:
            conn.rollback() # Critical: if email fails, rollback password change
            raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail="Password was reset in the database, but the notification email failed to send. The password change has been rolled back. Please try again.")

        # Invalidate all existing session tokens for this user
        now_utc_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        cursor.execute(
            "UPDATE auth_tokens SET used_at = ?, expires_at = ? WHERE user_id = ? AND token_type = 'session' AND used_at IS NULL",
            (now_utc_iso, now_utc_iso, user_id)
        )
        conn.commit()
        return models.RegeneratePasswordResponse(
            message="Password regenerated successfully. An email has been sent with your new password. You should now log out all other sessions and log back in with the new password."
        )
    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="A database error occurred while regenerating your password.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred.")
    finally:
        if conn: conn.close()

@app.patch("/api/me/update-email", response_model=models.UpdateEmailResponse, tags=["User Account Management"])
async def update_user_email(
    request: Request,
    payload: models.UpdateEmailRequest = Body(...),
    current_user: Dict[str, Any] = Depends(auth.get_current_active_user),
    csrf_protect: CsrfProtect = Depends()
):
    await _ensure_csrf_for_cookie_auth(request, csrf_protect)
    user_id = current_user.get("id")
    current_email_for_logging = current_user.get("email") # For logging comparison
    new_email_normalized = payload.new_email.lower().strip()

    if not utils.is_valid_email(new_email_normalized):
         raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid new email address format.")
    if new_email_normalized == current_email_for_logging:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="New email address is the same as the current one.")

    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT password_hash FROM users WHERE id = ?", (user_id,))
        user_record = cursor.fetchone()
        if not user_record:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User record not found. Please try logging out and back in.")
        
        stored_password_hash = user_record["password_hash"]
        if not stored_password_hash:
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Cannot verify password due to an account data issue. Please contact support.")

        if not auth.verify_password(payload.current_password, stored_password_hash):
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect current password.")

        cursor.execute("SELECT id FROM users WHERE email = ? AND id != ?", (new_email_normalized, user_id))
        if cursor.fetchone():
            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="This email address is already in use by another account.")

        cursor.execute("UPDATE users SET email = ?, updated_at = datetime('now') WHERE id = ?", (new_email_normalized, user_id))
        if cursor.rowcount == 0:
            conn.rollback()
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to update email due to a server error during the update operation.")

        # Invalidate all existing session tokens for this user as email (username) changed
        now_utc_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        cursor.execute(
            "UPDATE auth_tokens SET used_at = ?, expires_at = ? WHERE user_id = ? AND token_type = 'session' AND used_at IS NULL",
            (now_utc_iso, now_utc_iso, user_id)
        )
        conn.commit()
        return models.UpdateEmailResponse(
            message="Email updated successfully. You will now be logged out to apply changes and must log in with your new email address.",
            new_email=new_email_normalized
        )
    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="A database error occurred while updating your email.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred while updating your email.")
    finally:
        if conn: conn.close()

@app.patch("/api/me/update-name", response_model=models.UpdateNameResponse, tags=["User Account Management"])
async def update_user_name(
    request: Request,
    update_data: models.UpdateNameRequest = Body(...),
    current_user: Dict[str, Any] = Depends(auth.get_current_active_user),
    csrf_protect: CsrfProtect = Depends()
):
    await _ensure_csrf_for_cookie_auth(request, csrf_protect)
    user_id = current_user.get("id")
    new_name_stripped = update_data.new_name.strip()

    if not new_name_stripped:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="New name cannot be empty.")
    if len(new_name_stripped) > 100: # Example length validation
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="New name is too long (maximum 100 characters).")

    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT password_hash FROM users WHERE id = ?", (user_id,))
        user_record = cursor.fetchone()
        if not user_record:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User record not found. Please try logging out and back in.")
        
        stored_password_hash = user_record["password_hash"]
        if not stored_password_hash:
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Cannot verify password due to an account data issue. Please contact support.")

        if not auth.verify_password(update_data.current_password, stored_password_hash):
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect current password.")

        cursor.execute("UPDATE users SET name = ?, updated_at = datetime('now') WHERE id = ?", (new_name_stripped, user_id))
        if cursor.rowcount == 0:
            conn.rollback()
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to update name due to a server error during the update operation.")
        
        conn.commit()
        return models.UpdateNameResponse(message="Name updated successfully.", new_name=new_name_stripped)
    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="A database error occurred while updating your name.")
    except Exception as e:
        if conn: conn.rollback()
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred while updating your name.")
    finally:
        if conn: conn.close()


# --- LLM, User, Session Data (mostly GET requests or auth via Bearer, CSRF not primary concern for GET) ---

@app.get("/api/llm/providers", response_model=List[models.LLMProviderDetail], tags=["LLM Configuration"])
async def list_llm_providers(
    current_user: Optional[Dict[str, Any]] = Depends(auth.get_current_user) # Can be optional if public info
):
    # This is a GET request, so CSRF is not typically applied for read operations.
    response_providers = []
    for provider_id, provider_data_from_config_root in config.LLM_PROVIDERS.items():
        # Get runtime configuration which might include resolved env vars
        provider_runtime_config = config.get_provider_config(provider_id)
        if not provider_runtime_config:
            print(f"Warning: Runtime configuration for LLM provider '{provider_id}' not found. Skipping.")
            continue

        # Determine if the system has a key configured for this provider
        is_system_key_configured = False
        api_key_env_var_name = provider_runtime_config.get("api_key_env_var_name")
        if api_key_env_var_name and os.getenv(api_key_env_var_name):
            is_system_key_configured = True
        
        # A provider "requires_api_key_from_user" if:
        # 1. The provider definition inherently can use an API key (e.g., OpenAI, Anthropic).
        # 2. AND the system does NOT have a global key configured for it.
        # Some providers (like 'ollama' or local models) might not require a key at all.
        # Some (like 'openai_compatible_server') might always allow a user key even if a system one exists.
        
        # Base assumption: provider needs a key if it's one of the known types that use keys
        # OR if its config explicitly mentions an API key environment variable.
        provider_type_can_use_key = provider_id in config.PROVIDERS_TYPICALLY_USING_API_KEYS or \
                                    bool(api_key_env_var_name)

        # Does the user *need* to provide a key? True if the type can use a key AND system doesn't have one.
        needs_api_key_from_user = provider_type_can_use_key and not is_system_key_configured
        
        # Can the user *optionally* provide a key? (e.g. for OpenAI compatible servers, even if system has one)
        can_accept_user_api_key = provider_id in config.PROVIDERS_ALLOWING_USER_KEYS_EVEN_IF_SYSTEM_CONFIGURED or needs_api_key_from_user


        available_models_details = []
        for model_info in provider_data_from_config_root.get("available_models", []):
            available_models_details.append(
                models.LLMAvailableModel(
                    model_id=model_info.get("model_id"),
                    display_name=model_info.get("display_name"),
                    context_window=model_info.get("context_window") # Ensure this is handled if missing
                )
            )
        
        response_providers.append(
            models.LLMProviderDetail(
                id=provider_id,
                display_name=provider_data_from_config_root.get("display_name", provider_id.replace("_", " ").title()),
                type=provider_runtime_config.get("type", "unknown"),
                is_system_configured=is_system_key_configured or not provider_type_can_use_key, # System is "configured" if key is present OR if provider type doesn't need one
                can_accept_user_api_key=can_accept_user_api_key, # If user can enter their own key
                needs_api_key_from_user=needs_api_key_from_user, # If user *must* enter a key because system lacks one
                available_models=available_models_details,
                # Does provider support a user-defined base_url?
                can_accept_user_base_url=provider_runtime_config.get("type") == "openai_compatible_server" # Example
            )
        )
    return response_providers


@app.get("/api/me/llm-settings", response_model=models.UserLLMSettingsResponse, tags=["User Account Management", "LLM Configuration"])
async def get_user_llm_settings(
    current_user: Dict[str, Any] = Depends(auth.get_current_active_user) # Bearer token auth
):
    # GET request, CSRF not primary concern
    user_id = current_user["id"]
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            "SELECT selected_llm_provider_id, selected_llm_model_id, user_llm_api_key_encrypted, selected_llm_base_url FROM users WHERE id = ?",
            (user_id,)
        )
        user_settings_row = cursor.fetchone()

        if not user_settings_row: # Should not happen for an active user
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User LLM settings not found.")

        selected_provider_id = user_settings_row["selected_llm_provider_id"]
        selected_model_id = user_settings_row["selected_llm_model_id"]
        encrypted_api_key = user_settings_row["user_llm_api_key_encrypted"]
        selected_base_url_str = user_settings_row["selected_llm_base_url"]

        # If user has no provider/model selected in DB, use system defaults from config
        if selected_provider_id is None and config.DEFAULT_LLM_PROVIDER_ID:
            selected_provider_id = config.DEFAULT_LLM_PROVIDER_ID
            # If provider is defaulted, model should also be the system default model for that provider
            # or the overall system default model if the default provider doesn't specify one.
            default_provider_config = config.LLM_PROVIDERS.get(config.DEFAULT_LLM_PROVIDER_ID, {})
            if default_provider_config.get("available_models"):
                selected_model_id = default_provider_config["available_models"][0]["model_id"] # First model of default provider
            else: # Fallback to overall default model ID if any
                selected_model_id = config.DEFAULT_LLM_MODEL_ID

            # If defaulting the provider, logically clear any user-specific API key or base URL
            # as these were not explicitly chosen by the user for this default.
            encrypted_api_key = None
            selected_base_url_str = None
        elif selected_provider_id and not selected_model_id: # Provider chosen, but model missing (e.g. after config change)
            provider_config = config.LLM_PROVIDERS.get(selected_provider_id, {})
            if provider_config.get("available_models"):
                 selected_model_id = provider_config["available_models"][0]["model_id"] # Default to first model of chosen provider

        has_user_api_key = False
        if encrypted_api_key:
            if config.APP_SECRET_KEY:
                try:
                    decrypted_key_check = encryption_utils.decrypt_data(encrypted_api_key)
                    if decrypted_key_check and decrypted_key_check.strip(): # Ensure non-empty key after decryption
                        has_user_api_key = True
                except Exception: # Decryption can fail
                    print(f"WARNING: User {user_id} - Could not decrypt stored API key for has_user_api_key flag.")
                    pass # has_user_api_key remains False
            else:
                # APP_SECRET_KEY not set, cannot confirm key validity but it exists encrypted
                has_user_api_key = True # Best guess: it's there.
                print(f"WARNING: User {user_id} has an encrypted API key, but APP_SECRET_KEY is not set. Cannot fully verify for has_user_api_key flag.")

        valid_base_url_obj: Optional[HttpUrl] = None
        if selected_base_url_str:
            try:
                valid_base_url_obj = HttpUrl(selected_base_url_str)
            except ValueError:
                print(f"Warning: User {user_id} has an invalid base URL stored: {selected_base_url_str}")
                pass # Keep it None

        return models.UserLLMSettingsResponse(
            selected_llm_provider_id=selected_provider_id,
            selected_llm_model_id=selected_model_id,
            has_user_api_key=has_user_api_key,
            selected_llm_base_url=valid_base_url_obj
        )
    except sqlite3.Error as db_err:
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error retrieving LLM settings.")
    except Exception as e:
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Unexpected server error retrieving LLM settings.")
    finally:
        if conn: conn.close()


@app.get("/logout", tags=["Authentication"])
async def logout_route(
    request: Request, # To access CsrfProtect methods if needed, though not strictly for validation here
    response: FastAPIResponse, # To set/unset cookies
    session_token_value: Optional[str] = Depends(auth.cookie_scheme) # Gets session token from cookie
):
    # No CSRF validation needed for logout itself usually, as it's a benign action.
    # The main goal is to invalidate the session.
    print(f"---- SERVER LOG: GET /logout - User initiated logout. Session token from cookie: {'present' if session_token_value else 'missing'}")
    await auth.logout_user(response, session_token_value) # Invalidates session token and unsets session cookie
    
    # Unset the CSRF token cookie as well, as the session it was tied to is now invalid.
    # This requires a CsrfProtect instance. We can create one on the fly or inject it.
    # Since CSRF is app-wide, it might be cleaner if CsrfProtect had a static-like method or if we inject.
    # For simplicity here, instantiate, but in a larger app, manage dependencies carefully.
    # However, `fastapi-csrf-protect` sets cookies on responses where tokens are generated or validated.
    # The `logout_user` handles the session cookie. For the CSRF cookie, we explicitly unset.
    
    # Get a CsrfProtect instance - if we are not in a Depends context, we need to create it.
    # This is a bit of a workaround. Ideally, a CsrfProtect instance would be available.
    # We can try to get it from the app state if it was stored, or construct as needed.
    # For now, assuming we can construct one to call unset_csrf_cookie
    # csrf_protect_instance = CsrfProtect() # This would use default config if not loaded.
    # Instead of new instance, if we need to ensure it uses loaded config, we might need to pass it.
    # However, unsetting doesn't strictly need the secret key.

    # The CSRF cookie should be unset. `fastapi-csrf-protect` might do this if `validate_csrf` is called
    # and it decides to rotate/clear. For an explicit logout, better to be sure.
    # Let's assume csrf_protect.unset_csrf_cookie can be called on a response.
    # We might need to pass the `CsrfProtect` dependency.
    # Let's add it as a dependency to be safe.
    
    # Re-thinking: We don't generate new tokens or validate on logout usually.
    # We just want to clear the cookie.
    try:
        _csrf_protect_for_logout = CsrfProtect() # Standard instance
        _csrf_protect_for_logout.load_config(get_csrf_config) # Ensure it has the config
        _csrf_protect_for_logout.unset_csrf_cookie(response=response)
        print("---- SERVER LOG: GET /logout - CSRF token cookie explicitly unset.")
    except Exception as e_csrf_unset:
        print(f"---- SERVER LOG: GET /logout - Minor error unsetting CSRF cookie: {e_csrf_unset}")
        # Continue with redirect even if CSRF cookie unsetting had an issue.

    redirect_url = request.url_for('get_login_page_route')
    return RedirectResponse(url=str(redirect_url), status_code=status.HTTP_302_FOUND)


@app.get("/api/me", response_model=models.UserResponseModel, tags=["Users"])
async def get_current_user_details(
    user: Dict[str, Any] = Depends(auth.get_current_active_user) # Bearer token auth
):
    # GET request, CSRF not primary concern. Auth handled by Bearer token.
    if not user: # Should be caught by Depends
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated.")
    
    # Ensure all required fields are present in the user dict from the token/DB
    required_keys = ["id", "name", "email"]
    if not all(key in user for key in required_keys):
        print(f"ERROR: User object for /api/me is missing required keys. User: {user}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="User data is incomplete on server.")
        
    return models.UserResponseModel(id=user["id"], name=user["name"], email=user["email"])


@app.get("/api/sessions/{session_id}/code-results", response_model=List[Dict[str, Any]], tags=["Code Execution"])
async def get_session_code_execution_results(
    session_id: str = FastApiPath(..., description="The ID of the session to fetch code results for."),
    user: Dict[str, Any] = Depends(auth.get_current_active_user)
) -> List[Dict[str, Any]]:
    if not user:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")
    
    user_id = user.get('id')
    if not user_id:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="User ID missing in token/session.")

    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute(
            "SELECT 1 FROM session_participants WHERE session_id = ? AND user_id = ?", (session_id, user_id)
        )
        if not cursor.fetchone():
            cursor.execute("SELECT 1 FROM sessions WHERE id = ? AND is_active = 1", (session_id,))
            if not cursor.fetchone():
                raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Chat session not found or is inactive.")
            else:
                raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied to this session's code results.")
        
        results = database.get_code_execution_results(session_id)
        return results
        
    except HTTPException as http_exc:
        raise http_exc
    except Exception as e:
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred while fetching code results.")
    finally:
        if conn:
            conn.close()


@app.get("/api/sessions", response_model=List[models.SessionResponseModel], tags=["Sessions"])
async def get_user_sessions(
    user: Dict[str, Any] = Depends(auth.get_current_active_user) # Bearer token auth
) -> List[models.SessionResponseModel]: # Explicit return type annotation
    # GET request, CSRF not primary concern as it's a read operation
    if not user: # Should be caught by Depends, but as a safeguard
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")
    
    user_id = user.get('id')
    if not user_id:
        # This case should ideally not happen if auth.get_current_active_user guarantees 'id'
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="User ID missing in token/session.")

    sessions_list: List[models.SessionResponseModel] = []
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        # Fetches sessions where the user is a participant and session is active
        # The SQL query already aliases s.last_accessed_at AS last_active
        cursor.execute(
            """SELECT s.id, s.name, s.created_at, s.last_accessed_at AS last_active, s.host_user_id
               FROM sessions s
               JOIN session_participants sp ON s.id = sp.session_id
               WHERE sp.user_id = ? AND s.is_active = 1
               ORDER BY s.last_accessed_at DESC, s.created_at DESC""",
            (user_id,)
        )
        rows = cursor.fetchall()
        
        for row_data in rows:
            session_data_from_db = dict(row_data)
            
            # Ensure datetime fields from DB (if they are datetime objects) are converted to ISO strings
            # The model SessionResponseModel expects Optional[str] for these.
            if session_data_from_db.get("created_at") and isinstance(session_data_from_db["created_at"], (datetime.datetime, datetime.date)):
                session_data_from_db["created_at"] = session_data_from_db["created_at"].isoformat()
            
            if session_data_from_db.get("last_active") and isinstance(session_data_from_db["last_active"], (datetime.datetime, datetime.date)):
                session_data_from_db["last_active"] = session_data_from_db["last_active"].isoformat()

            # Pydantic will validate against SessionResponseModel fields:
            # id, name, created_at, last_active, host_user_id
            sessions_list.append(models.SessionResponseModel(**session_data_from_db))
            
        return sessions_list
    except sqlite3.Error as db_err:
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error while fetching sessions.")
    except Exception as e:
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred while fetching sessions.")
    finally:
        if conn:
            conn.close()

@app.get("/api/sessions/{session_id}/messages", response_model=List[models.MessageItem], tags=["Messages"])
async def get_chat_messages_for_session(
    session_id: str = FastApiPath(..., description="The ID of the session to fetch messages for."),
    user: Dict[str, Any] = Depends(auth.get_current_active_user) # Bearer token auth
) -> List[models.MessageItem]: # Explicit return type annotation
    # GET request, CSRF not primary concern
    if not user: # Should be caught by Depends
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")
    
    user_id = user.get('id')
    if not user_id:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="User ID missing in token/session.")

    messages_list: List[models.MessageItem] = []
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        
        # Verify user has access to this session
        cursor.execute(
            "SELECT 1 FROM session_participants WHERE session_id = ? AND user_id = ?", (session_id, user_id)
        )
        if not cursor.fetchone():
            # If user is not a participant, check if the session itself is valid before denying access
            cursor.execute("SELECT 1 FROM sessions WHERE id = ? AND is_active = 1", (session_id,))
            if not cursor.fetchone():
                raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Chat session not found or is inactive.")
            else: # Session exists and is active, but user is not a participant
                raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied to this chat session's messages.")
        
        # Session is valid and user is a participant, fetch messages
        # The query already includes model_provider_id and model_id
        cursor.execute(
            """SELECT id, session_id, user_id, sender_name, sender_type, content, 
                      client_id_temp, thinking_content, timestamp, turn_id, model_provider_id, model_id
               FROM chat_messages 
               WHERE session_id = ? 
               ORDER BY timestamp ASC, id ASC""", # Added id for tie-breaking if timestamps are identical
            (session_id,)
        )
        rows = cursor.fetchall()
        
        for row_data in rows:
            message_data_from_db = dict(row_data)
            
            # Ensure timestamp is ISO format string as expected by MessageItem model
            if message_data_from_db.get("timestamp") and isinstance(message_data_from_db["timestamp"], (datetime.datetime, datetime.date)):
                message_data_from_db["timestamp"] = message_data_from_db["timestamp"].isoformat()
            
            # Pydantic will validate against MessageItem fields
            messages_list.append(models.MessageItem(**message_data_from_db))
            
        return messages_list
    except sqlite3.Error as db_err:
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error while fetching messages.")
    except HTTPException as http_exc: # Re-raise if it's already an HTTPException (like 403/404)
        raise http_exc
    except Exception as e:
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An unexpected server error occurred while fetching messages.")
    finally:
        if conn:
            conn.close()


async def handle_chat_message(
    chain: Any, 
    memory: Any, 
    websocket: WebSocket, 
    client_js_id: str,
    current_user: Dict[str, Any], 
    session_id: str, 
    user_input: str, 
    turn_id: int,
    llm_provider_id_used: Optional[str], # For logging
    llm_model_id_used: Optional[str]     # For logging
):
    user_name = current_user.get('name', 'Anonymous User') # Fallback name
    user_db_id = current_user['id']
    full_response = ""
    thinking_content: Optional[str] = None # Placeholder for future use if 'think' mode provides preliminary thoughts
    stream_id = f"{client_js_id}_{turn_id}" 
    stop_event: Optional[asyncio.Event] = None
    
    # Store user message in DB
    db_conn_user_msg = None
    try:
        db_conn_user_msg = database.get_db_connection()
        db_cursor_user_msg = db_conn_user_msg.cursor()
        db_cursor_user_msg.execute(
            """INSERT INTO chat_messages (session_id, user_id, sender_name, sender_type, content, 
                                           client_id_temp, turn_id, timestamp, 
                                           model_provider_id, model_id) 
               VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now', 'utc'), ?, ?)""",
            (session_id, user_db_id, user_name, 'user', user_input, client_js_id, turn_id, None, None) # LLM info not applicable to user msg
        )
        db_conn_user_msg.commit()
    except Exception as db_err_user:
        traceback.print_exc()
        print(f"ERROR saving user message to DB for session {session_id}: {db_err_user}")
        if db_conn_user_msg: db_conn_user_msg.rollback()
        # Do not stop processing if DB save fails, but log it.
    finally:
        if db_conn_user_msg: db_conn_user_msg.close()

    # Process with LLM
    try:
        stop_event = await state.register_ai_stream(stream_id) # For handling 'stop generation'
        if chain is None:
            error_msg_no_chain = "<ERROR>LLM Error: Chat model is not available. Please check server configuration or your LLM settings."
            if websocket.client_state == WebSocketState.CONNECTED:
                await websocket.send_text(error_msg_no_chain)
                await websocket.send_text("<EOS>") # End of Stream signal
            return 

        async for chunk_data in chain.astream({"input": user_input}):
            
            # --- START: Added logging for debugging ---
            print(f"--- LLM RAW CHUNK (Turn ID: {turn_id}) ---\n{chunk_data}\n---------------------------------")
            # --- END: Added logging for debugging ---

            if stop_event and stop_event.is_set(): # Check if stop signal received
                print(f"AI stream {stream_id} stopped by client signal.")
                break 
            
            chunk_str = ""
            if isinstance(chunk_data, dict): 
                # Adapt based on actual chain output structure (e.g., LangChain LCEL)
                # Common for LCEL chains that output AIMessageChunk or similar
                if hasattr(chunk_data, 'content'): # Langchain AIMessageChunk
                    chunk_str = chunk_data.content
                elif "answer" in chunk_data: # Older LangChain style
                    chunk_str = chunk_data.get("answer", "")
                else: # Try to find content in a common key
                    content_keys = ['content', 'text', 'chunk']
                    for key in content_keys:
                        if key in chunk_data and isinstance(chunk_data[key], str):
                            chunk_str = chunk_data[key]
                            break
                    if not chunk_str:
                        print(f"DEBUG: LLM chunk_data (dict) received with unexpected structure: {chunk_data}")

            elif hasattr(chunk_data, 'content') and isinstance(chunk_data.content, str): # For AIMessageChunk like objects
                chunk_str = chunk_data.content
            else: 
                chunk_str = str(chunk_data) # Fallback
            
            if websocket.client_state != WebSocketState.CONNECTED:
                print(f"WebSocket for stream {stream_id} disconnected during AI response.")
                return 
            
            if chunk_str: # Only send if there's content
                await websocket.send_text(chunk_str)
                full_response += chunk_str
        
        # After loop finishes (either by completing or by stop_event)
        if websocket.client_state == WebSocketState.CONNECTED:
            if stop_event and stop_event.is_set():
                await websocket.send_text("<EOS_STOPPED>") # Signal client generation was stopped
            else:
                await websocket.send_text("<EOS>") # Normal End of Stream signal

        if memory: 
            try:
                memory.save_context({"input": user_input}, {"output": full_response})
                if hasattr(state, 'save_memory_state_to_db'): 
                    state.save_memory_state_to_db(session_id, memory) 
            except Exception as save_mem_err: 
                traceback.print_exc()
                print(f"Error saving memory state for session {session_id}: {save_mem_err}")
        
        # Store AI response in DB
        db_conn_ai_msg = None
        try:
            db_conn_ai_msg = database.get_db_connection()
            db_cursor_ai_msg = db_conn_ai_msg.cursor()
            db_cursor_ai_msg.execute(
                """INSERT INTO chat_messages (session_id, user_id, sender_name, sender_type, content, 
                                              thinking_content, client_id_temp, turn_id, timestamp,
                                              model_provider_id, model_id) 
                   VALUES (?, ?, ?, ?, ?, ?, ?, ?, datetime('now', 'utc'), ?, ?)""", 
                (session_id, None, "AI", 'ai', full_response, thinking_content, client_js_id, turn_id, llm_provider_id_used, llm_model_id_used)
            )
            db_conn_ai_msg.commit()
        except Exception as db_err_ai:
            traceback.print_exc()
            print(f"ERROR saving AI message to DB for session {session_id}: {db_err_ai}")
            if db_conn_ai_msg: db_conn_ai_msg.rollback()
        finally:
            if db_conn_ai_msg: db_conn_ai_msg.close()

    except Exception as chain_exc:
        error_msg = f"<ERROR>LLM Error: Processing your message failed. Details: {str(chain_exc)}"
        traceback.print_exc()
        print(f"Error during LLM chain processing for session {session_id}: {chain_exc}")
        if websocket.client_state == WebSocketState.CONNECTED:
            try:
                await websocket.send_text(error_msg)
                await websocket.send_text("<EOS>") 
            except Exception as send_err:
                print(f"Error sending LLM processing error to client {client_js_id}: {send_err}")
    finally:
        if stream_id and stop_event: 
            await state.unregister_ai_stream(stream_id)

@app.websocket("/ws/{session_id_ws}/{client_js_id}")
async def websocket_endpoint(
    websocket: WebSocket,
    session_id_ws: str = FastApiPath(..., title="Session ID", description="The ID of the chat session."),
    client_js_id: str = FastApiPath(..., title="Client JS ID", description="A unique ID generated by the client-side JavaScript.")
):
    print(f"---- WS LOG: Attempting WebSocket connection for session_id_ws: {session_id_ws}, client_js_id: {client_js_id} ----")
    print(f"---- WS LOG: WebSocket request headers: {websocket.headers}")
    print(f"---- WS LOG: WebSocket request cookies: {websocket.cookies}")

    session_token_from_cookie = websocket.cookies.get(auth.SESSION_COOKIE_NAME)
    current_ws_user: Optional[Dict[str, Any]] = None

    if not session_token_from_cookie:
        print(f"---- WS ERROR: No session token found in cookies. Cookie name expected: '{auth.SESSION_COOKIE_NAME}'. Cannot authenticate WebSocket.")
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Authentication required - no session token.")
        return
    
    print(f"---- WS LOG: Session token found in cookie: '{session_token_from_cookie[:10]}...' (first 10 chars)")

    try:
        # *** CORRECTED FUNCTION NAME HERE ***
        current_ws_user = await auth.get_user_by_session_token_internal(session_token_from_cookie)
    except Exception as e_auth_token:
        print(f"---- WS ERROR: Exception during auth.get_user_by_session_token_internal for token '{session_token_from_cookie[:10]}...': {e_auth_token}")
        traceback.print_exc()
        await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Server error during token validation.")
        return

    if not current_ws_user:
        print(f"---- WS ERROR: WebSocket authentication failed for session {session_id_ws}, client {client_js_id}. Token validation returned no user.")
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Authentication failed - invalid session token.")
        return

    user_id = current_ws_user.get('id')
    user_email = current_ws_user.get('email', 'N/A') # Get email for logging
    if not user_id:
        print(f"---- WS ERROR: Authenticated user object for email '{user_email}' is missing 'id'. User object: {current_ws_user}")
        await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Server error - user data incomplete.")
        return
        
    print(f"---- WS LOG: User successfully authenticated via session token. User ID: {user_id}, Email: {user_email}")
    print(f"---- WS LOG: Verifying session access for user {user_id} on session {session_id_ws}...")

    conn_verify = None
    try:
        conn_verify = database.get_db_connection()
        cursor_verify = conn_verify.cursor()
        
        cursor_verify.execute("SELECT id, name, is_active FROM sessions WHERE id = ?", (session_id_ws,))
        session_details = cursor_verify.fetchone()

        if not session_details:
            print(f"---- WS ERROR: Session {session_id_ws} not found in database for user {user_id}.")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Session not found.")
            return
        
        if not session_details["is_active"]:
            print(f"---- WS ERROR: Session {session_id_ws} is inactive for user {user_id}. Session name: {session_details['name']}")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Session is inactive.")
            return
        
        print(f"---- WS LOG: Session {session_id_ws} (Name: {session_details['name']}) found and is active.")

        cursor_verify.execute("SELECT 1 FROM session_participants WHERE session_id = ? AND user_id = ?", (session_id_ws, user_id))
        if not cursor_verify.fetchone():
            print(f"---- WS ERROR: User {user_id} ({user_email}) is not a participant of session {session_id_ws}.")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Access denied to session.")
            return
        print(f"---- WS LOG: User {user_id} ({user_email}) is a participant of session {session_id_ws}. Access granted.")

    except sqlite3.Error as e_db_verify: # Catch specific sqlite3 errors
        print(f"---- WS ERROR: Database error during session verification for user {user_id}, session {session_id_ws}: {e_db_verify}")
        traceback.print_exc()
        await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Server error during session verification (DB).")
        return
    except Exception as e_verify:
        print(f"---- WS ERROR: Unexpected error during session verification for user {user_id}, session {session_id_ws}: {e_verify}")
        traceback.print_exc()
        await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Server error during session verification (General).")
        return
    finally:
        if conn_verify: conn_verify.close()

    try:
        await websocket.accept()
        print(f"---- WS SUCCESS: WebSocket connection accepted for user {user_id} ({user_email}), session {session_id_ws}, client {client_js_id}.")
    except Exception as accept_err:
        print(f"---- WS CRITICAL ERROR: Failed to accept WebSocket connection for user {user_id}, session {session_id_ws}: {accept_err}")
        traceback.print_exc()
        return 

    llm_provider_id_for_session: Optional[str] = None
    llm_model_id_for_session: Optional[str] = None
    user_api_key_for_session: Optional[str] = None 
    user_base_url_for_session: Optional[str] = None
    
    db_conn_settings = None
    try:
        db_conn_settings = database.get_db_connection()
        cursor_settings = db_conn_settings.cursor()
        cursor_settings.execute(
            "SELECT selected_llm_provider_id, selected_llm_model_id, user_llm_api_key_encrypted, selected_llm_base_url FROM users WHERE id = ?",
            (user_id,)
        )
        user_llm_prefs = cursor_settings.fetchone()
        if user_llm_prefs:
            llm_provider_id_for_session = user_llm_prefs["selected_llm_provider_id"]
            llm_model_id_for_session = user_llm_prefs["selected_llm_model_id"]
            user_base_url_for_session = user_llm_prefs["selected_llm_base_url"] 
            encrypted_key = user_llm_prefs["user_llm_api_key_encrypted"]
            if encrypted_key and config.APP_SECRET_KEY:
                try:
                    user_api_key_for_session = encryption_utils.decrypt_data(encrypted_key)
                    if not user_api_key_for_session or not user_api_key_for_session.strip():
                        user_api_key_for_session = None 
                except Exception:
                    user_api_key_for_session = None
                    print(f"---- WS WARNING: User {user_id} - Failed to decrypt API key for session {session_id_ws}.")
            elif encrypted_key and not config.APP_SECRET_KEY:
                print(f"---- WS WARNING: User {user_id} - API key present but APP_SECRET_KEY not set, cannot decrypt for session {session_id_ws}.")

        if not llm_provider_id_for_session or not llm_model_id_for_session:
            print(f"---- WS INFO: User {user_id} has no LLM provider/model selected or incomplete. Using system defaults for session {session_id_ws}.")
            llm_provider_id_for_session = config.DEFAULT_LLM_PROVIDER_ID
            llm_model_id_for_session = config.DEFAULT_LLM_MODEL_ID
            if user_llm_prefs and llm_provider_id_for_session != user_llm_prefs["selected_llm_provider_id"]:
                user_api_key_for_session = None
                user_base_url_for_session = None
        print(f"---- WS LOG: LLM settings for session {session_id_ws} - Provider: '{llm_provider_id_for_session}', Model: '{llm_model_id_for_session}', HasUserAPIKey: {'Yes' if user_api_key_for_session else 'No'}, BaseURL: '{user_base_url_for_session if user_base_url_for_session else 'Default'}'")

    except Exception as e_settings:
        traceback.print_exc()
        print(f"---- WS ERROR: Error fetching LLM settings for user {user_id}, session {session_id_ws}: {e_settings}. Using system defaults.")
        llm_provider_id_for_session = config.DEFAULT_LLM_PROVIDER_ID
        llm_model_id_for_session = config.DEFAULT_LLM_MODEL_ID
        user_api_key_for_session = None 
        user_base_url_for_session = None 
    finally:
        if db_conn_settings: db_conn_settings.close()

    memory_for_session = state.get_memory_for_client(session_id_ws) 
    
    def load_memory_for_current_session_chain(_ignored_input_map=None):
        loaded_vars = memory_for_session.load_memory_variables({})
        return loaded_vars.get("history", [])

    chain_for_session: Optional[Any] = None 
    try:
        chain_for_session = llm.create_chain(
            provider_id=llm_provider_id_for_session,
            model_id=llm_model_id_for_session,
            memory_loader_func=load_memory_for_current_session_chain,
            api_key=user_api_key_for_session,
            base_url_override=user_base_url_for_session
        )
        if not chain_for_session:
            raise ValueError(f"LLM chain creation returned None for provider '{llm_provider_id_for_session}', model '{llm_model_id_for_session}'.")
        print(f"---- WS LOG: LLM chain successfully created for session {session_id_ws}.")
    except Exception as chain_init_error:
        traceback.print_exc()
        print(f"---- WS CRITICAL ERROR: Could not initialize LLM chain for session {session_id_ws}: {chain_init_error}")
        if websocket.client_state == WebSocketState.CONNECTED:
            try:
                await websocket.send_json({"type": "error", "payload": {"message": f"Server error: Could not initialize chat with the selected model configuration ({str(chain_init_error)})."}})
            except Exception: pass 
        if websocket.client_state != WebSocketState.CLOSED :
            await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="LLM initialization failed.")
        return 

    try:
        while True:
            if websocket.client_state != WebSocketState.CONNECTED:
                print(f"---- WS INFO: Client {client_js_id} for session {session_id_ws} disconnected pre-receive.")
                break

            received_data = await websocket.receive_text()
            try:
                message_data = json.loads(received_data)
                message_type = message_data.get("type")
                payload = message_data.get("payload")

                if message_type == "chat_message" and payload:
                    user_input = payload.get("user_input")
                    turn_id = payload.get("turn_id") 
                    if user_input is not None and turn_id is not None:
                        print(f"---- WS LOG: Received 'chat_message' from {user_id} for session {session_id_ws}, turn {turn_id}")
                        asyncio.create_task(
                            handle_chat_message( 
                                chain_for_session, memory_for_session, websocket, client_js_id, 
                                current_ws_user, session_id_ws, user_input, turn_id,
                                llm_provider_id_for_session, llm_model_id_for_session
                            )
                        )
                    else:
                        if websocket.client_state == WebSocketState.CONNECTED:
                            await websocket.send_text("<ERROR>Invalid chat_message payload: 'user_input' or 'turn_id' missing.<EOS>")
                
                elif message_type == "run_code" and payload and payload.get("code_block_id"):
                    language = payload.get("language")
                    code = payload.get("code")
                    code_block_id = payload.get("code_block_id")
                    if language and code is not None:
                        print(f"---- WS LOG: Received 'run_code' for block {code_block_id} ({language}) from {user_id}")
                        asyncio.create_task(docker_utils.run_code_in_docker_stream(websocket, client_js_id, code_block_id, language, code))
                    else:
                        if websocket.client_state == WebSocketState.CONNECTED:
                            await websocket.send_json({"type": "code_finished", "payload": {"code_block_id": code_block_id, "exit_code": -1, "error": "Invalid run_code payload: 'language' or 'code' missing."}})
                
                elif message_type == "save_code_result" and payload and payload.get("code_block_id"):
                    code_block_id = payload.get("code_block_id")
                    language = payload.get("language")
                    code_content = payload.get("code_content")
                    output_content = payload.get("output_content")
                    html_content = payload.get("html_content")
                    exit_code = payload.get("exit_code")
                    error_message = payload.get("error_message")
                    execution_status = payload.get("execution_status", "completed")
                    turn_id = payload.get("turn_id")
                    
                    database.save_code_execution_result(
                        session_id=session_id_ws,
                        code_block_id=code_block_id,
                        language=language,
                        code_content=code_content,
                        output_content=output_content,
                        html_content=html_content,
                        exit_code=exit_code,
                        error_message=error_message,
                        execution_status=execution_status,
                        turn_id=turn_id
                    )
                elif message_type == "stop_code" and payload and payload.get("code_block_id"):
                    code_block_id = payload.get("code_block_id")
                    print(f"---- WS LOG: Received 'stop_code' for block {code_block_id} from {user_id}")
                    asyncio.create_task(docker_utils.stop_docker_container(code_block_id))
                elif message_type == "delete_code_block" and payload and payload.get("code_block_id"):
                    session_id_from_payload = payload.get("session_id")
                    code_block_id = payload.get("code_block_id")
                    
                    if session_id_from_payload == session_id_ws:
                        print(f"---- WS LOG: Received 'delete_code_block' for block {code_block_id} from {user_id}")
                        database.delete_code_block_data(session_id_ws, code_block_id)
                    else:
                        print(f"---- WS WARNING: Ignoring 'delete_code_block' with mismatched session.")
                elif message_type == "save_code_content" and payload and payload.get("code_block_id"):
                    session_id_from_payload = payload.get("session_id")
                    code_block_id = payload.get("code_block_id")
                    language = payload.get("language")
                    code_content = payload.get("code_content")
                    
                    if session_id_from_payload == session_id_ws and code_content is not None:
                        print(f"---- WS LOG: Received 'save_code_content' for block {code_block_id} from {user_id}")
                        database.save_edited_code_content(session_id_ws, code_block_id, language, code_content)
                    else:
                        print(f"---- WS WARNING: Ignoring 'save_code_content' with mismatched session or missing content.")

                elif message_type == "stop_ai_stream" and payload:
                    stop_client_id = payload.get("client_id") 
                    stop_session_id = payload.get("session_id") 
                    stop_turn_id = payload.get("turn_id")
                    if stop_client_id == client_js_id and stop_session_id == session_id_ws and stop_turn_id is not None:
                        stream_id_to_stop = f"{stop_client_id}_{stop_turn_id}"
                        print(f"---- WS LOG: Received 'stop_ai_stream' for stream_id: {stream_id_to_stop} from {user_id}")
                        await state.signal_stop_ai_stream(stream_id_to_stop)
                    else:
                        print(f"---- WS WARNING: Ignoring 'stop_ai_stream' with mismatched identifiers. Client: {stop_client_id}/{client_js_id}, Session: {stop_session_id}/{session_id_ws}")

                elif message_type == "code_input" and payload and payload.get("code_block_id"):
                    code_block_id = payload.get("code_block_id")
                    user_input_text = payload.get("input", "")
                    print(f"---- WS LOG: Received 'code_input' for block {code_block_id} from {user_id}: '{user_input_text.strip()}'")
                    asyncio.create_task(docker_utils.send_input_to_container(code_block_id, user_input_text))

                else: 
                    if websocket.client_state == WebSocketState.CONNECTED:
                        await websocket.send_text(f"<ERROR>Unknown command type received: {message_type}<EOS>")
            
            except json.JSONDecodeError:
                if websocket.client_state == WebSocketState.CONNECTED:
                    await websocket.send_text("<ERROR>Invalid message format. Expected JSON.<EOS>")
            except Exception as handler_exc: 
                traceback.print_exc()
                print(f"---- WS ERROR: Error handling received data for session {session_id_ws}, client {client_js_id}: {handler_exc}")
                if websocket.client_state == WebSocketState.CONNECTED:
                    try:
                        await websocket.send_text(f"<ERROR>Server error processing your request: {str(handler_exc)}<EOS>")
                    except Exception: pass

    except WebSocketDisconnect:
        print(f"---- WS INFO: Client {client_js_id} (User {user_id}, {user_email}) disconnected from session {session_id_ws}.")
    except Exception as e_ws_loop: 
        traceback.print_exc()
        print(f"---- WS CRITICAL ERROR: Unexpected error in main WebSocket loop for session {session_id_ws}, client {client_js_id}: {e_ws_loop}")
        if websocket.client_state == WebSocketState.CONNECTED:
            try: await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Unexpected server error in WebSocket.")
            except Exception: pass 
    finally:
        print(f"---- WS INFO: Cleaning up resources for client {client_js_id}, session {session_id_ws}.")
        # Ensure docker_utils.cleanup_client_containers is an async function if awaited
        await docker_utils.cleanup_client_containers(client_js_id) 
        
        if websocket.client_state == WebSocketState.CONNECTED:
            try: 
                print(f"---- WS INFO: Explicitly closing WebSocket connection for client {client_js_id}, session {session_id_ws}.")
                await websocket.close(code=status.WS_1000_NORMAL_CLOSURE)
            except Exception: pass

@app.delete("/api/sessions/{session_id}", status_code=status.HTTP_204_NO_CONTENT, tags=["Sessions"])
async def delete_session_route(
    request: Request, # For CSRF validation
    session_id: str = FastApiPath(..., description="The ID of the session to delete."),
    user: Dict[str, Any] = Depends(auth.get_current_active_user), # Ensures user is authenticated
    csrf_protect: CsrfProtect = Depends() # CSRF protection dependency
):
    """
    Deletes a specific chat session (marks it as inactive).
    Requires the user to be authenticated and provide a valid CSRF token.
    """
    print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - Attempt by user ID: {user.get('id')} ----")
    
    # Perform CSRF validation. This is crucial for state-changing operations.
    await csrf_protect.validate_csrf(request)
    print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - CSRF validation PASSED ----")

    user_id = user.get('id') # Get the ID of the authenticated user
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()

        print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - Fetching session data from DB.")
        # Fetch necessary session details, ensuring it's active
        cursor.execute("SELECT host_user_id, name FROM sessions WHERE id = ? AND is_active = 1", (session_id,))
        session_data = cursor.fetchone()

        if not session_data:
            # If not found active, check if it exists at all or was already inactive
            cursor.execute("SELECT id, name, is_active FROM sessions WHERE id = ?", (session_id,))
            already_exists_data = cursor.fetchone()
            if not already_exists_data:
                print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - Session ID truly not found in database.")
                raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Session not found.")
            else:
                # Session exists but was already inactive. Consider this a "successful" delete.
                # Use dictionary-style access for sqlite3.Row
                name_val = already_exists_data['name'] if 'name' in already_exists_data.keys() else 'N/A'
                is_active_val = already_exists_data['is_active'] if 'is_active' in already_exists_data.keys() else 'N/A'
                print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - Session found but is already inactive. Name: {name_val}, Active: {is_active_val}")
                conn.commit() # Commit if any prior transaction was started, though unlikely here
                return # Return 204 as it's effectively "deleted" or already in that state
        
        print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - Session data fetched: Type={type(session_data)}, Keys={list(session_data.keys()) if hasattr(session_data, 'keys') else 'N/A (not dict-like)'}")

        # Use dictionary-style access for sqlite3.Row
        # Ensure 'name' is in keys before accessing, or handle potential None if name can be NULL
        session_name_from_db = session_data["name"] if "name" in session_data.keys() and session_data["name"] is not None else None
        # session_host_id = session_data["host_user_id"] # Access directly if needed for permission check

        # Example permission check (if you want to re-enable it):
        # if session_host_id != user_id:
        #     print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - User {user_id} is not host ({session_host_id}). Forbidden.")
        #     raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="You do not have permission to delete this session.")

        current_time_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        
        deleted_session_name = f"Deleted: {session_name_from_db if session_name_from_db else session_id[:8]} ({current_time_iso})"
        
        print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - Updating session to inactive. New name: '{deleted_session_name}'")
        cursor.execute(
            "UPDATE sessions SET is_active = 0, name = ?, last_accessed_at = ? WHERE id = ?",
            (deleted_session_name, current_time_iso, session_id)
        )
        
        if cursor.rowcount == 0:
            # This case implies the session was active when fetched but couldn't be updated (e.g., race condition or DB issue).
            print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - Session was found active but UPDATE operation affected 0 rows. This is unexpected.")
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to update session state during deletion.")

        conn.commit()
        print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - Session marked as inactive by user ID: {user_id}.")

    except HTTPException as http_exc:
        if conn: conn.rollback()
        raise http_exc
    except sqlite3.Error as e_db:
        if conn: conn.rollback()
        print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - SQLite Error ----")
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Database error processing delete request: {e_db}")
    except Exception as e_general: # This will catch other errors like KeyError or IndexError
        if conn: conn.rollback()
        print(f"---- SERVER LOG: DELETE /api/sessions/{session_id} - Unexpected General Error ----")
        traceback.print_exc() 
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"An unexpected server error occurred: {e_general}")
    finally:
        if conn:
            conn.close()

# --- Application Startup and Static Files ---

@app.on_event("startup")
async def startup_event():
    print("Application startup: Initializing database...")
    # Ensure the database directory exists
    db_parent_dir = config.DATABASE_PATH.parent
    if not db_parent_dir.exists():
        db_parent_dir.mkdir(parents=True, exist_ok=True)
        print(f"Created database directory: {db_parent_dir}")
    database.init_db() # Initializes tables if they don't exist
    print("Database initialization check complete.")

    # Docker client check (optional, for code execution feature)
    docker_client = None
    try:
        docker_client = docker_utils.get_docker_client() 
        if docker_client is None:
            print("WARNING: Could not get Docker client via get_docker_client(). Code execution features might be disabled or limited.")
        else:
            # Perform a quick check like docker_client.ping()
            if docker_client.ping():
                print("Docker client confirmed available and responsive at startup.")
            else:
                print("WARNING: Docker client obtained, but ping failed. Docker daemon might not be running correctly. Code execution may fail.")
    except Exception as e_docker:
        print(f"WARNING: Could not connect to Docker daemon at startup: {e_docker}")
        print("Code execution via Docker will be unavailable if Docker is not running or misconfigured.")

    # Default LLM check (optional, for system health check)
    try:
        if config.DEFAULT_LLM_PROVIDER_ID and config.DEFAULT_LLM_MODEL_ID:
            print(f"Attempting to initialize default LLM: Provider='{config.DEFAULT_LLM_PROVIDER_ID}', Model='{config.DEFAULT_LLM_MODEL_ID}'")
            # This just gets the model class/config, doesn't make a call unless get_model itself does.
            # For a true health check, you might try a very short, non-streaming test call if feasible.
            default_model_instance = llm.get_model( 
                provider_id=config.DEFAULT_LLM_PROVIDER_ID,
                model_id=config.DEFAULT_LLM_MODEL_ID
                # No API key or base URL here, assumes system config if needed by default model
            )
            if default_model_instance:
                print("Default LLM model configuration seems accessible at startup.")
                # To test further, you might try creating a chain:
                # llm.create_chain(config.DEFAULT_LLM_PROVIDER_ID, config.DEFAULT_LLM_MODEL_ID, memory_loader_func=lambda: [])
                # print("Default LLM chain creation test successful.")
            else:
                print(f"CRITICAL WARNING: Could not get default LLM model instance (Provider: {config.DEFAULT_LLM_PROVIDER_ID}, Model: {config.DEFAULT_LLM_MODEL_ID}). Check LLM config and server environment.")
        else:
            print("INFO: No default LLM provider/model ID configured for startup check.")
    except Exception as e_llm_startup:
        print(f"CRITICAL ERROR during startup default LLM check: {e_llm_startup}")
        traceback.print_exc()


# Static file mounting
# Ensure config.STATIC_DIR is an absolute path or correctly relative to the app's root.
if not isinstance(config.STATIC_DIR, Path) or not config.STATIC_DIR.is_dir():
    # Try to resolve if it's a string relative to the current file's directory
    current_file_dir = Path(__file__).parent
    potential_static_dir = (current_file_dir / str(config.STATIC_DIR)).resolve()
    if potential_static_dir.is_dir():
        # Correct config.STATIC_DIR to be the resolved Path object
        # This assumes config.py might define STATIC_DIR as a relative string.
        # It's better if config.py defines it as an absolute Path.
        print(f"Warning: config.STATIC_DIR was not a valid Path object. Resolved '{config.STATIC_DIR}' to '{potential_static_dir}'. Consider defining STATIC_DIR as a Path in config.py.")
        # config.STATIC_DIR = potential_static_dir # This would modify config module, be careful.
        # Better to use the resolved path directly for mounting.
        _resolved_static_dir = potential_static_dir
    else:
        print(f"CRITICAL ERROR: Base static directory invalid or not found: '{config.STATIC_DIR}' (also checked '{potential_static_dir}'). Application may not serve frontend assets correctly.")
        # sys.exit(1) # Exiting might be too drastic if other parts can run.
        _resolved_static_dir = None # Signal that static serving might fail
else:
    _resolved_static_dir = config.STATIC_DIR


if _resolved_static_dir:
    dist_dir = _resolved_static_dir / "dist"
    if not dist_dir.is_dir():
        print(f"WARNING: Bundled assets directory not found: '{dist_dir}'. Ensure frontend assets are built (e.g., 'npm run build' or similar) and placed in the 'dist' subdirectory of your static path.")
        # Frontend might not work correctly.
    else:
        try:
            app.mount("/dist", StaticFiles(directory=dist_dir, html=False), name="dist_assets") # html=False for /dist unless it serves an index.html
            print(f"Mounted bundled assets from '{dist_dir}' at '/dist'")
        except Exception as e_mount_dist:
            print(f"ERROR mounting /dist static files from '{dist_dir}': {e_mount_dist}")

    # Mount the root static directory itself for files like login.html, _sidebar.html, etc.
    # This should come AFTER more specific mounts if there are overlaps (though /static and /dist are usually distinct).
    try:
        # If login.html, etc., are directly in STATIC_DIR and not served by specific routes.
        # However, we are serving login.html, etc., via specific routes now to inject CSRF.
        # So, this mount is for other assets like CSS (if not in /dist), JS helpers (app-ui.js), images.
        app.mount("/static", StaticFiles(directory=_resolved_static_dir, html=True), name="static_general") # html=True if it can serve index.html from subdirs
        print(f"Mounted general static files from '{_resolved_static_dir}' at '/static'")
    except Exception as e_mount_static:
        print(f"ERROR mounting /static general files from '{_resolved_static_dir}': {e_mount_static}")
else:
    print("CRITICAL: Static directory not resolved. Static file serving will likely fail.")


# Print registered routes (useful for debugging, should be near the end)
if config.DEBUG_MODE: # Only print in debug mode
    print("\n---- FastAPI Registered Routes (End of Module Definition) ----")
    for route_item in app.routes:
        if hasattr(route_item, "path"):
            methods_str = ", ".join(sorted(list(getattr(route_item, 'methods', {})))) or ( "WS" if isinstance(route_item, WebSocket) else "N/A")
            route_name = getattr(route_item, 'name', 'N/A')
            print(f"  Path: {route_item.path}, Name: {route_name}, Methods: {{{methods_str}}}")
    print("-------------------------------\n")

=== app/models.py ===
from pydantic import BaseModel, Field, EmailStr, StringConstraints, HttpUrl
from pydantic_settings import BaseSettings
from typing import Optional, List, Dict, Any, Annotated

class LLMAvailableModel(BaseModel):
    model_id: str
    display_name: str
    context_window: Optional[int] = None

class LLMProviderDetail(BaseModel):
    id: str
    display_name: str
    type: str
    is_system_configured: bool
    needs_api_key_from_user: bool
    can_accept_user_api_key: bool
    can_accept_user_base_url: bool
    available_models: List[LLMAvailableModel]

class UserLLMSettingsResponse(BaseModel):
    selected_llm_provider_id: Optional[str] = None
    selected_llm_model_id: Optional[str] = None
    has_user_api_key: bool = False
    selected_llm_base_url: Optional[HttpUrl] = None

class UserLLMSettingsUpdateRequest(BaseModel):
    selected_llm_provider_id: Optional[str] = Field(None, description="ID of the selected LLM provider (e.g., 'ollama_local'). Use null to clear.")
    selected_llm_model_id: Optional[str] = Field(None, description="ID of the selected model (e.g., 'qwen2:7b-instruct-q4_K_M'). Use null to clear if provider allows.")
    user_llm_api_key: Optional[str] = Field(None, description="User-provided API key. Will be encrypted. Send empty string or null to clear.")
    selected_llm_base_url: Optional[HttpUrl] = Field(None, description="User-defined base URL. Send empty string or null to clear.")

class Token(BaseModel):
    access_token: str
    token_type: str
    user_id: Optional[int] = None
    user_name: Optional[str] = None
    user_email: Optional[EmailStr] = None

class UserResponseModel(BaseModel):
    id: int
    name: str
    email: EmailStr

class EmailCheckRequest(BaseModel):
    email: EmailStr

class EmailCheckResponse(BaseModel):
    exists: bool
    user_name: Optional[str] = None

class RegistrationRequest(BaseModel):
    email: EmailStr
    name: Annotated[str, StringConstraints(strip_whitespace=True, min_length=1, max_length=100)]

class RegistrationResponse(BaseModel):
    message: str

class ForgotPasswordRequest(BaseModel):
    email: EmailStr

class ForgotPasswordResponse(BaseModel):
    message: str

class UpdateNameRequest(BaseModel):
    new_name: Annotated[str, StringConstraints(strip_whitespace=True, min_length=1, max_length=100)]
    current_password: str = Field(..., min_length=1)

class UpdateNameResponse(BaseModel):
    message: str
    new_name: str

class RegeneratePasswordRequest(BaseModel):
    current_password: str = Field(..., min_length=1, description="The user's current password for verification.")

class RegeneratePasswordResponse(BaseModel):
    message: str

class UpdateEmailRequest(BaseModel):
    new_email: EmailStr
    current_password: str = Field(..., min_length=1, description="The user's current password for verification.")

class UpdateEmailResponse(BaseModel):
    message: str
    new_email: EmailStr

class SessionUpdateRequest(BaseModel):
    name: Annotated[str, StringConstraints(strip_whitespace=True, min_length=1, max_length=100)]

class SessionResponseModel(BaseModel):
    id: str
    name: Optional[str] = None
    created_at: Optional[str] = None
    last_active: Optional[str] = None
    host_user_id: Optional[int] = None

class SessionListContainerResponse(BaseModel):
    sessions: List[SessionResponseModel]

class MessageItem(BaseModel):
    id: int
    session_id: str
    user_id: Optional[int] = None
    sender_name: Optional[str] = None
    sender_type: str
    content: str
    client_id_temp: Optional[str] = None
    thinking_content: Optional[str] = None
    timestamp: str
    turn_id: Optional[int] = None
    model_provider_id: Optional[str] = None
    model_id: Optional[str] = None

class MessageListContainerResponse(BaseModel):
    messages: List[MessageItem]

=== app/state.py ===
# app/state.py

import asyncio
import json
import sqlite3
import datetime
from langchain.memory import ConversationBufferMemory # Ensure this import is correct for your LangChain version
from langchain_core.messages import messages_from_dict, messages_to_dict
from typing import Dict, Any, Optional
from . import database
import traceback # For detailed error logging

# In-memory cache for client-specific conversation memory
client_memory: Dict[str, ConversationBufferMemory] = {}

# For managing Docker code execution containers (if still used, otherwise can be removed if Docker utils are separate)
running_containers: Dict[str, Dict[str, Any]] = {} 
running_containers_lock = asyncio.Lock()

# For managing active AI streaming tasks to allow stopping them
active_ai_streams: Dict[str, asyncio.Event] = {}
active_ai_streams_lock = asyncio.Lock() # Lock for safe concurrent access to active_ai_streams

def get_memory_for_client(session_id: str) -> ConversationBufferMemory:
    """
    Retrieves or creates ConversationBufferMemory for a specific session_id.
    Loads from DB if available, otherwise creates a new one.
    """
    global client_memory
    if session_id in client_memory:
        # Return from in-memory cache if available
        return client_memory[session_id]

    # Attempt to load from database
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            "SELECT memory_state_json FROM session_memory_state WHERE session_id = ?",
            (session_id,)
        )
        row = cursor.fetchone()

        if row and row["memory_state_json"]:
            try:
                memory_data_list = json.loads(row["memory_state_json"]) # Expecting a list of message dicts
                if isinstance(memory_data_list, list):
                    # Create a new memory instance
                    memory_instance = ConversationBufferMemory(
                        return_messages=True, 
                        memory_key="history" # Default memory key for ConversationBufferMemory
                    )
                    # Load messages into the new instance
                    loaded_messages = messages_from_dict(memory_data_list)
                    memory_instance.chat_memory.messages = loaded_messages
                    
                    client_memory[session_id] = memory_instance # Store in cache
                    print(f"STATE: Memory loaded from DB for session {session_id}")
                    return memory_instance
                else:
                    # Log if the stored JSON is not in the expected list format
                    print(f"STATE WARNING: Memory data for session {session_id} is not a list. Creating new memory.")
            except (json.JSONDecodeError, TypeError, Exception) as e:
                # Catch errors during JSON loading or message reconstruction
                print(f"STATE ERROR: Failed to load/parse memory for session {session_id} from DB: {e}")
                traceback.print_exc() # Log full traceback for debugging
                # Fall through to create new memory if parsing fails
    except sqlite3.Error as db_err:
        # Catch database errors during the query
        print(f"STATE DB ERROR: Could not query session_memory_state for session {session_id}: {db_err}")
        traceback.print_exc() # Log full traceback
        # Fall through to create new memory if DB query fails
    finally:
        if conn:
            conn.close()

    # If not found in cache or DB, or if loading failed, create and cache new memory
    print(f"STATE: Creating new memory for session {session_id}")
    new_memory = ConversationBufferMemory(return_messages=True, memory_key="history")
    client_memory[session_id] = new_memory
    return new_memory

def save_memory_state_to_db(session_id: str, memory: Optional[ConversationBufferMemory]):
    """
    Saves the current state of the ConversationBufferMemory to the database for a given session_id.
    Includes detailed logging for debugging.
    """
    if not memory:
        print(f"STATE WARNING (save_memory): Attempted to save null memory for session {session_id}. Skipping.")
        return

    conn = None
    print(f"STATE ATTEMPT (save_memory): Saving memory state to DB for session {session_id}.")
    try:
        # Get messages from LangChain memory object
        messages = memory.chat_memory.messages
        # Convert messages to a list of dictionaries suitable for JSON serialization
        memory_state_list = messages_to_dict(messages) 
        memory_state_json = json.dumps(memory_state_list) # Serialize the list to a JSON string
        
        current_time_utc = datetime.datetime.now(datetime.timezone.utc).isoformat()

        conn = database.get_db_connection()
        cursor = conn.cursor()
        print(f"STATE PRE-EXECUTE (save_memory): About to execute INSERT OR REPLACE for session {session_id}.")
        cursor.execute(
            """
            INSERT OR REPLACE INTO session_memory_state 
            (session_id, memory_state_json, updated_at) 
            VALUES (?, ?, ?)
            """,
            (session_id, memory_state_json, current_time_utc)
        )
        print(f"STATE POST-EXECUTE (save_memory): SQL executed for session {session_id}.")
        conn.commit()
        print(f"STATE SUCCESS (save_memory): Memory saved and committed to DB for session {session_id}.")
    except json.JSONDecodeError as json_err: 
        print(f"STATE JSON ERROR (save_memory): Failed to serialize memory for session {session_id}: {json_err}")
        traceback.print_exc()
        if conn:
            conn.rollback()
    except sqlite3.Error as db_err: 
        print(f"STATE DB ERROR (save_memory): Failed to save memory state to DB for session {session_id}: {db_err}")
        traceback.print_exc()
        if conn:
            conn.rollback()
    except Exception as e: 
        print(f"STATE UNEXPECTED ERROR (save_memory): Failed to save memory state for session {session_id}: {e}")
        traceback.print_exc()
        if conn:
            conn.rollback()
    finally:
        if conn:
            conn.close()
            print(f"STATE FINALLY (save_memory): DB connection closed for session {session_id}.")

def remove_memory_for_client(session_id: str):
    """Removes memory for a specific session_id from the in-memory cache."""
    global client_memory
    if session_id in client_memory:
        del client_memory[session_id]
        print(f"STATE: Memory removed from cache for session {session_id}")

# --- Functions to manage AI stream stop events ---
async def register_ai_stream(stream_id: str) -> asyncio.Event:
    """
    Registers a new AI stream and returns an event to signal its stopping.
    """
    async with active_ai_streams_lock:
        if stream_id in active_ai_streams:
            print(f"STATE WARNING: Stream ID {stream_id} already registered. Overwriting stop event.")
        stop_event = asyncio.Event()
        active_ai_streams[stream_id] = stop_event
        print(f"STATE: AI stream {stream_id} registered for stopping.")
        return stop_event

async def unregister_ai_stream(stream_id: str):
    """
    Unregisters an AI stream, typically when it finishes or is stopped.
    """
    async with active_ai_streams_lock:
        if stream_id in active_ai_streams:
            del active_ai_streams[stream_id]
            print(f"STATE: AI stream {stream_id} unregistered.")
        else:
            print(f"STATE WARNING: Attempted to unregister non-existent AI stream {stream_id}.")

async def signal_stop_ai_stream(stream_id: str) -> bool:
    """
    Sets the stop event for a given AI stream ID, if it exists.
    Returns True if signaled, False otherwise.
    """
    async with active_ai_streams_lock:
        stop_event = active_ai_streams.get(stream_id)
        if stop_event:
            stop_event.set()
            print(f"STATE: Stop signal sent to AI stream {stream_id}.")
            return True
        else:
            print(f"STATE WARNING: Attempted to signal stop for non-existent AI stream {stream_id}.")
            return False


=== app/utils.py ===
# app/utils.py

from fastapi import WebSocket, WebSocketDisconnect
from fastapi.websockets import WebSocketState
import re
import html
import traceback

def escape_html(s: str) -> str:
    """
    Escapes a string for safe inclusion in HTML, preventing XSS.
    """
    if not isinstance(s, str):
        s = str(s) # Ensure it's a string
    return html.escape(s)

def is_valid_email(email: str) -> bool:
    """
    Validates an email address.
    (This is a basic example, consider a more robust library for production)
    """
    if not email:
        return False
    # Basic regex for email validation
    pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
    if re.match(pattern, email):
        return True
    return False

async def send_ws_message(websocket: WebSocket, message_type: str, payload: dict):
    """Safely sends a JSON message over the WebSocket."""
    code_block_id = payload.get('code_block_id', 'N/A')
    
    print(f"[utils] Attempting to send {message_type} for {code_block_id}")
    
    # Check state before sending
    if websocket.client_state != WebSocketState.CONNECTED:
        print(f"[utils] ✗ WebSocket not connected (state: {websocket.client_state.name}), cannot send {message_type} for {code_block_id}")
        return False
        
    try:
        message = {"type": message_type, "payload": payload}
        print(f"[utils] Sending message: {message}")
        await websocket.send_json(message)
        print(f"[utils] ✓ Successfully sent {message_type} for {code_block_id}")
        return True
    except WebSocketDisconnect:
        print(f"[utils] ✗ WebSocket disconnected while trying to send {message_type} for {code_block_id}")
        return False
    except Exception as e:
        # Catch other potential errors like Runtime Error if connection closed during send
        print(f"[utils] ✗ Error sending WebSocket message ({message_type}) for {code_block_id}: {e}")
        traceback.print_exc() # Enable this to see full error details
        return False

=== app/static/_sidebar.html ===
<div class="p-4 border-b border-gray-700 flex items-center justify-between">
    <h2 class="text-xl font-semibold text-white">Tesseracs</h2>
    <a href="/" title="Home" aria-label="Home" class="text-gray-400 hover:text-white">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path></svg>
    </a>
</div>

<nav class="flex-1 p-4 space-y-2 sidebar-scrollable" aria-label="Main navigation">
    <form action="/sessions/create" method="POST" class="mb-4" id="new-chat-form-sidebar">
        <input type="hidden" name="csrf_token" id="sidebar_csrf_token">
        
        <button type="submit" id="new-chat-button-sidebar"
                class="w-full flex items-center justify-center px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-md text-white font-medium transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 disabled:opacity-70 disabled:cursor-not-allowed">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
            New Chat
        </button>
    </form>

    <div class="text-sm text-gray-400 uppercase tracking-wider mb-2" id="sessions-heading">Sessions</div>
    <ul id="session-list" class="space-y-1" aria-labelledby="sessions-heading">
        <li class="px-3 py-1 text-gray-400 italic text-sm">Loading sessions...</li>
    </ul>

    <div class="mt-auto pt-4 border-t border-gray-700"> <a href="/settings" id="settings-link-sidebar" class="flex items-center px-3 py-2 text-gray-300 hover:bg-gray-700 hover:text-white rounded-md text-sm">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826 3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
            Settings
        </a>
    </div>
</nav>

<div class="p-4 border-t border-gray-700">
    <a href="/logout" id="logout-link-sidebar" class="flex items-center justify-center w-full px-4 py-2 border border-gray-600 hover:bg-gray-700 rounded-md text-sm font-medium text-gray-300 hover:text-white transition duration-150 ease-in-out">
        Logout
    </a>
</div>

=== app/static/chat-session.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>%%SESSION_NAME_PLACEHOLDER%% - Tesseracs Chat</title>
    <link rel="stylesheet" href="/dist/input.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script id="csrf-token-script-page-chat">
     // This placeholder will be replaced by the server with the actual raw CSRF token.
     window.csrfTokenRaw = "%%CSRF_TOKEN_RAW%%";
    </script>
    <script>
     // Optional immediate diagnostic client-side to verify token injection
     if (typeof window.csrfTokenRaw !== 'undefined' && window.csrfTokenRaw !== "%%CSRF_TOKEN_RAW%%") {
       console.log('CHAT PAGE JS (after csrf-token-script): window.csrfTokenRaw is available.');
     } else {
       console.warn('CHAT PAGE JS (after csrf-token-script): window.csrfTokenRaw IS STILL THE PLACEHOLDER "%%CSRF_TOKEN_RAW%%" OR UNDEFINED. Value:', window.csrfTokenRaw);
     }
    </script>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="flex h-screen overflow-hidden">
        <aside id="sidebar-loader-target" class="w-64 bg-gray-800 text-gray-200 flex flex-col overflow-hidden shrink-0">
            </aside>

        <main class="flex-1 flex flex-col overflow-hidden">
            <header class="bg-white border-b border-gray-200 p-4 shadow-sm">
                <h1 id="chat-session-title" class="text-lg font-semibold text-gray-800 truncate">%%SESSION_NAME_PLACEHOLDER%%</h1>
            </header>
            <div id="chat-history" class="flex-1 overflow-y-auto p-4 space-y-4 bg-white shadow-inner m-2 md:m-4 rounded-lg">
                </div>
            <footer class="p-4 bg-gray-200 border-t border-gray-300">
                <form id="chat-form" class="flex items-center space-x-2">
                    <div class="think-checkbox-container flex items-center text-sm text-gray-600 mr-1 md:mr-2">
                        <input type="checkbox" id="think-checkbox" class="mr-1 h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 cursor-pointer">
                        <label for="think-checkbox" class="cursor-pointer select-none">Think</label>
                    </div>
                    <input type="text" id="message-input" placeholder="Type your message..." autocomplete="off" required
                           class="flex-1 p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                    <button type="submit" id="send-button"
                            class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                        Send
                    </button>
                    <button type="button" id="stop-ai-button" class="hidden"> <svg class="w-5 h-5 inline-block mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1zm4 0a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                        Stop
                    </button>
                </form>
            </footer>
        </main>
    </div>

    <script type="module">
        // Imports loadSidebarHTML and populateSessionList from app-ui.js
        import { loadSidebarHTML, populateSessionList } from '/static/js/app-ui.js'; 

        document.addEventListener('DOMContentLoaded', async () => {
            console.log("Chat Session Page: DOMContentLoaded. Attempting to load UI components.");
            const sidebarContainer = document.getElementById('sidebar-loader-target');
            if (!sidebarContainer) {
                console.error("Chat Session Page: Sidebar container 'sidebar-loader-target' not found!");
                return;
            }
            // Load the sidebar HTML into the designated container.
            // loadSidebarHTML also calls setupSidebarCSRF internally.
            const sidebarLoaded = await loadSidebarHTML('/static/_sidebar.html', 'sidebar-loader-target');
            
            if (sidebarLoaded) {
                // If sidebar loaded, try to populate the session list within it.
                const sessionListElement = document.getElementById('session-list');
                if (sessionListElement) {
                    await populateSessionList('/api/sessions', 'session-list', '/chat/');
                } else {
                    console.error("Chat Session Page: Session list element 'session-list' not found after sidebar load.");
                }
            } else {
                console.error("Chat Session Page: Sidebar loading failed. Session list will not be populated.");
            }
        });
    </script>
    <script src="/dist/script.js" defer></script> 
</body>
</html>


=== app/static/languages.json ===
{
  "html": {
    "image": "alpine:latest",
    "filename": "script.html",
    "command": ["cat", "/app/script.html"],
    "executable": true,
    "interactive": false
  },
  "python": {
    "image": "python:3.11-slim",
    "filename": "script.py",
    "command": ["stdbuf", "-o0", "python", "-u", "/app/script.py"],
    "executable": true,
    "interactive": true
  },
  "javascript": {
    "image": "node:18-alpine",
    "filename": "script.js",
    "command": ["stdbuf", "-o0", "node", "/app/script.js"],
    "executable": true,
    "interactive": true
  },
  "c": {
    "image": "gcc:latest",
    "filename": "script.c",
    "command": ["sh", "-c", "gcc /app/script.c -o /app/output_executable && exec stdbuf -o0 /app/output_executable"],
    "executable": true,
    "interactive": true
  },
  "cpp": {
    "image": "gcc:latest",
    "filename": "script.cpp",
    "command": ["sh", "-c", "g++ /app/script.cpp -o /app/output_executable && exec stdbuf -o0 /app/output_executable"],
    "executable": true,
    "interactive": true
  },
  "csharp": {
    "image": "mcr.microsoft.com/dotnet/sdk:latest",
    "filename": "Script.cs",
    "command": ["sh", "-c", "cd /app && dotnet new console --force -o . > /dev/null && cp Script.cs Program.cs && rm Script.cs && exec dotnet run"],
    "executable": true,
    "interactive": true
  },
  "typescript": {
    "image": "node:18-alpine",
    "filename": "script.ts",
    "command": ["sh", "-c", "npm install -g typescript > /dev/null 2>&1 && tsc --module commonjs /app/script.ts && exec stdbuf -o0 node /app/script.js"],
    "executable": true,
    "interactive": true
  },
  "java": {
    "image": "openjdk:17-jdk-slim",
    "filename": "Main.java",
    "command": ["sh", "-c", "javac /app/Main.java && exec stdbuf -o0 java -cp /app Main"],
    "executable": true,
    "interactive": true
  },
  "go": {
    "image": "golang:1.21-alpine",
    "filename": "script.go",
    "command": ["stdbuf", "-o0", "go", "run", "/app/script.go"],
    "executable": true,
    "interactive": true
  },
  "rust": {
    "image": "rust:1-slim",
    "filename": "main.rs",
    "command": ["sh", "-c", "cd /app && rustc main.rs -o main_executable && exec stdbuf -o0 ./main_executable"],
    "executable": true,
    "interactive": true
  }
}

=== app/static/login.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Login - Tesseracs Chat</title>
    <link rel="stylesheet" href="/dist/input.css">
    <script id="csrf-token-script">
      // This placeholder is replaced by the server with the actual raw CSRF token.
      window.csrfTokenRaw = "%%CSRF_TOKEN_RAW%%"; 
    </script>
    <script>
      // Early diagnostic log to check if the CSRF token is injected correctly by the server.
      console.log('JS EARLY DIAGNOSTIC (immediately after csrf-token-script): window.csrfTokenRaw =', "'" + window.csrfTokenRaw + "'", "(Type:", typeof window.csrfTokenRaw + ")");
    </script>
</head>
<body class="flex flex-col justify-center items-center min-h-screen bg-gray-100 font-sans p-4">
    <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-md">
        <h1 class="text-center mb-6 text-2xl font-semibold text-gray-900">Tesseracs Chat</h1>
        <div id="message-area" class="p-3 rounded-md text-sm text-center mb-4" style="display: none;"></div>
        
        <form id="auth-form" class="mt-4">
            <input type="hidden" name="csrf_token" id="csrf_token_form_field">
            
            <div class="mb-5">
                <label for="email" class="block mb-2 text-sm font-medium text-gray-700">Email:</label>
                <input type="email" id="email" name="username" required autocomplete="username" class="block w-full py-2.5 px-3 border border-gray-300 rounded-md text-sm transition-colors duration-200 ease-in-out focus:border-blue-600 focus:ring-2 focus:ring-blue-300 focus:outline-none">
            </div>
            
            <div id="password-field-container" class="mb-5 hidden">
                <label for="password" class="block mb-2 text-sm font-medium text-gray-700">Password:</label>
                <input type="password" id="password" name="password" autocomplete="current-password" class="block w-full py-2.5 px-3 border border-gray-300 rounded-md text-sm transition-colors duration-200 ease-in-out focus:border-blue-600 focus:ring-2 focus:ring-blue-300 focus:outline-none">
                <a href="#" id="forgot-password-link" class="block text-right text-sm text-gray-600 no-underline mt-2 mb-5 hover:text-blue-700 hover:underline hidden">Forgot Password?</a>
            </div>
            
            <div id="name-field-container" class="mb-5 hidden">
                <label for="name" class="block mb-2 text-sm font-medium text-gray-700">Full Name:</label>
                <input type="text" id="name" name="name" autocomplete="name" class="block w-full py-2.5 px-3 border border-gray-300 rounded-md text-sm transition-colors duration-200 ease-in-out focus:border-blue-600 focus:ring-2 focus:ring-blue-300 focus:outline-none">
            </div>
            
            <button type="submit" id="submit-button" class="w-full py-3 bg-blue-600 text-white rounded-md text-sm font-medium cursor-pointer transition-colors duration-200 ease-in-out hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed">Continue</button>
            <button type="button" id="change-email-button" class="block w-auto mt-3 mx-auto py-2 px-4 text-sm text-gray-600 bg-gray-100 border border-gray-300 rounded-md cursor-pointer text-center hover:bg-gray-200 hidden">Change Email / Start Over</button>
        </form>
        
        <p id="form-instructions" class="text-xs text-center mt-6 text-gray-500">
            Enter your email to log in or create an account.
        </p>
    </div>

    <script>
        // Utility function to get a cookie by name. Used for diagnostics or specific needs,
        // but CSRF token for AJAX is primarily handled via window.csrfTokenRaw.
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        // DOM element references
        const authForm = document.getElementById('auth-form');
        const emailInput = document.getElementById('email'); 
        const nameInput = document.getElementById('name');
        const passwordInput = document.getElementById('password');
        const nameFieldContainer = document.getElementById('name-field-container');
        const passwordFieldContainer = document.getElementById('password-field-container');
        const submitButton = document.getElementById('submit-button');
        const messageArea = document.getElementById('message-area');
        const formInstructions = document.getElementById('form-instructions');
        const forgotPasswordLink = document.getElementById('forgot-password-link');
        const changeEmailButton = document.getElementById('change-email-button');
        const csrfTokenFormField = document.getElementById('csrf_token_form_field'); // Hidden input for CSRF token in form
        
        // Placeholder string that the server is supposed to replace with the actual CSRF token.
        const CSRF_ORIGINAL_PLACEHOLDER = ['%', '%CSRF_TOKEN_RAW%', '%'].join('');

        let formState = 'initial_email'; // Manages the current state of the login/registration form
        let cachedEmail = ''; // Stores the email after it's been checked

        // Log the initial CSRF token value when the main script runs.
        console.log('JS MAIN SCRIPT: window.csrfTokenRaw at script start =', "'" + window.csrfTokenRaw + "'", "(Type:", typeof window.csrfTokenRaw + ")");
        console.log('JS MAIN SCRIPT: CSRF_ORIGINAL_PLACEHOLDER =', "'" + CSRF_ORIGINAL_PLACEHOLDER + "'");

        /**
         * Updates the UI elements (input fields, buttons, instructions) based on the current formState.
         */
        function updateUIForState() {
            // Hide all optional sections by default; specific states will unhide them.
            passwordFieldContainer.classList.add('hidden');
            nameFieldContainer.classList.add('hidden');
            forgotPasswordLink.classList.add('hidden');
            changeEmailButton.classList.add('hidden');

            // Reset 'required' attributes; states will set them if needed.
            passwordInput.required = false;
            nameInput.required = false;
            emailInput.readOnly = false; // Email input is generally editable unless a state locks it.
            submitButton.disabled = false; // Submit button is enabled by default.

            // **MODIFICATION**: messageArea is NOT hidden here by default.
            // It will be hidden explicitly by states that require a clean slate (e.g., 'initial_email').
            // Otherwise, messages shown by showMessage() will persist into the new state.

            // Populate the hidden CSRF token field if window.csrfTokenRaw is valid.
            const tokenValue = window.csrfTokenRaw;
            const isTokenValid = tokenValue && typeof tokenValue === 'string' && tokenValue !== CSRF_ORIGINAL_PLACEHOLDER && tokenValue.trim() !== "";

            if (isTokenValid) {
                csrfTokenFormField.value = tokenValue;
            } else {
                csrfTokenFormField.value = ""; // Ensure field is empty if token is invalid.
                console.warn("JS WARN (updateUIForState): window.csrfTokenRaw ('" + tokenValue + "') is not a valid token for form field. Hidden CSRF field set to empty. Is it the original placeholder?", tokenValue === CSRF_ORIGINAL_PLACEHOLDER);
            }

            // Configure UI based on the current state
            switch (formState) {
                case 'initial_email':
                    emailInput.value = ''; 
                    passwordInput.value = '';
                    nameInput.value = '';
                    cachedEmail = '';
                    submitButton.textContent = 'Continue';
                    formInstructions.textContent = 'Enter your email to log in or create an account.';
                    submitButton.disabled = emailInput.value.trim() === ''; // Disable if email is empty
                    emailInput.focus();
                    messageArea.style.display = 'none'; // Explicitly hide message area for this clean state
                    break;
                case 'login_password':
                    passwordFieldContainer.classList.remove('hidden');
                    forgotPasswordLink.classList.remove('hidden');
                    changeEmailButton.classList.remove('hidden');
                    passwordInput.required = true;
                    emailInput.readOnly = true; 
                    emailInput.value = cachedEmail; 
                    submitButton.textContent = 'Login';
                    formInstructions.textContent = 'Enter your password to log in.';
                    passwordInput.value = ''; 
                    submitButton.disabled = true; // Disable until password input
                    passwordInput.focus();
                    // messageArea might still be visible from a previous action if not explicitly hidden
                    break;
                case 'register_name':
                    nameFieldContainer.classList.remove('hidden');
                    changeEmailButton.classList.remove('hidden');
                    nameInput.required = true;
                    emailInput.readOnly = true; 
                    emailInput.value = cachedEmail; 
                    submitButton.textContent = 'Create Account & Send Password';
                    formInstructions.textContent = 'This email is not registered. Enter your name to create an account. A password will be emailed to you.';
                    nameInput.value = '';
                    submitButton.disabled = nameInput.value.trim() === ''; // Disable if name is empty
                    nameInput.focus();
                    // messageArea might still be visible (e.g. if an error occurred before reaching this state)
                    break;
                case 'forgot_password_prompt':
                    emailInput.readOnly = false; 
                    emailInput.value = cachedEmail || ''; 
                    passwordInput.value = '';
                    nameInput.value = '';
                    submitButton.textContent = 'Send Reset Email';
                    formInstructions.textContent = 'Enter your email address to receive a password reset email.';
                    changeEmailButton.classList.remove('hidden'); 
                    submitButton.disabled = emailInput.value.trim() === '';
                    emailInput.focus();
                    // messageArea might be visible from a previous action
                    break;
                case 'login_after_registration':
                case 'login_after_password_reset':
                    emailInput.value = cachedEmail; 
                    emailInput.readOnly = true;
                    passwordFieldContainer.classList.remove('hidden');
                    changeEmailButton.classList.remove('hidden');
                    passwordInput.required = true;
                    submitButton.textContent = 'Login';
                    if (formState === 'login_after_registration') {
                        // The success message from registration (via showMessage) should still be visible here.
                        formInstructions.textContent = 'Account created! Please check your email for the password and enter it below.';
                    } else { 
                        // The success message from password reset (via showMessage) should still be visible.
                        formInstructions.textContent = 'Please check your email for the new password and enter it below.';
                    }
                    passwordInput.value = '';
                    submitButton.disabled = true; // Disable until password input
                    passwordInput.focus();
                    break;
            }
        }

        // Event listeners to enable/disable submit button based on input
        emailInput.addEventListener('input', function() {
            if (formState === 'initial_email' || formState === 'forgot_password_prompt') {
                submitButton.disabled = emailInput.value.trim() === '';
            }
        });
        nameInput.addEventListener('input', function() {
            if (formState === 'register_name') {
                submitButton.disabled = nameInput.value.trim() === '';
            }
        });
        passwordInput.addEventListener('input', function() {
            if (formState === 'login_password' || formState === 'login_after_registration' || formState === 'login_after_password_reset') {
                submitButton.disabled = passwordInput.value.trim() === '';
            }
        });

        // Event listener for "Forgot Password?" link
        forgotPasswordLink.addEventListener('click', (event) => {
            event.preventDefault();
            formState = 'forgot_password_prompt';
            updateUIForState();
            messageArea.style.display = 'none'; // Clear previous messages when switching to forgot password
        });

        // Event listener for "Change Email / Start Over" button
        changeEmailButton.addEventListener('click', (event) => {
            event.preventDefault();
            formState = 'initial_email';
            updateUIForState(); // This will hide messageArea as per 'initial_email' state
        });

        /**
         * Handles form submission for all states (email check, login, registration, forgot password).
         */
        authForm.addEventListener('submit', async function(event) {
            event.preventDefault(); // Prevent default form submission
            messageArea.className = 'p-3 rounded-md text-sm text-center mb-4 border'; // Reset message area classes
            submitButton.disabled = true; // Disable submit button during processing

            const emailForLogic = emailInput.value.trim().toLowerCase();
            const currentRawCsrfToken = window.csrfTokenRaw; 
            
            console.log('JS LOG (Submit Start): currentRawCsrfToken value is:', "'" + currentRawCsrfToken + "'", "(Type:", typeof currentRawCsrfToken + ")");
            const isTokenTheOriginalPlaceholder = currentRawCsrfToken === CSRF_ORIGINAL_PLACEHOLDER;
            console.log('JS LOG (Submit Start): Is currentRawCsrfToken the original placeholder?', isTokenTheOriginalPlaceholder);
            
            const headers = { 
                // Content-Type is set per request type below (JSON or FormData)
            };

            // Set X-CSRF-Token header if the token is valid and not the placeholder.
            if (typeof currentRawCsrfToken === 'string' && !isTokenTheOriginalPlaceholder && currentRawCsrfToken.trim() !== "") {
                headers['X-CSRF-Token'] = currentRawCsrfToken;
            } else {
                console.warn('JS WARN (Submit): X-CSRF-Token header will NOT be set or will be problematic. currentRawCsrfToken:', "'" + currentRawCsrfToken + "'. Is it original placeholder?", isTokenTheOriginalPlaceholder);
                // If CSRF token is missing/invalid, for critical operations, we might stop here.
                // For now, proceeding and letting server handle it, but this is a potential failure point.
            }

            // --- State: Initial Email Check ---
            if (formState === 'initial_email') {
                submitButton.textContent = 'Checking Email...';
                headers['Content-Type'] = 'application/json';
                try {
                    const response = await fetch('/check_email', {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify({ email: emailForLogic })
                    });
                    const result = await response.json();
                    if (response.ok) {
                        cachedEmail = emailForLogic; 
                        formState = result.exists ? 'login_password' : 'register_name';
                        updateUIForState(); 
                        // No explicit message shown here by showMessage, state instructions will guide.
                    } else {
                        showMessage(result, 'error'); 
                        submitButton.textContent = 'Continue'; 
                        submitButton.disabled = emailInput.value.trim() === ''; 
                    }
                } catch (error) {
                    console.error('Email check error:', error);
                    showMessage('Network error or server issue checking email. Please try again.', 'error');
                    submitButton.textContent = 'Continue';
                    submitButton.disabled = emailInput.value.trim() === '';
                }
            } 
            // --- State: Login (Password Submission) ---
            else if (formState === 'login_password' || formState === 'login_after_registration' || formState === 'login_after_password_reset') {
                submitButton.textContent = 'Logging In...';
                const formData = new FormData(authForm); 
                // formData will include email (name="username"), password, and csrf_token (from hidden input)
                // csrfTokenFormField.value is set by updateUIForState()
                console.log('JS LOG (Submit /token): FormData csrf_token field value being sent:', "'" + csrfTokenFormField.value + "'");
                
                // The `headers` object already contains X-CSRF-Token if currentRawCsrfToken was valid.
                // For FormData, fetch sets Content-Type automatically.
                try {
                    const response = await fetch('/token', { 
                        method: 'POST', 
                        headers: headers, // Send X-CSRF-Token header
                        body: formData    // Body is FormData
                    });
                    const result = await response.json(); 
                    if (response.ok) {
                        showMessage('Login successful! Redirecting...', 'success');
                        setTimeout(() => { window.location.href = '/'; }, 1500); // Redirect to dashboard/main page
                    } else {
                        showMessage(result, 'error'); 
                        submitButton.textContent = 'Login';
                        submitButton.disabled = passwordInput.value.trim() === '';
                    }
                } catch (error) { 
                    console.error('Login error:', error);
                    showMessage('Network error or server issue during login. Please try again.', 'error');
                    submitButton.textContent = 'Login';
                    submitButton.disabled = passwordInput.value.trim() === '';
                }
            }
            // --- State: Registration (Name Submission) ---
            else if (formState === 'register_name') {
                submitButton.textContent = 'Creating Account...';
                headers['Content-Type'] = 'application/json';
                const name = nameInput.value.trim();
                try {
                    const response = await fetch('/register', {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify({ email: emailForLogic, name: name }) 
                    });
                    const result = await response.json(); // Expects models.RegistrationResponse
                    if (response.ok) {
                        // `result.message` contains the success string from the server
                        showMessage(result.message, 'success'); // This will show the green banner
                        formState = 'login_after_registration';
                        updateUIForState(); // This will set up the form for password entry
                                            // The success message from showMessage() should remain visible.
                    } else {
                        showMessage(result, 'error'); // `result` would be like {"detail": "error message"}
                        submitButton.textContent = 'Create Account & Send Password';
                        submitButton.disabled = nameInput.value.trim() === '';
                    }
                } catch (error) {
                    console.error('Registration error:', error);
                    showMessage('Network error or server issue during registration. Please try again.', 'error');
                    submitButton.textContent = 'Create Account & Send Password';
                    submitButton.disabled = nameInput.value.trim() === '';
                }
            }
            // --- State: Forgot Password ---
            else if (formState === 'forgot_password_prompt') {
                submitButton.textContent = 'Sending Reset Email...';
                headers['Content-Type'] = 'application/json';
                try {
                    const response = await fetch('/forgot_password', {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify({ email: emailForLogic })
                    });
                    const result = await response.json(); // Expects models.ForgotPasswordResponse
                    showMessage(result.message, response.ok ? 'success' : 'error'); 
                    if (response.ok) {
                        cachedEmail = emailForLogic; 
                        formState = 'login_after_password_reset';
                        updateUIForState(); // Sets up form for new password entry
                                            // The success message from showMessage() should remain.
                    } else {
                        submitButton.textContent = 'Send Reset Email';
                        submitButton.disabled = emailInput.value.trim() === '';
                    }
                } catch (error) {
                    console.error('Forgot password error:', error);
                    // Provide a generic message for security (don't confirm/deny email existence based on network error)
                    showMessage('A network error occurred. If an account with this email exists, a password reset email may have been sent.', 'error');
                    submitButton.textContent = 'Send Reset Email';
                    submitButton.disabled = emailInput.value.trim() === '';
                }
            }
        });

        /**
         * Displays a message (error, success, info) in the messageArea.
         * @param {string|object} messageData - The message string or an error object from the server.
         * @param {string} type - 'info', 'success', or 'error'.
         */
        function showMessage(messageData, type = 'info') { 
            let displayMessage = "An unexpected error occurred.";
            if (typeof messageData === 'string') {
                displayMessage = messageData;
            } else if (typeof messageData === 'object' && messageData !== null) {
                // Handle FastAPI HTTPException detail structure
                if (messageData.detail) {
                    if (typeof messageData.detail === 'string') {
                        displayMessage = messageData.detail;
                    } else if (Array.isArray(messageData.detail) && messageData.detail.length > 0) {
                        // Handle Pydantic validation error arrays
                        displayMessage = messageData.detail.map(err => {
                            let loc = err.loc ? err.loc.join('.') : 'field';
                            return `${loc}: ${err.msg}`;
                        }).join('; ');
                    } else {
                        displayMessage = JSON.stringify(messageData.detail); // Fallback for other detail structures
                    }
                } else if (messageData.message) { // Handle custom success messages like {"message": "..."}
                     displayMessage = messageData.message;
                } else {
                    displayMessage = JSON.stringify(messageData); // Fallback for other object structures
                }
            }
            
            messageArea.textContent = displayMessage;
            messageArea.className = 'p-3 rounded-md text-sm text-center mb-4 border'; // Reset base classes
            if (type === 'error') {
                messageArea.classList.add('text-red-700', 'bg-red-100', 'border-red-300');
            } else if (type === 'success') {
                messageArea.classList.add('text-green-700', 'bg-green-100', 'border-green-300');
            } else { // 'info' or default
                messageArea.classList.add('text-blue-700', 'bg-blue-100', 'border-blue-300');
            }
            messageArea.style.display = 'block'; // Make the message area visible
        }

        // Initialize the UI to the default state when the page loads.
        updateUIForState();
    </script>
</body>
</html>

=== app/static/script.js ===
// --- JS Imports ---
import { marked } from 'marked';
import katex from 'katex';
import Prism from 'prismjs';

// --- Prism Components ---
import 'prismjs/components/prism-clike';
import 'prismjs/components/prism-python';
import 'prismjs/components/prism-javascript';
import 'prismjs/components/prism-css';
import 'prismjs/components/prism-bash';
import 'prismjs/components/prism-json';
import 'prismjs/components/prism-yaml';
import 'prismjs/components/prism-sql';
import 'prismjs/components/prism-java';
import 'prismjs/components/prism-csharp';
import 'prismjs/components/prism-go';
import 'prismjs/components/prism-rust';
import 'prismjs/components/prism-docker';
import 'prismjs/components/prism-typescript';
import 'prismjs/components/prism-c';
import 'prismjs/components/prism-cpp';

// --- DOM Elements ---
const chatHistory = document.getElementById('chat-history');
const chatForm = document.getElementById('chat-form');
const messageInput = document.getElementById('message-input');
const sendButton = document.getElementById('send-button');
const thinkCheckbox = document.getElementById('think-checkbox');
const stopAiButton = document.getElementById('stop-ai-button');

// --- Core Variables ---
let websocket;
const clientId = `web-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
let currentTurnId = 0;

// --- Constants ---
const NO_THINK_PREFIX = "\\no_think";
const THINK_PREFIX = "\\think";

const LANGUAGE_ALIASES = {
    'python': 'python', 'py': 'python',
    'javascript': 'javascript', 'js': 'javascript',
    'html': 'html',
    'css': 'css',
    'bash': 'bash', 'sh': 'bash', 'shell': 'bash',
    'json': 'json',
    'c': 'c',
    'cpp': 'cpp', 'c++': 'cpp',
    'csharp': 'csharp', 'cs': 'csharp',
    'go': 'go',
    'rust': 'rust',
    'typescript': 'typescript', 'ts': 'typescript',
    'java': 'java',
    'plaintext': 'plaintext', 'text': 'plaintext',
};

const PRISM_LANGUAGE_MAP = {
    'html': 'markup', // Prism's class for HTML is 'markup'
    'xml': 'markup',
    'svg': 'markup',
    'c++': 'cpp',
    'cs': 'csharp',
    'js': 'javascript',
    'py': 'python',
    'ts': 'typescript',
    'sh': 'bash',
    'shell': 'bash'
};

// --- State Variables ---
let supportedLanguagesConfig = {};
let currentAiTurnContainer = null;
let currentAnswerElement = null;
let currentThinkingArea = null;
let currentThinkingPreElement = null;
let currentCodeBlocksArea = null;
let codeBlockCounterThisTurn = 0;
let thinkingRequestedForCurrentTurn = false;
let accumulatedAnswerText = '';
let hasThinkingContentArrivedThisTurn = false;
let firstAnswerTokenReceived = false;
let activeStreamingCodeBlocks = new Map(); // blockId -> { element, language, content }
let streamingCodeBlockCounter = 0;




function addTerminalPrompt(outputPreElement, promptText) {
    if (!outputPreElement) return;
    
    const outputContainer = outputPreElement.closest('.block-container');
    if (!outputContainer) return;
    
    const inputField = document.createElement('input');
    inputField.type = 'text';
    inputField.style.border = 'none';
    inputField.style.outline = 'none';
    inputField.style.background = 'transparent';
    inputField.style.color = 'inherit';
    inputField.style.font = 'inherit';
    inputField.style.padding = '0';
    inputField.style.margin = '0';
    inputField.style.display = 'inline';
    inputField.style.width = 'auto';
    inputField.style.minWidth = '200px';
    
    outputPreElement.appendChild(inputField);
    inputField.focus();
    
    inputField.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            const userInput = inputField.value;
            
            const textNode = document.createTextNode(userInput + '\n');
            outputPreElement.replaceChild(textNode, inputField);
            
            // FIX: Get the output block's ID and strip the prefix to find the original code block ID.
            const outputBlockId = outputContainer.id; // e.g., "output-for-code-block-turn1-1"
            const originalCodeBlockId = outputBlockId.replace('output-for-', ''); // results in "code-block-turn1-1"

            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.send(JSON.stringify({
                    type: 'code_input',
                    payload: { 
                        code_block_id: originalCodeBlockId, // Send the CORRECT ID
                        input: userInput + '\n' 
                    }
                }));
            }
        }
    });
}

function escapeHTML(str) {
    if (str === null || str === undefined) return '';
    return str.toString()
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}

function getCursorPosition(parentElement) {
    const selection = window.getSelection();
    if (selection.rangeCount === 0) return -1;

    const range = selection.getRangeAt(0);
    if (!parentElement.contains(range.startContainer)) {
        return -1;
    }

    const preSelectionRange = range.cloneRange();
    preSelectionRange.selectNodeContents(parentElement);
    try {
        preSelectionRange.setEnd(range.startContainer, range.startOffset);
        return preSelectionRange.toString().length;
    } catch (e) {
        console.error("Error getting cursor position:", e);
        return -1;
    }
}

function setCursorPosition(parentElement, offset) {
    const selection = window.getSelection();
    if (!selection) return;

    const range = document.createRange();
    let charCount = 0;
    let foundStart = false;

    function findNodeAndOffset(node) {
        if (foundStart) return;

        if (node.nodeType === Node.TEXT_NODE) {
            const nextCharCount = charCount + node.length;
            if (!foundStart && offset >= charCount && offset <= nextCharCount) {
                try {
                    const offsetInNode = Math.min(offset - charCount, node.length);
                    range.setStart(node, offsetInNode);
                    foundStart = true;
                } catch (e) {
                    console.error("Error setting range start:", e);
                }
            }
            charCount = nextCharCount;
        } else {
            for (let i = 0; i < node.childNodes.length; i++) {
                findNodeAndOffset(node.childNodes[i]);
                if (foundStart) break;
            }
        }
    }

    findNodeAndOffset(parentElement);

    if (foundStart) {
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
    } else {
        range.selectNodeContents(parentElement);
        range.collapse(false);
        selection.removeAllRanges();
        selection.addRange(range);
    }
}

function initializeCodeBlockHistory(blockId, initialContent) {
    if (!window.codeBlockHistories) {
        window.codeBlockHistories = new Map();
    }
    
    if (!window.codeBlockHistories.has(blockId)) {
        window.codeBlockHistories.set(blockId, {
            history: [initialContent],
            currentIndex: 0,
            saveTimeout: null
        });
    }
}

// --- Configuration Loading ---
async function loadLanguagesConfig() {
    try {
        const response = await fetch('/static/languages.json');
        if (!response.ok) {
            console.error('Failed to fetch languages.json');
            return;
        }
        supportedLanguagesConfig = await response.json();
        console.log("Successfully loaded language config:", supportedLanguagesConfig);
    } catch (error) {
        console.error('Error loading languages.json:', error);
    }
}

async function initializeCurrentUser() {
    try {
        const response = await fetch('/api/me');
        if (response.ok) {
            const userData = await response.json();
            if (userData && userData.name) {
                window.currentUserInfo = {
                    name: userData.name,
                    email: userData.email,
                    id: userData.id
                };
            } else {
                window.currentUserInfo = null;
            }
        } else {
            window.currentUserInfo = null;
        }
    } catch (error) {
        window.currentUserInfo = null;
    }
}

// --- Session Management ---
function getSessionIdFromPath() {
    const pathName = window.location.pathname;
    const pathParts = pathName.split('/');

    if (pathParts.length >= 3 && pathParts[1] === 'chat') {
        const sessionId = pathParts[2];
        if (sessionId && sessionId.trim() !== "") {
            return sessionId;
        } else {
            console.error("Session ID extracted from path is empty or invalid.");
            return null;
        }
    }

    return null;
}

// --- UI Helper Functions ---
function scrollToBottom(behavior = 'auto') {
    const isNearBottom = chatHistory.scrollHeight - chatHistory.scrollTop - chatHistory.clientHeight < 100;
    if (isNearBottom) {
        requestAnimationFrame(() => {
            chatHistory.scrollTo({ top: chatHistory.scrollHeight, behavior: behavior });
        });
    }
}

function setInputDisabledState(inputsDisabled, aiResponding) {
    if (messageInput) messageInput.disabled = inputsDisabled;
    if (sendButton) sendButton.disabled = inputsDisabled;
    if (thinkCheckbox) thinkCheckbox.disabled = inputsDisabled;

    if (stopAiButton) {
        if (aiResponding) {
            stopAiButton.classList.remove('hidden');
            stopAiButton.disabled = false;
            stopAiButton.innerHTML = `
                <svg class="w-5 h-5 inline-block mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1zm4 0a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                Stop`;
            if (sendButton) sendButton.classList.add('hidden');
        } else {
            stopAiButton.classList.add('hidden');
            stopAiButton.disabled = true;
            stopAiButton.innerHTML = `
                <svg class="w-5 h-5 inline-block mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1zm4 0a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                Stop`;
            if (sendButton) sendButton.classList.remove('hidden');
        }
    }
}

// --- Message Display Functions ---
function addUserMessage(text) {
    if (!chatHistory) {
        console.error("addUserMessage: chatHistory element not found.");
        return;
    }

    const messageElement = document.createElement('div');
    messageElement.classList.add('message', 'user-message', 'p-3', 'rounded-lg', 'max-w-xl', 'mb-2', 'break-words', 'flex', 'flex-col', 'bg-emerald-100', 'self-end', 'ml-auto');
    messageElement.setAttribute('data-sender', 'user');

    const senderElem = document.createElement('p');
    senderElem.classList.add('font-semibold', 'text-sm', 'mb-1', 'text-emerald-700');
    let userName = 'User';

    if (typeof window.currentUserInfo === 'object' && window.currentUserInfo !== null && window.currentUserInfo.name) {
        userName = window.currentUserInfo.name;
    }
    senderElem.textContent = escapeHTML(userName);
    messageElement.appendChild(senderElem);

    const contentElem = document.createElement('div');
    contentElem.classList.add('text-gray-800', 'text-sm', 'message-content');
    
    let displayedText = text;
    if (displayedText.startsWith(NO_THINK_PREFIX)) {
        displayedText = displayedText.substring(NO_THINK_PREFIX.length);
    } else if (displayedText.startsWith(THINK_PREFIX)) {
        displayedText = displayedText.substring(THINK_PREFIX.length);
    }

    contentElem.textContent = displayedText;
    messageElement.appendChild(contentElem);

    const timestampElem = document.createElement('p');
    timestampElem.classList.add('text-xs', 'text-slate-500', 'mt-1', 'text-right');
    timestampElem.textContent = new Date().toLocaleString();
    messageElement.appendChild(timestampElem);

    chatHistory.appendChild(messageElement);
    setTimeout(() => scrollToBottom('smooth'), 50);
}

function addSystemMessage(text) {
    const messageElement = document.createElement('div');
    messageElement.classList.add('system-message');
    messageElement.textContent = text;
    chatHistory.appendChild(messageElement);
    setTimeout(() => scrollToBottom('smooth'), 50);
}

function addErrorMessage(text) {
    console.error("[UI ERROR] ", text);
    const messageElement = document.createElement('div');
    messageElement.classList.add('error-message');
    messageElement.textContent = `Error: ${text}`;
    if (currentAiTurnContainer) {
        const target = currentAnswerElement || currentCodeBlocksArea || currentAiTurnContainer;
        target.appendChild(messageElement);
    } else {
        chatHistory.appendChild(messageElement);
    }
    setTimeout(() => scrollToBottom('smooth'), 50);
}

function setupNewAiTurn() {
    currentTurnId++;
    codeBlockCounterThisTurn = 0;
    accumulatedAnswerText = '';
    hasThinkingContentArrivedThisTurn = false;
    firstAnswerTokenReceived = false;

    // This map is for tracking blocks within a single turn and MUST be cleared.
    activeStreamingCodeBlocks.clear();
    // The main counter variable is NOT reset here, allowing it to be session-wide.

    currentAiTurnContainer = null;
    currentThinkingArea = null;
    currentThinkingPreElement = null;
    currentAnswerElement = null;
    currentCodeBlocksArea = null;

    console.log(`[setupNewAiTurn] Starting setup for Turn ID: ${currentTurnId}. thinkingRequestedForCurrentTurn is: ${thinkingRequestedForCurrentTurn}`);

    currentAiTurnContainer = document.createElement('div');
    currentAiTurnContainer.classList.add('ai-turn-container');
    currentAiTurnContainer.dataset.turnId = currentTurnId;

    // Thinking Area Setup
    currentThinkingArea = document.createElement('div');
    currentThinkingArea.classList.add('thinking-area');
    currentThinkingArea.dataset.turnId = currentTurnId;
    if (!thinkingRequestedForCurrentTurn) {
        currentThinkingArea.style.display = 'none';
    }
    
    const details = document.createElement('details');
    details.id = `thinking-details-${currentTurnId}`;
    const summary = document.createElement('summary');
    summary.classList.add('thinking-summary');
    const summaryTextSpan = document.createElement('span');
    summaryTextSpan.classList.add('text');
    summaryTextSpan.textContent = 'Show Thinking';
    const summaryDotsSpan = document.createElement('span');
    summaryDotsSpan.classList.add('dots');
    summary.appendChild(summaryTextSpan);
    summary.appendChild(summaryDotsSpan);
    currentThinkingPreElement = document.createElement('pre');
    details.appendChild(summary);
    details.appendChild(currentThinkingPreElement);
    currentThinkingArea.appendChild(details);
    currentAiTurnContainer.appendChild(currentThinkingArea);
    
    details.addEventListener('toggle', (event) => {
        const textSpan = event.target.querySelector('.thinking-summary .text');
        if (!textSpan) return;
        textSpan.textContent = event.target.open ? 'Hide Thinking' : 'Show Thinking';
    });

    // Answer Element (AI Message Bubble) Setup
    currentAnswerElement = document.createElement('div');
    currentAnswerElement.classList.add('message', 'ai-message', 'p-3', 'rounded-lg', 'max-w-xl', 'mb-2', 'break-words', 'flex', 'flex-col', 'bg-sky-100', 'self-start', 'mr-auto');

    const senderElem = document.createElement('p');
    senderElem.classList.add('font-semibold', 'text-sm', 'mb-1', 'text-sky-700');
    senderElem.textContent = 'AI';
    currentAnswerElement.appendChild(senderElem);

    const liveContentDiv = document.createElement('div');
    liveContentDiv.classList.add('text-gray-800', 'text-sm', 'message-content', 'live-ai-content-area');
    currentAnswerElement.appendChild(liveContentDiv);

    if (thinkingRequestedForCurrentTurn) {
        currentAnswerElement.style.display = 'none';
    } else {
        const loadingSpan = document.createElement('span');
        loadingSpan.classList.add('loading-dots');
        liveContentDiv.appendChild(loadingSpan);
    }
    currentAiTurnContainer.appendChild(currentAnswerElement);

    // Code Blocks Area Setup
    currentCodeBlocksArea = document.createElement('div');
    currentCodeBlocksArea.classList.add('code-blocks-area');
    currentAiTurnContainer.appendChild(currentCodeBlocksArea);

    chatHistory.appendChild(currentAiTurnContainer);
    console.log(`[setupNewAiTurn] Finished setup for Turn ID: ${currentTurnId}.`);
}

// --- Live Rendering ---
function renderLiveMessage(fullContent) {
    if (!currentAiTurnContainer) return;

    if (!firstAnswerTokenReceived && fullContent.trim().length > 0) {
        if (currentAnswerElement && currentAnswerElement.style.display === 'none') {
            currentAnswerElement.style.display = '';
        }
        const loadingDots = currentAnswerElement ? currentAnswerElement.querySelector('.loading-dots') : null;
        if (loadingDots) loadingDots.remove();
        firstAnswerTokenReceived = true;
    }

    const contentArea = currentAnswerElement.querySelector('.live-ai-content-area');
    const codeArea = currentCodeBlocksArea;

    if (!contentArea || !codeArea) return;
    
    parseAndRenderStreamingContent(fullContent, contentArea, codeArea, currentTurnId);
    scrollToBottom('auto');
}

function parseAndRenderAiContent(contentString, answerBubbleContentElement, codeBlocksDivElement, turnIdSuffix) {
    if (!contentString || !answerBubbleContentElement || !codeBlocksDivElement) return;

    const KATEX_PLACEHOLDER_PREFIX_HISTORICAL = `%%HISTORICAL_KATEX_PLACEHOLDER_${turnIdSuffix}_`;

    let contentForProcessing = contentString;
    let historicalCodeBlockCounter = 0;
    const codeBlockRegex = /```(\w*)\n([\s\S]*?)\n```/g;
    const extractedCodeBlocks = [];
    let tempContentForCodeExtraction = contentForProcessing;
    let contentAfterCodeExtraction = "";
    let lastCodeMatchEndIndex = 0;
    let matchCode;

    codeBlocksDivElement.innerHTML = '';

    while ((matchCode = codeBlockRegex.exec(tempContentForCodeExtraction)) !== null) {
        historicalCodeBlockCounter++;
        const language = matchCode[1] || 'plaintext';
        const code = matchCode[2];
        const placeholder = `%%HISTORICAL_CODE_BLOCK_${historicalCodeBlockCounter}%%`;
        extractedCodeBlocks.push({ language, code, placeholder, index: historicalCodeBlockCounter });
        contentAfterCodeExtraction += tempContentForCodeExtraction.substring(lastCodeMatchEndIndex, matchCode.index);
        contentAfterCodeExtraction += placeholder;
        lastCodeMatchEndIndex = codeBlockRegex.lastIndex;
    }
    contentAfterCodeExtraction += tempContentForCodeExtraction.substring(lastCodeMatchEndIndex);
    contentForProcessing = contentAfterCodeExtraction;
    
    extractedCodeBlocks.forEach(block => {
        const newBlockElement = createCodeBlock(block.language, block.code, turnIdSuffix, block.index, codeBlocksDivElement, false);
        const blockId = `code-block-turn${turnIdSuffix}-${block.index}`;
        initializeCodeBlockHistory(blockId, block.code);
        const linkHTML = `<a href="#${blockId}" class="code-block-link text-blue-600 hover:underline">[Code Block ${block.index}]</a>`;
        contentForProcessing = contentForProcessing.replace(block.placeholder, linkHTML);
    });

    const storedKatex = {};
    let katexPlaceholderIndex = 0;
    const katexRegexGlobal = /(?<!\\)\$\$([\s\S]+?)(?<!\\)\$\$|(?<!\\)\$((?:\\\$|[^$])+?)(?<!\\)\$/g;
    let textForMarkdownParsing = contentForProcessing.replace(katexRegexGlobal, (match, displayContent, inlineContent) => {
        const isDisplayMode = !!displayContent;
        const katexString = displayContent || inlineContent;
        const cleanedKatexString = katexString.replace(/\\([$])/g, '$1');
        let katexHtml = '';
        try {
            katexHtml = katex.renderToString(cleanedKatexString, {
                displayMode: isDisplayMode, throwOnError: false, output: "html", strict: false
            });
        } catch (e) {
            katexHtml = `<span class="katex-error" title="${escapeHTML(e.toString())}">${escapeHTML(match)}</span>`;
        }
        const placeholderId = `${KATEX_PLACEHOLDER_PREFIX_HISTORICAL}${katexPlaceholderIndex++}`;
        storedKatex[placeholderId] = katexHtml;
        return placeholderId;
    });

    answerBubbleContentElement.innerHTML = marked.parse(textForMarkdownParsing);

    if (Object.keys(storedKatex).length > 0) {
        const walker = document.createTreeWalker(answerBubbleContentElement, NodeFilter.SHOW_TEXT, null, false);
        let node;
        const textNodesToModify = [];
        while (node = walker.nextNode()) {
            if (node.nodeValue && node.nodeValue.includes(KATEX_PLACEHOLDER_PREFIX_HISTORICAL)) {
                textNodesToModify.push(node);
            }
        }
        textNodesToModify.forEach(textNode => {
            let currentTextValue = textNode.nodeValue;
            const parent = textNode.parentNode;
            if (!parent) return;
            const fragment = document.createDocumentFragment();
            let lastSplitEnd = 0;
            const placeholderScanRegex = new RegExp(`(${KATEX_PLACEHOLDER_PREFIX_HISTORICAL}\\d+)`, 'g');
            let placeholderMatch;
            while((placeholderMatch = placeholderScanRegex.exec(currentTextValue)) !== null) {
                const placeholderId = placeholderMatch[1];
                const matchStartIndex = placeholderMatch.index;
                if (matchStartIndex > lastSplitEnd) {
                    fragment.appendChild(document.createTextNode(currentTextValue.substring(lastSplitEnd, matchStartIndex)));
                }
                if (storedKatex[placeholderId]) {
                    const katexWrapperSpan = document.createElement('span');
                    katexWrapperSpan.innerHTML = storedKatex[placeholderId];
                    fragment.appendChild(katexWrapperSpan.firstChild || katexWrapperSpan);
                } else {
                    fragment.appendChild(document.createTextNode(placeholderId));
                }
                lastSplitEnd = placeholderScanRegex.lastIndex;
            }
            if (lastSplitEnd < currentTextValue.length) {
                fragment.appendChild(document.createTextNode(currentTextValue.substring(lastSplitEnd)));
            }
            parent.replaceChild(fragment, textNode);
        });
    }
}

function parseAndRenderStreamingContent(contentString, answerBubbleContentElement, codeBlocksDivElement, turnIdSuffix) {
    if (!contentString || !answerBubbleContentElement || !codeBlocksDivElement) return;

    const codeBlockRegex = /```(\w*)\n?([\s\S]*?)(?:\n```|$)/g;
    let match;
    let lastIndex = 0;
    let contentWithPlaceholders = '';

    while ((match = codeBlockRegex.exec(contentString)) !== null) {
        const [fullMatch, language, code] = match;
        const isComplete = fullMatch.endsWith('\n```') || fullMatch.endsWith('```');
        const startIndex = match.index;
        
        contentWithPlaceholders += contentString.substring(lastIndex, startIndex);
        
        if (!activeStreamingCodeBlocks.has(startIndex)) {
            streamingCodeBlockCounter++;
            // Use the new, unified function
            const newBlockElement = createCodeBlock(language || 'plaintext', code, turnIdSuffix, streamingCodeBlockCounter, codeBlocksDivElement, true);
            activeStreamingCodeBlocks.set(startIndex, {
                blockId: newBlockElement.id,
                language: language || 'plaintext',
                content: code,
                isComplete: isComplete
            });
        } else {
            const blockData = activeStreamingCodeBlocks.get(startIndex);
            const newLanguage = language || 'plaintext';
            blockData.language = newLanguage;
            blockData.content = code;
            blockData.isComplete = isComplete;
            updateStreamingCodeBlockContent(blockData.blockId, newLanguage, code, isComplete);
        }
        
        const blockData = activeStreamingCodeBlocks.get(startIndex);
        const blockNumber = blockData.blockId.split('-').pop();
        const blockId = `code-block-turn${turnIdSuffix}-${blockNumber}`;
        const linkHTML = `<a href="#${blockId}" class="code-block-link text-blue-600 hover:underline">[Code Block ${blockNumber}]</a>`;
        contentWithPlaceholders += linkHTML;
        lastIndex = codeBlockRegex.lastIndex;
    }
    
    contentWithPlaceholders += contentString.substring(lastIndex);

    const KATEX_PLACEHOLDER_PREFIX_STREAMING = `%%STREAMING_KATEX_PLACEHOLDER_${turnIdSuffix}_`;
    const storedKatex = {};
    let katexPlaceholderIndex = 0;
    
    const katexRegexGlobal = /(?<!\\)\$\$([\s\S]+?)(?<!\\)\$\$|(?<!\\)\$((?:\\\$|[^$])+?)(?<!\\)\$/g;
    let textForMarkdownParsing = contentWithPlaceholders.replace(katexRegexGlobal, (match, displayContent, inlineContent) => {
        const isDisplayMode = !!displayContent;
        const katexString = displayContent || inlineContent;
        const cleanedKatexString = katexString.replace(/\\([$])/g, '$1');
        let katexHtml = '';
        try {
            katexHtml = katex.renderToString(cleanedKatexString, {
                displayMode: isDisplayMode, throwOnError: false, output: "html", strict: false
            });
        } catch (e) {
            katexHtml = `<span class="katex-error" title="${escapeHTML(e.toString())}">${escapeHTML(match)}</span>`;
        }
        const placeholderId = `${KATEX_PLACEHOLDER_PREFIX_STREAMING}${katexPlaceholderIndex++}`;
        storedKatex[placeholderId] = katexHtml;
        return placeholderId;
    });

    answerBubbleContentElement.innerHTML = marked.parse(textForMarkdownParsing);

    if (Object.keys(storedKatex).length > 0) {
        const walker = document.createTreeWalker(answerBubbleContentElement, NodeFilter.SHOW_TEXT, null, false);
        let node;
        const textNodesToModify = [];
        while (node = walker.nextNode()) {
            if (node.nodeValue && node.nodeValue.includes(KATEX_PLACEHOLDER_PREFIX_STREAMING)) {
                textNodesToModify.push(node);
            }
        }
        textNodesToModify.forEach(textNode => {
            let currentTextValue = textNode.nodeValue;
            const parent = textNode.parentNode;
            if (!parent) return;
            const fragment = document.createDocumentFragment();
            let lastSplitEnd = 0;
            const placeholderScanRegex = new RegExp(`(${KATEX_PLACEHOLDER_PREFIX_STREAMING}\\d+)`, 'g');
            let placeholderMatch;
            while((placeholderMatch = placeholderScanRegex.exec(currentTextValue)) !== null) {
                const placeholderId = placeholderMatch[1];
                const matchStartIndex = placeholderMatch.index;
                if (matchStartIndex > lastSplitEnd) {
                    fragment.appendChild(document.createTextNode(currentTextValue.substring(lastSplitEnd, matchStartIndex)));
                }
                if (storedKatex[placeholderId]) {
                    const katexWrapperSpan = document.createElement('span');
                    katexWrapperSpan.innerHTML = storedKatex[placeholderId];
                    fragment.appendChild(katexWrapperSpan.firstChild || katexWrapperSpan);
                } else {
                    fragment.appendChild(document.createTextNode(placeholderId));
                }
                lastSplitEnd = placeholderScanRegex.lastIndex;
            }
            if (lastSplitEnd < currentTextValue.length) {
                fragment.appendChild(document.createTextNode(currentTextValue.substring(lastSplitEnd)));
            }
            parent.replaceChild(fragment, textNode);
        });
    }
}


function updateStreamingCodeBlockContent(blockId, language, content, isComplete) {
    const container = document.getElementById(blockId);
    if (!container) return;

    const codeElement = container.querySelector('code');
    const dotsSpan = container.querySelector('.streaming-dots');
    const titleTextSpan = container.querySelector('.block-title .title-text');
    const currentLanguage = container.dataset.language;

    const rawLang = (language || 'plaintext').trim().toLowerCase();
    const canonicalLang = LANGUAGE_ALIASES[rawLang] || 'plaintext';

    if (canonicalLang && canonicalLang !== currentLanguage) {
        container.dataset.language = canonicalLang;
        if (titleTextSpan) {
            const blockNumber = blockId.split('-').pop();
            titleTextSpan.textContent = `Code Block ${blockNumber} (${canonicalLang})`;
        }
        
        const prismLang = PRISM_LANGUAGE_MAP[canonicalLang] || canonicalLang;
        if (codeElement) {
            codeElement.className = `language-${prismLang}`;
        }

        const runStopBtn = container.querySelector('.run-code-btn');
        if (runStopBtn) {
            const isLanguageSupported = supportedLanguagesConfig[canonicalLang]?.executable;
            if (isLanguageSupported) {
                runStopBtn.style.display = '';
                runStopBtn.title = 'Run Code';
            } else {
                runStopBtn.style.display = 'none';
                runStopBtn.title = `Run Code (language '${canonicalLang}' not supported for execution)`;
            }
        }
        
        initializeCodeBlockHistory(blockId, content);
    }
    
    if (codeElement) {
        const cursorPos = getCursorPosition(codeElement);
        const wasEditing = document.activeElement === codeElement;
        
        codeElement.textContent = content;
        
        if (typeof Prism !== 'undefined' && typeof Prism.highlightElement === 'function') {
            try {
                Prism.highlightElement(codeElement);
                if (wasEditing) {
                    setCursorPosition(codeElement, cursorPos);
                    codeElement.focus();
                }
            } catch (e) {
                console.error(`Prism highlight error:`, e);
            }
        }
        
        if (window.codeBlockHistories && window.codeBlockHistories.has(blockId)) {
            const historyData = window.codeBlockHistories.get(blockId);
            if (historyData.history.length === 1) {
                historyData.history[0] = content;
            }
        }
    }
    
    if (isComplete && dotsSpan) {
        dotsSpan.remove();
    }
}

function updateAllRunButtonStates() {
    document.querySelectorAll('.run-code-btn').forEach(btn => {
        const container = btn.closest('.block-container');
        const lang = container ? container.dataset.language : null;
        const isExecutable = lang ? supportedLanguagesConfig[lang]?.executable : false;

        if (isExecutable && !btn.disabled) {
            btn.disabled = false;
            btn.title = 'Run Code';
        }
    });
}

function createCodeBlock(language, codeContent, turnIdSuffix, codeBlockIndex, codeBlocksAreaElement, isStreaming = false) {
   if (!codeBlocksAreaElement) {
       console.error("createCodeBlock: Code blocks area element is null!");
       return;
   }

   const rawLang = (language || 'plaintext').trim().toLowerCase();
   const canonicalLang = LANGUAGE_ALIASES[rawLang] || 'plaintext';
   const isLanguageSupported = supportedLanguagesConfig[canonicalLang]?.executable;
   const prismLang = PRISM_LANGUAGE_MAP[canonicalLang] || canonicalLang;

   const blockId = `code-block-turn${turnIdSuffix}-${codeBlockIndex}`;
   
   const container = document.createElement('div');
   container.classList.add('block-container');
   container.id = blockId;
   container.dataset.language = canonicalLang;
   container.dataset.originalContent = codeContent;

   const codeHeader = document.createElement('div');
   codeHeader.classList.add('block-header');

   const codeButtonsDiv = document.createElement('div');
   codeButtonsDiv.classList.add('block-buttons');

   const runStopBtn = document.createElement('button');
   runStopBtn.classList.add('run-code-btn', 'block-action-btn');
   runStopBtn.dataset.status = 'idle';
   runStopBtn.innerHTML = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;
   runStopBtn.addEventListener('click', handleRunStopCodeClick);
   runStopBtn.disabled = false;
   runStopBtn.title = 'Run Code';

   if (!isLanguageSupported) {
       runStopBtn.style.display = 'none';
   }

   const restoreBtn = document.createElement('button');
   restoreBtn.classList.add('restore-code-btn', 'block-action-btn');
   restoreBtn.textContent = 'Restore';
   restoreBtn.title = 'Restore Original Code';

   const deleteBtn = document.createElement('button');
   deleteBtn.classList.add('delete-code-btn', 'block-action-btn');
   deleteBtn.textContent = 'Delete';
   deleteBtn.title = 'Delete Code Block';

   const toggleCodeBtn = document.createElement('button');
   toggleCodeBtn.classList.add('toggle-code-btn', 'block-action-btn');
   toggleCodeBtn.textContent = 'Hide';
   toggleCodeBtn.title = 'Show/Hide Code';

   const copyCodeBtn = document.createElement('button');
   copyCodeBtn.classList.add('copy-code-btn', 'block-action-btn');
   copyCodeBtn.textContent = 'Copy';
   copyCodeBtn.title = 'Copy Code';
   
   codeButtonsDiv.appendChild(runStopBtn);
   codeButtonsDiv.appendChild(restoreBtn);
   codeButtonsDiv.appendChild(deleteBtn);
   codeButtonsDiv.appendChild(toggleCodeBtn);
   codeButtonsDiv.appendChild(copyCodeBtn);

   const codeTitle = document.createElement('span');
   codeTitle.classList.add('block-title');
   const titleTextSpan = document.createElement('span');
   titleTextSpan.classList.add('title-text');
   titleTextSpan.textContent = `Code Block ${codeBlockIndex} (${canonicalLang})`;
   codeTitle.appendChild(titleTextSpan);
   
   if (isStreaming) {
       const dotsSpan = document.createElement('span');
       dotsSpan.classList.add('streaming-dots');
       dotsSpan.textContent = '...';
       codeTitle.appendChild(dotsSpan);
   }
   
   codeHeader.appendChild(codeButtonsDiv);
   codeHeader.appendChild(codeTitle);

   const preElement = document.createElement('pre');
   preElement.classList.add('manual');
   const codeElement = document.createElement('code');
   codeElement.className = `language-${prismLang}`;
   codeElement.setAttribute('contenteditable', 'true');
   codeElement.setAttribute('spellcheck', 'false');
   codeElement.textContent = codeContent;

   initializeCodeBlockHistory(blockId, codeContent);

   preElement.appendChild(codeElement);
   container.appendChild(codeHeader);
   container.appendChild(preElement);
   codeBlocksAreaElement.appendChild(container);
   
   toggleCodeBtn.addEventListener('click', () => {
       const isHidden = preElement.classList.toggle('hidden');
       toggleCodeBtn.textContent = isHidden ? 'Show' : 'Hide';
   });

   copyCodeBtn.addEventListener('click', async () => {
       try {
           await navigator.clipboard.writeText(codeElement.textContent || '');
           copyCodeBtn.textContent = 'Copied!';
           setTimeout(() => { copyCodeBtn.textContent = 'Copy'; }, 1500);
       } catch (err) {
           console.error('Failed to copy code: ', err);
       }
   });

   restoreBtn.addEventListener('click', () => {
       const originalContent = container.dataset.originalContent;
       const cursorPos = getCursorPosition(codeElement);
       codeElement.textContent = originalContent;
       
       if (typeof Prism !== 'undefined' && typeof Prism.highlightElement === 'function') {
           try {
               Prism.highlightElement(codeElement);
               setCursorPosition(codeElement, Math.min(cursorPos, originalContent.length));
           } catch (e) {
               console.error(`Prism highlight error:`, e);
           }
       }
       
       saveCodeBlockContent(blockId, originalContent);
   });

   deleteBtn.addEventListener('click', () => {
       if (confirm('Are you sure you want to delete this code block? This action cannot be undone.')) {
           deleteCodeBlock(blockId);
       }
   });
   
   codeElement.addEventListener('keydown', (event) => {
       handleCodeBlockKeydown(event, blockId);
   });

   codeElement.addEventListener('blur', () => {
       const content = codeElement.textContent || '';
       saveCodeBlockContent(blockId, content);
   });

   codeElement.addEventListener('input', () => {
       const cursorPos = getCursorPosition(codeElement);
       const content = codeElement.textContent || '';
       
       setTimeout(() => {
           if (typeof Prism !== 'undefined' && typeof Prism.highlightElement === 'function') {
               try {
                   Prism.highlightElement(codeElement);
                   setCursorPosition(codeElement, cursorPos);
               } catch (e) {
                   console.error(`Prism highlight error:`, e);
               }
           }
       }, 10);
       
       saveCodeBlockState(blockId, content);
   });

   return container;
}

function deleteCodeBlock(blockId) {
    const container = document.getElementById(blockId);
    if (!container) return;
    
    // Clean up sticky header if this block has one
    const header = container.querySelector('.block-header');
    if (header) {
        unstickHeader(header);
    }
    
    // Find and remove the associated output container
    const outputContainer = document.getElementById(`output-for-${blockId}`);
    if (outputContainer) {
        // Clean up sticky header for output container too
        const outputHeader = outputContainer.querySelector('.block-header');
        if (outputHeader) {
            unstickHeader(outputHeader);
        }
        outputContainer.remove();
    }
    
    // Update chat message to indicate deletion
    updateChatMessageForDeletedCodeBlock(blockId);
    
    // Remove the main code block container
    container.remove();
    
    // Clean up from code block histories
    if (window.codeBlockHistories && window.codeBlockHistories.has(blockId)) {
        window.codeBlockHistories.delete(blockId);
    }
    
    // Send deletion message to server
    const sessionId = getSessionIdFromPath();
    if (sessionId && websocket && websocket.readyState === WebSocket.OPEN) {
        websocket.send(JSON.stringify({
            type: 'delete_code_block',
            payload: {
                session_id: sessionId,
                code_block_id: blockId
            }
        }));
    }
}

function updateChatMessageForDeletedCodeBlock(blockId) {
    // Find the code block link in the chat message and replace it with deletion notice
    const codeBlockLinks = document.querySelectorAll(`a[href="#${blockId}"]`);
    
    codeBlockLinks.forEach(link => {
        if (link.classList.contains('code-block-link')) {
            // Replace the link with a deleted indicator
            const deletedSpan = document.createElement('span');
            deletedSpan.className = 'deleted-code-block text-gray-500 italic line-through';
            deletedSpan.textContent = '[Code Block Deleted]';
            deletedSpan.title = `Original code block ${blockId} was deleted`;
            
            // Replace the link with the deleted indicator
            link.parentNode.replaceChild(deletedSpan, link);
        }
    });
}

function saveCodeBlockContent(blockId, content) {
    const container = document.getElementById(blockId);
    if (!container) return;
    
    const language = container.dataset.language;
    const sessionId = getSessionIdFromPath();
    
    if (!sessionId || !websocket || websocket.readyState !== WebSocket.OPEN) {
        return;
    }
    
    websocket.send(JSON.stringify({
        type: 'save_code_content',
        payload: {
            session_id: sessionId,
            code_block_id: blockId,
            language: language,
            code_content: content
        }
    }));
}

function createOutputHeaderHTML(blockNumber, statusText = 'Running...', statusClass = 'running') {
    return `
        <div class="block-buttons">
            <button class="run-code-btn block-action-btn" style="display: none;">Run</button>
            <button class="toggle-output-btn block-action-btn">Hide</button>
            <button class="copy-output-btn block-action-btn">Copy</button>
        </div>
        <span class="block-title">Output Block ${blockNumber}</span>
        <span class="block-status ${statusClass}">${statusText}</span>
    `;
}

async function handleRunStopCodeClick(event) {
    const button = event.currentTarget;
    const container = button.closest('.block-container');
    if (!container) return;

    const codeBlockId = container.id;
    const language = container.dataset.language;
    const codeElement = container.querySelector('code');
    const code = codeElement ? codeElement.textContent || '' : '';

    saveCodeBlockContent(codeBlockId, code);

    let outputContainer = document.getElementById(`output-for-${codeBlockId}`);
    if (!outputContainer) {
        outputContainer = document.createElement('div');
        outputContainer.id = `output-for-${codeBlockId}`;
        outputContainer.className = 'block-container';

        const blockNumber = codeBlockId.split('-').pop();

        const outputHeader = document.createElement('div');
        outputHeader.className = 'block-header';
        outputHeader.innerHTML = createOutputHeaderHTML(blockNumber);
        const outputConsoleDiv = document.createElement('div');
        outputConsoleDiv.className = 'block-output-console';
        const outputPre = document.createElement('pre');
        outputConsoleDiv.appendChild(outputPre);

        outputContainer.appendChild(outputHeader);
        outputContainer.appendChild(outputConsoleDiv);

        container.insertAdjacentElement('afterend', outputContainer);

        outputContainer.querySelector('.toggle-output-btn').addEventListener('click', (e) => {
            const isHidden = outputConsoleDiv.classList.toggle('hidden');
            e.target.textContent = isHidden ? 'Show' : 'Hide';
        });
        outputContainer.querySelector('.copy-output-btn').addEventListener('click', async (e) => {
            try {
                await navigator.clipboard.writeText(outputPre.textContent || '');
                e.target.textContent = 'Copied!';
                setTimeout(() => { e.target.textContent = 'Copy'; }, 1500);
            } catch (err) { console.error('Failed to copy output:', err); }
        });
    } else {
        const outputPre = outputContainer.querySelector('.block-output-console pre, .block-output-console iframe');
        if (outputPre) {
            if (outputPre.tagName === 'IFRAME') {
                const newPre = document.createElement('pre');
                outputPre.parentNode.replaceChild(newPre, outputPre);
            } else {
                outputPre.textContent = '';
                outputPre.innerHTML = '';
                if (outputPre.htmlBuffer) {
                    delete outputPre.htmlBuffer;
                }
            }
        }
        const statusSpan = outputContainer.querySelector('.block-status');
        if (statusSpan) {
            statusSpan.textContent = 'Running...';
            statusSpan.className = 'code-status-span running';
        }
    }
    
    button.dataset.status = 'running';
    button.innerHTML = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><rect width="100" height="100" rx="15"/></svg>`;
    button.title = 'Stop Execution';
    
    if (websocket && websocket.readyState === WebSocket.OPEN) {
        websocket.send(JSON.stringify({
            type: 'run_code',
            payload: { code_block_id: codeBlockId, language: language, code: code }
        }));
        
        setTimeout(() => {
            const outputBlock = document.getElementById(`output-for-${codeBlockId}`);
            if (outputBlock) {
                outputBlock.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
            }
        }, 100);
    } else {
        addErrorMessage("Cannot run code: Not connected to server.");
        button.dataset.status = 'idle';
        button.innerHTML = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;
        button.title = 'Run Code';
    }
}

function updateHeaderStatus(outputContainer, statusText, statusClass) {
    const statusSpan = outputContainer.querySelector('.block-status');
    if (statusSpan) {
        statusSpan.textContent = statusText;
        statusSpan.className = `block-status ${statusClass}`;
    }
    
    const outputHeader = outputContainer.querySelector('.block-header');
    if (outputHeader && outputHeader.classList.contains('header-is-sticky-js')) {
        const stickyId = outputHeader.dataset.stickyId;
        if (stickyId) {
            const stickyClone = document.getElementById(stickyId);
            if (stickyClone) {
                const stickyStatusSpan = stickyClone.querySelector('.block-status');
                if (stickyStatusSpan) {
                    stickyStatusSpan.textContent = statusText;
                    stickyStatusSpan.className = `block-status ${statusClass}`;
                }
            }
        }
    }
}


function addCodeOutput(outputPreElement, streamType, text, language) {
    if (!outputPreElement || !text) return;

    // The language is now passed in directly, so we don't need to guess it from the DOM.
    if (language === 'html' && streamType !== 'stderr') {
        if (!outputPreElement.htmlBuffer) {
            outputPreElement.htmlBuffer = '';
        }
        outputPreElement.htmlBuffer += text;
        return;
    }

    // For all other languages, append the output as text.
    const span = document.createElement('span');
    span.classList.add(streamType === 'stderr' ? 'stderr-output' : 'stdout-output');
    span.textContent = text;
    outputPreElement.appendChild(span);
    outputPreElement.scrollTop = outputPreElement.scrollHeight;
}

function performUndo(blockId) {
    if (!window.codeBlockHistories) return false;
    
    const historyData = window.codeBlockHistories.get(blockId);
    if (!historyData || historyData.currentIndex <= 0) return false;
    
    historyData.currentIndex--;
    const content = historyData.history[historyData.currentIndex];
    
    const container = document.getElementById(blockId);
    if (!container) return false;
    
    const codeElement = container.querySelector('code');
    if (!codeElement) return false;
    
    const cursorPos = getCursorPosition(codeElement);
    codeElement.textContent = content;
    
    if (typeof Prism !== 'undefined' && typeof Prism.highlightElement === 'function') {
        try {
            Prism.highlightElement(codeElement);
            setCursorPosition(codeElement, Math.min(cursorPos, content.length));
        } catch (e) {
            console.error(`Prism highlight error:`, e);
        }
    }
    
    return true;
}

function performRedo(blockId) {
    if (!window.codeBlockHistories) return false;
    
    const historyData = window.codeBlockHistories.get(blockId);
    if (!historyData || historyData.currentIndex >= historyData.history.length - 1) return false;
    
    historyData.currentIndex++;
    const content = historyData.history[historyData.currentIndex];
    
    const container = document.getElementById(blockId);
    if (!container) return false;
    
    const codeElement = container.querySelector('code');
    if (!codeElement) return false;
    
    const cursorPos = getCursorPosition(codeElement);
    codeElement.textContent = content;
    
    if (typeof Prism !== 'undefined' && typeof Prism.highlightElement === 'function') {
        try {
            Prism.highlightElement(codeElement);
            setCursorPosition(codeElement, Math.min(cursorPos, content.length));
        } catch (e) {
            console.error(`Prism highlight error:`, e);
        }
    }
    
    return true;
}

function handleCodeBlockKeydown(event, blockId) {
    const isCtrlZ = event.ctrlKey && event.key === 'z' && !event.shiftKey;
    const isCtrlY = event.ctrlKey && (event.key === 'y' || (event.key === 'z' && event.shiftKey));
    
    if (isCtrlZ) {
        event.preventDefault();
        performUndo(blockId);
        return;
    }
    
    if (isCtrlY) {
        event.preventDefault();
        performRedo(blockId);
        return;
    }
    
    const codeElement = event.target;
    const content = codeElement.textContent || '';
    saveCodeBlockState(blockId, content);
}

function saveCodeBlockState(blockId, content) {
    if (!window.codeBlockHistories) return;
    
    const historyData = window.codeBlockHistories.get(blockId);
    if (!historyData) return;

    clearTimeout(historyData.saveTimeout);
    historyData.saveTimeout = setTimeout(() => {
        const lastContent = historyData.history[historyData.currentIndex];
        if (lastContent !== content) {
            historyData.history = historyData.history.slice(0, historyData.currentIndex + 1);
            historyData.history.push(content);
            
            if (historyData.history.length > 50) {
                historyData.history.shift();
            } else {
                historyData.currentIndex++;
            }
        }
    }, 2000);
}


function handleStructuredMessage(messageData) {
    const { type, payload } = messageData;
    console.log(`[handleStructuredMessage] Processing ${type} for ${payload?.code_block_id || 'unknown'}`);
    
    if (!payload || !payload.code_block_id) return;
    
    const codeBlockId = payload.code_block_id;
    const codeContainer = document.getElementById(codeBlockId);
    const outputBlockId = `output-for-${codeBlockId}`;
    let outputContainer = document.getElementById(outputBlockId);

    console.log(`[handleStructuredMessage] Found container for ${codeBlockId}:`, codeContainer);
    console.log(`[handleStructuredMessage] Found output container for ${outputBlockId}:`, outputContainer);

    if (!outputContainer && type === 'code_output') {
        console.log(`[DEBUG] Creating new output container for ${codeBlockId}`);
        outputContainer = document.createElement('div');
        outputContainer.id = outputBlockId;
        outputContainer.className = 'block-container';

        const blockNumber = codeBlockId.split('-').pop();
        console.log(`[DEBUG] Block number: ${blockNumber}`);

        const outputHeader = document.createElement('div');
        outputHeader.className = 'block-header';
        
        const headerHTML = createOutputHeaderHTML(blockNumber);
        console.log(`[DEBUG] Generated header HTML:`, headerHTML);
        outputHeader.innerHTML = headerHTML;
        console.log(`[DEBUG] Header after innerHTML:`, outputHeader);
        
        const outputConsoleDiv = document.createElement('div');
        outputConsoleDiv.className = 'block-output-console';
        const outputPre = document.createElement('pre');
        outputConsoleDiv.appendChild(outputPre);

        outputContainer.appendChild(outputHeader);
        outputContainer.appendChild(outputConsoleDiv);

        codeContainer.insertAdjacentElement('afterend', outputContainer);

        outputContainer.querySelector('.toggle-output-btn').addEventListener('click', (e) => {
            const isHidden = outputConsoleDiv.classList.toggle('hidden');
            e.target.textContent = isHidden ? 'Show' : 'Hide';
        });
        outputContainer.querySelector('.copy-output-btn').addEventListener('click', async (e) => {
            try {
                await navigator.clipboard.writeText(outputPre.textContent || '');
                e.target.textContent = 'Copied!';
                setTimeout(() => { e.target.textContent = 'Copy'; }, 1500);
            } catch (err) { console.error('Failed to copy output:', err); }
        });
    } else if (outputContainer && type === 'code_output') {
        // Check if existing output container has proper header structure
        const existingStatusSpan = outputContainer.querySelector('.block-status');
        if (!existingStatusSpan) {
            console.log(`[DEBUG] Existing output container missing status span, fixing header...`);
            const existingHeader = outputContainer.querySelector('.block-header');
            if (existingHeader) {
                const blockNumber = codeBlockId.split('-').pop();
                const headerHTML = createOutputHeaderHTML(blockNumber);
                console.log(`[DEBUG] Replacing header HTML with:`, headerHTML);
                existingHeader.innerHTML = headerHTML;
                console.log(`[DEBUG] Header after fix:`, existingHeader);
                
                // Re-add event listeners
                outputContainer.querySelector('.toggle-output-btn').addEventListener('click', (e) => {
                    const outputConsoleDiv = outputContainer.querySelector('.block-output-console');
                    const isHidden = outputConsoleDiv.classList.toggle('hidden');
                    e.target.textContent = isHidden ? 'Show' : 'Hide';
                });
                outputContainer.querySelector('.copy-output-btn').addEventListener('click', async (e) => {
                    try {
                        const outputPre = outputContainer.querySelector('.block-output-console pre');
                        await navigator.clipboard.writeText(outputPre.textContent || '');
                        e.target.textContent = 'Copied!';
                        setTimeout(() => { e.target.textContent = 'Copy'; }, 1500);
                    } catch (err) { console.error('Failed to copy output:', err); }
                });
            }
        }
    }

    if (!outputContainer || !codeContainer) return;
    
    switch (type) {
        case 'code_output': {
            const outputPre = outputContainer.querySelector('.block-output-console pre');
            const language = codeContainer.dataset.language;
            if (outputPre) {
                addCodeOutput(outputPre, payload.stream, payload.data, language);
            }
            break;
        }

        case 'code_waiting_input': {
            updateHeaderStatus(outputContainer, 'Waiting for input...', 'waiting-input');
            const outputPre = outputContainer.querySelector('.block-output-console pre');
            if (outputPre) {
                addTerminalPrompt(outputPre, payload.prompt || '');
            }
            break;
        }

        case 'code_finished': {
            console.log(`[handleStructuredMessage] Processing code_finished for ${codeBlockId}`);
            const runStopBtn = codeContainer.querySelector('.run-code-btn');
            const statusSpan = outputContainer.querySelector('.block-status');
            const outputConsoleDiv = outputContainer.querySelector('.block-output-console');
            const outputPre = outputConsoleDiv ? outputConsoleDiv.querySelector('pre') : null;

            console.log(`[handleStructuredMessage] Found run button:`, runStopBtn);
            console.log(`[handleStructuredMessage] Found status span:`, statusSpan);
            console.log(`[handleStructuredMessage] Found output console div:`, outputConsoleDiv);

            if (!runStopBtn || !statusSpan || !outputConsoleDiv || !outputPre) {
                console.log(`[handleStructuredMessage] Missing elements - runStopBtn: ${!!runStopBtn}, statusSpan: ${!!statusSpan}, outputConsoleDiv: ${!!outputConsoleDiv}, outputPre: ${!!outputPre}`);
                return;
            }

            const { exit_code, error } = payload;
            let finishMessage = '';
            let statusClass = '';
            
            const language = codeContainer.dataset.language;
            const codeElement = codeContainer.querySelector('code');
            const codeContent = codeElement ? codeElement.textContent || '' : '';
            
            let outputContent = null;
            let htmlContent = null;
            
            if (error) {
                finishMessage = 'Failed';
                statusClass = 'error';
                const helpfulHint = error.includes("Docker service is unavailable") 
                    ? "\n\nHint: Is Docker Desktop running?" 
                    : "";
                addCodeOutput(outputPre, 'stderr', `Error: ${error}${helpfulHint}`, language);
                outputContent = outputPre.textContent;
            } else if (language === 'html') {
                const iframe = document.createElement('iframe');
                iframe.className = 'html-render-iframe';
                iframe.style.width = '100%';
                iframe.style.border = '1px solid #e2e8f0';
                iframe.setAttribute('scrolling', 'no');
                iframe.style.overflow = 'hidden';
                iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin');
                
                htmlContent = outputPre.htmlBuffer || '';
                const style = `<style>body { margin: 0; background-color: white; color: black; font-family: sans-serif; padding: 1rem; }</style>`;
                iframe.srcdoc = style + htmlContent;
                
                iframe.onload = () => {
                    try {
                        const iWin = iframe.contentWindow;
                        const iDoc = iWin.document;
                        const updateHeight = () => {
                            if (!iDoc || !iDoc.body) return;
                            const newHeight = Math.max(
                                iDoc.body.scrollHeight, iDoc.documentElement.scrollHeight,
                                iDoc.body.offsetHeight, iDoc.documentElement.offsetHeight
                            );
                            iframe.style.height = `${newHeight}px`;
                        };
                        updateHeight();
                        const observer = new ResizeObserver(updateHeight);
                        if (iDoc.body) observer.observe(iDoc.body);
                        setTimeout(updateHeight, 150);
                        setTimeout(updateHeight, 500);
                    } catch (e) {
                        iframe.style.height = '400px';
                    }
                };
                
                outputPre.replaceWith(iframe);
                outputConsoleDiv.style.maxHeight = 'none';

                finishMessage = `Finished (Rendered HTML)`;
                statusClass = 'success';
            } else {
                finishMessage = `Finished (Exit: ${exit_code})`;
                statusClass = (exit_code === 0) ? 'success' : 'error';
                outputContent = outputPre.textContent;
            }
            
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                const codeBlockParts = codeBlockId.split('-');
                const extractedTurnId = codeBlockParts[2].replace('turn', '');
                
                websocket.send(JSON.stringify({
                    type: 'save_code_result',
                    payload: {
                        code_block_id: codeBlockId,
                        language: language,
                        code_content: codeContent,
                        output_content: outputContent,
                        html_content: htmlContent,
                        exit_code: exit_code,
                        error_message: error,
                        execution_status: error ? 'error' : 'completed',
                        turn_id: parseInt(extractedTurnId)
                    }
                }));
            }
            
            console.log(`[handleStructuredMessage] About to update button status to idle and set finish message: ${finishMessage}`);
            updateHeaderStatus(outputContainer, finishMessage, statusClass);
            runStopBtn.dataset.status = 'idle';
            runStopBtn.innerHTML = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;
            runStopBtn.title = 'Run Code';
            console.log(`[handleStructuredMessage] Button and status updated successfully`);
            break;
        }
    }
}

function renderSingleMessage(msg, parentElement, isHistory = false) {
    if (!parentElement || !msg) return;

    const senderType = msg.sender_type;
    const senderName = msg.sender_name || (senderType === 'ai' ? 'AI' : 'User');
    const timestamp = msg.timestamp;

    if (senderType === 'user' || senderType === 'system') {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message-item', 'p-3', 'rounded-lg', 'max-w-xl', 'mb-2', 'break-words', 'flex', 'flex-col');
        messageDiv.setAttribute('data-sender', senderType);
        if (msg.id) messageDiv.setAttribute('data-message-id', String(msg.id));
        
        if (senderType === 'user') {
            messageDiv.classList.add('bg-emerald-100', 'self-end', 'ml-auto');
        } else {
            messageDiv.classList.add('bg-slate-200', 'self-center', 'mx-auto', 'text-xs', 'italic');
        }

        const senderElem = document.createElement('p');
        senderElem.classList.add('font-semibold', 'text-sm', 'mb-1');
        senderElem.classList.add(senderType === 'user' ? 'text-emerald-700' : 'text-slate-600');
        senderElem.textContent = escapeHTML(senderName);
        messageDiv.appendChild(senderElem);

        const contentElem = document.createElement('div');
        contentElem.classList.add('text-gray-800', 'text-sm', 'message-content');
        let displayedContent = msg.content || '';
        if (senderType === 'user' && displayedContent.startsWith(NO_THINK_PREFIX)) {
            displayedContent = displayedContent.substring(NO_THINK_PREFIX.length);
        }
        contentElem.innerHTML = marked.parse(displayedContent);
        messageDiv.appendChild(contentElem);

        if (timestamp) {
            const timestampElem = document.createElement('p');
            timestampElem.classList.add('text-xs', 'text-slate-500', 'mt-1');
            timestampElem.classList.add(senderType === 'user' ? 'text-right' : 'text-center');
            try {
                timestampElem.textContent = new Date(timestamp).toLocaleString();
            } catch (e) {
                timestampElem.textContent = String(timestamp);
            }
            messageDiv.appendChild(timestampElem);
        }
        parentElement.appendChild(messageDiv);

    } else if (senderType === 'ai') {
        const turnIdSuffix = (msg.turn_id !== null && msg.turn_id !== undefined) ? String(msg.turn_id) : (msg.id ? `msg${msg.id}` : `hist-${Date.now()}`);
        
        const aiTurnContainer = document.createElement('div');
        aiTurnContainer.classList.add('ai-turn-container');
        if (msg.id) aiTurnContainer.setAttribute('data-message-id', String(msg.id));

        const thinkingArea = document.createElement('div');
        thinkingArea.classList.add('thinking-area');
        thinkingArea.style.display = msg.thinking_content ? 'block' : 'none';
        
        const details = document.createElement('details');
        const summary = document.createElement('summary');
        summary.classList.add('thinking-summary');
        summary.innerHTML = `<span class="text">Show Thinking</span><span class="dots"></span>`;
        const thinkingPre = document.createElement('pre');
        thinkingPre.textContent = msg.thinking_content || '';
        details.appendChild(summary);
        details.appendChild(thinkingPre);
        thinkingArea.appendChild(details);

        const answerElement = document.createElement('div');
        answerElement.classList.add('message', 'ai-message', 'p-3', 'rounded-lg', 'max-w-xl', 'mb-2', 'break-words', 'flex', 'flex-col', 'bg-sky-100', 'self-start', 'mr-auto');
        
        const senderElem = document.createElement('p');
        senderElem.classList.add('font-semibold', 'text-sm', 'mb-1', 'text-sky-700');
        senderElem.textContent = 'AI';
        answerElement.appendChild(senderElem);
        
        const contentDiv = document.createElement('div');
        contentDiv.classList.add('text-gray-800', 'text-sm', 'message-content');
        answerElement.appendChild(contentDiv);

        const codeBlocksArea = document.createElement('div');
        codeBlocksArea.classList.add('code-blocks-area');
        
        parseAndRenderAiContent(msg.content, contentDiv, codeBlocksArea, turnIdSuffix);

        if (timestamp) {
            const timestampElem = document.createElement('p');
            timestampElem.classList.add('text-xs', 'text-slate-500', 'mt-1', 'text-left', 'timestamp-p');
            timestampElem.textContent = new Date(timestamp).toLocaleString();
            answerElement.appendChild(timestampElem);
        }

        aiTurnContainer.appendChild(thinkingArea);
        aiTurnContainer.appendChild(answerElement);
        aiTurnContainer.appendChild(codeBlocksArea);
        parentElement.appendChild(aiTurnContainer);
    }
}

function restoreCodeExecutionResult(result) {
    const codeContainer = document.getElementById(result.code_block_id);
    if (!codeContainer) {
        console.log(`Code container not found for ${result.code_block_id}, skipping restore`);
        return;
    }

    const outputBlockId = `output-for-${result.code_block_id}`;
    let outputContainer = document.getElementById(outputBlockId);
    
    if (outputContainer) {
        outputContainer.remove();
    }

    outputContainer = document.createElement('div');
    outputContainer.id = outputBlockId;
    outputContainer.className = 'block-container';

    const blockNumber = result.code_block_id.split('-').pop();

    const outputHeader = document.createElement('div');
    outputHeader.className = 'block-header';
    
    let statusText = '';
    let statusClass = '';
    if (result.error_message) {
        statusText = 'Failed';
        statusClass = 'error';
    } else if (result.language === 'html') {
        statusText = 'Finished (Rendered HTML)';
        statusClass = 'success';
    } else {
        statusText = `Finished (Exit: ${result.exit_code})`;
        statusClass = (result.exit_code === 0) ? 'success' : 'error';
    }
    
    outputHeader.innerHTML = `
        <div class="block-buttons">
            <button class="toggle-output-btn block-action-btn">Hide</button>
            <button class="copy-output-btn block-action-btn">Copy</button>
        </div>
        <span class="block-title">Output Block ${blockNumber}</span>
        <span class="block-status ${statusClass}">${statusText}</span>
    `;
    
    const outputConsoleDiv = document.createElement('div');
    outputConsoleDiv.className = 'block-output-console';
    
    if (result.language === 'html' && result.html_content) {
        const iframe = document.createElement('iframe');
        iframe.className = 'html-render-iframe';
        iframe.style.width = '100%';
        iframe.style.border = '1px solid #e2e8f0';
        iframe.setAttribute('scrolling', 'no');
        iframe.style.overflow = 'hidden';
        iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin');
        
        const style = `<style>body { margin: 0; background-color: white; color: black; font-family: sans-serif; padding: 1rem; }</style>`;
        iframe.srcdoc = style + result.html_content;
        
        iframe.onload = () => {
            try {
                const iWin = iframe.contentWindow;
                const iDoc = iWin.document;
                const updateHeight = () => {
                    if (!iDoc || !iDoc.body) return;
                    const newHeight = Math.max(
                        iDoc.body.scrollHeight, iDoc.documentElement.scrollHeight,
                        iDoc.body.offsetHeight, iDoc.documentElement.offsetHeight
                    );
                    iframe.style.height = `${newHeight}px`;
                };
                updateHeight();
                const observer = new ResizeObserver(updateHeight);
                if (iDoc.body) observer.observe(iDoc.body);
                setTimeout(updateHeight, 150);
                setTimeout(updateHeight, 500);
            } catch (e) {
                iframe.style.height = '400px';
            }
        };
        
        outputConsoleDiv.appendChild(iframe);
        outputConsoleDiv.style.maxHeight = 'none';
    } else {
        const outputPre = document.createElement('pre');
        if (result.output_content) {
            outputPre.textContent = result.output_content;
        }
        outputConsoleDiv.appendChild(outputPre);
    }

    outputContainer.appendChild(outputHeader);
    outputContainer.appendChild(outputConsoleDiv);

    codeContainer.insertAdjacentElement('afterend', outputContainer);

    outputContainer.querySelector('.toggle-output-btn').addEventListener('click', (e) => {
        const isHidden = outputConsoleDiv.classList.toggle('hidden');
        e.target.textContent = isHidden ? 'Show' : 'Hide';
    });
    
    const copyBtn = outputContainer.querySelector('.copy-output-btn');
    copyBtn.addEventListener('click', async (e) => {
        try {
            const textToCopy = result.language === 'html' && result.html_content ? 
                result.html_content : (result.output_content || '');
            await navigator.clipboard.writeText(textToCopy);
            e.target.textContent = 'Copied!';
            setTimeout(() => { e.target.textContent = 'Copy'; }, 1500);
        } catch (err) { 
            console.error('Failed to copy output:', err); 
        }
    });
}

async function loadAndDisplayChatHistory(sessionId) {
    const chatHistoryDiv = document.getElementById('chat-history');
    if (!chatHistoryDiv) {
        console.error("Chat history container 'chat-history' not found.");
        return;
    }

    streamingCodeBlockCounter = 0;

    chatHistoryDiv.innerHTML = '<p class="text-center text-gray-500 p-4">Loading history...</p>'; 

    try {
        const response = await fetch(`/api/sessions/${sessionId}/messages`);
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ detail: "Failed to load chat history." }));
            console.error(`Error fetching chat history for session ${sessionId}:`, response.status, errorData.detail);
            chatHistoryDiv.innerHTML = `<p class="text-center text-red-500 p-4">Error loading history: ${escapeHTML(errorData.detail || response.statusText)}</p>`;
            return;
        }

        const messages = await response.json();
        
        const codeResultsResponse = await fetch(`/api/sessions/${sessionId}/code-results`);
        const codeResults = codeResultsResponse.ok ? await codeResultsResponse.json() : [];
        
        chatHistoryDiv.innerHTML = '';

        if (messages.length === 0) {
            chatHistoryDiv.innerHTML = '<p class="text-center text-gray-500 p-4">No messages in this session yet. Start chatting!</p>';
        } else {
            messages.forEach(msg => {
                renderSingleMessage(msg, chatHistoryDiv, true);
            });

            codeResults.forEach(result => {
                restoreCodeExecutionResult(result);
            });

            if (typeof Prism !== 'undefined' && typeof Prism.highlightAll === 'function') {
                Prism.highlightAll();
            }

            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight; 
        }
        console.log(`Successfully loaded ${messages.length} messages for session ${sessionId}.`);

    } catch (error){
        console.error(`Failed to fetch or display chat history for session ${sessionId}:`, error);
        chatHistoryDiv.innerHTML = `<p class="text-center text-red-500 p-4">An unexpected error occurred while loading history. Check console.</p>`;
    }
}

// --- WebSocket Connection ---
function resetAllCodeButtonsOnErrorOrClose() {
    console.log("Resetting all code run/stop buttons and statuses due to connection issue.");
    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;

    document.querySelectorAll('.block-container').forEach(container => {
        const button = container.querySelector('.run-code-btn');
        const outputHeader = container.querySelector('.block-header');
        const statusSpan = outputHeader ? outputHeader.querySelector('.block-status') : null;

        if (button && button.dataset.status !== 'idle') {
            button.dataset.status = 'idle';
            button.innerHTML = playIconSvg;
            button.title = 'Run Code';
            button.disabled = false;
        }
        if (statusSpan) {
            if (!statusSpan.classList.contains('idle') && !statusSpan.classList.contains('success')) {
                if (outputHeader) outputHeader.style.display = 'flex';
                statusSpan.textContent = 'Error: Disconnected';
                statusSpan.className = 'code-status-span error';
            }
        }
    });
}

// ADD THIS ENTIRE BLOCK OF HELPER FUNCTIONS

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

function stickHeader(header, scrollerRect) {
    if (!header || header.classList.contains('header-is-sticky-js')) return;
    
    const container = header.parentElement;
    const containerRect = container.getBoundingClientRect();
    const stickyId = `sticky-${header.classList[0]}-${Date.now()}`;
    
    if (document.getElementById(stickyId)) return;
    
    const stickyClone = header.cloneNode(true);
    stickyClone.id = stickyId;
    stickyClone.style.position = 'fixed';
    stickyClone.style.top = `${scrollerRect.top}px`;
    stickyClone.style.left = `${containerRect.left}px`;
    stickyClone.style.width = `${containerRect.width}px`;
    stickyClone.style.zIndex = '1000';
    stickyClone.style.backgroundColor = '#e5e7eb';
    stickyClone.style.borderRadius = '0';
    stickyClone.style.boxShadow = 'none';
    stickyClone.style.overflow = 'hidden';
    
    const originalButtons = header.querySelectorAll('button');
    const cloneButtons = stickyClone.querySelectorAll('button');
    
    cloneButtons.forEach((cloneBtn, index) => {
        const originalBtn = originalButtons[index];
        if (originalBtn) {
            cloneBtn.disabled = originalBtn.disabled;
            cloneBtn.className = originalBtn.className;
            cloneBtn.innerHTML = originalBtn.innerHTML;
            cloneBtn.dataset.status = originalBtn.dataset.status;
            
            cloneBtn.onclick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                originalBtn.click();
            };
            
            const syncButton = () => {
                cloneBtn.disabled = originalBtn.disabled;
                cloneBtn.className = originalBtn.className;
                cloneBtn.innerHTML = originalBtn.innerHTML;
                cloneBtn.dataset.status = originalBtn.dataset.status;
            };
            
            const observer = new MutationObserver(syncButton);
            observer.observe(originalBtn, { 
                attributes: true, 
                attributeFilter: ['class', 'disabled', 'data-status'],
                childList: true,
                subtree: true
            });
            
            cloneBtn._syncObserver = observer;
        }
    });
    
    document.body.appendChild(stickyClone);
    header.classList.add('header-is-sticky-js');
    header.dataset.stickyId = stickyId;
}

function unstickHeader(header) {
    if (!header || !header.classList.contains('header-is-sticky-js')) return;

    const stickyId = header.dataset.stickyId;
    if (stickyId) {
        const stickyClone = document.getElementById(stickyId);
        if (stickyClone) {
            // Clean up button observers
            const cloneButtons = stickyClone.querySelectorAll('button');
            cloneButtons.forEach(btn => {
                if (btn._syncObserver) {
                    btn._syncObserver.disconnect();
                    delete btn._syncObserver;
                }
            });
            
            // NEW: Clean up status observer
            const cloneStatusSpan = stickyClone.querySelector('.block-status');
            if (cloneStatusSpan && cloneStatusSpan._syncObserver) {
                cloneStatusSpan._syncObserver.disconnect();
                delete cloneStatusSpan._syncObserver;
            }
            
            stickyClone.remove();
        }
    }

    header.classList.remove('header-is-sticky-js');
    delete header.dataset.stickyId;
}

function finalizeTurnOnErrorOrClose() {
    if (currentAnswerElement && !currentAnswerElement.querySelector('.timestamp-p')) {
        const timestampElem = document.createElement('p');
        timestampElem.classList.add('text-xs', 'text-slate-500', 'mt-1', 'text-left', 'timestamp-p');
        timestampElem.textContent = new Date().toLocaleString();
        currentAnswerElement.appendChild(timestampElem);
    }
    
    // Clean up streaming dots from any active code blocks
    activeStreamingCodeBlocks.forEach((blockData) => {
        const container = document.getElementById(blockData.blockId);
        if (container) {
            const dotsSpan = container.querySelector('.streaming-dots');
            if (dotsSpan) dotsSpan.remove();
        }
    });
    
    // Reset state
    codeBlockCounterThisTurn = 0;
    accumulatedAnswerText = '';
    hasThinkingContentArrivedThisTurn = false;
    firstAnswerTokenReceived = false;
    thinkingRequestedForCurrentTurn = false;
    activeStreamingCodeBlocks.clear();
    streamingCodeBlockCounter = 0;
    
    setInputDisabledState(false, false);
    if (messageInput && messageInput.offsetParent !== null) {
        messageInput.focus();
    }
}

function connectWebSocket() {
    let sessionId = getSessionIdFromPath();
    if (!sessionId) {
        addErrorMessage("Cannot connect to chat: Invalid session ID in URL.");
        setInputDisabledState(true);
        return;
    }
    
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${window.location.host}/ws/${sessionId}/${clientId}`;
    console.log(`[WebSocket] Attempting to connect: ${wsUrl}`);

    try {
        const ws = new WebSocket(wsUrl);
        websocket = ws;

        ws.onopen = () => {
            console.log("[WebSocket] Connection opened.");
            setInputDisabledState(false, false);
            addSystemMessage("Connected to the chat server.");
            updateAllRunButtonStates();
            if (messageInput) messageInput.focus();
        };

        ws.onclose = (event) => {
            if (window.isNavigatingAway) return;
            console.log("WebSocket connection closed.", event);
            addSystemMessage(`Connection closed: ${event.reason || 'Normal closure'} (Code: ${event.code})`);
            finalizeTurnOnErrorOrClose();
            resetAllCodeButtonsOnErrorOrClose();
            updateAllRunButtonStates();
            const noReconnectCodes = [1000, 1005, 1008, 1011];
            if (!noReconnectCodes.includes(event.code)) {
                addSystemMessage("Attempting to reconnect...");
                setInputDisabledState(true, false);
                setTimeout(connectWebSocket, 3000);
            } else {
                setInputDisabledState(true, false);
            }
        };

        ws.onerror = (event) => {
            console.error("WebSocket error:", event);
            addErrorMessage("WebSocket connection error. Please try refreshing.");
            finalizeTurnOnErrorOrClose();
            resetAllCodeButtonsOnErrorOrClose();
            updateAllRunButtonStates();
            setInputDisabledState(true, false);
        };

        ws.onmessage = (event) => {
            let messageData;
            try {
                messageData = JSON.parse(event.data);
                console.log("[WebSocket] Received structured message:", messageData); // ADD THIS
            } catch (e) {
                messageData = null;
            }

            if (messageData && messageData.type) {
                console.log("[WebSocket] Handling structured message type:", messageData.type); // ADD THIS
                handleStructuredMessage(messageData);
            } else {
                const chunk = event.data;
                if (chunk === "<EOS>" || chunk === "<EOS_STOPPED>") {
                    console.log(`%c[WebSocket] Received ${chunk}. Finalizing turn.`, 'color: green; font-weight: bold;');
                    renderLiveMessage(accumulatedAnswerText);
                    finalizeTurnOnErrorOrClose();
                    return;
                }
                if (chunk.startsWith("<ERROR>")) {
                    addErrorMessage(chunk.substring(7));
                    finalizeTurnOnErrorOrClose();
                    return;
                }
                if (!currentAiTurnContainer && chunk.trim().length > 0) {
                    setupNewAiTurn();
                }
                accumulatedAnswerText += chunk;
                renderLiveMessage(accumulatedAnswerText);
            }
        };
    } catch (error) {
        console.error("WebSocket creation error:", error);
        addErrorMessage(`WebSocket Creation Error: ${error.message}.`);
        setInputDisabledState(true, false);
        updateAllRunButtonStates();
    }
}

document.addEventListener('DOMContentLoaded', async () => {
    await loadLanguagesConfig();
    await initializeCurrentUser();

    setInputDisabledState(true, false);

    if (typeof marked !== 'undefined' && typeof marked.setOptions === 'function') {
        marked.setOptions({
            gfm: true, breaks: true, sanitize: false, smartLists: true, smartypants: false,
        });
    }

    if (chatForm && messageInput && sendButton && stopAiButton) {
        chatForm.addEventListener('submit', (event) => {
            event.preventDefault();
            const userMessage = messageInput.value.trim();
            if (!userMessage) return;
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                addErrorMessage("Not connected to the server.");
                return;
            }
            
            try {
                addUserMessage(userMessage);
                thinkingRequestedForCurrentTurn = thinkCheckbox ? thinkCheckbox.checked : false;
                let messageTextForPayload;
                if (thinkingRequestedForCurrentTurn) {
                    messageTextForPayload = THINK_PREFIX + userMessage.replace(NO_THINK_PREFIX, '').replace(THINK_PREFIX, '');
                } else {
                    messageTextForPayload = NO_THINK_PREFIX + userMessage.replace(NO_THINK_PREFIX, '').replace(THINK_PREFIX, '');
                }
                
                setupNewAiTurn();
                
                const messagePayload = {
                    type: "chat_message",
                    payload: {
                        user_input: messageTextForPayload,
                        turn_id: currentTurnId 
                    }
                };
                websocket.send(JSON.stringify(messagePayload));
                
                messageInput.value = '';
                setInputDisabledState(true, true);
            } catch (sendError) {
                addErrorMessage(`Failed to send message: ${sendError.message}`);
            }
        });

        if (chatHistory) {
            chatHistory.addEventListener('click', (event) => {
                const target = event.target.closest('a.code-block-link');
                if (!target) {
                    return;
                }

                event.preventDefault();
                const targetId = target.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);

                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        }

        stopAiButton.addEventListener('click', () => {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                addErrorMessage("Cannot stop: Not connected.");
                return;
            }
            const sessionId = getSessionIdFromPath();
            if (!sessionId) {
                addErrorMessage("Cannot stop: Session ID not found.");
                return;
            }
            websocket.send(JSON.stringify({
                type: "stop_ai_stream",
                payload: {
                    client_id: clientId,
                    session_id: sessionId,
                    turn_id: currentTurnId 
                }
            }));
            stopAiButton.disabled = true;
            finalizeTurnOnErrorOrClose();
        });

    } else {
        if (window.location.pathname.includes("/chat/")) {
            addErrorMessage("Initialization Error: Chat input components missing.");
        }
    }

    const currentSessionId = getSessionIdFromPath();
    if (currentSessionId) {
        await loadAndDisplayChatHistory(currentSessionId);
        connectWebSocket();
    } else {
        if (messageInput) {
            setInputDisabledState(true, false);
        }
    }

    const chatHistoryScroller = document.getElementById('chat-history');
    if (chatHistoryScroller) {
        let rafId = null;
        const handleScroll = function() {
            if (rafId) cancelAnimationFrame(rafId);
            rafId = requestAnimationFrame(function() {
                const scrollerRect = chatHistoryScroller.getBoundingClientRect();
                const containers = chatHistoryScroller.querySelectorAll('.block-container');

                const measurements = [];
                containers.forEach(function(container) {
                    const header = container.querySelector('.block-header, .block-header');
                    const content = container.querySelector('pre, .block-output-console');
                    
                    if (header && content) {
                        measurements.push({
                            header: header,
                            headerRect: header.getBoundingClientRect(),
                            contentRect: content.getBoundingClientRect(),
                            container: container
                        });
                    }
                });

                measurements.forEach(function(m) {
                    const shouldStick = m.headerRect.top < scrollerRect.top && m.contentRect.bottom > scrollerRect.top;
                    
                    if (shouldStick) {
                        stickHeader(m.header, scrollerRect);
                        
                        // Handle clipping when approaching the bottom of content
                        const stickyId = m.header.dataset.stickyId;
                        if (stickyId) {
                            const stickyClone = document.getElementById(stickyId);
                            if (stickyClone) {
                                const headerHeight = stickyClone.offsetHeight;
                                const contentBottom = m.contentRect.bottom;
                                const viewportTop = scrollerRect.top + 1; // Add 1px offset
                                
                                // Calculate how much space is available for the header (add 2px buffer)
                                const availableSpace = contentBottom - viewportTop + 3;
                                
                                if (availableSpace < headerHeight && availableSpace > 0) {
                                    // Clip the header from the top by moving it up and adjusting height
                                    const clipAmount = headerHeight - availableSpace - 1;
                                    stickyClone.style.top = `${viewportTop - clipAmount - 1}px`; // Move up by clip amount
                                    stickyClone.style.clipPath = `inset(${clipAmount}px 0 0 0)`; // Clip from top
                                    stickyClone.style.height = `${headerHeight}px`; // Keep original height for proper clipping
                                    stickyClone.style.borderBottomLeftRadius = '0.375rem';
                                    stickyClone.style.borderBottomRightRadius = '0.375rem';
                                } else if (availableSpace <= 2) {
                                    // Content has scrolled completely past, hide the sticky header
                                    stickyClone.style.display = 'none';
                                } else {
                                    // Normal case: full header visible
                                    stickyClone.style.height = 'auto';
                                    stickyClone.style.top = `${scrollerRect.top}px`; // Use original viewport top without offset
                                    stickyClone.style.display = 'flex';
                                    stickyClone.style.clipPath = 'none'; // Reset clipping
                                    stickyClone.style.borderBottomLeftRadius = '0';
                                    stickyClone.style.borderBottomRightRadius = '0';
                                }
                            }
                        }
                    } else {
                        unstickHeader(m.header);
                    }
                });
            });
        };

        chatHistoryScroller.addEventListener('scroll', function(e) {
            // Only handle scroll if it's specifically from the chat history scroller
            if (e.target === chatHistoryScroller) {
                handleScroll();
            }
        }, { passive: true });
            }
});

=== app/static/session-choice.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to Tesseracs Chat</title>
    <link rel="stylesheet" href="/dist/input.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <script id="csrf-token-script-page-session-choice">
      // This placeholder will be replaced by the server with the actual raw CSRF token.
      window.csrfTokenRaw = "%%CSRF_TOKEN_RAW%%";
    </script>
    <script>
      // Optional immediate diagnostic client-side to verify token injection
      if (typeof window.csrfTokenRaw !== 'undefined' && window.csrfTokenRaw !== "%%CSRF_TOKEN_RAW%%") {
        console.log('SESSION CHOICE PAGE JS (after csrf-token-script): window.csrfTokenRaw is available.');
      } else {
        console.warn('SESSION CHOICE PAGE JS (after csrf-token-script): window.csrfTokenRaw IS STILL THE PLACEHOLDER "%%CSRF_TOKEN_RAW%%" OR UNDEFINED. Value:', window.csrfTokenRaw);
      }
    </script> 
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="flex h-screen overflow-hidden">
        <aside id="sidebar-loader-target" class="w-64 bg-gray-800 text-gray-200 flex flex-col overflow-hidden shrink-0">
            </aside>

        <main id="session-choice-content" class="flex-1 flex flex-col p-6 overflow-y-auto items-center justify-center">
            <div class="bg-white p-8 rounded-lg shadow-xl text-center max-w-lg">
                <h1 class="text-3xl font-bold text-gray-800 mb-4">Welcome to Tesseracs Chat, [User Name]!</h1>
                <p class="text-gray-600 mb-6">
                    Select an existing session from the sidebar to continue your conversations,
                    or click "New Chat" in the sidebar to start a fresh one.
                </p>
                <p class="text-gray-500 text-sm">
                    Engage in dynamic chat sessions, powered by advanced AI. Your discussions are saved and can be revisited anytime.
                </p>
            </div>
            <div class="mt-10 text-center">
                <h2 class="text-xl font-semibold text-gray-700 mb-3">About Tesseracs</h2>
                <p class="text-gray-600">
                    Tesseracs Chat is designed for seamless and intelligent conversations. <br/>
                    Manage your chat sessions efficiently and collaborate with AI.
                </p>
            </div>
        </main>
    </div>

    <script type="module">
        import { loadSidebarHTML, populateSessionList } from '/static/js/app-ui.js'; // Ensure setupSidebarCSRF is called within/after loadSidebarHTML

        document.addEventListener('DOMContentLoaded', async () => {
            console.log("Session Choice Page (Welcome Page): DOMContentLoaded. Attempting to load UI components.");
            const sidebarContainer = document.getElementById('sidebar-loader-target');
            if (!sidebarContainer) {
                console.error("Session Choice Page: Sidebar container 'sidebar-loader-target' not found!");
                return;
            }
            
            const sidebarLoaded = await loadSidebarHTML('/static/_sidebar.html', 'sidebar-loader-target');
            
            if (sidebarLoaded) {
                // The setupSidebarCSRF() call should ideally be part of loadSidebarHTML's success logic
                // or called immediately after if loadSidebarHTML is synchronous in its DOM update.
                const sessionListElement = document.getElementById('session-list');
                 if (sessionListElement) {
                    await populateSessionList('/api/sessions', 'session-list', '/chat/');
                } else {
                    console.error("Session Choice Page: Session list element 'session-list' not found after sidebar load.");
                }
            } else {
                console.error("Session Choice Page: Sidebar loading failed. Session list will not be populated.");
            }
        });
    </script>
    </body>
</html>

=== app/static/settings.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>User Settings - Tesseracs Chat</title>
    <link rel="stylesheet" href="/dist/input.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <script id="csrf-token-script-page-settings">
      // This placeholder will be replaced by the server with the actual raw CSRF token.
      window.csrfTokenRaw = "%%CSRF_TOKEN_RAW%%";
    </script>
    <script>
      // Optional immediate diagnostic client-side to verify token injection
      if (typeof window.csrfTokenRaw !== 'undefined' && window.csrfTokenRaw !== "%%CSRF_TOKEN_RAW%%") {
        console.log('SETTINGS PAGE JS (after csrf-token-script): window.csrfTokenRaw is available.');
      } else {
        console.warn('SETTINGS PAGE JS (after csrf-token-script): window.csrfTokenRaw IS STILL THE PLACEHOLDER "%%CSRF_TOKEN_RAW%%" OR UNDEFINED. Value:', window.csrfTokenRaw);
      }
    </script>    
    <style>
        .sidebar-scrollable { overflow-y: auto; scrollbar-width: thin; scrollbar-color: #a0aec0 #edf2f7; }
        .sidebar-scrollable::-webkit-scrollbar { width: 6px; }
        .sidebar-scrollable::-webkit-scrollbar-track { background: #edf2f7; border-radius: 3px; }
        .sidebar-scrollable::-webkit-scrollbar-thumb { background-color: #a0aec0; border-radius: 3px; border: 1px solid #edf2f7; }
        /* Additional styles for focused state or loading states if needed */
        input:read-only, select:disabled {
            background-color: #f3f4f6; /* Tailwind gray-100 */
            cursor: not-allowed;
            opacity: 0.7;
        }
        label {
            user-select: none;
        }
    </style>
</head>
<body class="font-inter bg-gray-100 text-gray-800">

    <div class="flex h-screen overflow-hidden">
        <aside id="sidebar-loader-target" class="w-64 bg-gray-800 text-gray-200 flex flex-col overflow-hidden">
            </aside>

        <main class="flex-1 flex flex-col overflow-y-auto p-6 items-center">
            <div class="bg-white p-6 md:p-8 rounded-lg shadow-xl w-full max-w-2xl lg:max-w-3xl"> <h1 class="text-2xl lg:text-3xl font-semibold text-gray-900 mb-6 border-b border-gray-200 pb-4">User Settings</h1>

                <div id="settings-message-area" class="p-3 rounded-md text-sm text-center mb-4" style="display: none;" role="alert" aria-live="polite"></div>

                <section id="account-settings" aria-labelledby="account-settings-heading" class="mb-8">
                    <h2 id="account-settings-heading" class="text-xl font-semibold text-gray-700 mb-5">Account Information</h2>
                    
                    <form id="update-name-form" class="space-y-4 mb-6">
                        <div class="mb-4">
                            <label for="current-name" class="block text-sm font-medium text-gray-700 mb-1">Current Name</label>
                            <input type="text" id="current-name" name="current-name" readonly
                                   class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm"
                                   placeholder="Loading...">
                        </div>
                        <div class="mb-4">
                            <label for="new-name" class="block text-sm font-medium text-gray-700 mb-1">New Name</label>
                            <input type="text" id="new-name" name="new_name" required autocomplete="name"
                                   class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:outline-none transition-colors duration-150"
                                   minlength="1" maxlength="100">
                        </div>
                        <div class="mb-4">
                            <label for="current-password-for-name" class="block text-sm font-medium text-gray-700 mb-1">Current Password <span class="text-gray-500">(to confirm name change)</span></label>
                            <input type="password" id="current-password-for-name" name="current_password" required autocomplete="current-password"
                                   class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:outline-none transition-colors duration-150">
                        </div>
                        <div>
                            <button type="submit" id="update-name-button"
                                    class="py-2.5 px-5 bg-blue-600 text-white rounded-md font-medium text-sm transition-colors duration-150 hover:bg-blue-700 focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:bg-gray-400 disabled:cursor-not-allowed">
                                Update Name
                            </button>
                        </div>
                    </form>

                    <div class="mt-6 pt-6 border-t border-gray-200">
                        <h3 class="text-lg font-medium text-gray-700 mb-3">Change Email</h3>
                        <p class="text-sm text-gray-500 mb-3" id="change-email-description">You will be logged out after successfully changing your email address.</p>
                        <form id="update-email-form" class="space-y-4 mb-6" aria-describedby="change-email-description">
                            <div class="mb-4">
                                <label for="current-email" class="block text-sm font-medium text-gray-700 mb-1">Current Email</label>
                                <input type="email" id="current-email" name="current-email" readonly
                                       class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm"
                                       placeholder="Loading...">
                            </div>
                            <div class="mb-4">
                                <label for="new-email" class="block text-sm font-medium text-gray-700 mb-1">New Email Address</label>
                                <input type="email" id="new-email" name="new_email" required autocomplete="email"
                                       class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:outline-none transition-colors duration-150">
                            </div>
                            <div class="mb-4">
                                <label for="current-password-for-email" class="block text-sm font-medium text-gray-700 mb-1">Current Password <span class="text-gray-500">(to confirm email change)</span></label>
                                <input type="password" id="current-password-for-email" name="current_password" required autocomplete="current-password"
                                       class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:outline-none transition-colors duration-150">
                            </div>
                            <div>
                                <button type="submit" id="update-email-button"
                                        class="py-2.5 px-5 bg-blue-600 text-white rounded-md font-medium text-sm transition-colors duration-150 hover:bg-blue-700 focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:bg-gray-400 disabled:cursor-not-allowed">
                                    Update Email Address
                                </button>
                            </div>
                        </form>
                    </div>

                    <div class="mt-6 pt-6 border-t border-gray-200">
                        <h3 class="text-lg font-medium text-gray-700 mb-3">Regenerate Password</h3>
                        <p class="text-sm text-gray-500 mb-3" id="regenerate-password-description">A new password will be generated and emailed to your current email address. You will be logged out after this action.</p>
                        <form id="regenerate-password-form" class="space-y-4" aria-describedby="regenerate-password-description">
                            <div class="mb-4">
                                <label for="current-password-for-regen" class="block text-sm font-medium text-gray-700 mb-1">Current Password <span class="text-gray-500">(to confirm password regeneration)</span></label>
                                <input type="password" id="current-password-for-regen" name="current_password" required autocomplete="current-password"
                                       class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:outline-none transition-colors duration-150">
                            </div>
                            <div>
                                <button type="submit" id="regenerate-password-button"
                                        class="py-2.5 px-5 bg-orange-600 text-white rounded-md font-medium text-sm transition-colors duration-150 hover:bg-orange-700 focus:ring-2 focus:ring-orange-500 focus:ring-offset-2 disabled:bg-gray-400 disabled:cursor-not-allowed">
                                    Regenerate Password & Send Email
                                </button>
                            </div>
                        </form>
                    </div>
                </section>

                <section id="llm-settings" class="mt-8 pt-6 border-t border-gray-200" aria-labelledby="llm-settings-heading">
                    <h2 id="llm-settings-heading" class="text-xl font-semibold text-gray-700 mb-5">LLM Configuration</h2>
                    <form id="llm-settings-form" class="space-y-4">
                        <div class="mb-4">
                            <label for="llm-provider" class="block text-sm font-medium text-gray-700 mb-1">Chat Provider</label>
                            <select id="llm-provider" name="selected_llm_provider_id"
                                    class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm bg-white focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:outline-none transition-colors duration-150"
                                    aria-describedby="llm-provider-status">
                                <option value="">Loading providers...</option>
                            </select>
                            <p id="llm-provider-status" class="text-xs text-gray-500 mt-1"></p>
                        </div>

                        <div class="mb-4">
                            <label for="llm-model" class="block text-sm font-medium text-gray-700 mb-1">Model</label>
                            <select id="llm-model" name="selected_llm_model_id"
                                    class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm bg-white focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:outline-none transition-colors duration-150"
                                    disabled> <option value="">Select a provider first</option>
                            </select>
                        </div>

                        <div id="llm-api-key-group" class="mb-4" style="display: none;" aria-hidden="true">
                            <label for="llm-api-key" class="block text-sm font-medium text-gray-700 mb-1">API Key</label>
                            <input type="password" id="llm-api-key" name="user_llm_api_key" autocomplete="off"
                                   class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:outline-none transition-colors duration-150"
                                   placeholder="Leave blank to use system key or if not required"
                                   aria-describedby="llm-api-key-status">
                            <p id="llm-api-key-status" class="text-xs text-gray-500 mt-1"></p>
                        </div>

                        <div id="llm-base-url-group" class="mb-4" style="display: none;" aria-hidden="true">
                            <label for="llm-base-url" class="block text-sm font-medium text-gray-700 mb-1">Custom Base URL <span class="text-gray-500">(Optional)</span></label>
                            <input type="url" id="llm-base-url" name="selected_llm_base_url" autocomplete="off"
                                   class="w-full py-2.5 px-4 border border-gray-300 rounded-md text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:outline-none transition-colors duration-150"
                                   placeholder="e.g., http://localhost:11434/v1"
                                   aria-describedby="llm-base-url-description">
                               <p id="llm-base-url-description" class="text-xs text-gray-500 mt-1">Typically for OpenAI-compatible servers or custom Ollama instances.</p>
                        </div>
                        <div>
                            <button type="submit" id="save-llm-settings-button"
                                    class="py-2.5 px-5 bg-blue-600 text-white rounded-md font-medium text-sm transition-colors duration-150 hover:bg-blue-700 focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:bg-gray-400 disabled:cursor-not-allowed">
                                Save LLM Settings
                            </button>
                        </div>
                    </form>
                </section>
            </div>
        </main>
    </div>

    <script type="module" src="/static/js/settings.js"></script>
    </body>
</html>

=== app/static/email_templates/password_reset_email.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Password Reset - Tesseracs Chat</title>
    <style>
        body {
            font-family: 'Inter', Arial, sans-serif;
            line-height: 1.6;
            color: #333333;
            margin: 0;
            padding: 0;
            background-color: #f7fafc;
        }
        .email-container {
            width: 100%;
            max-width: 600px;
            margin: 20px auto;
            background-color: #ffffff;
            padding: 25px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }
        .header {
            text-align: center;
            padding-bottom: 20px;
            border-bottom: 1px solid #edf2f7;
        }
        .header h2 {
            color: #2c5282;
            margin: 0;
            font-size: 24px;
            font-weight: 600;
        }
        .content {
            padding-top: 10px;
        }
        .content p {
            margin: 18px 0;
            font-size: 16px;
            color: #4a5568;
        }
        .content strong {
            color: #2b6cb0;
            font-weight: 500;
        }
        .password-display-container {
            margin: 25px 0;
            text-align: center;
        }
        .password-label {
            font-size: 16px;
            color: #4a5568;
            margin-bottom: 8px;
            display: block;
        }
        .password-value {
            background-color: #edf2f7;
            padding: 15px 20px;
            border-radius: 6px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.2em;
            text-align: center;
            color: #1a202c;
            border: 1px solid #cbd5e0;
            display: inline-block;
            letter-spacing: 1px;
            word-break: break-all;
        }
        .login-button-container {
            text-align: center;
            margin: 30px 0;
        }
        .login-button {
            display: inline-block;
            background-color: #3182ce;
            color: #ffffff !important;
            padding: 14px 28px;
            text-decoration: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.2s ease-in-out;
        }
        .login-button:hover {
            background-color: #2b6cb0;
        }
        .footer {
            text-align: center;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #edf2f7;
            font-size: 0.875em;
            color: #718096;
        }
        .link {
            color: #3182ce;
            text-decoration: none;
        }
        .link:hover {
            text-decoration: underline;
        }
        .url-display { /* Style for displaying the URL as text */
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            color: #718096; /* Tailwind gray-600 */
            word-break: break-all;
        }
    </style>
</head>
<body>
    <div class="email-container">
        <div class="header">
            <h2>Password Reset for Tesseracs Chat</h2>
        </div>
        <div class="content">
            <p>Hello {{ recipient_name }},</p>
            <p>As requested, your password for Tesseracs Chat has been reset.</p>
            <p>Your email: <strong>{{ email }}</strong></p>
            <div class="password-display-container">
                <span class="password-label">Your new password is:</span>
                <div class="password-value">{{ password }}</div>
            </div>
            <p>Please use this new password to log in. You can log in here:</p>
            <div class="login-button-container">
                <a href="{{ login_url }}" class="login-button">Log In to Tesseracs Chat</a>
            </div>
            <p>If the button doesn't work, you can also <a href="{{ login_url }}" class="link">click here to log in</a> or copy and paste the following URL into your browser: <br><span class="url-display">{{ login_url }}</span></p>
            <p>If you did not request a password reset, please contact support or secure your account immediately.</p>
        </div>
        <div class="footer">
            <p>Thanks,<br>The Tesseracs Chat Team</p>
            <p><small>This is an automated message. Please do not reply directly to this email.</small></p>
        </div>
    </div>
</body>
</html>


=== app/static/email_templates/registration_email.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to Tesseracs Chat</title>
    <style>
        body {
            font-family: 'Inter', Arial, sans-serif;
            line-height: 1.6;
            color: #333333;
            margin: 0;
            padding: 0;
            background-color: #f7fafc; /* Tailwind gray-100 */
        }
        .email-container {
            width: 100%;
            max-width: 600px;
            margin: 20px auto;
            background-color: #ffffff;
            padding: 25px;
            border: 1px solid #e2e8f0; /* Tailwind gray-300 */
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }
        .header {
            text-align: center;
            padding-bottom: 20px;
            border-bottom: 1px solid #edf2f7; /* Tailwind gray-200 */
        }
        .header h2 {
            color: #2c5282; /* Tailwind blue-800 */
            margin: 0;
            font-size: 24px;
            font-weight: 600;
        }
        .content {
            padding-top: 10px;
        }
        .content p {
            margin: 18px 0;
            font-size: 16px;
            color: #4a5568; /* Tailwind gray-700 */
        }
        .content strong {
            color: #2b6cb0; /* Tailwind blue-700 */
            font-weight: 500;
        }
        .password-display-container {
            margin: 25px 0;
            text-align: center;
        }
        .password-label {
            font-size: 16px;
            color: #4a5568; /* Tailwind gray-700 */
            margin-bottom: 8px;
            display: block;
        }
        .password-value {
            background-color: #edf2f7; /* Tailwind gray-200 */
            padding: 15px 20px;
            border-radius: 6px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.2em;
            text-align: center;
            color: #1a202c; /* Tailwind gray-900 */
            border: 1px solid #cbd5e0; /* Tailwind gray-400 */
            display: inline-block;
            letter-spacing: 1px;
            word-break: break-all;
        }
        .login-button-container {
            text-align: center;
            margin: 30px 0;
        }
        .login-button {
            display: inline-block;
            background-color: #3182ce; /* Tailwind blue-500 */
            color: #ffffff !important;
            padding: 14px 28px;
            text-decoration: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.2s ease-in-out;
        }
        .login-button:hover {
            background-color: #2b6cb0; /* Tailwind blue-600 */
        }
        .footer {
            text-align: center;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #edf2f7; /* Tailwind gray-200 */
            font-size: 0.875em; /* text-sm */
            color: #718096; /* Tailwind gray-600 */
        }
        .link {
            color: #3182ce; /* Tailwind blue-500 */
            text-decoration: none;
        }
        .link:hover {
            text-decoration: underline;
        }
        .url-display { /* Style for displaying the URL as text */
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            color: #718096; /* Tailwind gray-600 */
            word-break: break-all;
        }
    </style>
</head>
<body>
    <div class="email-container">
        <div class="header">
            <h2>Welcome to Tesseracs Chat, {{ recipient_name }}!</h2>
        </div>
        <div class="content">
            <p>Your account has been successfully created.</p>
            <p>Your email: <strong>{{ email }}</strong></p>
            <div class="password-display-container">
                <span class="password-label">Your password is:</span>
                <div class="password-value">{{ password }}</div>
            </div>
            <p>Please use this password to log in. You can log in here:</p>
            <div class="login-button-container">
                <a href="{{ login_url }}" class="login-button">Log In to Tesseracs Chat</a>
            </div>
            <p>If the button doesn't work, you can also <a href="{{ login_url }}" class="link">click here to log in</a> or copy and paste the following URL into your browser: <br><span class="url-display">{{ login_url }}</span></p>
            <p>Please keep this password secure. While you cannot choose your own password, you can regenerate a new secure password at any time from the user settings page after logging in.</p>
            <p>If you did not request this account, please ignore this email.</p>
        </div>
        <div class="footer">
            <p>Thanks,<br>The Tesseracs Chat Team</p>
            <p><small>This is an automated message. Please do not reply directly to this email.</small></p>
        </div>
    </div>
</body>
</html>

=== app/static/js/app-ui.js ===
// static/js/app-ui.js

window.isNavigatingAway = false;

function setupSidebarCSRF() {
    const sidebarCsrfField = document.getElementById('sidebar_csrf_token');
    const newChatButton = document.getElementById('new-chat-button-sidebar'); // For disabling/enabling

    // First, ensure the critical CSRF input field exists.
    if (!sidebarCsrfField) {
        console.error("app-ui.js: CRITICAL - CSRF token input field 'sidebar_csrf_token' NOT FOUND in the sidebar HTML. 'New Chat' functionality will be impaired or fail.");
        if (newChatButton) {
            newChatButton.disabled = true;
            newChatButton.title = "Error: Security component missing. Cannot create new chat.";
        }
        // alert("A critical security component for creating new chats is missing. Please refresh or contact support if this persists.");
        return; // Stop execution if the field isn't there; nothing more to do.
    }

    // If the field exists, attempt to populate it.
    if (window.csrfTokenRaw && 
        typeof window.csrfTokenRaw === 'string' && 
        window.csrfTokenRaw !== "%%CSRF_TOKEN_RAW%%" && 
        window.csrfTokenRaw.trim() !== "") {
        
        sidebarCsrfField.value = window.csrfTokenRaw;
        console.log("app-ui.js: Sidebar CSRF token field ('sidebar_csrf_token') populated successfully.");
        if (newChatButton) {
            newChatButton.disabled = false; // Ensure button is enabled as token is available
            newChatButton.title = "Start a new chat session"; // Reset title
        }
    } else {
        // The field exists, but the global CSRF token is invalid or missing.
        console.warn("app-ui.js: window.csrfTokenRaw is invalid, placeholder, or empty. CSRF token for sidebar form cannot be populated. Value of window.csrfTokenRaw:", window.csrfTokenRaw);
        sidebarCsrfField.value = ""; // Ensure the field is empty if the token is bad
        if (newChatButton) {
            newChatButton.disabled = true; // Disable button if token is missing/invalid
            newChatButton.title = "New Chat disabled: Security token missing or invalid. Please refresh the page.";
        }
        // alert("A security token required for creating a new chat is missing or invalid. Please try refreshing the page. If the issue persists, contact support.");
    }
}

/**
 * Loads HTML content (like a sidebar) from a given path into a target element.
 * Also sets up CSRF token for forms within the loaded HTML and handles
 * the "New Chat" form submission via AJAX.
 * @param {string} sidebarHtmlPath - Path to the HTML file to load (e.g., '/static/_sidebar.html').
 * @param {string} targetElementId - ID of the DOM element to load the HTML into.
 * @returns {Promise<boolean>} - True if successful, false otherwise.
 */
export async function loadSidebarHTML(sidebarHtmlPath = '/static/_sidebar.html', targetElementId = 'sidebar-loader-target') {
    const sidebarTarget = document.getElementById(targetElementId);
    if (!sidebarTarget) {
        console.error(`app-ui.js: Sidebar target element with ID '${targetElementId}' not found.`);
        return false;
    }
    try {
        const response = await fetch(sidebarHtmlPath); // Fetch the static _sidebar.html
        if (!response.ok) {
            console.error(`app-ui.js: Failed to fetch sidebar HTML from ${sidebarHtmlPath}. Status: ${response.status}`);
            sidebarTarget.innerHTML = `<p class="p-4 text-red-400">Error loading sidebar (status: ${response.status}).</p>`;
            return false;
        }
        const sidebarHTML = await response.text();
        sidebarTarget.innerHTML = sidebarHTML;
        console.log(`app-ui.js: Sidebar HTML successfully loaded from ${sidebarHtmlPath} into #${targetElementId}`);

        // Setup CSRF for the loaded sidebar form AFTER injecting HTML
        // This function (setupSidebarCSRF) should populate the #sidebar_csrf_token input field
        setupSidebarCSRF();

        // --- MODIFIED PART: Handle "New Chat" form submission with AJAX ---
        const newChatFormSidebar = document.getElementById('new-chat-form-sidebar');
        const sidebarCsrfTokenInput = document.getElementById('sidebar_csrf_token'); // The hidden input
        const newChatButton = document.getElementById('new-chat-button-sidebar');

        if (newChatFormSidebar && sidebarCsrfTokenInput && newChatButton) {
            newChatFormSidebar.addEventListener('submit', async function(event) {
                event.preventDefault(); // Prevent default HTML form submission

                const rawCsrfToken = sidebarCsrfTokenInput.value;

                if (!rawCsrfToken || rawCsrfToken === "%%CSRF_TOKEN_RAW%%" || rawCsrfToken.trim() === "") {
                    alert("A security token for creating new chats is missing or invalid. Please refresh the page.");
                    console.error("New Chat submission: CSRF token from sidebar_csrf_token input is missing or placeholder:", rawCsrfToken);
                    return;
                }

                newChatButton.disabled = true;
                newChatButton.innerHTML = `
                    <svg class="animate-spin h-5 w-5 mr-2 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    Creating...`;

                try {
                    const fetchResponse = await fetch('/sessions/create', { // The form's action attribute
                        method: 'POST', // The form's method attribute
                        headers: {
                            'X-CSRF-Token': rawCsrfToken // Send the raw token in the header
                            // Content-Type is not strictly necessary for an empty POST body,
                            // but if issues arise, 'application/x-www-form-urlencoded' could be added.
                            // However, the server endpoint /sessions/create doesn't expect other form data.
                        }
                        // No body is sent, as the original form only contained the CSRF token for this purpose.
                    });

                    if (fetchResponse.ok) {
                        // The server responds with HTTP 303 See Other,
                        // fetch with redirect: 'follow' (default) should handle this.
                        // The browser will navigate to the URL specified in the Location header.
                        if (fetchResponse.redirected) {
                            window.location.href = fetchResponse.url;
                        } else {
                            // If for some reason it wasn't redirected (e.g. server didn't send 303 or Location)
                            // or if the status is OK but not a redirect (e.g. 200 with JSON URL)
                            // We might need to manually parse a redirect URL if the server sends one in JSON.
                            // For now, assume the 303 redirect will be followed.
                            // If the server sends Location header, browser handles it.
                            // If not, a page reload or navigation to '/' might be a fallback.
                            console.warn("New chat creation was successful, but no redirect occurred client-side. Server status:", fetchResponse.status);
                            // Attempt to get location header if browser didn't auto-redirect
                            const locationHeader = fetchResponse.headers.get('Location');
                            if (locationHeader) {
                                window.location.href = locationHeader;
                            } else {
                                window.location.href = '/'; // Fallback to home/session choice
                            }
                        }
                    } else {
                        const errorData = await fetchResponse.json().catch(() => ({ 
                            detail: `Failed to create new chat. Server responded with status: ${fetchResponse.status}` 
                        }));
                        console.error('Failed to create new chat session:', errorData.detail);
                        alert(`Error creating new chat: ${errorData.detail}`);
                        newChatButton.disabled = false;
                        newChatButton.innerHTML = `
                            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
                            New Chat`;
                    }
                } catch (error) {
                    console.error('Network error or other issue trying to create new chat session:', error);
                    alert('An error occurred while creating the new chat session. Please check your network connection and try again.');
                    newChatButton.disabled = false;
                    newChatButton.innerHTML = `
                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
                        New Chat`;
                }
            });
        } else {
            console.warn("app-ui.js: 'New Chat' form or its CSRF input field was not found after sidebar load. AJAX submission not configured.");
        }
        // --- END OF MODIFIED PART ---
        
        return true;
    } catch (error) {
        console.error('app-ui.js: Could not load sidebar due to an error:', error);
        sidebarTarget.innerHTML = '<p class="p-4 text-red-400">Error loading sidebar content (exception).</p>';
        return false;
    }
}

export async function handleDeleteSession(sessionId, sessionName, apiEndpointForList, listElementId, chatPageBaseUrl) {
    if (!window.confirm(`Are you sure you want to delete the session "${sessionName}"? This action cannot be undone.`)) {
        return;
    }

    console.log(`app-ui.js: Attempting to delete session: ${sessionId}`);
    
    // *** ADDED DETAILED LOGGING FOR window.csrfTokenRaw ***
    const currentTokenValue = window.csrfTokenRaw;
    const isPlaceholder = currentTokenValue === "%%CSRF_TOKEN_RAW%%";
    const isEmptyOrWhitespace = !currentTokenValue || currentTokenValue.trim() === "";

    console.log(`app-ui.js (handleDeleteSession): Checking CSRF token. 
        Value: '${currentTokenValue}'
        Is Placeholder: ${isPlaceholder}
        Is Undefined/Null/Empty/Whitespace: ${isEmptyOrWhitespace}`);

    if (!currentTokenValue || isPlaceholder || isEmptyOrWhitespace) {
        console.error(`app-ui.js: CSRF token is missing or invalid. Cannot proceed with delete operation. 
            Raw Value: '${currentTokenValue}', 
            Is Placeholder: ${isPlaceholder}, 
            Is Empty: ${isEmptyOrWhitespace}`);
        alert("Error: Could not perform action: CSRF token not found. Please refresh the page.");
        return;
    }

    try {
        const response = await fetch(`/api/sessions/${sessionId}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': currentTokenValue // Use the validated token
            }
        });

        if (response.status === 204) {
            console.log(`app-ui.js: Session ${sessionId} successfully deleted from server.`);
            const currentPath = window.location.pathname;
            const base = chatPageBaseUrl.endsWith('/') ? chatPageBaseUrl : chatPageBaseUrl + '/';
            const deletedSessionPath = `${base}${sessionId}`;

            if (currentPath === deletedSessionPath || currentPath === `${deletedSessionPath}/`) {
                window.location.href = '/'; 
            } else {
                await populateSessionList(apiEndpointForList, listElementId, chatPageBaseUrl);
            }
        } else {
            const errorData = await response.json().catch(() => ({ detail: `Failed to delete session. Server responded with status: ${response.status}` }));
            console.error(`app-ui.js: Failed to delete session ${sessionId}. Status: ${response.status}`, errorData);
            alert(`Error deleting session: ${errorData.detail || response.statusText || `Status ${response.status}`}`);
        }
    } catch (error) {
        console.error('app-ui.js: Error during delete session request:', error);
        alert('An error occurred while trying to delete the session. Please check the console for details.');
    }
}

/**
 * Fetches and populates the list of user sessions in the sidebar.
 * @param {string} apiEndpoint - API endpoint to fetch sessions (e.g., '/api/sessions').
 * @param {string} listElementId - ID of the ul element to populate.
 * @param {string} chatPageBaseUrl - Base URL for constructing chat page links (e.g., '/chat/').
 */
export async function populateSessionList(apiEndpoint = '/api/sessions', listElementId = 'session-list', chatPageBaseUrl = '/chat/') {
    const sessionListElement = document.getElementById(listElementId);
    if (!sessionListElement) {
        console.error(`app-ui.js: Session list element with ID '${listElementId}' not found.`);
        return;
    }
    sessionListElement.innerHTML = '<li class="px-3 py-1 text-gray-400 italic text-sm">Loading sessions...</li>';

    try {
        console.log(`app-ui.js: Fetching sessions from: ${apiEndpoint}`);
        const response = await fetch(apiEndpoint); // GET request, no CSRF header needed for this

        if (!response.ok) {
            const errorText = await response.text().catch(() => "Unknown server error");
            console.error(`app-ui.js: Failed to fetch sessions from ${apiEndpoint}. Status: ${response.status}. Response: ${errorText}`);
            sessionListElement.innerHTML = `<li class="px-3 py-1 text-red-400 text-sm">Error loading sessions (status: ${response.status}).</li>`;
            return; // Stop further processing
        }
        
        const sessions = await response.json();
        if (!Array.isArray(sessions)) {
            console.error(`app-ui.js: Data from ${apiEndpoint} is not an array:`, sessions);
            sessionListElement.innerHTML = '<li class="px-3 py-1 text-red-400 text-sm">Error: Invalid session data format.</li>';
            return; // Stop further processing
        }

        if (sessions.length === 0) {
            sessionListElement.innerHTML = '<li class="px-3 py-1 text-gray-400 text-sm italic">No active sessions found.</li>';
        } else {
            sessionListElement.innerHTML = ''; // Clear "Loading..." or previous list
            sessions.forEach(session => {
                if (!session.id || typeof session.name === 'undefined') { // Check for essential properties
                    console.warn('app-ui.js: Session object is missing id or name:', session);
                    return; // Skip this malformed session entry
                }

                const listItem = document.createElement('li');
                // Added group for hover effects on children (like the delete button)
                listItem.className = 'flex items-center justify-between pr-2 group hover:bg-gray-700 rounded-md transition-colors duration-100';

                const link = document.createElement('a');
                const base = chatPageBaseUrl.endsWith('/') ? chatPageBaseUrl : chatPageBaseUrl + '/';
                link.href = `${base}${session.id}`;
                
                // Apply active state styling if this session's link matches the current page path
                const currentPath = window.location.pathname;
                const isActive = currentPath === link.pathname || currentPath === `${link.pathname}/`;
                
                link.className = `block pl-3 pr-1 py-2 text-gray-300 group-hover:text-white rounded-l-md text-sm truncate flex-grow ${isActive ? 'bg-gray-700 text-white font-semibold' : 'hover:text-white'}`;
                if (isActive) {
                    listItem.classList.add('bg-gray-700'); // Highlight the whole li item if active
                }
                
                let lastActiveDisplay = "Never";
                if (session.last_active) {
                    try {
                        // Format date for better readability; toLocaleString can be verbose
                        const date = new Date(session.last_active);
                        lastActiveDisplay = `${date.toLocaleDateString()} ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
                    } catch (e) {
                        console.warn("app-ui.js: Could not parse last_active date:", session.last_active, e);
                        lastActiveDisplay = session.last_active; // show raw if parsing fails
                    }
                }
                link.title = `${session.name || 'Unnamed Session'}\nLast active: ${lastActiveDisplay}`;
                link.textContent = session.name || `Session ${session.id.substring(0, 8)}...`;
                
                const deleteButton = document.createElement('button');
                deleteButton.innerHTML = '&#x2715;'; // Multiplication X, a common delete symbol
                deleteButton.className = 'ml-2 p-1 text-gray-500 hover:text-red-400 focus:outline-none rounded-full hover:bg-gray-600 transition-colors duration-150 ease-in-out text-xs opacity-0 group-hover:opacity-100 focus:opacity-100 flex-shrink-0'; 
                deleteButton.title = `Delete session: ${session.name || 'Unnamed Session'}`;
                deleteButton.setAttribute('aria-label', `Delete session: ${session.name || 'Unnamed Session'}`);
                
                deleteButton.onclick = (event) => {
                    event.preventDefault(); // Prevent link navigation if button is somehow inside <a> or form
                    event.stopPropagation(); // Prevent triggering link navigation or other parent events
                    handleDeleteSession(session.id, session.name || 'Unnamed Session', apiEndpoint, listElementId, base);
                };

                listItem.appendChild(link);
                listItem.appendChild(deleteButton);
                sessionListElement.appendChild(listItem);
            });
        }
        console.log(`app-ui.js: Session list successfully populated from ${apiEndpoint} with ${sessions.length} sessions.`);

    } catch (error) {
        console.error('app-ui.js: Error populating session list:', error);
        if (sessionListElement) { // Check again in case it became null
            sessionListElement.innerHTML = `<li class="px-3 py-1 text-red-400 text-sm">Could not load sessions. Error: ${error.message || 'Unknown error'}</li>`;
        }
    }
}

=== app/static/js/settings.js ===
// app/static/js/settings.js
import { loadSidebarHTML, populateSessionList } from '/static/js/app-ui.js';

/**
 * Retrieves a cookie value by its name.
 * @param {string} name The name of the cookie to retrieve.
 * @returns {string|null} The cookie value, or null if not found.
 */
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            // Does this cookie string begin with the name we want?
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

document.addEventListener('DOMContentLoaded', async () => {
    console.log("Settings Page: DOMContentLoaded.");

    // Ensure sidebar is scrollable using the class defined in input.css
    const sidebarLoaderTarget = document.getElementById('sidebar-loader-target');
    if (sidebarLoaderTarget) {
        sidebarLoaderTarget.classList.add('sidebar-scrollable');
    }

    const sidebarLoaded = await loadSidebarHTML('/static/_sidebar.html', 'sidebar-loader-target');
    if (sidebarLoaded) {
        await populateSessionList('/api/sessions', 'session-list', '/chat/');
    } else {
        console.error("Settings Page: Sidebar loading failed.");
    }

    const settingsMessageArea = document.getElementById('settings-message-area');

    /**
     * Displays a message in the settings message area and focuses it.
     * @param {string} message The message to display.
     * @param {string} type The type of message ('info', 'success', 'error').
     * @param {number} duration Time in ms to display the message (0 for indefinite).
     * @param {HTMLElement|null} elementToFocusAfter An optional element to return focus to after message timeout.
     */
    function showSettingsMessage(message, type = 'info', duration = 0, elementToFocusAfter = null) {
        settingsMessageArea.textContent = message;
        settingsMessageArea.className = 'py-3 px-4 rounded-md text-center mb-4 text-sm'; // Reset classes
        if (type === 'success') {
            settingsMessageArea.classList.add('bg-green-100', 'text-green-800', 'border', 'border-green-300');
        } else if (type === 'error') {
            settingsMessageArea.classList.add('bg-red-100', 'text-red-800', 'border', 'border-red-300');
        } else { // 'info' or default
            settingsMessageArea.classList.add('bg-blue-100', 'text-blue-700', 'border', 'border-blue-300');
        }
        settingsMessageArea.style.display = 'block';

        settingsMessageArea.setAttribute('tabindex', '-1');
        settingsMessageArea.focus();

        if (duration > 0) {
            setTimeout(() => {
                settingsMessageArea.style.display = 'none';
                settingsMessageArea.removeAttribute('tabindex');
                if (elementToFocusAfter && typeof elementToFocusAfter.focus === 'function') {
                    elementToFocusAfter.focus();
                }
            }, duration);
        }
    }

    const currentNameInput = document.getElementById('current-name');
    const currentEmailInput = document.getElementById('current-email');

    async function fetchCurrentUser() {
        try {
            const response = await fetch('/api/me', { cache: 'no-store' });
            if (response.ok) {
                const userData = await response.json();
                if (currentNameInput) currentNameInput.value = userData.name;
                if (currentEmailInput) currentEmailInput.value = userData.email;
                window.currentUserDetails = userData;
            } else {
                showSettingsMessage('Could not load your current user details.', 'error', 0, document.body);
                if (currentNameInput) currentNameInput.value = 'Error loading';
                if (currentEmailInput) currentEmailInput.value = 'Error loading';
            }
        } catch (error) {
            console.error("Error fetching current user:", error);
            showSettingsMessage('An error occurred while loading your details.', 'error', 0, document.body);
        }
    }
    await fetchCurrentUser();

    // --- Account Settings Forms (Keep existing logic for these) ---
    const updateNameForm = document.getElementById('update-name-form');
    if (updateNameForm) {
        const newNameInput = document.getElementById('new-name');
        updateNameForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            settingsMessageArea.style.display = 'none';
            const updateNameButton = document.getElementById('update-name-button');
            updateNameButton.disabled = true;
            updateNameButton.textContent = 'Updating...';
            const newName = newNameInput.value;
            const currentPasswordForName = document.getElementById('current-password-for-name');
            const currentPassword = currentPasswordForName.value;
            // Use window.csrfTokenRaw which should be populated by the server
            const csrfToken = window.csrfTokenRaw; 
            let focusTargetAfterMessage = newNameInput;

            if (!csrfToken || csrfToken === "%%CSRF_TOKEN_RAW%%") {
                showSettingsMessage('CSRF token missing. Cannot update name. Please refresh.', 'error', 0, updateNameButton);
                updateNameButton.disabled = false;
                updateNameButton.textContent = 'Update Name';
                return;
            }

            try {
                const response = await fetch('/api/me/update-name', {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': csrfToken
                    },
                    body: JSON.stringify({ new_name: newName, current_password: currentPassword })
                });
                const result = await response.json();
                if (response.ok) {
                    showSettingsMessage(result.message || 'Name updated successfully!', 'success', 3000, newNameInput);
                    if (currentNameInput) currentNameInput.value = result.new_name;
                    currentPasswordForName.value = '';
                    newNameInput.value = '';
                } else {
                    focusTargetAfterMessage = result.field === 'current_password' ? currentPasswordForName : newNameInput;
                    showSettingsMessage(result.detail || 'Failed to update name.', 'error', 0, focusTargetAfterMessage);
                }
            } catch (error) {
                console.error("Error updating name:", error);
                showSettingsMessage('An error occurred. Please try again.', 'error', 0, newNameInput);
            } finally {
                updateNameButton.disabled = false;
                updateNameButton.textContent = 'Update Name';
            }
        });
    }

    const updateEmailForm = document.getElementById('update-email-form');
    if (updateEmailForm) {
        const newEmailInput = document.getElementById('new-email');
        updateEmailForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            settingsMessageArea.style.display = 'none';
            const updateEmailButton = document.getElementById('update-email-button');
            updateEmailButton.disabled = true;
            updateEmailButton.textContent = 'Updating Email...';
            const newEmail = newEmailInput.value;
            const currentPasswordForEmail = document.getElementById('current-password-for-email');
            const currentPassword = currentPasswordForEmail.value;
            const csrfToken = window.csrfTokenRaw; // Use window.csrfTokenRaw
            let focusTargetAfterMessage = newEmailInput;

            if (!csrfToken || csrfToken === "%%CSRF_TOKEN_RAW%%") {
                showSettingsMessage('CSRF token missing. Cannot update email. Please refresh.', 'error', 0, updateEmailButton);
                updateEmailButton.disabled = false;
                updateEmailButton.textContent = 'Update Email Address';
                return;
            }

            try {
                const response = await fetch('/api/me/update-email', {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': csrfToken
                    },
                    body: JSON.stringify({ new_email: newEmail, current_password: currentPassword })
                });
                const result = await response.json();
                if (response.ok) {
                    showSettingsMessage(result.message || 'Email updated. Logging out...', 'success', 0);
                    setTimeout(() => { window.location.href = '/logout'; }, 4000);
                } else {
                    focusTargetAfterMessage = result.field === 'current_password' ? currentPasswordForEmail : newEmailInput;
                    showSettingsMessage(result.detail || 'Failed to update email.', 'error', 0, focusTargetAfterMessage);
                    updateEmailButton.disabled = false;
                    updateEmailButton.textContent = 'Update Email Address';
                }
            } catch (error) {
                console.error("Error updating email:", error);
                showSettingsMessage('An error occurred. Please try again.', 'error', 0, newEmailInput);
                updateEmailButton.disabled = false;
                updateEmailButton.textContent = 'Update Email Address';
            }
        });
    }

    const regeneratePasswordForm = document.getElementById('regenerate-password-form');
    if (regeneratePasswordForm) {
        const currentPasswordForRegen = document.getElementById('current-password-for-regen');
        regeneratePasswordForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            settingsMessageArea.style.display = 'none';
            const regeneratePasswordButton = document.getElementById('regenerate-password-button');
            regeneratePasswordButton.disabled = true;
            regeneratePasswordButton.textContent = 'Regenerating...';
            const currentPassword = currentPasswordForRegen.value;
            const csrfToken = window.csrfTokenRaw; // Use window.csrfTokenRaw

            if (!csrfToken || csrfToken === "%%CSRF_TOKEN_RAW%%") {
                showSettingsMessage('CSRF token missing. Cannot regenerate password. Please refresh.', 'error', 0, regeneratePasswordButton);
                regeneratePasswordButton.disabled = false;
                regeneratePasswordButton.textContent = 'Regenerate Password & Send Email';
                return;
            }

            try {
                const response = await fetch('/api/me/regenerate-password', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': csrfToken
                    },
                    body: JSON.stringify({ current_password: currentPassword })
                });
                const result = await response.json();
                if (response.ok) {
                    showSettingsMessage(result.message || 'Password regenerated. Check email. Logging out...', 'success', 0);
                    setTimeout(() => { window.location.href = '/logout'; }, 4000);
                } else {
                    showSettingsMessage(result.detail || 'Failed to regenerate password.', 'error', 0, currentPasswordForRegen);
                    regeneratePasswordButton.disabled = false;
                    regeneratePasswordButton.textContent = 'Regenerate Password & Send Email';
                }
            } catch (error) {
                console.error("Error regenerating password:", error);
                showSettingsMessage('An error occurred. Please try again.', 'error', 0, currentPasswordForRegen);
                regeneratePasswordButton.disabled = false;
                regeneratePasswordButton.textContent = 'Regenerate Password & Send Email';
            }
        });
    }

    // --- LLM Settings Functionality ---
    const llmProviderSelect = document.getElementById('llm-provider');
    const llmModelSelect = document.getElementById('llm-model');
    const llmApiKeyGroup = document.getElementById('llm-api-key-group');
    const llmApiKeyInput = document.getElementById('llm-api-key');
    const llmApiKeyStatus = document.getElementById('llm-api-key-status');
    const llmBaseUrlGroup = document.getElementById('llm-base-url-group');
    const llmBaseUrlInput = document.getElementById('llm-base-url');
    const llmProviderStatus = document.getElementById('llm-provider-status');
    const saveLLMSettingsButton = document.getElementById('save-llm-settings-button');
    const llmSettingsForm = document.getElementById('llm-settings-form');

    let availableProvidersData = []; // To store fetched provider details, including their models

    /**
     * Loads initial LLM configuration data: available providers and current user's LLM settings.
     * Populates the provider dropdown and sets initial values for other fields.
     */
    async function loadLLMConfigData() {
        if (!llmProviderSelect || !llmModelSelect) {
            console.error("LLM configuration select elements not found in the DOM.");
            return;
        }
        try {
            // Fetch all available providers and their details (including models)
            const providersResponse = await fetch('/api/llm/providers');
            if (!providersResponse.ok) {
                showSettingsMessage('Failed to load LLM providers configuration.', 'error', 0, llmProviderSelect);
                llmProviderSelect.innerHTML = '<option value="">Error loading providers</option>';
                llmModelSelect.innerHTML = '<option value="">-- Select Provider First --</option>';
                llmModelSelect.disabled = true;
                return;
            }
            availableProvidersData = await providersResponse.json(); // Store for later use

            // Fetch the current user's saved LLM settings
            const userSettingsResponse = await fetch('/api/me/llm-settings', { cache: 'no-store' });
            const currentUserLLMSettings = userSettingsResponse.ok ? await userSettingsResponse.json() : {};
            
            if (!userSettingsResponse.ok && availableProvidersData.length > 0) {
                showSettingsMessage('Could not load your saved LLM settings. Defaults may be shown.', 'error', 4000, llmProviderSelect);
            }

            // Populate the providers dropdown
            populateLLMProviders(currentUserLLMSettings.selected_llm_provider_id);

            // Set the initially selected provider (if any)
            const effectiveProviderId = currentUserLLMSettings.selected_llm_provider_id || "";
            if (llmProviderSelect.querySelector(`option[value="${effectiveProviderId}"]`)) {
                 llmProviderSelect.value = effectiveProviderId;
            } else {
                llmProviderSelect.value = ""; // Default to "Select Provider"
            }
           

            // Update model dropdown and other fields based on the (potentially) selected provider
            updateModelDropdown(llmProviderSelect.value, currentUserLLMSettings.selected_llm_model_id, currentUserLLMSettings);
            updateProviderSpecificFields(llmProviderSelect.value, currentUserLLMSettings);

        } catch (error) {
            console.error("Error loading LLM configuration:", error);
            showSettingsMessage('A critical error occurred while loading LLM configuration.', 'error', 0, llmProviderSelect);
            llmProviderSelect.innerHTML = '<option value="">Error</option>';
            llmModelSelect.innerHTML = '<option value="">Error</option>';
            llmModelSelect.disabled = true;
        }
    }

    /**
     * Populates the LLM Provider dropdown.
     * @param {string|null} currentProviderId The ID of the currently selected provider (to pre-select it).
     */
    function populateLLMProviders(currentProviderId) {
        llmProviderSelect.innerHTML = '<option value="">-- Select Provider --</option>'; // Default empty option
        availableProvidersData.forEach(provider => {
            // You might have filtering logic here if needed, e.g., based on provider.is_system_configured
            const option = document.createElement('option');
            option.value = provider.id;
            option.textContent = provider.display_name;
            if (provider.id === currentProviderId) {
                option.selected = true;
            }
            llmProviderSelect.appendChild(option);
        });
    }

    /**
     * Updates the LLM Model dropdown based on the selected provider.
     * Enables or disables the model dropdown accordingly.
     * @param {string} providerId The ID of the selected provider.
     * @param {string|null} currentModelId The ID of the currently selected model (to pre-select it).
     * @param {object} userSettings The current user's LLM settings (for context).
     */
    function updateModelDropdown(providerId, currentModelId, userSettings = {}) {
        llmModelSelect.innerHTML = '<option value="">-- Select Model --</option>'; // Default empty option
        const selectedProvider = availableProvidersData.find(p => p.id === providerId);

        if (selectedProvider && selectedProvider.available_models && selectedProvider.available_models.length > 0) {
            llmModelSelect.disabled = false; // *** ENABLE the dropdown ***
            selectedProvider.available_models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.model_id;
                // Display both name and ID for clarity, especially if names are not unique across providers
                option.textContent = model.display_name ? `${model.display_name} (${model.model_id})` : model.model_id;
                
                // Pre-select if this model was the user's saved choice for this provider
                if (providerId === userSettings.selected_llm_provider_id && model.model_id === currentModelId) {
                    option.selected = true;
                }
                llmModelSelect.appendChild(option);
            });
        } else if (providerId) { // Provider selected, but no models
            llmModelSelect.innerHTML = '<option value="">No models available for this provider</option>';
            llmModelSelect.disabled = true; // *** DISABLE if no models ***
        } else { // No provider selected
            llmModelSelect.innerHTML = '<option value="">-- Select Provider First --</option>';
            llmModelSelect.disabled = true; // *** DISABLE if no provider selected ***
        }
    }

    /**
     * Updates provider-specific fields (API key, base URL) based on the selected provider.
     * @param {string} providerId The ID of the selected provider.
     * @param {object} userSettings The current user's LLM settings.
     */
    function updateProviderSpecificFields(providerId, userSettings = {}) {
        const selectedProvider = availableProvidersData.find(p => p.id === providerId);

        // Hide all optional groups by default
        llmApiKeyGroup.style.display = 'none';
        llmApiKeyGroup.setAttribute('aria-hidden', 'true');
        llmBaseUrlGroup.style.display = 'none';
        llmBaseUrlGroup.setAttribute('aria-hidden', 'true');

        // Reset fields and status messages
        llmProviderStatus.textContent = providerId ? "Loading provider details..." : "Select a provider to see more options.";
        llmApiKeyInput.value = '';
        llmApiKeyInput.placeholder = '';
        llmApiKeyStatus.textContent = '';
        llmBaseUrlInput.value = '';
        llmBaseUrlInput.placeholder = '';

        if (selectedProvider) {
            // API Key field visibility and status
            if (selectedProvider.can_accept_user_api_key) { // Check if provider *can* accept a user key
                llmApiKeyGroup.style.display = 'block';
                llmApiKeyGroup.setAttribute('aria-hidden', 'false');
                if (userSettings.has_user_api_key && selectedProvider.id === userSettings.selected_llm_provider_id) {
                    llmApiKeyInput.placeholder = "•••••••• (A key is currently saved)";
                    llmApiKeyStatus.textContent = "A key is saved. Edit to change, or clear field and save to remove your key.";
                } else if (selectedProvider.is_system_configured && selectedProvider.needs_api_key_from_user === false) {
                    // System has a key, and user doesn't strictly need to provide one, but can.
                    llmApiKeyInput.placeholder = "API Key (Optional - System key available)";
                    llmApiKeyStatus.textContent = "A system key is configured. You can provide your own to override it for your account.";
                } else if (selectedProvider.needs_api_key_from_user === true) {
                    llmApiKeyInput.placeholder = "API Key (Required)";
                    llmApiKeyStatus.textContent = "Please enter your API key for this provider.";
                } else { // Can accept, but not strictly required and no system key (e.g. some local models)
                    llmApiKeyInput.placeholder = "API Key (Optional)";
                    llmApiKeyStatus.textContent = "You can optionally provide an API key.";
                }
            }

            // Base URL field visibility and status
            if (selectedProvider.can_accept_user_base_url) { // Check if provider *can* accept a user base URL
                llmBaseUrlGroup.style.display = 'block';
                llmBaseUrlGroup.setAttribute('aria-hidden', 'false');
                if (selectedProvider.id === userSettings.selected_llm_provider_id && userSettings.selected_llm_base_url) {
                    llmBaseUrlInput.value = userSettings.selected_llm_base_url;
                }
                // Provide more specific placeholders based on provider type if available
                if (selectedProvider.type === 'ollama') {
                    llmBaseUrlInput.placeholder = "e.g., http://localhost:11434 (uses system default if empty)";
                } else if (selectedProvider.type === 'openai_compatible_server') {
                    llmBaseUrlInput.placeholder = "e.g., https://api.example.com/v1 (Required if no system default)";
                } else {
                    llmBaseUrlInput.placeholder = "Custom Base URL (Optional)";
                }
            }

            // General provider status message
            if (!selectedProvider.is_system_configured && selectedProvider.needs_api_key_from_user === true) {
                llmProviderStatus.textContent = "This provider requires configuration (e.g., an API key).";
            } else if (selectedProvider.is_system_configured && selectedProvider.needs_api_key_from_user === false) {
                llmProviderStatus.textContent = "This provider is system-configured and ready to use.";
            } else if (selectedProvider.can_accept_user_api_key || selectedProvider.can_accept_user_base_url) {
                llmProviderStatus.textContent = "This provider can be customized with your own API key or base URL.";
            } else {
                llmProviderStatus.textContent = "This provider does not require additional configuration.";
            }

        } else if (providerId === "") { // "-- Select Provider --" is chosen
             llmProviderStatus.textContent = "Select a provider to see configuration options.";
        }
    }

    // Event listener for when the LLM provider selection changes
    llmProviderSelect.addEventListener('change', async (event) => {
        const selectedProviderId = event.target.value;
        
        // Fetch the latest user settings as they might have changed or to get defaults for the new provider
        const userSettingsResponse = await fetch('/api/me/llm-settings', {cache: 'no-store'});
        const currentUserLLMSettings = userSettingsResponse.ok ? await userSettingsResponse.json() : {};

        // Determine which model should be pre-selected.
        // If the newly selected provider is the same as the user's saved provider, use their saved model.
        // Otherwise, no specific model is pre-selected (will default to "-- Select Model --").
        const modelToSelect = (selectedProviderId === currentUserLLMSettings.selected_llm_provider_id)
                                ? currentUserLLMSettings.selected_llm_model_id
                                : null; // Let updateModelDropdown handle the default "-- Select Model --"

        updateModelDropdown(selectedProviderId, modelToSelect, currentUserLLMSettings);
        updateProviderSpecificFields(selectedProviderId, currentUserLLMSettings);
    });

    // Event listener for saving LLM settings
    llmSettingsForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        settingsMessageArea.style.display = 'none';
        saveLLMSettingsButton.disabled = true;
        saveLLMSettingsButton.textContent = 'Saving...';
        const csrfToken = window.csrfTokenRaw; // Use the globally available raw CSRF token

        if (!csrfToken || csrfToken === "%%CSRF_TOKEN_RAW%%") {
            showSettingsMessage('CSRF token missing. Cannot save settings. Please refresh.', 'error', 0, saveLLMSettingsButton);
            saveLLMSettingsButton.disabled = false;
            saveLLMSettingsButton.textContent = 'Save LLM Settings';
            return;
        }

        const providerId = llmProviderSelect.value;
        const modelId = llmModelSelect.value;
        // Only include API key if the input group is visible (meaning provider accepts it)
        const apiKey = (llmApiKeyGroup.style.display !== 'none') ? llmApiKeyInput.value : undefined;
        // Only include base URL if the input group is visible
        const baseUrl = (llmBaseUrlGroup.style.display !== 'none') ? llmBaseUrlInput.value : undefined;

        const payload = {
            selected_llm_provider_id: providerId || null, // Send null if empty string
            selected_llm_model_id: modelId || null,     // Send null if empty string
        };

        // Conditionally add api_key and base_url to the payload
        // The backend expects `user_llm_api_key` and `selected_llm_base_url`
        if (apiKey !== undefined) { // Check for undefined, empty string means "clear the key"
            payload.user_llm_api_key = apiKey;
        }
        if (baseUrl !== undefined) { // Check for undefined, empty string means "clear the base URL"
            payload.selected_llm_base_url = baseUrl || null; // Send null if empty string
        }

        try {
            const response = await fetch('/api/me/llm-settings', {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': csrfToken
                },
                body: JSON.stringify(payload)
            });
            const result = await response.json();
            if (response.ok) {
                showSettingsMessage('LLM settings saved successfully!', 'success', 3000, saveLLMSettingsButton);
                // Reload the config data to reflect saved settings (e.g., has_user_api_key status)
                await loadLLMConfigData(); 
            } else {
                let fieldToFocus = llmProviderSelect;
                if (result.detail && typeof result.detail === 'string') {
                    if (result.detail.toLowerCase().includes('model')) fieldToFocus = llmModelSelect;
                    else if (result.detail.toLowerCase().includes('api key')) fieldToFocus = llmApiKeyInput;
                    else if (result.detail.toLowerCase().includes('base url')) fieldToFocus = llmBaseUrlInput;
                }
                showSettingsMessage(result.detail || 'Failed to save LLM settings.', 'error', 0, fieldToFocus);
            }
        } catch (error) {
            console.error("Error saving LLM settings:", error);
            showSettingsMessage('An error occurred while saving LLM settings.', 'error', 0, saveLLMSettingsButton);
        } finally {
            saveLLMSettingsButton.disabled = false;
            saveLLMSettingsButton.textContent = 'Save LLM Settings';
        }
    });

    // Initial load of LLM configuration when the page is ready
    await loadLLMConfigData(); 
});


=== app/static/js/temp.js ===
// Add these new state variables at the top with other state variables
let activeStreamingCodeBlocks = new Map(); // blockId -> { element, language, content }
let streamingCodeBlockCounter = 0;

// Replace the renderLiveMessage function
function renderLiveMessage(fullContent) {
    if (!currentAiTurnContainer) return;

    if (!firstAnswerTokenReceived && fullContent.trim().length > 0) {
        if (currentAnswerElement && currentAnswerElement.style.display === 'none') {
            currentAnswerElement.style.display = '';
        }
        const loadingDots = currentAnswerElement ? currentAnswerElement.querySelector('.loading-dots') : null;
        if (loadingDots) loadingDots.remove();
        firstAnswerTokenReceived = true;
    }

    const contentArea = currentAnswerElement.querySelector('.live-ai-content-area');
    const codeArea = currentCodeBlocksArea;

    if (!contentArea || !codeArea) return;
    
    parseAndRenderStreamingContent(fullContent, contentArea, codeArea, currentTurnId);
    scrollToBottom('auto');
}

// New function to handle streaming content with live code block creation
function parseAndRenderStreamingContent(contentString, answerBubbleContentElement, codeBlocksDivElement, turnIdSuffix) {
    if (!contentString || !answerBubbleContentElement || !codeBlocksDivElement) return;

    let processedContent = contentString;
    const codeBlockRegex = /```(\w*)\n?([\s\S]*?)(?:\n```|$)/g;
    let match;
    let lastIndex = 0;
    let contentWithPlaceholders = '';

    // Process each code block
    while ((match = codeBlockRegex.exec(contentString)) !== null) {
        const [fullMatch, language, code] = match;
        const isComplete = fullMatch.endsWith('\n```') || fullMatch.endsWith('```');
        
        // Add content before this code block
        contentWithPlaceholders += contentString.substring(lastIndex, match.index);
        
        const blockId = `streaming-code-block-turn${turnIdSuffix}-${++streamingCodeBlockCounter}`;
        
        if (!activeStreamingCodeBlocks.has(blockId)) {
            // Create new streaming code block
            createStreamingCodeBlock(language || 'plaintext', blockId, codeBlocksDivElement, turnIdSuffix, streamingCodeBlockCounter);
            activeStreamingCodeBlocks.set(blockId, {
                language: language || 'plaintext',
                content: code,
                isComplete: isComplete
            });
        } else {
            // Update existing streaming code block
            const blockData = activeStreamingCodeBlocks.get(blockId);
            blockData.content = code;
            blockData.isComplete = isComplete;
            updateStreamingCodeBlockContent(blockId, code, isComplete);
        }
        
        // Add placeholder reference
        contentWithPlaceholders += ` [Code Block ${streamingCodeBlockCounter}] `;
        lastIndex = codeBlockRegex.lastIndex;
    }
    
    // Add remaining content after last code block
    contentWithPlaceholders += contentString.substring(lastIndex);
    
    // Handle KaTeX and render markdown for non-code content
    const KATEX_PLACEHOLDER_PREFIX_STREAMING = `%%STREAMING_KATEX_PLACEHOLDER_${turnIdSuffix}_`;
    const storedKatex = {};
    let katexPlaceholderIndex = 0;
    
    const katexRegexGlobal = /(?<!\\)\$\$([\s\S]+?)(?<!\\)\$\$|(?<!\\)\$((?:\\\$|[^$])+?)(?<!\\)\$/g;
    let textForMarkdownParsing = contentWithPlaceholders.replace(katexRegexGlobal, (match, displayContent, inlineContent) => {
        const isDisplayMode = !!displayContent;
        const katexString = displayContent || inlineContent;
        const cleanedKatexString = katexString.replace(/\\([$])/g, '$1');
        let katexHtml = '';
        try {
            katexHtml = katex.renderToString(cleanedKatexString, {
                displayMode: isDisplayMode, throwOnError: false, output: "html", strict: false
            });
        } catch (e) {
            katexHtml = `<span class="katex-error" title="${escapeHTML(e.toString())}">${escapeHTML(match)}</span>`;
        }
        const placeholderId = `${KATEX_PLACEHOLDER_PREFIX_STREAMING}${katexPlaceholderIndex++}`;
        storedKatex[placeholderId] = katexHtml;
        return placeholderId;
    });

    answerBubbleContentElement.innerHTML = marked.parse(textForMarkdownParsing);

    // Restore KaTeX content
    if (Object.keys(storedKatex).length > 0) {
        const walker = document.createTreeWalker(answerBubbleContentElement, NodeFilter.SHOW_TEXT, null, false);
        let node;
        const textNodesToModify = [];
        while (node = walker.nextNode()) {
            if (node.nodeValue && node.nodeValue.includes(KATEX_PLACEHOLDER_PREFIX_STREAMING)) {
                textNodesToModify.push(node);
            }
        }
        textNodesToModify.forEach(textNode => {
            let currentTextValue = textNode.nodeValue;
            const parent = textNode.parentNode;
            if (!parent) return;
            const fragment = document.createDocumentFragment();
            let lastSplitEnd = 0;
            const placeholderScanRegex = new RegExp(`(${KATEX_PLACEHOLDER_PREFIX_STREAMING}\\d+)`, 'g');
            let placeholderMatch;
            while((placeholderMatch = placeholderScanRegex.exec(currentTextValue)) !== null) {
                const placeholderId = placeholderMatch[1];
                const matchStartIndex = placeholderMatch.index;
                if (matchStartIndex > lastSplitEnd) {
                    fragment.appendChild(document.createTextNode(currentTextValue.substring(lastSplitEnd, matchStartIndex)));
                }
                if (storedKatex[placeholderId]) {
                    const katexWrapperSpan = document.createElement('span');
                    katexWrapperSpan.innerHTML = storedKatex[placeholderId];
                    fragment.appendChild(katexWrapperSpan.firstChild || katexWrapperSpan);
                } else {
                    fragment.appendChild(document.createTextNode(placeholderId));
                }
                lastSplitEnd = placeholderScanRegex.lastIndex;
            }
            if (lastSplitEnd < currentTextValue.length) {
                fragment.appendChild(document.createTextNode(currentTextValue.substring(lastSplitEnd)));
            }
            parent.replaceChild(fragment, textNode);
        });
    }
}

// New function to create streaming code blocks immediately
function createStreamingCodeBlock(language, blockId, codeBlocksAreaElement, turnIdSuffix, codeBlockIndex) {
    if (!codeBlocksAreaElement) {
        console.error("createStreamingCodeBlock: Code blocks area element is null!");
        return;
    }

    const safeLanguage = (language || '').trim().toLowerCase() || 'plaintext';
    const langAlias = {
        'python': 'python', 'py': 'python', 'javascript': 'javascript', 'js': 'javascript',
        'html': 'markup', 'xml': 'markup', 'svg': 'markup', 'css': 'css', 'bash': 'bash',
        'sh': 'bash', 'shell': 'bash', 'json': 'json', 'yaml': 'yaml', 'yml': 'yaml',
        'markdown': 'markdown', 'md': 'markdown', 'sql': 'sql', 'java': 'java', 'c': 'c',
        'cpp': 'cpp', 'c++': 'cpp', 'csharp': 'csharp', 'cs': 'csharp', 'go': 'go',
        'rust': 'rust', 'php': 'php', 'ruby': 'ruby', 'rb': 'ruby',
        'dockerfile': 'docker', 'docker': 'docker', 'typescript': 'typescript', 'ts': 'typescript',
        'plaintext': 'plain', 'text': 'plain',
    };
    const prismLang = langAlias[safeLanguage] || safeLanguage;
    const displayLang = safeLanguage;

    const isLanguageSupported = supportedLanguagesConfig[displayLang]?.executable;
    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;

    const container = document.createElement('div');
    container.classList.add('block-container');
    container.id = blockId;
    container.dataset.language = displayLang;

    const codeHeader = document.createElement('div');
    codeHeader.classList.add('block-header');

    const codeButtonsDiv = document.createElement('div');
    codeButtonsDiv.classList.add('block-buttons');

    const runStopBtn = document.createElement('button');
    runStopBtn.classList.add('run-code-btn', 'block-action-btn');
    runStopBtn.dataset.status = 'idle';
    runStopBtn.innerHTML = playIconSvg;
    runStopBtn.title = 'Run Code';
    runStopBtn.addEventListener('click', handleRunStopCodeClick);

    const toggleCodeBtn = document.createElement('button');
    toggleCodeBtn.classList.add('toggle-code-btn', 'block-action-btn');
    toggleCodeBtn.textContent = 'Hide';
    toggleCodeBtn.title = 'Show/Hide Code';

    const copyCodeBtn = document.createElement('button');
    copyCodeBtn.classList.add('copy-code-btn', 'block-action-btn');
    copyCodeBtn.textContent = 'Copy';
    copyCodeBtn.title = 'Copy Code';

    if (!isLanguageSupported) {
        runStopBtn.style.display = 'none';
        runStopBtn.title = `Run Code (language '${displayLang}' not supported for execution)`;
    }

    codeButtonsDiv.appendChild(runStopBtn);
    codeButtonsDiv.appendChild(toggleCodeBtn);
    codeButtonsDiv.appendChild(copyCodeBtn);

    const codeTitle = document.createElement('span');
    codeTitle.classList.add('block-title');
    const titleTextSpan = document.createElement('span');
    titleTextSpan.classList.add('title-text');
    titleTextSpan.textContent = `Code Block ${codeBlockIndex} (${displayLang})`;
    const dotsSpan = document.createElement('span');
    dotsSpan.classList.add('streaming-dots');
    dotsSpan.textContent = '...';
    codeTitle.appendChild(titleTextSpan);
    codeTitle.appendChild(dotsSpan);
    codeTitle.style.flexGrow = '1';
    codeTitle.style.textAlign = 'left';

    codeHeader.appendChild(codeButtonsDiv);
    codeHeader.appendChild(codeTitle);

    const preElement = document.createElement('pre');
    preElement.classList.add('manual');
    const codeElement = document.createElement('code');
    codeElement.className = `language-${prismLang}`;
    codeElement.setAttribute('contenteditable', 'true');
    codeElement.setAttribute('spellcheck', 'false');
    codeElement.textContent = '';

    // Create output area structure (same as before)
    const outputHeader = document.createElement('div');
    outputHeader.classList.add('block-header');
    outputHeader.style.display = 'none';
    
    const outputButtonsDiv = document.createElement('div');
    outputButtonsDiv.classList.add('block-buttons');
    const placeholderSpan = document.createElement('span');
    placeholderSpan.classList.add('output-header-button-placeholder');
    outputButtonsDiv.appendChild(placeholderSpan);
    
    const toggleOutputBtn = document.createElement('button');
    toggleOutputBtn.classList.add('toggle-output-btn', 'block-action-btn');
    toggleOutputBtn.textContent = 'Hide';
    toggleOutputBtn.title = 'Show/Hide Output';
    
    const copyOutputBtn = document.createElement('button');
    copyOutputBtn.classList.add('copy-output-btn', 'block-action-btn');
    copyOutputBtn.textContent = 'Copy';
    copyOutputBtn.title = 'Copy Output';
    
    outputButtonsDiv.appendChild(toggleOutputBtn);
    outputButtonsDiv.appendChild(copyOutputBtn);
    
    const outputTitle = document.createElement('span');
    outputTitle.classList.add('block-title');
    outputTitle.textContent = `Output Code Block ${codeBlockIndex}`;
    
    const codeStatusSpan = document.createElement('span');
    codeStatusSpan.classList.add('block-status');
    codeStatusSpan.textContent = 'Idle';
    
    outputHeader.appendChild(outputButtonsDiv);
    outputHeader.appendChild(outputTitle);
    outputHeader.appendChild(codeStatusSpan);

    const outputConsoleDiv = document.createElement('div');
    outputConsoleDiv.classList.add('block-output-console');
    outputConsoleDiv.style.display = 'none';
    const outputPre = document.createElement('pre');
    outputConsoleDiv.appendChild(outputPre);

    preElement.appendChild(codeElement);
    container.appendChild(codeHeader);
    container.appendChild(preElement);
    container.appendChild(outputHeader);
    container.appendChild(outputConsoleDiv);

    // Add all the same event listeners as the original function
    toggleCodeBtn.addEventListener('click', () => {
        const isHidden = preElement.classList.toggle('hidden');
        toggleCodeBtn.textContent = isHidden ? 'Show' : 'Hide';
    });

    copyCodeBtn.addEventListener('click', async () => {
        try {
            await navigator.clipboard.writeText(codeElement.textContent || '');
            copyCodeBtn.textContent = 'Copied!';
            copyCodeBtn.classList.add('copied');
            setTimeout(() => { 
                copyCodeBtn.textContent = 'Copy'; 
                copyCodeBtn.classList.remove('copied'); 
            }, 1500);
        } catch (err) {
            console.error('Failed to copy code: ', err);
            copyCodeBtn.textContent = 'Error';
            setTimeout(() => { copyCodeBtn.textContent = 'Copy'; }, 1500);
        }
    });

    const debouncedHighlight = debounce(() => {
        const savedPosition = getCursorPosition(codeElement);
        try {
            const currentText = codeElement.textContent;
            codeElement.innerHTML = ''; 
            codeElement.textContent = currentText; 
            if (typeof Prism !== 'undefined' && typeof Prism.highlightElement === 'function') {
                Prism.highlightElement(codeElement);
            }
            if (savedPosition !== -1) { 
                setCursorPosition(codeElement, savedPosition); 
            }
        } catch (e) {
            console.error("Error during debounced highlighting:", e);
            if (savedPosition !== -1) { 
                setCursorPosition(codeElement, savedPosition); 
            }
        }
    }, 500);

    codeElement.addEventListener('input', debouncedHighlight);
    codeElement.addEventListener('paste', (e) => { 
        setTimeout(debouncedHighlight, 100); 
    });

    toggleOutputBtn.addEventListener('click', () => {
        const isHidden = outputConsoleDiv.classList.toggle('hidden');
        toggleOutputBtn.textContent = isHidden ? 'Show' : 'Hide';
    });

    copyOutputBtn.addEventListener('click', async () => {
        if (!outputPre) return;
        try {
            await navigator.clipboard.writeText(outputPre.textContent || '');
            copyOutputBtn.textContent = 'Copied!';
            copyOutputBtn.classList.add('copied');
            setTimeout(() => { 
                copyOutputBtn.textContent = 'Copy'; 
                copyOutputBtn.classList.remove('copied'); 
            }, 1500);
        } catch (err) {
            console.error('Failed to copy output: ', err);
            copyOutputBtn.textContent = 'Error';
            setTimeout(() => { copyOutputBtn.textContent = 'Copy'; }, 1500);
        }
    });

    codeBlocksAreaElement.appendChild(container);
}

// New function to update streaming code block content
function updateStreamingCodeBlockContent(blockId, content, isComplete) {
    const container = document.getElementById(blockId);
    if (!container) return;

    const codeElement = container.querySelector('code');
    const dotsSpan = container.querySelector('.streaming-dots');
    
    if (codeElement) {
        codeElement.textContent = content;
        
        // Apply syntax highlighting
        if (typeof Prism !== 'undefined' && typeof Prism.highlightElement === 'function') {
            try {
                Prism.highlightElement(codeElement);
            } catch (e) {
                console.error(`Prism highlight error:`, e);
            }
        }
    }
    
    // Remove dots animation when complete
    if (isComplete && dotsSpan) {
        dotsSpan.remove();
    }
}

=== tests/test_coding.py ===
import pytest
import asyncio
import time
import sys
import os

# Add the app directory to Python path
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from app import docker_utils
from app import state


def test_docker_client_connection():
    """Test that Docker client can be obtained"""
    client = docker_utils.get_docker_client()
    assert client is not None, "Docker client should be available"
    
    # Test ping
    try:
        result = client.ping()
        assert result is True, "Docker daemon should respond to ping"
    except Exception as e:
        pytest.fail(f"Docker ping failed: {e}")


def test_input_prompt_detection_patterns():
    """Test the input prompt detection logic"""
    
    # Test cases: (input_line, should_detect_as_prompt)
    test_cases = [
        ("Enter your name: ", True),
        ("What is your age? ", True), 
        ("Type something> ", True),
        ("Please enter input: ", True),
        ("Password: ", True),
        ("Normal output with newline\n", False),
        ("Processing...\n", False),
        ("Error occurred\n", False),
        ("", False),
    ]
    
    for line_str, expected in test_cases:
        # This is the same logic from sync_log_streamer
        stripped_line = line_str.rstrip('\n\r')
        is_input_prompt = (
            line_str == stripped_line and  # No newline at end
            len(stripped_line) > 0 and
            (stripped_line.endswith(': ') or 
             stripped_line.endswith('? ') or
             stripped_line.endswith('> ') or
             'enter' in stripped_line.lower() or
             'input' in stripped_line.lower())
        )
        
        assert is_input_prompt == expected, f"Failed for line: '{line_str}'"


@pytest.mark.asyncio
async def test_run_simple_python_code():
    """Test running simple Python code without input"""
    
    from fastapi.websockets import WebSocketState
    
    class TestWebSocket:
        def __init__(self):
            self.messages = []
            self.client_state = WebSocketState.CONNECTED
        
        async def send_text(self, text):
            self.messages.append(text)
        
        async def send_json(self, data):
            self.messages.append(data)
    
    ws = TestWebSocket()
    # Use code that takes a bit longer to execute
    code = '''
import time
print("Hello from Docker")
time.sleep(0.5)
print("Docker execution complete")
'''
    code_block_id = f"test_simple_{int(time.time())}"
    
    await docker_utils.run_code_in_docker_stream(
        ws, "test_client", code_block_id, "python", code
    )
    
    # Should have some output
    assert len(ws.messages) > 0
    
    print(f"Received {len(ws.messages)} messages")
    
    # Check if we got code_output messages (the actual stdout)
    output_messages = [msg for msg in ws.messages if isinstance(msg, dict) and msg.get('type') == 'code_output']
    finished_messages = [msg for msg in ws.messages if isinstance(msg, dict) and msg.get('type') == 'code_finished']
    
    # Should have at least the finished message
    assert len(finished_messages) > 0
    assert finished_messages[0]['payload']['exit_code'] == 0
    
    # If we got output messages, check for our text
    if output_messages:
        # Concatenate all the character data without spaces
        output_text = "".join(msg['payload']['data'] for msg in output_messages)
        print(f"Combined output: '{output_text}'")
        assert "Hello from Docker" in output_text
        assert "Docker execution complete" in output_text
    else:
        print("No code_output messages received, but container executed successfully")
    
    print("✅ Test passed - Docker execution with interactive flags works!")

@pytest.mark.asyncio  
async def test_run_python_with_input_prompt():
    """Test running Python code that has input() call"""
    
    from fastapi.websockets import WebSocketState
    
    class TestWebSocket:
        def __init__(self):
            self.messages = []
            self.structured_messages = []
            # Use the correct WebSocketState enum
            self.client_state = WebSocketState.CONNECTED
        
        async def send_text(self, text):
            self.messages.append(text)
        
        async def send_json(self, data):
            self.messages.append(data)
            self.structured_messages.append(data)
    
    ws = TestWebSocket()
    code = '''
print("Starting program")
name = input("Enter your name: ")
print(f"Hello {name}")
'''
    code_block_id = f"test_input_{int(time.time())}"
    
    # Start the execution task
    task = asyncio.create_task(
        docker_utils.run_code_in_docker_stream(
            ws, "test_client", code_block_id, "python", code
        )
    )
    
    # Wait a bit for it to reach the input prompt
    await asyncio.sleep(3)
    
    # Stop the container to avoid hanging
    await docker_utils.stop_docker_container(code_block_id)
    
    # Check that we got some output
    assert len(ws.messages) > 0
    
    print(f"Received {len(ws.messages)} messages")
    
    # Should see the program starting
    output_messages = [msg for msg in ws.messages if isinstance(msg, dict) and msg.get('type') == 'code_output']
    if output_messages:
        output_text = "".join(msg['payload']['data'] for msg in output_messages)
        print(f"Combined output: '{output_text}'")
        assert "Starting program" in output_text
    
    print("✅ Input prompt test completed")


@pytest.mark.asyncio
async def test_send_input_to_nonexistent_container():
    """Test sending input to a container that doesn't exist"""
    
    # This should not raise an exception, just log and return
    await docker_utils.send_input_to_container("nonexistent_block", "test input\n")
    
    # If we get here without exception, the test passes


@pytest.mark.asyncio
async def test_stop_nonexistent_container():
    """Test stopping a container that doesn't exist"""
    
    # This should not raise an exception
    await docker_utils.stop_docker_container("nonexistent_block")
    

@pytest.mark.asyncio
async def test_container_lifecycle():
    """Test creating, running, and stopping a container"""
    
    from fastapi.websockets import WebSocketState
    
    class TestWebSocket:
        def __init__(self):
            self.messages = []
            # Use the correct WebSocketState enum
            self.client_state = WebSocketState.CONNECTED
        
        async def send_text(self, text):
            self.messages.append(text)
        
        async def send_json(self, data):
            self.messages.append(data)
    
    ws = TestWebSocket()
    code = '''
import time
print("Container started")
time.sleep(2)
print("Container finishing")
'''
    code_block_id = f"test_lifecycle_{int(time.time())}"
    
    # Start execution
    task = asyncio.create_task(
        docker_utils.run_code_in_docker_stream(
            ws, "test_client", code_block_id, "python", code
        )
    )
    
    # Wait a moment
    await asyncio.sleep(1)
    
    # Check that container is tracked
    async with state.running_containers_lock:
        assert code_block_id in state.running_containers
    
    # Stop the container
    await docker_utils.stop_docker_container(code_block_id)
    
    # Wait a moment for cleanup
    await asyncio.sleep(1)
    
    # Check that container is no longer tracked
    async with state.running_containers_lock:
        assert code_block_id not in state.running_containers
    
    # Should have received some output
    assert len(ws.messages) > 0
    
    print(f"Lifecycle test completed with {len(ws.messages)} messages")
    print("✅ Container lifecycle test passed")

@pytest.mark.asyncio
async def test_interactive_container_creation():
    """Test that containers are created with interactive flags"""
    
    from fastapi.websockets import WebSocketState
    
    class TestWebSocket:
        def __init__(self):
            self.messages = []
            # Use the correct WebSocketState enum
            self.client_state = WebSocketState.CONNECTED
        
        async def send_text(self, text):
            self.messages.append(text)
        
        async def send_json(self, data):
            self.messages.append(data)
    
    ws = TestWebSocket()
    code = "print('Testing interactive flags')"
    code_block_id = f"test_interactive_{int(time.time())}"
    
    # This should work without errors if interactive flags are set correctly
    await docker_utils.run_code_in_docker_stream(
        ws, "test_client", code_block_id, "python", code
    )
    
    # Should complete successfully
    assert len(ws.messages) > 0
    
    # Get the actual output text from code_output messages
    output_messages = [msg for msg in ws.messages if isinstance(msg, dict) and msg.get('type') == 'code_output']
    if output_messages:
        # Concatenate character-by-character output
        output_text = "".join(msg['payload']['data'] for msg in output_messages)
        print(f"Interactive test output: '{output_text}'")
        assert "Testing interactive flags" in output_text
    else:
        # If no code_output messages, check if container finished successfully
        finished_messages = [msg for msg in ws.messages if isinstance(msg, dict) and msg.get('type') == 'code_finished']
        assert len(finished_messages) > 0
        assert finished_messages[0]['payload']['exit_code'] == 0
        print("✅ Interactive container executed successfully (no output captured)")
    
    print("✅ Interactive container creation test passed")


def test_state_initialization():
    """Test that required state objects exist"""
    
    # Check that running_containers exists
    assert hasattr(state, 'running_containers')
    assert hasattr(state, 'running_containers_lock')
    
    # Should be able to access the lock
    assert state.running_containers_lock is not None


=== LLM Instructions ===
Now please just read the project and the rules for writing code and just wait for instructions.

Here are the rules:
1. DONT write comments, placeholders or docstrings if not explicitely told.
2. Write functions with the correct initial indentation so that if the function is indented so is your code that you write.
3. DO NOT USE NON-TERMINATED SPACES. MAKE SURE TO FOLLOW THIS! ITS SUPER IMPORTANT AND YOU SEEM TO BREAK IT, PLEASE!!!
4. For changes that require multiple replacements please tell me what to replace with what instead of rewriting large portions of text. You can use vscode valid regexp for instance.
5. For small functions less than 100 lines of code please rewrite the full function. For larger functions please only write complete control statements if/while/case.
6. Never omit/change working logic if not explicitely statet that it should be removed/change
7. DONT use the CANVAS TOOL where code is written in artifacts.
8. Write only functions that are new seperately from functions that needs updates.
9. Make sure to write what has been change where to place/what to replace for each code snippet.
