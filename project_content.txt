=== Project Directory Structure ===
Root: C:\Users\viktor.jonsson\OneDrive - CellMax Technologies AB\Documents\Repositories\svenviktorjonsson\tesseracs-chat
Relevant files and folders (excluding specified patterns):

.
├── Readme.md
├── build.js
├── fetch_assets.py
├── package-lock.json
├── package.json
├── postcss.config.js
├── project_content.txt
├── pyproject.toml
├── tailwind.config.js
├── temp.js
├── temp.py
├── write_project_content_to_file.py
app/
├── __init__.py
├── config.py
├── docker_utils.py
├── llm.py
├── main.py
├── state.py
├── utils.py
├── static/
│   ├── index.html
│   ├── input.css
│   ├── script.js
│   ├── assets/
│   │   ├── css/
│   │   │   ├── katex.min.css
│   │   │   ├── prism-tomorrow.min.css
│   │   ├── fonts/
│   ├── dist/
│   │   ├── input.css
│   │   ├── input.js
│   │   ├── script.css
│   │   ├── script.js
│   │   ├── assets/


=== File Contents ===

=== Readme.md ===
Readme


=== build.js ===
const esbuild = require('esbuild');
const stylePlugin = require('esbuild-style-plugin');
const path = require('path');

async function build() {
    console.log("--- Starting esbuild build process (Revised Approach) ---");
    try {
        await esbuild.build({
            // Define BOTH JS and main CSS as entry points
            entryPoints: {
                'script': 'app/static/script.js', // Output will be dist/script.js
                'input': 'app/static/input.css'   // Output will be dist/input.css
            },
            bundle: true,
            // Use outdir instead of outfile when using multiple entry points
            outdir: 'app/static/dist',
            entryNames: '[name]', // Keep original names (script.js, input.css)
            format: 'iife', // For script.js
            platform: 'browser',
            sourcemap: true,
            minify: false,
            loader: {
              '.woff': 'file',
              '.woff2': 'file',
              '.ttf': 'file',
              '.eot': 'file',
              '.svg': 'file'
            },
            plugins: [
                stylePlugin({
                    // No 'extract' needed when CSS is an entry point
                    // Plugin is still needed for PostCSS processing of input.css
                    // and potentially CSS imported from node_modules via script.js
                    postcss: {
                        // Intentionally empty to force loading postcss.config.js
                    }
                })
            ],
            // Assets relative to the outdir ('dist')
            assetNames: 'assets/[name]-[hash]',

        });
        console.log('Build successful!');
    } catch (error) {
        console.error('Build failed:', error);
        process.exit(1);
    }
}

build();


=== fetch_assets.py ===
import os
import requests
import sys

# --- Configuration ---
# Get the directory where the script is located
script_dir = os.path.dirname(os.path.abspath(__file__))
print(f"DEBUG: Script is running from directory: {script_dir}") # <-- Added Debug Print

# Define paths relative to the script's location
static_dir = os.path.join(script_dir, 'app', 'static')
assets_dir = os.path.join(static_dir, 'assets')
css_dir = os.path.join(assets_dir, 'css')
fonts_dir = os.path.join(assets_dir, 'fonts') # Define fonts dir for creation

# Print the calculated target directories for verification
print(f"DEBUG: Target static directory: {static_dir}")
print(f"DEBUG: Target assets directory: {assets_dir}")
print(f"DEBUG: Target CSS directory: {css_dir}")
print(f"DEBUG: Target fonts directory: {fonts_dir}") # <-- Added Debug Print

# List of CSS files to download
css_files_to_download = [
    {
        'name': 'katex.min.css',
        'url': 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css',
        'dest': os.path.join(css_dir, 'katex.min.css')
    },
    {
        'name': 'prism-tomorrow.min.css',
        'url': 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css',
        'dest': os.path.join(css_dir, 'prism-tomorrow.min.css')
    }
]

# --- Helper Functions ---
def ensure_dir_exists(dir_path):
    """Creates a directory if it doesn't exist."""
    if not os.path.exists(dir_path):
        print(f"Creating directory: {dir_path}")
        try:
            os.makedirs(dir_path, exist_ok=True)
        except OSError as e:
            print(f"Error creating directory {dir_path}: {e}", file=sys.stderr)
            sys.exit(1) # Exit if directory creation fails

def download_file(url, destination_path):
    """Downloads a file from a URL to a destination path."""
    print(f"Attempting to download {os.path.basename(destination_path)} to {destination_path} from {url}...") # <-- Added Debug Print
    try:
        response = requests.get(url, stream=True, timeout=30) # Added timeout
        response.raise_for_status() # Raise an exception for bad status codes (4xx or 5xx)

        with open(destination_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
        print(f"Successfully downloaded: {os.path.basename(destination_path)}")
        return True
    except requests.exceptions.RequestException as e:
        print(f"Error downloading {url}: {e}", file=sys.stderr)
        # Clean up partially downloaded file if it exists
        if os.path.exists(destination_path):
            try:
                os.remove(destination_path)
                print(f"Removed partially downloaded file: {os.path.basename(destination_path)}")
            except OSError as remove_error:
                print(f"Error removing partial file {destination_path}: {remove_error}", file=sys.stderr)
        return False
    except Exception as e:
        print(f"An unexpected error occurred during download of {url}: {e}", file=sys.stderr)
        return False


# --- Main Execution ---
def main():
    print("Starting Python asset fetching process...")

    # 1. Ensure directories exist
    print("Ensuring necessary directories exist...")
    ensure_dir_exists(static_dir)
    ensure_dir_exists(assets_dir)
    ensure_dir_exists(css_dir)
    ensure_dir_exists(fonts_dir) # Also create fonts dir
    print("Directory check complete.")

    # 2. Download CSS files
    print("\nDownloading CSS files...")
    success_count = 0
    failure_count = 0
    for file_info in css_files_to_download:
        # Print the destination path before downloading
        print(f"DEBUG: Calculated destination for {file_info['name']}: {file_info['dest']}") # <-- Added Debug Print
        if download_file(file_info['url'], file_info['dest']):
            success_count += 1
        else:
            failure_count += 1

    print(f"\nDownload summary: {success_count} succeeded, {failure_count} failed.")

    if failure_count > 0:
        print("\nOne or more downloads failed. Please check the errors above.", file=sys.stderr)
        sys.exit(1) # Exit with error code if any download failed
    else:
        print("\nPython asset fetching process completed successfully.")
        print("CSS files downloaded to:", css_dir)
        print("Ensure font files are placed in:", fonts_dir)

if __name__ == "__main__":
    main()


=== package-lock.json ===
--- CONTENT EXCLUDED (listed in exclude_files) ---


=== package.json ===
{
  "name": "tesseracs-chat",
  "version": "1.0.0",
  "description": "Readme",
  "main": "temp.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "node build.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/svenviktorjonsson/tesseracs-chat.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/svenviktorjonsson/tesseracs-chat/issues"
  },
  "homepage": "https://github.com/svenviktorjonsson/tesseracs-chat#readme",
  "devDependencies": {
    "@tailwindcss/postcss": "^4.1.5",
    "autoprefixer": "^10.4.21",
    "esbuild": "^0.25.3",
    "esbuild-style-plugin": "^1.6.3",
    "postcss": "^8.5.3",
    "tailwindcss": "^4.1.5"
  },
  "dependencies": {
    "katex": "^0.16.22",
    "marked": "^15.0.11",
    "prismjs": "^1.29.0"
  }
}


=== postcss.config.js ===
// postcss.config.js
module.exports = {
  plugins: {
    '@tailwindcss/postcss': {}, // Use the new package name (UNCOMMENTED)
    autoprefixer: {},             // (UNCOMMENTED)
  },
}

=== project_content.txt ===


=== pyproject.toml ===
[tool.poetry]
name = "tesseracs-chat"
version = "0.1.0"
description = "Web chat interface for Ollama using FastAPI and LangChain"
authors = ["Viktor Jonsson <viktor.jonsson@tesseracs.com>"]
readme = "README.md" # Optional README
packages = [
    { include = "app" },
]

[tool.poetry.dependencies]
python = "^3.9" # Adjust Python version if needed
fastapi = "^0.110.0"
uvicorn = {extras = ["standard"], version = "^0.29.0"}

# Let Poetry resolve the latest compatible LangChain versions
# Using "*" allows any version, but be aware this might pull in breaking changes in the future.
langchain = "*"
langchain-ollama = "*"
langchain-core = "*"
langchain-community = "*"
langchain-text-splitters = "*"

# Other dependencies
websockets = "^12.0" # Required by FastAPI for WebSockets
python-dotenv = "^1.0.1" # For optional .env file
aiofiles = "^23.2.1" # For serving static files asynchronously
docker = "^7.1.0"
requests = "^2.32.3"

[tool.poetry.scripts]
app = "app.main:start_server" # Command to run the app

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"



=== tailwind.config.js ===
/** @type {import('tailwindcss').Config} */
module.exports = {
    content: [
      "./app/static/**/*.html", // Scan HTML files in static
      "./app/static/**/*.js",   // Scan JS files in static
    ],
    theme: {
      extend: {},
    },
    plugins: [],
  }

=== temp.js ===
// --- DOM Elements ---
const chatHistory = document.getElementById('chat-history');
const chatForm = document.getElementById('chat-form');
const messageInput = document.getElementById('message-input');
const sendButton = document.getElementById('send-button');
const thinkCheckbox = document.getElementById('think-checkbox'); // Restored

// --- WebSocket & Client ID ---
let websocket;
const clientId = `web-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
let currentTurnId = 0; // Simple counter for unique IDs per turn

// --- State Machine Modes ---
const MODE_ANSWER = 'MODE_ANSWER';
const MODE_SEEKING_CODE_START_FENCE = 'MODE_SEEKING_CODE_START_FENCE'; // Looking for ```
const MODE_SEEKING_CODE_LANGUAGE = 'MODE_SEEKING_CODE_LANGUAGE';     // Reading language after ```
const MODE_INSIDE_CODE_BLOCK = 'MODE_INSIDE_CODE_BLOCK';        // Inside the code block
const MODE_SEEKING_CODE_END_FENCE = 'MODE_SEEKING_CODE_END_FENCE';   // Found potential closing ```

// --- State Variables ---
let currentProcessingMode = MODE_ANSWER;
let fenceBuffer = '';             // Buffer for detecting ``` fences
let langBuffer = '';              // Buffer for language string
let codeBuffer = '';              // Buffer for code content within a block
let currentCodeBlockLang = '';    // Detected language for the current block
let currentCodeBlockElement = null; // The <code> element being filled
let currentCodeBlockPreElement = null; // The <pre> element wrapping the code
let currentAiTurnContainer = null;  // The main container for the AI bubble + its code blocks
let currentAnswerElement = null;    // The div.ai-message bubble
let currentCodeBlocksArea = null; // The div below bubble holding code blocks
let codeBlockCounterThisTurn = 0; // Counter for code blocks within the *current* AI turn
let thinkingRequestedForCurrentTurn = false; // Restored
let isFirstContentChunkForTurn = true;

// --- Constants ---
const FENCE = '```';

// --- Helper Functions ---

function scrollToBottom() {
    // Adding a small delay can sometimes help ensure scrolling happens after render
    setTimeout(() => {
        chatHistory.scrollTo({ top: chatHistory.scrollHeight, behavior: 'smooth' });
    }, 50);
}

function addUserMessage(text) {
    const messageElement = document.createElement('div');
    messageElement.classList.add('message', 'user-message');
    messageElement.textContent = text;
    chatHistory.appendChild(messageElement);
    scrollToBottom();
}

function addSystemMessage(text) {
     const messageElement = document.createElement('div');
     messageElement.classList.add('system-message');
     messageElement.textContent = text;
     chatHistory.appendChild(messageElement);
     scrollToBottom();
}

function addErrorMessage(text) {
     console.error("[UI ERROR] ", text);
     const messageElement = document.createElement('div');
     messageElement.classList.add('error-message'); // Use error styling
     messageElement.textContent = `Error: ${text}`;
     if(currentAiTurnContainer) {
         currentAiTurnContainer.appendChild(messageElement); // Append error within the turn container
     } else {
         chatHistory.appendChild(messageElement); // Fallback if no turn container exists
     }
     scrollToBottom();
}

function setInputDisabledState(disabled) {
    messageInput.disabled = disabled;
    sendButton.disabled = disabled;
    if (thinkCheckbox) {
        thinkCheckbox.disabled = disabled;
    }
}

function finalizeTurnOnErrorOrClose() {
    console.log("[DEBUG] finalizeTurnOnErrorOrClose called.");
    if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK && currentCodeBlockElement) {
        console.warn("Stream ended unexpectedly inside a code block.");
        try {
            Prism.highlightElement(currentCodeBlockElement);
        } catch (e) { console.error("Prism highlighting error on incomplete block:", e); }
    }
    resetStreamingState();
    setInputDisabledState(true); // Disable input on error/close
}

function resetStreamingState() {
    console.log("[DEBUG] Resetting streaming state.");
    currentProcessingMode = MODE_ANSWER;
    fenceBuffer = '';
    langBuffer = '';
    codeBuffer = '';
    currentCodeBlockLang = '';
    currentCodeBlockElement = null;
    currentCodeBlockPreElement = null;
    // Note: Turn-specific elements (currentAiTurnContainer, etc.) are managed by setupNewAiTurn
}

function setupNewAiTurn() {
    currentTurnId++;
    codeBlockCounterThisTurn = 0; // Reset code block counter
    isFirstContentChunkForTurn = true; // <<< Reset the flag for the new turn

    currentAiTurnContainer = document.createElement('div');
    currentAiTurnContainer.classList.add('ai-turn-container');
    currentAiTurnContainer.dataset.turnId = currentTurnId;

    currentAnswerElement = document.createElement('div');
    currentAnswerElement.classList.add('message', 'ai-message');
    currentAiTurnContainer.appendChild(currentAnswerElement);

    currentCodeBlocksArea = document.createElement('div');
    currentCodeBlocksArea.classList.add('code-blocks-area');
    currentAiTurnContainer.appendChild(currentCodeBlocksArea);

    chatHistory.appendChild(currentAiTurnContainer);
}

function appendToAnswerBubble(text) {
    if (!currentAnswerElement) {
        console.error("Attempted to append to null answer bubble!");
        // Attempt recovery only if there's actual text content
        if (text.trim().length === 0) return; // Don't try to recover for whitespace only

        if (currentAiTurnContainer && !currentAiTurnContainer.querySelector('.ai-message')) {
             currentAnswerElement = document.createElement('div');
             currentAnswerElement.classList.add('message', 'ai-message');
             currentAiTurnContainer.insertBefore(currentAnswerElement, currentCodeBlocksArea);
        } else if (currentAiTurnContainer) {
             currentAnswerElement = currentAiTurnContainer.querySelector('.ai-message');
             if(!currentAnswerElement) {
                console.error("CRITICAL: Cannot find or create answer bubble in turn container.");
                return;
             }
        } else {
            console.error("CRITICAL: No turn container to recover answer bubble.");
            return;
        }
    }

    // <<< START: Added Leading Whitespace Trim Logic >>>
    let processedText = text;
    if (isFirstContentChunkForTurn) {
        processedText = text.trimStart(); // Remove leading whitespace ONLY for the first chunk
        // Only set flag to false if we actually processed non-empty text after trimming
        if (processedText.length > 0) {
             isFirstContentChunkForTurn = false;
        }
    }
    // <<< END: Added Leading Whitespace Trim Logic >>>

    // Append text content only if there is something left after trimming
    if (processedText.length > 0) {
        currentAnswerElement.appendChild(document.createTextNode(processedText));
    }
}


function appendCodeReference() {
    if (!currentAnswerElement) {
        console.error("Attempted to append code reference to null answer bubble!");
        return;
    }
    codeBlockCounterThisTurn++;
    const refSpan = document.createElement('span');
    refSpan.classList.add('code-reference');
    refSpan.textContent = `[Code ${codeBlockCounterThisTurn}]`;
    currentAnswerElement.appendChild(refSpan); // Append the span node
}

function createCodeBlockStructure(language) {
    if (!currentCodeBlocksArea) {
        console.error("Attempted to create code block in null area!");
        return;
    }

    const blockId = `code-block-turn${currentTurnId}-${codeBlockCounterThisTurn}`;
    // Normalize language: lowercase, trim, default 'plain', handle potential null/undefined
    const safeLanguage = (language || '').trim().toLowerCase() || 'plain';
    // Alias common variations
    const langAlias = {
        'python': 'python', 'py': 'python',
        'javascript': 'javascript', 'js': 'javascript',
        'html': 'markup', 'xml': 'markup', 'svg': 'markup', // Prism uses 'markup' for HTML/XML
        'css': 'css',
        'bash': 'bash', 'shell': 'bash',
        'java': 'java',
        'csharp': 'csharp', 'cs': 'csharp',
        'cpp': 'cpp', 'c++': 'cpp',
        'ruby': 'ruby', 'rb': 'ruby',
        'go': 'go',
        'php': 'php',
        'json': 'json',
        'yaml': 'yaml', 'yml': 'yaml',
        'sql': 'sql',
        'markdown': 'markdown', 'md': 'markdown'
    };
    const prismLang = langAlias[safeLanguage] || safeLanguage; // Use alias or original safe name
    const displayLang = safeLanguage; // Show the user what they typed (or 'plain')


    const container = document.createElement('div');
    container.classList.add('code-block-container');
    container.id = blockId;

    const header = document.createElement('div');
    header.classList.add('code-block-header');

    const title = document.createElement('span');
    title.textContent = `Code ${codeBlockCounterThisTurn} (${displayLang})`;

    const buttonsDiv = document.createElement('div');
    const toggleBtn = document.createElement('button');
    toggleBtn.classList.add('toggle-code-btn');
    toggleBtn.textContent = 'Show'; // Default text
    const copyBtn = document.createElement('button');
    copyBtn.classList.add('copy-code-btn');
    copyBtn.textContent = 'Copy';

    buttonsDiv.appendChild(toggleBtn);
    buttonsDiv.appendChild(copyBtn);

    // Append buttons first, then title
    header.appendChild(buttonsDiv);
    header.appendChild(title);

    // Create pre/code elements but store references locally for listeners
    const preElement = document.createElement('pre');
    const codeElement = document.createElement('code');
    codeElement.classList.add(`language-${prismLang}`);
    preElement.classList.add('hidden'); // Add hidden class by default

    // Assign references for streaming
    currentCodeBlockPreElement = preElement;
    currentCodeBlockElement = codeElement; // This global ref is used *during* streaming

    preElement.appendChild(codeElement);
    container.appendChild(header);
    container.appendChild(preElement);

    // --- Event Listeners ---

    toggleBtn.addEventListener('click', () => {
        // Find the pre element relative to the button clicked
        const containerDiv = toggleBtn.closest('.code-block-container');
        const preToToggle = containerDiv?.querySelector('pre');
        if (preToToggle) {
            const isHidden = preToToggle.classList.toggle('hidden');
            toggleBtn.textContent = isHidden ? 'Show' : 'Hide'; // Toggle text
        }
    });

    copyBtn.addEventListener('click', () => {
        // <<< START: Updated Copy Logic >>>
        // Find the specific container and code element relative to *this* button
        const containerDiv = copyBtn.closest('.code-block-container');
        const codeElementToCopy = containerDiv?.querySelector('pre > code');

        if (!codeElementToCopy) {
            console.error('Could not find code element to copy for button:', copyBtn);
            copyBtn.textContent = 'Error!';
             setTimeout(() => { copyBtn.textContent = 'Copy'; }, 1500);
            return; // Exit if element not found
        }

        const codeContent = codeElementToCopy.textContent;
        navigator.clipboard.writeText(codeContent).then(() => {
            copyBtn.textContent = 'Copied!';
            copyBtn.classList.add('copied'); // Add class for potential styling feedback
            setTimeout(() => {
                // Check if the text is still 'Copied!' before resetting
                // (prevents flicker if user clicks multiple times quickly)
                if (copyBtn.textContent === 'Copied!') {
                    copyBtn.textContent = 'Copy';
                    copyBtn.classList.remove('copied');
                }
            }, 1500); // Reset after 1.5 seconds
        }).catch(err => {
            console.error('Failed to copy code: ', err);
            copyBtn.textContent = 'Error!';
             // Remove copied class if it was somehow added
            copyBtn.classList.remove('copied');
            setTimeout(() => {
                 if (copyBtn.textContent === 'Error!') {
                    copyBtn.textContent = 'Copy';
                 }
            }, 1500); // Reset after 1.5 seconds
        });
        // <<< END: Updated Copy Logic >>>
    });

    currentCodeBlocksArea.appendChild(container);
}

function appendToCodeBlock(text) {
    if (currentCodeBlockElement) {
        // Append text content to the <code> element
         currentCodeBlockElement.appendChild(document.createTextNode(text));
    } else {
        console.error("Attempted to append to null code block element!");
    }
}

function finalizeCodeBlock() {
    if (currentCodeBlockElement) {
        try {
            // Highlight the completed block using Prism
            Prism.highlightElement(currentCodeBlockElement);
            console.log(`[DEBUG] Highlighted code block ${codeBlockCounterThisTurn} (lang: ${currentCodeBlockLang})`);
            // Optional: Add line numbers if plugin is active
            // if (currentCodeBlockPreElement.classList.contains('line-numbers')) {
            //     Prism.plugins.lineNumbers.resize(currentCodeBlockPreElement);
            // }
        } catch (e) {
            console.error(`Prism highlighting error for lang '${currentCodeBlockLang}':`, e);
            // Add a class indicating error?
             currentCodeBlockElement.classList.add('prism-highlight-error');
        }
    }
    // Reset code block specific state
    currentCodeBlockElement = null;
    currentCodeBlockPreElement = null;
    currentCodeBlockLang = '';
    codeBuffer = ''; // Clear code buffer
}

// --- WebSocket Connection ---
function connectWebSocket() {
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${window.location.host}/ws/${clientId}`;
    console.log(`[DEBUG] Attempting to connect to WebSocket: ${wsUrl}`);

    try {
        const ws = new WebSocket(wsUrl);

        ws.onopen = (event) => {
            console.log("[DEBUG] WebSocket connection opened");
            websocket = ws;
            setInputDisabledState(false); // Enable inputs
            addSystemMessage("Connected to the chat server.");
            // Add initial AI message
            setupNewAiTurn();
            appendToAnswerBubble("AI: Hello! How can I help you today?");
            resetStreamingState(); // Reset state machine after initial message

            if(messageInput.offsetParent !== null) messageInput.focus();
        };

        ws.onmessage = (event) => {
            let chunk = event.data;

            // --- Handle Control Messages First ---
            if (chunk === "<EOS>") {
                console.log("[DEBUG] Received <EOS>. Finalizing turn.");
                 // If ended inside a code block, finalize it
                 if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK) {
                    finalizeCodeBlock();
                } else if (currentProcessingMode === MODE_SEEKING_CODE_END_FENCE && fenceBuffer.length > 0) {
                    // Ended while seeking end fence, treat buffer as regular text
                    appendToAnswerBubble(fenceBuffer);
                 } else if (currentProcessingMode === MODE_SEEKING_CODE_LANGUAGE && langBuffer.length > 0) {
                     // Ended while seeking language, treat as regular text
                    appendToAnswerBubble(FENCE + langBuffer);
                 } else if (currentProcessingMode === MODE_SEEKING_CODE_START_FENCE && fenceBuffer.length > 0) {
                     // Ended while seeking start fence, treat as regular text
                    appendToAnswerBubble(fenceBuffer);
                 }

                resetStreamingState();
                setInputDisabledState(false); // Re-enable inputs
                if(messageInput.offsetParent !== null) messageInput.focus();
                scrollToBottom();
                return; // End processing for this message
            }
            if (chunk.startsWith("<ERROR>")) {
                const errorMessage = chunk.substring(7);
                console.error("[DEBUG] Received <ERROR>:", errorMessage);
                addErrorMessage(errorMessage);
                finalizeTurnOnErrorOrClose(); // Disables input
                scrollToBottom();
                return; // End processing for this message
            }

            // <<< --- START: Tag Filtering --- >>>
            // Remove <think> and </think> tags and any surrounding whitespace globally
            chunk = chunk.replace(/\s*<think>\s*/g, '').replace(/\s*<\/think>\s*/g, '');
            // If the chunk becomes empty after filtering, skip further processing for this chunk
            if (chunk.length === 0) {
                return;
            }
            // <<< --- END: Tag Filtering --- >>>


            // Ensure AI turn container exists (should be set up by setupNewAiTurn)
             if (!currentAiTurnContainer) {
                 console.error("CRITICAL: No AI turn container set up before message chunk received!");
                 // Attempt recovery only if chunk contains non-whitespace content after filtering
                 if (chunk.trim().length > 0) {
                    setupNewAiTurn();
                 } else {
                    return; // Don't set up turn for empty/whitespace-only chunks
                 }
            }

            // --- State Machine Processing ---
            let currentPos = 0;
            while (currentPos < chunk.length) {
                const char = chunk[currentPos];
                let incrementPos = true;

                switch (currentProcessingMode) {
                    case MODE_ANSWER:
                        if (char === FENCE[0]) {
                            fenceBuffer = char;
                            currentProcessingMode = MODE_SEEKING_CODE_START_FENCE;
                        } else {
                            appendToAnswerBubble(char);
                        }
                        break;

                    case MODE_SEEKING_CODE_START_FENCE:
                        if (char === FENCE[fenceBuffer.length]) {
                            fenceBuffer += char;
                            if (fenceBuffer === FENCE) {
                                console.log("[DEBUG] Found ``` start fence.");
                                fenceBuffer = '';
                                langBuffer = '';
                                currentProcessingMode = MODE_SEEKING_CODE_LANGUAGE;
                            }
                        } else {
                            appendToAnswerBubble(fenceBuffer + char);
                            fenceBuffer = '';
                            currentProcessingMode = MODE_ANSWER;
                        }
                        break;

                    case MODE_SEEKING_CODE_LANGUAGE:
                        if (char === '\n') {
                            console.log(`[DEBUG] Found language line: '${langBuffer}'`);
                            currentCodeBlockLang = langBuffer; // Keep raw lang buffer for createCodeBlockStructure
                            appendCodeReference();
                            createCodeBlockStructure(currentCodeBlockLang); // Handles normalization/aliasing
                            langBuffer = '';
                            codeBuffer = '';
                            currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                        } else if (langBuffer.length > 50) { // Prevent runaway language buffer
                             console.warn("Language line too long, assuming no language.");
                             appendToAnswerBubble(FENCE + langBuffer + char); // Treat as text
                             langBuffer = '';
                             fenceBuffer = '';
                             currentProcessingMode = MODE_ANSWER;
                        } else {
                            langBuffer += char;
                        }
                        break;

                    case MODE_INSIDE_CODE_BLOCK:
                        if (char === FENCE[0]) {
                            fenceBuffer = char;
                            currentProcessingMode = MODE_SEEKING_CODE_END_FENCE;
                        } else {
                            appendToCodeBlock(char);
                        }
                        break;

                    case MODE_SEEKING_CODE_END_FENCE:
                        if (char === FENCE[fenceBuffer.length]) {
                            fenceBuffer += char;
                            if (fenceBuffer === FENCE) {
                                console.log("[DEBUG] Found ``` end fence.");
                                // Check for immediate newline after fence, common pattern
                                if (currentPos + 1 < chunk.length && chunk[currentPos + 1] === '\n') {
                                     currentPos++; // Consume the newline
                                } else {
                                     // If next char is not newline, maybe check later chunks?
                                     // For simplicity, we'll just finalize here.
                                }
                                finalizeCodeBlock();
                                fenceBuffer = '';
                                currentProcessingMode = MODE_ANSWER;
                            }
                        } else {
                            appendToCodeBlock(fenceBuffer + char);
                            fenceBuffer = '';
                            currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                        }
                        break;

                    default:
                        console.error("Unknown processing mode:", currentProcessingMode);
                        currentProcessingMode = MODE_ANSWER;
                        incrementPos = false;
                }

                if (incrementPos) {
                    currentPos++;
                }
            } // end while loop over chunk

            scrollToBottom();
        }; // end onmessage

        ws.onerror = (event) => {
             console.error("WebSocket error:", event);
             addErrorMessage("WebSocket connection error. Please try refreshing the page.");
             finalizeTurnOnErrorOrClose();
        };

        ws.onclose = (event) => {
             console.log(`[DEBUG] WebSocket connection closed: Code=${event.code}, Reason='${event.reason}', WasClean=${event.wasClean}`);
             addSystemMessage(`Connection closed. ${event.reason ? event.reason : ''} (Code: ${event.code}). Attempting to reconnect...`);
             finalizeTurnOnErrorOrClose();
             websocket = undefined;
             const reconnectDelay = Math.min(1000 * (2 ** Math.min(8, event.code === 1000 ? 0 : 1)), 30000);
             console.log(`[DEBUG] Attempting reconnect in ${reconnectDelay}ms`);
             setTimeout(connectWebSocket, reconnectDelay);
        };

        console.log("[DEBUG] WebSocket object created and handlers assigned.");

    } catch (error) {
        console.error("[DEBUG] Error creating WebSocket:", error);
        addErrorMessage(`Failed to initialize WebSocket connection: ${error.message}. Check browser console.`);
        finalizeTurnOnErrorOrClose();
    }
}

if (chatForm) {
    chatForm.addEventListener('submit', (event) => {
        event.preventDefault(); // Prevent default form submission

        const userMessage = messageInput.value.trim(); // Get user text

        if (!userMessage) {
            return; // Do nothing if message is empty
        }

        // --- Check WebSocket State BEFORE Attempting Send ---
        if (!websocket || websocket.readyState !== WebSocket.OPEN) {
            console.warn("[Submit] WebSocket not ready or not defined. State:", websocket?.readyState);
            addErrorMessage("Not connected to the server. Please wait or refresh.");
            return; // Exit if not connected
        }

        // --- If WebSocket is OPEN, proceed ---
        try {
            // --- Step 1: Display User Message ---
            addUserMessage(userMessage); // Show user's raw message immediately

            // --- Step 2: Determine Thinking State & Prepare Message for Backend ---
            thinkingRequestedForCurrentTurn = thinkCheckbox ? thinkCheckbox.checked : false;
            console.log(`[Submit] Checkbox checked: ${thinkingRequestedForCurrentTurn}.`);

            let messageToSend = userMessage; // Default to the raw user message
            // Ensure NO_THINK_PREFIX is defined globally, e.g., const NO_THINK_PREFIX = "\\no_think";
            if (!thinkingRequestedForCurrentTurn) {
                messageToSend = NO_THINK_PREFIX + userMessage;
                console.log(`[Submit] Prepended '${NO_THINK_PREFIX}'. Prepared message: "${messageToSend.substring(0, 100)}..."`);
            } else {
                console.log(`[Submit] Prepared raw message (thinking requested): "${messageToSend.substring(0, 100)}..."`);
            }

            // --- Step 3: Setup UI for AI Response ---
            setupNewAiTurn(); // Uses thinkingRequestedForCurrentTurn for initial visibility

            // --- Step 4: Attempt to Send Message to WebSocket ---
            console.log(`[Submit] >>> About to call websocket.send(). State: ${websocket?.readyState}`); // Log state right before send

            websocket.send(messageToSend); // *** THE ACTUAL SEND CALL ***

            console.log("[Submit] <<< websocket.send() call completed (no immediate error thrown)."); // Log right after send

            // --- Step 5: Clear Input & Disable ---
            messageInput.value = '';          // Clear the input field
            setInputDisabledState(true); // Disable inputs while waiting for response
            console.log("[Submit] Input cleared and disabled.");

        } catch (sendError) {
            // --- Catch Errors During Send or Subsequent Steps ---
            console.error("[Submit] !!! ERROR during send attempt or post-send steps:", sendError);
            addErrorMessage(`Failed to send message: ${sendError.message}`);
            // Optionally re-enable input if send fails? Or leave disabled?
            // setInputDisabledState(false);
        }

    }); // End of submit handler
} else {
    // Handle case where the form element itself is missing
    console.error("CRITICAL ERROR: Could not find chat form element with ID 'chat-form'. Messages cannot be sent.");
    if (typeof addErrorMessage === 'function') {
        addErrorMessage("Initialization Error: Chat input form not found.");
    } else {
        alert("Initialization Error: Chat input form not found.");
    }
}

// --- Initial Setup ---
setInputDisabledState(true); // Disable inputs until connected
connectWebSocket(); // Start connection (will add initial AI message and enable inputs onopen)

=== temp.py ===
import os
import asyncio
import sys
import uvicorn
import webbrowser
import tempfile
import shutil
import json # Added for WebSocket message parsing/sending
import traceback # For detailed error logging
from pathlib import Path
from dotenv import load_dotenv
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Request, HTTPException
from fastapi.responses import HTMLResponse # JSONResponse no longer needed for run_code
from fastapi.staticfiles import StaticFiles
from fastapi.websockets import WebSocketState # Import WebSocketState
from pydantic import BaseModel # Keep for potential future HTTP models
import docker # Docker SDK
from docker.errors import DockerException, ImageNotFound, APIError, NotFound # Docker specific errors
from docker.models.containers import Container # For type hinting
from langchain_ollama.llms import OllamaLLM
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.output_parsers import StrOutputParser
from langchain.memory import ConversationBufferMemory
from langchain_core.runnables import RunnablePassthrough # RunnableLambda no longer needed here
from langchain_core.messages import HumanMessage, AIMessage

# --- Configuration ---
load_dotenv()
MODEL_ID = os.getenv("MODEL_ID", "qwen3")
OLLAMA_BASE_URL = os.getenv("OLLAMA_BASE_URL", "http://localhost:11434")
# NO_THINK_PREFIX is handled by frontend, backend receives prefixed message
NO_THINK_PREFIX = "\\no_think"

# --- Docker Configuration ---
SUPPORTED_LANGUAGES = {
    "python": {
        "image": "python:3.11-slim",
        "filename": "script.py",
        "command": ["python", "-u", "/app/script.py"] # Added -u for unbuffered output
    },
    "javascript": {
        "image": "node:18-alpine",
        "filename": "script.js",
        "command": ["node", "/app/script.js"]
    },
    # Add more languages here if needed
}
DOCKER_TIMEOUT_SECONDS = 30 # Increased timeout for potentially longer runs
DOCKER_MEM_LIMIT = "128m"

# --- FastAPI App Initialization ---
# Ensure the app object is created correctly
app = FastAPI(title="Ollama Web Chat")

# --- Docker Client Initialization ---
docker_client = None
try:
    docker_client = docker.from_env()
    docker_client.ping()
    print("Successfully connected to Docker daemon.")
except DockerException as e:
    print(f"CRITICAL WARNING: Could not connect to Docker daemon: {e}")
    print("Code execution via Docker will be unavailable.")
    docker_client = None

# --- Static Files Setup ---
# Determine the static files directory relative to this script's location
# This assumes main.py is either in the project root or inside an 'app' directory.
script_location = Path(__file__).parent
static_dir_in_app = script_location / "static"
static_dir_at_root = script_location.parent / "static" # If main.py is in 'app' dir

if static_dir_in_app.is_dir():
    static_dir = static_dir_in_app
    print(f"Found static directory at: {static_dir}")
elif script_location.name == "app" and static_dir_at_root.is_dir():
     # If script is in 'app' and 'static' is sibling to 'app'
     static_dir = static_dir_at_root
     print(f"Found static directory at: {static_dir}")
else:
    # Fallback check if script is in root and static is in root
    if (script_location.parent / "static").is_dir():
         static_dir = script_location.parent / "static"
         print(f"Found static directory at: {static_dir}")
    else:
        print(f"CRITICAL ERROR: Static directory not found near '{script_location}'. Looked for '{static_dir_in_app}' and '{static_dir_at_root}'. Exiting.")
        sys.exit(1)

# Mount static files - THIS MUST BE CORRECT FOR CSS/JS
app.mount("/static", StaticFiles(directory=str(static_dir)), name="static")
print(f"Mounted static directory '{static_dir}' at '/static'")


# --- LangChain Setup ---
try:
    model = OllamaLLM(model=MODEL_ID, base_url=OLLAMA_BASE_URL)
    print(f"Successfully initialized OllamaLLM: {MODEL_ID} at {OLLAMA_BASE_URL}")
except Exception as e:
    print(f"CRITICAL ERROR: OllamaLLM init failed: {e}"); sys.exit(1)

# --- Global State for WebSocket Connections and Running Containers ---
client_memory = {}
# Stores info about currently running code executions
# Format: { "code_block_id": {"container": Container, "stream_task": asyncio.Task, "client_id": str, "websocket": WebSocket, "stop_event": asyncio.Event} }
running_containers = {}
running_containers_lock = asyncio.Lock() # Lock for safe concurrent access

# --- Memory Management Functions (Unchanged) ---
def get_memory_for_client(client_id: str) -> ConversationBufferMemory:
    """Retrieves or creates memory for a specific client."""
    if client_id not in client_memory:
        client_memory[client_id] = ConversationBufferMemory(return_messages=True, memory_key="history")
        print(f"Initialized new memory for client: {client_id}")
    return client_memory[client_id]

def remove_memory_for_client(client_id: str):
    """Removes memory when a client disconnects."""
    if client_id in client_memory:
        del client_memory[client_id]
        print(f"Removed memory for client: {client_id}")

# --- LangChain Prompt and Chain Setup (Unchanged) ---
prompt = ChatPromptTemplate.from_messages([
    ("system", "You are a helpful AI assistant chatting in a web interface. Answer the user's questions concisely. Always use katex for math ($...$ or $$...$$). For a literal dollar sign use \\$. When providing code, use standard markdown code blocks (e.g., ```python ... ```)."),
    MessagesPlaceholder(variable_name="history"),
    ("human", "{input}")
])
output_parser = StrOutputParser()

# --- Helper Functions for WebSocket Code Execution (Unchanged from previous version) ---

async def send_ws_message(websocket: WebSocket, message_type: str, payload: dict):
    """Safely sends a JSON message over the WebSocket."""
    # Check state before sending
    if websocket.client_state != WebSocketState.CONNECTED:
         print(f"WebSocket not connected, cannot send {message_type} for {payload.get('code_block_id', 'N/A')}")
         return
    try:
        await websocket.send_json({"type": message_type, "payload": payload})
    except WebSocketDisconnect:
        print(f"WebSocket disconnected while trying to send {message_type} for {payload.get('code_block_id', 'N/A')}")
    except Exception as e:
        # Catch other potential errors like Runtime Error if connection closed during send
        print(f"Error sending WebSocket message ({message_type}) for {payload.get('code_block_id', 'N/A')}: {e}")
        # traceback.print_exc() # Optional: uncomment for more detail

# This function runs in a separate thread via run_in_executor
def sync_log_streamer(container: Container, websocket: WebSocket, code_block_id: str, loop: asyncio.AbstractEventLoop, stop_event: asyncio.Event):
    """
    Synchronously iterates through Docker logs and schedules sending messages
    back to the main asyncio loop. Runs in an executor thread.
    """
    try:
        # Note: follow=True keeps the stream open until container stops or stream is closed.
        log_stream = container.logs(stream=True, follow=True, stdout=True, stderr=True)
        print(f"[Thread-{code_block_id}] Starting log iteration for container {container.short_id}")

        for line_bytes in log_stream:
            if stop_event.is_set():
                print(f"[Thread-{code_block_id}] Stop event set, breaking log iteration.")
                break

            line_str = line_bytes.decode('utf-8', errors='replace')
            # Schedule the send_ws_message coroutine to run on the main event loop
            asyncio.run_coroutine_threadsafe(
                send_ws_message(websocket, "code_output", {
                    "code_block_id": code_block_id,
                    "stream": "stdout", # Sending all as stdout for simplicity, could try parsing later
                    "data": line_str
                }),
                loop # Pass the main event loop
            )

        print(f"[Thread-{code_block_id}] Finished log iteration for container {container.short_id}")

    except Exception as e:
        # Log error from the thread
        print(f"[Thread-{code_block_id}] Error during log streaming: {e}")
        # Don't print traceback here usually, as it might be expected on stop
        # traceback.print_exc()
        # Try to send an error message back to the client via the main loop
        asyncio.run_coroutine_threadsafe(
            send_ws_message(websocket, "code_output", {
                "code_block_id": code_block_id,
                "stream": "error",
                "data": f"\n[Error streaming logs from container: {str(e)}]"
            }),
            loop
        )

async def stream_docker_logs_via_executor(websocket: WebSocket, container: Container, code_block_id: str, stop_event: asyncio.Event):
    """
    Runs the synchronous log streamer function in an executor thread.
    """
    loop = asyncio.get_running_loop()
    print(f"Scheduling log streaming task in executor for {code_block_id}")
    # Run the sync function in the default executor
    await loop.run_in_executor(
        None, # Use default thread pool executor
        sync_log_streamer, # The function to run
        container, websocket, code_block_id, loop, stop_event # Arguments for the function
    )
    print(f"Executor task for log streaming finished for {code_block_id}")


async def run_code_in_docker_stream(websocket: WebSocket, client_id: str, code_block_id: str, language: str, code: str):
    """Runs code in Docker, streams output via WebSocket, and manages container lifecycle."""
    global docker_client, running_containers, running_containers_lock

    if not docker_client:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": "Docker service is unavailable on the server."
        })
        return

    lang_key = language.lower()
    lang_config = SUPPORTED_LANGUAGES.get(lang_key)
    if not lang_config:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": f"Language '{language}' not supported for execution."
        })
        return

    image_name = lang_config["image"]
    script_filename = lang_config["filename"]
    command = lang_config["command"]
    container_obj: Container | None = None
    stream_task: asyncio.Task | None = None
    tmpdir_obj = None # To hold the TemporaryDirectory object
    stop_event = asyncio.Event() # Event to signal cancellation to the streamer thread

    try:
        # Create temporary directory safely
        tmpdir_obj = tempfile.TemporaryDirectory()
        tmpdir = tmpdir_obj.name # Get the path string
        host_script_path = Path(tmpdir) / script_filename
        with open(host_script_path, "w", encoding="utf-8") as f:
            f.write(code)

        print(f"Attempting to run block {code_block_id} ({lang_key}) in Docker image {image_name}...")

        # Run the container detached
        container_obj = docker_client.containers.run(
            image=image_name,
            command=command,
            volumes={tmpdir: {'bind': '/app', 'mode': 'ro'}}, # Read-only mount
            working_dir='/app',
            mem_limit=DOCKER_MEM_LIMIT,
            stdout=True,
            stderr=True,
            detach=True, # Run in background
            # auto_remove=True, # Cannot auto-remove if we need to wait/get logs/stop
        )
        print(f"Container {container_obj.short_id} started for {code_block_id}")

        # Start the log streaming task using the executor helper
        stream_task = asyncio.create_task(
            stream_docker_logs_via_executor(websocket, container_obj, code_block_id, stop_event),
            name=f"log_stream_{code_block_id}" # Give the task a name for debugging
        )

        # Store container and task info BEFORE waiting
        async with running_containers_lock:
            if code_block_id in running_containers:
                 # This should ideally not happen if frontend disables button, but handle defensively
                 print(f"WARNING: Code block {code_block_id} was already running. Stopping previous run.")
                 # Call stop without await here, as we are inside the lock
                 # stop_docker_container needs to acquire the lock itself, so we schedule it
                 asyncio.create_task(stop_docker_container(code_block_id))


            running_containers[code_block_id] = {
                "container": container_obj,
                "stream_task": stream_task,
                "client_id": client_id,
                "websocket": websocket,
                "stop_event": stop_event # Store the stop event
            }

        # Wait for the container to finish execution or timeout
        print(f"Waiting for container {container_obj.short_id} ({code_block_id}) to finish...")
        loop = asyncio.get_running_loop()
        result = await loop.run_in_executor(
            None, # Use default executor
            lambda: container_obj.wait(timeout=DOCKER_TIMEOUT_SECONDS)
        )
        exit_code = result.get("StatusCode", -1)
        error_msg = result.get("Error", None)
        print(f"Container {container_obj.short_id} ({code_block_id}) finished. Result: {result}")

        # Ensure log streaming task is complete (it should be if container exited naturally)
        # Set stop event first to signal the thread, then wait/cancel task
        stop_event.set()
        try:
            # Wait briefly for the executor task to finish processing final logs
            await asyncio.wait_for(stream_task, timeout=5.0)
        except asyncio.TimeoutError:
            print(f"Warning: Log streaming task for {code_block_id} did not finish quickly after container exit.")
            # If it timed out, ensure it's cancelled (though setting stop_event should handle it)
            if not stream_task.done():
                stream_task.cancel()
        except asyncio.CancelledError:
             print(f"Log streaming task for {code_block_id} was cancelled (likely during stop).")
             pass # Already handled

        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id,
            "exit_code": exit_code,
            "error": error_msg # Send Docker-level error if any
        })

    except asyncio.TimeoutError: # Timeout from container_obj.wait()
        print(f"ERROR: Docker execution timed out for block {code_block_id} after {DOCKER_TIMEOUT_SECONDS}s.")
        await send_ws_message(websocket, "code_finished", {
             "code_block_id": code_block_id, "exit_code": -1,
             "error": f"Execution timed out after {DOCKER_TIMEOUT_SECONDS} seconds."
        })
        # Attempt to stop the timed-out container (this will also cancel the stream task via stop_docker_container)
        # Schedule stop_docker_container as it needs to acquire the lock
        asyncio.create_task(stop_docker_container(code_block_id))


    except ImageNotFound:
        error_msg = f"Server Error: Docker image '{image_name}' not found. Please pull it."
        print(f"ERROR for block {code_block_id}: {error_msg}")
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except APIError as e:
        error_msg = f"Server Error: Docker API error: {e}"
        print(f"ERROR for block {code_block_id}: {error_msg}")
        traceback.print_exc()
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except Exception as e:
        error_msg = f"Server Execution Error: {str(e)}"
        print(f"ERROR during Docker execution setup or wait for block {code_block_id}: {e}")
        traceback.print_exc()
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
        # Ensure stream task is cancelled if it was started
        if stream_task and not stream_task.done():
            print(f"Cancelling stream task for {code_block_id} due to setup/wait error.")
            stop_event.set() # Signal thread to stop
            stream_task.cancel()

    finally:
        # --- Final Cleanup ---
        # Remove from tracking dict if it hasn't been removed by stop_docker_container already
        async with running_containers_lock:
            if code_block_id in running_containers:
                print(f"Performing final cleanup check for {code_block_id}")
                task_to_cancel = running_containers[code_block_id]["stream_task"]
                stop_ev = running_containers[code_block_id]["stop_event"]
                if task_to_cancel and not task_to_cancel.done():
                     print(f"Final cleanup: Cancelling stream task for {code_block_id}")
                     stop_ev.set() # Signal thread
                     task_to_cancel.cancel()
                # Remove from tracking dict
                del running_containers[code_block_id]
                print(f"Removed {code_block_id} from running_containers during final cleanup")

        # Remove container if it exists and hasn't been removed by stop
        if container_obj:
            try:
                # Check if container still exists before removing
                await asyncio.get_running_loop().run_in_executor(None, container_obj.reload)
                print(f"Removing container {container_obj.short_id} ({code_block_id}) in final cleanup")
                # Need to run blocking remove in executor
                await asyncio.get_running_loop().run_in_executor(None, lambda: container_obj.remove(force=True))
            except NotFound:
                 print(f"Container {container_obj.short_id} already removed.")
                 pass # Already removed
            except Exception as rm_err:
                print(f"Error removing container {container_obj.short_id} in final cleanup: {rm_err}")

        # Clean up temporary directory
        if tmpdir_obj:
             try:
                  tmpdir_obj.cleanup()
             except Exception as cleanup_err:
                  print(f"Error cleaning up temp directory {tmpdir}: {cleanup_err}")


async def stop_docker_container(code_block_id: str):
    """Stops a running Docker container and cancels its log stream task."""
    global running_containers, running_containers_lock
    print(f"Attempting to stop execution for code block: {code_block_id}")
    loop = asyncio.get_running_loop()
    container_info = None
    container_obj = None
    stream_task = None
    websocket = None
    stop_event = None

    async with running_containers_lock:
        if code_block_id in running_containers:
            # Pop the entry to prevent others from trying to stop it simultaneously
            container_info = running_containers.pop(code_block_id)
            container_obj = container_info["container"]
            stream_task = container_info["stream_task"]
            websocket = container_info["websocket"] # Get websocket for final message
            stop_event = container_info["stop_event"]
            print(f"Found and removed running container {container_obj.short_id} for {code_block_id} from tracking.")
        else:
            print(f"Stop request for {code_block_id}, but it was not found in running_containers.")
            return # Nothing to stop

    # Perform actions outside the lock

    # 1. Signal the streaming thread to stop and cancel the task
    if stop_event:
        print(f"Setting stop event for {code_block_id}")
        stop_event.set()
    if stream_task and not stream_task.done():
        print(f"Cancelling stream task for {code_block_id}")
        stream_task.cancel()
        try:
            # Wait briefly for cancellation to be processed by the task
            await asyncio.wait_for(stream_task, timeout=1.0)
        except asyncio.TimeoutError:
            print(f"Stream task for {code_block_id} did not cancel quickly.")
        except asyncio.CancelledError:
            print(f"Stream task for {code_block_id} cancelled successfully.")
            pass # Expected

    # 2. Stop the container
    if container_obj:
        try:
            print(f"Stopping container {container_obj.short_id} ({code_block_id})...")
            # Stop needs to run in executor
            await loop.run_in_executor(None, lambda: container_obj.stop(timeout=5))
            print(f"Container {container_obj.short_id} stopped.")
        except Exception as stop_err:
            print(f"Error stopping container {container_obj.short_id}, attempting kill: {stop_err}")
            try:
                # Kill needs to run in executor
                await loop.run_in_executor(None, container_obj.kill)
                print(f"Container {container_obj.short_id} killed.")
            except Exception as kill_err:
                # Ignore kill error if container is already gone
                if "No such container" not in str(kill_err):
                     print(f"Error killing container {container_obj.short_id}: {kill_err}")

        # 3. Remove the container
        try:
            print(f"Removing container {container_obj.short_id} ({code_block_id}) after stop request.")
            # Remove needs to run in executor
            await loop.run_in_executor(None, lambda: container_obj.remove(force=True))
        except NotFound:
             pass # Already removed
        except Exception as rm_err:
            print(f"Error removing container {container_obj.short_id} after stop: {rm_err}")

    # 4. Send final message to client if websocket is still valid
    if websocket and websocket.client_state == WebSocketState.CONNECTED:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id,
            "exit_code": -1, # Indicate abnormal termination
            "error": "Execution stopped by user."
        })
    else:
         print(f"Cannot send stop confirmation for {code_block_id}, WebSocket reference lost or disconnected.")


async def cleanup_client_containers(client_id: str):
    """Stops and cleans up all running containers associated with a client ID."""
    global running_containers, running_containers_lock
    print(f"Cleaning up containers for disconnected client: {client_id}")
    containers_to_stop = []
    # Create a separate list to avoid modifying dict while iterating
    async with running_containers_lock:
         # Find code_block_ids associated with the client
         ids_for_client = [cb_id for cb_id, info in running_containers.items() if info["client_id"] == client_id]
         containers_to_stop.extend(ids_for_client)

    # Stop each container outside the lock to avoid holding it too long
    if containers_to_stop:
         print(f"Found containers to stop for client {client_id}: {containers_to_stop}")
         # Use asyncio.gather to stop them concurrently
         # Note: stop_docker_container already removes the entry from running_containers
         stop_tasks = [stop_docker_container(cb_id) for cb_id in containers_to_stop]
         results = await asyncio.gather(*stop_tasks, return_exceptions=True) # Log exceptions if any stop fails
         for i, result in enumerate(results):
              if isinstance(result, Exception):
                   print(f"Error during cleanup stop for {containers_to_stop[i]}: {result}")
         print(f"Finished cleanup for client {client_id}")
    else:
         print(f"No running containers found for client {client_id} during cleanup.")

# --- FastAPI Routes ---

# Root route to serve the main HTML page
@app.get("/", response_class=HTMLResponse)
async def get_chat_page(request: Request):
    """Serves the main chat HTML page."""
    html_file_path = static_dir / "index.html"
    if not html_file_path.is_file():
         print(f"ERROR: index.html not found at expected location: {html_file_path}")
         raise HTTPException(status_code=404, detail="index.html not found")
    try:
        with open(html_file_path, "r", encoding="utf-8") as f:
            html_content = f.read()
        return HTMLResponse(content=html_content)
    except Exception as e:
        print(f"ERROR reading index.html: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error reading index.html: {e}")


# --- WebSocket Endpoint ---
@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: str):
    """Handles WebSocket connections for chat and code execution."""
    await websocket.accept()
    print(f"WebSocket connection accepted for client: {client_id}")
    memory = get_memory_for_client(client_id)

    # Function to load history using this client's memory (Unchanged)
    def load_memory_for_current_client(_):
        loaded_vars = memory.load_memory_variables({})
        return loaded_vars.get("history", [])

    # Simple chain using the fixed global 'prompt' (Unchanged)
    chain = (
        RunnablePassthrough.assign(history=load_memory_for_current_client)
        | prompt
        | model
        | output_parser
    )
    print(f"LCEL Chain created for client: {client_id}")

    try:
        while True:
            # Check state before receiving
            if websocket.client_state != WebSocketState.CONNECTED:
                 print(f"WebSocket no longer connected for {client_id} before receive. Breaking loop.")
                 break

            received_data = await websocket.receive_text()

            # Check if it's a JSON command or regular chat input
            try:
                message_data = json.loads(received_data)
                message_type = message_data.get("type")
                payload = message_data.get("payload")

                if message_type and payload and isinstance(payload, dict):
                    # --- Handle JSON Commands ---
                    code_block_id = payload.get("code_block_id")
                    if not code_block_id:
                         print(f"Received JSON command without code_block_id: {message_data}")
                         continue

                    if message_type == "run_code":
                        language = payload.get("language")
                        code = payload.get("code")
                        if language and code is not None:
                             print(f"Received 'run_code' request for block {code_block_id} ({language}) from {client_id}")
                             # Start execution in background task
                             asyncio.create_task(
                                 run_code_in_docker_stream(websocket, client_id, code_block_id, language, code)
                             )
                        else:
                             print(f"Invalid 'run_code' payload received: {payload}")
                             await send_ws_message(websocket, "code_finished", {
                                  "code_block_id": code_block_id, "exit_code": -1,
                                  "error": "Invalid run_code request payload from client."
                             })

                    elif message_type == "stop_code":
                        print(f"Received 'stop_code' request for block {code_block_id} from {client_id}")
                        # Stop execution in background task
                        asyncio.create_task(
                             stop_docker_container(code_block_id)
                        )

                    else:
                        print(f"Received unknown JSON command type '{message_type}' from {client_id}")

                else:
                     # Treat as chat if JSON structure is invalid
                     print(f"Received invalid JSON structure from {client_id}, treating as chat: {received_data[:100]}...")
                     await handle_chat_message(chain, memory, websocket, client_id, received_data)

            except json.JSONDecodeError:
                # --- Handle Regular Chat Message ---
                # print(f"Handling text message from {client_id}: '{received_data[:50]}...'")
                await handle_chat_message(chain, memory, websocket, client_id, received_data)

    except WebSocketDisconnect:
        print(f"WebSocket disconnected during receive/process for client: {client_id}")
    except Exception as e:
        print(f"Unknown Error in WebSocket loop for client {client_id}: {e}")
        traceback.print_exc()
    finally:
        # --- Cleanup on Disconnect or Error ---
        print(f"Cleaning up resources for client: {client_id}")
        remove_memory_for_client(client_id)
        # Stop any running containers for this client
        await cleanup_client_containers(client_id)
        # Attempt to close websocket gracefully if it's not already closed
        if websocket.client_state == WebSocketState.CONNECTED:
            try:
                await websocket.close(code=1000) # Normal closure
                print(f"WebSocket closed gracefully for {client_id}")
            except Exception as close_exc:
                # Ignore errors if already closed or cannot close
                 print(f"Ignoring error during explicit WebSocket close for {client_id}: {close_exc}")
                 pass
        else:
             print(f"WebSocket already closed for {client_id} during cleanup.")


async def handle_chat_message(chain, memory, websocket: WebSocket, client_id: str, user_input: str):
     """Handles processing and streaming response for a regular chat message."""
     print(f"Handling chat message from {client_id}: '{user_input[:50]}...'")
     full_response = ""
     try:
         # Stream response using the chain
         async for chunk in chain.astream({"input": user_input}):
             # Check connection before sending each chunk
             if websocket.client_state != WebSocketState.CONNECTED:
                  print(f"WebSocket disconnected during chat stream for {client_id}. Aborting send.")
                  return # Stop sending if disconnected
             await websocket.send_text(chunk)
             full_response += chunk
     except Exception as chain_exc:
         error_msg = f"<ERROR>Error processing message: {chain_exc}"
         print(f"ERROR during chain execution for {client_id}: {chain_exc}")
         traceback.print_exc()
         # Try sending error message only if connected
         if websocket.client_state == WebSocketState.CONNECTED:
              await websocket.send_text(error_msg)
         # Don't save context if chain failed, but allow next message
         return

     # Send End Of Stream marker for chat message only if connected
     if websocket.client_state == WebSocketState.CONNECTED:
          await websocket.send_text("<EOS>")
          print(f"Finished streaming chat response to {client_id}")
          # Save context to memory
          # Note: user_input might contain the NO_THINK_PREFIX, which is fine for memory
          memory.save_context({"input": user_input}, {"output": full_response})
          print(f"Saved chat context to memory for client: {client_id}")
     else:
          print(f"WebSocket disconnected before sending <EOS> for {client_id}.")


# --- Function to run the server ---
def start_server():
    """Starts the Uvicorn server and opens the browser."""
    host = "127.0.0.1"
    port = 8001
    url = f"http://{host}:{port}"
    print(f"Starting server at {url}...")
    print(f"Using Ollama base URL: {OLLAMA_BASE_URL}")
    print(f"Using Model ID: {MODEL_ID}")
    print(f"Static files served from: {static_dir}")
    print(f"Supported execution languages: {list(SUPPORTED_LANGUAGES.keys())}")
    if not docker_client:
        print("WARNING: Docker client unavailable. Code execution will fail.")

    print(f"Attempting to open browser at {url}...")
    try:
        webbrowser.open(url)
    except Exception as browser_err:
        print(f"Warning: Could not automatically open browser: {browser_err}")
        print(f"Please navigate to {url} manually.")

    # --- Uvicorn Run ---
    # IMPORTANT: The target 'app.main:app' assumes this script (main.py)
    # is located inside a directory named 'app' relative to where you
    # run the uvicorn command OR that you run python like: python -m app.main
    # If main.py is at the project root, change the target to "main:app"
    uvicorn_target = "app.main:app"
    # Check if running directly (e.g., python main.py) vs module (python -m app.main)
    # A simple check: if the script's directory is named 'app'
    if Path(__file__).parent.name == "app":
         print(f"Running Uvicorn with target: '{uvicorn_target}' (assuming script is in 'app' directory)")
    else:
         # If not in 'app', assume it's at the root
         uvicorn_target = "main:app"
         print(f"Running Uvicorn with target: '{uvicorn_target}' (assuming script is at project root)")

    uvicorn.run(uvicorn_target, host=host, port=port, log_level="info", reload=True)

if __name__ == "__main__":
    # Add basic check for Docker client availability at startup
    if docker_client is None:
         print("\n---")
         print("WARNING: Docker is not running or accessible.")
         print("Code execution features will be disabled.")
         print("Please start Docker and restart this application for code execution.")
         print("---\n")
    start_server()



=== write_project_content_to_file.py ===
import os
import sys

# --- Configuration ---

# Set the starting directory (e.g., "." for current directory)
root = "."

# Extensions to include
extensions = ('.py', '.html', '.css', '.js', '.json', '.md', '.txt', '.yaml', '.yml', '.toml')

# Directories to completely exclude (will not be walked)
exclude_dirs = (
    '.git',
    '__pycache__',
    '.pytest_cache',
    'node_modules',
    'build',
    'old2',
    'testing-bundles', # Exclude this directory name wherever it appears
    '.venv',           # Common virtual environment folder
    'venv',
    'env',
    '.env',
)

# Files to list in the tree but exclude their *content*
exclude_files = (
    'package-lock.json',
    'yarn.lock',
    'katex.min.css',
    'katex.min.js'
    # Add other large or irrelevant files by name here
)

# Output file name
output_filename = "project_content.txt"

# --- Script Logic ---

try:
    root = os.path.abspath(root)
    print(f"Starting directory: {root}")
    print(f"Output file: {output_filename}")
    print(f"Excluding directories: {exclude_dirs}")
    print(f"Excluding content of files: {exclude_files}")

    # Use a set for faster lookups
    exclude_dirs_set = set(exclude_dirs)
    exclude_files_set = set(exclude_files)

    with open(output_filename, "w", encoding="utf-8", errors="replace") as outfile:
        # === Add Directory Structure ===
        outfile.write("=== Project Directory Structure ===\n")
        outfile.write(f"Root: {root}\n")
        outfile.write("Relevant files and folders (excluding specified patterns):\n\n")

        structure_lines = []
        processed_dirs_for_structure = set()

        for current_root, dirs, files in os.walk(root, topdown=True):
            # Filter directories *in place* to prevent walking into excluded ones
            # Also exclude hidden directories starting with '.' unless root is hidden
            original_dirs = list(dirs) # Keep original for path checking if needed
            dirs[:] = [d for d in dirs if d not in exclude_dirs_set and not (d.startswith('.') and d != '.')]

            rel_path_from_start = os.path.relpath(current_root, root)

            # --- Skip processing if current path is inside an excluded directory ---
            # Check if any component of the relative path is in the exclusion list
            # Normalize path separators for consistent checking
            norm_rel_path = os.path.normpath(rel_path_from_start).replace(os.sep, '/')
            path_components = set(comp for comp in norm_rel_path.split('/') if comp and comp != '.')

            if any(comp in exclude_dirs_set or (comp.startswith('.') and comp != '.') for comp in path_components):
                 continue # Skip this directory entirely if any parent was excluded

            level = norm_rel_path.count('/') if norm_rel_path != '.' else 0

            # Add directory entry
            if rel_path_from_start == '.':
                 structure_lines.append(".\n")
            else:
                 indent = '│   ' * (level - 1) + '├── ' if level > 0 else ''
                 dir_name = os.path.basename(current_root)
                 # Check if this specific dir name should be excluded (e.g., if it's at the root)
                 if dir_name not in exclude_dirs_set and not (dir_name.startswith('.') and dir_name != '.'):
                     structure_lines.append(f"{indent}{dir_name}/\n")
                     processed_dirs_for_structure.add(norm_rel_path)


            # Add file entries for this directory
            file_indent = '│   ' * level + '├── '
            files.sort()
            for file in files:
                if file.endswith(extensions) and not file.startswith('.'):
                     structure_lines.append(f"{file_indent}{file}\n")

        # Write collected structure lines
        for line in structure_lines:
             outfile.write(line)

        outfile.write("\n\n=== File Contents ===\n\n")

        # === Add File Contents ===
        for current_root, dirs, files in os.walk(root, topdown=True):
            # Apply the same directory filtering as in the first walk
            dirs[:] = [d for d in dirs if d not in exclude_dirs_set and not (d.startswith('.') and d != '.')]

            rel_path_from_start = os.path.relpath(current_root, root)

            # --- Skip processing if current path is inside an excluded/hidden directory ---
            norm_rel_path = os.path.normpath(rel_path_from_start).replace(os.sep, '/')
            path_components = set(comp for comp in norm_rel_path.split('/') if comp and comp != '.')
            if any(comp in exclude_dirs_set or (comp.startswith('.') and comp != '.') for comp in path_components):
                 continue # Skip files in this directory

            files.sort()
            for file in files:
                 # Exclude hidden files and check extensions
                 if file.endswith(extensions) and not file.startswith('.'):
                     file_path = os.path.join(current_root, file)
                     relative_path = os.path.relpath(file_path, root)
                     display_path = relative_path.replace(os.sep, '/')

                     outfile.write(f"=== {display_path} ===\n")

                     # Check if the file *content* should be excluded
                     if file in exclude_files_set:
                         outfile.write("--- CONTENT EXCLUDED (listed in exclude_files) ---\n")
                     else:
                         try:
                             # Try reading with utf-8 first
                             with open(file_path, "r", encoding="utf-8") as infile:
                                 outfile.write(infile.read())
                         except UnicodeDecodeError:
                             # Fallback for non-utf8 files
                             try:
                                 with open(file_path, "r", encoding="latin-1") as infile:
                                     outfile.write(infile.read())
                                 outfile.write("\n--- (Warning: Read using latin-1 encoding) ---\n")
                             except Exception as inner_e:
                                 outfile.write(f"--- Error reading file (fallback failed): {inner_e} ---\n")
                         except Exception as e:
                             # Handle other potential file reading errors
                             outfile.write(f"--- Error reading file: {e} ---\n")

                     outfile.write("\n\n") # Add separation between file contents

    print(f"Successfully generated project content file: {output_filename}")

except FileNotFoundError:
    print(f"Error: Starting directory not found: {root}", file=sys.stderr)
except IOError as e:
    print(f"Error writing to output file {output_filename}: {e}", file=sys.stderr)
except Exception as e:
    print(f"An unexpected error occurred: {e}", file=sys.stderr)

=== app/__init__.py ===


=== app/config.py ===
# app/config.py
import os
import sys
from pathlib import Path
from dotenv import load_dotenv

# Load environment variables from a .env file if it exists
load_dotenv()

# --- LLM Configuration ---
# Model ID for the Ollama language model
MODEL_ID = os.getenv("MODEL_ID", "qwen3:8B")
# Base URL for the Ollama API server
OLLAMA_BASE_URL = os.getenv("OLLAMA_BASE_URL", "http://localhost:11434")
# Prefix used by the frontend to signal non-thinking requests (handled by frontend)
NO_THINK_PREFIX = "\\no_think"

# --- Docker Configuration ---
# Dictionary defining supported languages for code execution.
# Each key is the language identifier (lowercase).
# Each value is a dictionary containing:
#   - image: The Docker image to use for execution.
#   - filename: The expected filename for the code snippet inside the container.
#   - command: The command list to execute the code within the container.
SUPPORTED_LANGUAGES = {
    # --- Existing Languages ---
    "python": {
        "image": "python:3.11-slim",
        "filename": "script.py",
        # Run python with unbuffered output (-u)
        "command": ["python", "-u", "/app/script.py"]
    },
    "javascript": {
        # --- UPDATED IMAGE ---
        "image": "node-ts:18", # Use standard Node.js 18 image (same as TypeScript)
        "filename": "script.js",
        "command": ["node", "/app/script.js"]
    },
    # --- Added Languages ---
    "cpp": {
        "image": "gcc:latest", # GNU C++ compiler image
        "filename": "script.cpp",
        # Command compiles script.cpp to an executable, then runs it.
        # Uses 'sh -c' to chain the compilation (g++) and execution steps.
        "command": ["sh", "-c", "g++ /app/script.cpp -o /app/output_executable && /app/output_executable"]
    },
    "csharp": {
        "image": "mcr.microsoft.com/dotnet/sdk:latest",
        "filename": "Script.cs", # Backend saves user code as Script.cs
        # ------ UPDATED COMMAND TO FIX DUPLICATE DEFINITION ERRORS ------
        # Creates project, copies user code over Program.cs,
        # REMOVES the original Script.cs, then runs.
        "command": [
            "sh", "-c",
            "cd /app && dotnet new console --force -o . > /dev/null && cp Script.cs Program.cs && rm Script.cs && dotnet run"
        ]
        # ------ END UPDATED COMMAND ------
    },
    "typescript": {
        "image": "node-ts:18", # Use standard Node.js 18 image (Debian based, includes npm/npx)
        "filename": "script.ts",
        # Compile script.ts to script.js targeting CommonJS, then run with node.
        # Assumes 'tsc' (TypeScript compiler) is available in the 'node:18' image.
        # If 'tsc' is not found, you may need to revert to the previous command with 'npm install'
        # or build a custom image with typescript pre-installed.
        "command": ["sh", "-c", "tsc --module commonjs /app/script.ts && node /app/script.js"]
    },
    "java": {
        "image": "openjdk:17-jdk-slim", # Java Development Kit image
        "filename": "Main.java", # Java requires filename match public class name
        # Command compiles Main.java and then runs the compiled Main class.
        "command": ["sh", "-c", "javac /app/Main.java && java -cp /app Main"]
    },
    "go": {
        "image": "golang:1.21-alpine", # Go language image
        "filename": "script.go",
        # Command uses 'go run' to compile and run the source file directly.
        "command": ["go", "run", "/app/script.go"]
    },
    "rust": {
        "image": "rust:1-slim", # Rust language image
        "filename": "main.rs", # Rust convention often uses main.rs
        # Command compiles main.rs to an executable, then runs it.
        "command": ["sh", "-c", "cd /app && rustc main.rs -o main_executable && ./main_executable"]
    }
    # Add more languages here following the pattern:
    # "language_name": { "image": "docker_image", "filename": "script_name", "command": ["command", "arg1", ...]}
}
# Timeout in seconds for Docker container execution
DOCKER_TIMEOUT_SECONDS = 30
# Memory limit for Docker containers (e.g., "128m", "256m")
DOCKER_MEM_LIMIT = "128m"

# --- Static Files Configuration ---
# Determine the static files directory relative to this config file's location.
# Assumes config.py is inside the 'app' directory.
APP_DIR = Path(__file__).parent
PROJECT_ROOT = APP_DIR.parent
STATIC_DIR_IN_APP = APP_DIR / "static"
STATIC_DIR_AT_ROOT_LEVEL = PROJECT_ROOT / "static" # If static is sibling to 'app'

STATIC_DIR = None
# Check for static directory inside 'app' first
if STATIC_DIR_IN_APP.is_dir():
    STATIC_DIR = STATIC_DIR_IN_APP
    # print(f"Found static directory at: {STATIC_DIR}") # Uncomment for debug
# If not found inside 'app', check at the project root level (sibling to 'app')
elif STATIC_DIR_AT_ROOT_LEVEL.is_dir():
     STATIC_DIR = STATIC_DIR_AT_ROOT_LEVEL
     # print(f"Found static directory at: {STATIC_DIR}") # Uncomment for debug
# If neither location is found, print an error and exit
else:
    print(f"CRITICAL ERROR: Static directory not found. Looked in '{STATIC_DIR_IN_APP}' and '{STATIC_DIR_AT_ROOT_LEVEL}'. Exiting.")
    sys.exit(1)



=== app/docker_utils.py ===
# app/docker_utils.py

import asyncio
import tempfile
import shutil
import traceback
from pathlib import Path
import docker # Docker SDK for Python
from docker.errors import DockerException, ImageNotFound, APIError, NotFound # Docker specific errors
from docker.models.containers import Container # For type hinting container objects
from fastapi import WebSocket # For type hinting WebSockets

# Relative imports for modules within the 'app' package
from . import config
from . import state
from .utils import send_ws_message # Utility function for sending WebSocket messages

# --- Docker Client Initialization ---
# Attempt to initialize the Docker client from the environment settings.
# This typically connects to the Docker daemon running locally.
docker_client = None
try:
    # Get Docker client from environment variables (DOCKER_HOST, etc.)
    docker_client = docker.from_env()
    # Ping the Docker daemon to ensure connectivity
    docker_client.ping()
    print("Successfully connected to Docker daemon.")
except DockerException as e:
    # Handle exceptions if the Docker daemon is not reachable
    print(f"CRITICAL WARNING: Could not connect to Docker daemon: {e}")
    print("Code execution via Docker will be unavailable.")
    docker_client = None # Ensure client is None if connection failed

def get_docker_client():
    """
    Returns the initialized Docker client instance.
    Returns None if the client failed to initialize.
    """
    return docker_client

# --- Log Streaming Logic (Designed to Run in Executor Thread) ---

def sync_log_streamer(container: Container, websocket: WebSocket, code_block_id: str, loop: asyncio.AbstractEventLoop, stop_event: asyncio.Event):
    """
    Synchronously iterates through Docker container logs and schedules sending
    log lines back to the main asyncio event loop via WebSocket.
    This function is blocking and intended to be run in a separate thread using run_in_executor.

    Args:
        container: The Docker container object to stream logs from.
        websocket: The WebSocket connection to send log messages to.
        code_block_id: Identifier for the code block being executed.
        loop: The main asyncio event loop to schedule coroutines on.
        stop_event: An asyncio.Event used to signal when to stop streaming.
    """
    try:
        # Get a blocking generator for log lines (stdout and stderr)
        # follow=True keeps the stream open until the container stops or stop_event is set.
        log_stream = container.logs(stream=True, follow=True, stdout=True, stderr=True)
        print(f"[Thread-{code_block_id}] Starting log iteration for container {container.short_id}")

        # Iterate through the log stream line by line
        for line_bytes in log_stream:
            # Check if the stop event has been set (e.g., by user cancellation)
            if stop_event.is_set():
                print(f"[Thread-{code_block_id}] Stop event set, breaking log iteration.")
                break # Exit the loop if stop is requested

            # Decode bytes to string, replacing errors
            line_str = line_bytes.decode('utf-8', errors='replace')

            # Schedule the asynchronous send_ws_message function to run on the main event loop
            # This is crucial for thread safety when interacting with asyncio objects like WebSockets.
            asyncio.run_coroutine_threadsafe(
                send_ws_message(websocket, "code_output", {
                    "code_block_id": code_block_id,
                    "stream": "stdout", # Simplification: send both stdout/stderr as stdout type for now
                    "data": line_str
                }),
                loop # Pass the main event loop
            )

        print(f"[Thread-{code_block_id}] Finished log iteration for container {container.short_id}")

    except Exception as e:
        # Handle exceptions during log streaming (e.g., container removed unexpectedly)
        print(f"[Thread-{code_block_id}] Error during log streaming: {e}")
        # Schedule sending an error message back to the client via the main loop
        asyncio.run_coroutine_threadsafe(
            send_ws_message(websocket, "code_output", {
                "code_block_id": code_block_id,
                "stream": "error", # Indicate an error stream
                "data": f"\n[Error streaming logs from container: {str(e)}]"
            }),
            loop
        )

async def stream_docker_logs_via_executor(websocket: WebSocket, container: Container, code_block_id: str, stop_event: asyncio.Event):
    """
    Asynchronously runs the synchronous log streamer function (`sync_log_streamer`)
    in a separate thread using asyncio's default executor.

    Args:
        websocket: The WebSocket connection.
        container: The Docker container object.
        code_block_id: Identifier for the code block.
        stop_event: Event to signal stopping the stream.
    """
    loop = asyncio.get_running_loop()
    print(f"Scheduling log streaming task in executor for {code_block_id}")
    # Run the blocking sync_log_streamer function in the thread pool executor
    await loop.run_in_executor(
        None, # Use the default executor
        sync_log_streamer, # The function to run
        # Arguments to pass to sync_log_streamer:
        container, websocket, code_block_id, loop, stop_event
    )
    print(f"Executor task for log streaming finished for {code_block_id}")


# --- Docker Code Execution Core Function ---

async def run_code_in_docker_stream(websocket: WebSocket, client_id: str, code_block_id: str, language: str, code: str):
    """
    Handles the complete process of running user-provided code in a Docker container:
    1. Validates language and Docker availability.
    2. Creates a temporary directory and writes the code to a file.
    3. Starts the appropriate Docker container based on the language config.
    4. Starts a background task to stream container logs back via WebSocket.
    5. Waits for the container to finish or timeout.
    6. Sends a final status message (success, error, timeout) via WebSocket.
    7. Cleans up the container and temporary directory.

    Args:
        websocket: The client's WebSocket connection.
        client_id: The unique ID of the client.
        code_block_id: Identifier for the specific code block being run.
        language: The programming language of the code (e.g., "python", "c++").
        code: The actual code string provided by the user.
    """
    # Get the initialized Docker client instance
    local_docker_client = get_docker_client()

    # Check if Docker client is available
    if not local_docker_client:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": "Docker service is unavailable on the server."
        })
        return

    # Validate the requested language against the configuration
    lang_key = language.lower()
    lang_config = config.SUPPORTED_LANGUAGES.get(lang_key)
    if not lang_config:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": f"Language '{language}' not supported for execution."
        })
        return

    # Extract language-specific configuration
    image_name = lang_config["image"]
    script_filename = lang_config["filename"]
    command = lang_config["command"]

    # Initialize variables for container, task, temp dir, and stop event
    container_obj: Container | None = None
    stream_task: asyncio.Task | None = None
    tmpdir_obj = None # To hold the TemporaryDirectory object for proper cleanup
    stop_event = asyncio.Event() # Event to signal cancellation to the streamer thread

    try:
        # Create a temporary directory to store the script file
        # Using 'with' ensures cleanup even if errors occur later, but we need the path
        # outside the 'with', so we create it manually and clean up in 'finally'.
        tmpdir_obj = tempfile.TemporaryDirectory()
        tmpdir = tmpdir_obj.name # Get the path string
        host_script_path = Path(tmpdir) / script_filename

        # Write the user's code to the script file inside the temp directory
        with open(host_script_path, "w", encoding="utf-8") as f:
            f.write(code)

        print(f"Attempting to run block {code_block_id} ({lang_key}) in Docker image {image_name}...")

        # Run the Docker container
        # This might implicitly pull the image if not found locally
        container_obj = local_docker_client.containers.run(
            image=image_name,
            command=command, # Command defined in config.py
            # Mount the temporary directory read-write into /app inside the container
            # Changed mode from 'ro' to 'rw' to allow compilation output
            volumes={tmpdir: {'bind': '/app', 'mode': 'rw'}}, # <<< CHANGED HERE
            working_dir='/app', # Set working directory inside the container
            mem_limit=config.DOCKER_MEM_LIMIT, # Apply memory limit from config
            stdout=True, # Capture stdout
            stderr=True, # Capture stderr
            detach=True, # Run the container in the background
            # auto_remove=True, # Cannot auto-remove if we need logs/exit code/manual stop
        )
        print(f"Container {container_obj.short_id} started for {code_block_id}")

        # Create and start the background task for streaming logs
        stream_task = asyncio.create_task(
            stream_docker_logs_via_executor(websocket, container_obj, code_block_id, stop_event),
            name=f"log_stream_{code_block_id}" # Name the task for easier debugging
        )

        # Add the running container info to the global state dictionary (thread-safe)
        async with state.running_containers_lock:
            # Check if another execution for the same block ID is already running
            if code_block_id in state.running_containers:
                # This shouldn't happen if frontend disables button, but handle defensively
                print(f"WARNING: Code block {code_block_id} was already running. Stopping previous run.")
                # Schedule stop_docker_container; do not await inside the lock
                asyncio.create_task(stop_docker_container(code_block_id))

            # Store container details in the shared state dictionary
            state.running_containers[code_block_id] = {
                "container": container_obj,
                "stream_task": stream_task,
                "client_id": client_id,
                "websocket": websocket,
                "stop_event": stop_event # Store the stop event for cancellation
            }

        # Wait for the container to finish execution (blocking call run in executor)
        print(f"Waiting for container {container_obj.short_id} ({code_block_id}) to finish...")
        loop = asyncio.get_running_loop()
        # container.wait() is blocking, so run it in the executor
        result = await loop.run_in_executor(
            None, # Use default executor
            lambda: container_obj.wait(timeout=config.DOCKER_TIMEOUT_SECONDS) # Wait with timeout
        )
        # Extract exit code and potential error message from the result
        exit_code = result.get("StatusCode", -1) # Default to -1 if status code missing
        error_msg = result.get("Error", None) # Docker daemon error message
        print(f"Container {container_obj.short_id} ({code_block_id}) finished. Result: {result}")

        # --- Container Finished Normally or Errored ---
        # Signal the log streaming thread that it can stop
        stop_event.set()
        try:
            # Wait briefly for the log streaming task to finish processing final logs
            await asyncio.wait_for(stream_task, timeout=5.0)
        except asyncio.TimeoutError:
            print(f"Warning: Log streaming task for {code_block_id} did not finish quickly after container exit.")
            # Cancel the task if it's still running after the timeout
            if stream_task and not stream_task.done():
                stream_task.cancel()
        except asyncio.CancelledError:
            # Expected if the task was cancelled during stop_docker_container
             print(f"Log streaming task for {code_block_id} was cancelled (likely during stop).")

        # Send the final result message to the client
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id,
            "exit_code": exit_code,
            "error": error_msg # Send Docker-level error if any (e.g., OOMKilled)
        })

    except asyncio.TimeoutError: # Timeout triggered by container_obj.wait()
        # Handle the case where the container ran longer than DOCKER_TIMEOUT_SECONDS
        print(f"ERROR: Docker execution timed out for block {code_block_id} after {config.DOCKER_TIMEOUT_SECONDS}s.")
        await send_ws_message(websocket, "code_finished", {
             "code_block_id": code_block_id, "exit_code": -1,
             "error": f"Execution timed out after {config.DOCKER_TIMEOUT_SECONDS} seconds."
        })
        # Schedule the container stop process in the background
        asyncio.create_task(stop_docker_container(code_block_id))

    except ImageNotFound:
        # Handle case where the specified Docker image doesn't exist locally and couldn't be pulled
        error_msg = f"Server Error: Docker image '{image_name}' not found. Please ensure it's pulled or available."
        print(f"ERROR for block {code_block_id}: {error_msg}")
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except APIError as e:
        # Handle errors from the Docker daemon API
        error_msg = f"Server Error: Docker API error: {e}"
        print(f"ERROR for block {code_block_id}: {error_msg}")
        traceback.print_exc() # Print full traceback for server logs
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except Exception as e:
        # Catch any other unexpected errors during setup or execution
        error_msg = f"Server Execution Error: An unexpected error occurred." # Generic message for client
        print(f"ERROR during Docker execution setup or wait for block {code_block_id}: {e}")
        traceback.print_exc() # Print full traceback for server logs
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
        # Ensure stream task is cancelled if it was started before the error
        if stream_task and not stream_task.done():
            print(f"Cancelling stream task for {code_block_id} due to setup/wait error.")
            stop_event.set() # Signal thread to stop
            stream_task.cancel()

    finally:
        # --- Final Cleanup ---
        # This block executes whether the try block succeeded or failed

        # Remove container info from tracking dict if it hasn't been removed already
        async with state.running_containers_lock:
            if code_block_id in state.running_containers:
                print(f"Performing final cleanup check for {code_block_id}")
                # Retrieve task and event references before deleting the entry
                task_to_cancel = state.running_containers[code_block_id].get("stream_task")
                stop_ev = state.running_containers[code_block_id].get("stop_event")
                # Ensure task is stopped and cancelled if still running
                if task_to_cancel and not task_to_cancel.done():
                    print(f"Final cleanup: Cancelling stream task for {code_block_id}")
                    if stop_ev: stop_ev.set() # Signal thread
                    task_to_cancel.cancel()
                # Remove the entry from the tracking dictionary
                del state.running_containers[code_block_id]
                print(f"Removed {code_block_id} from running_containers during final cleanup")

        # Ensure the Docker container is removed
        if container_obj:
            try:
                # Need to run blocking Docker SDK calls in an executor thread
                loop = asyncio.get_running_loop()
                # Check if container still exists before trying to remove
                await loop.run_in_executor(None, container_obj.reload)
                print(f"Removing container {container_obj.short_id} ({code_block_id}) in final cleanup")
                # Force remove the container
                await loop.run_in_executor(None, lambda: container_obj.remove(force=True))
            except NotFound:
                # Container was already removed (e.g., by stop_docker_container)
                 print(f"Container {container_obj.short_id} already removed.")
            except Exception as rm_err:
                # Log error if removal fails for some other reason
                 print(f"Error removing container {container_obj.short_id} in final cleanup: {rm_err}")

        # Clean up the temporary directory
        if tmpdir_obj:
             try:
                 tmpdir_obj.cleanup() # Deletes the temporary directory and its contents
             except Exception as cleanup_err:
                 print(f"Error cleaning up temp directory {tmpdir_obj.name}: {cleanup_err}")


# --- Container Stopping Logic ---

async def stop_docker_container(code_block_id: str):
    """
    Stops a specific running Docker container identified by code_block_id.
    Handles cancelling the log stream task and removing the container.

    Args:
        code_block_id: The identifier of the code block whose container needs stopping.
    """
    print(f"Attempting to stop execution for code block: {code_block_id}")
    loop = asyncio.get_running_loop()
    container_info = None
    container_obj = None
    stream_task = None
    websocket = None
    stop_event = None

    # Safely access and remove the container info from the shared state
    async with state.running_containers_lock:
        if code_block_id in state.running_containers:
            # Pop the entry to prevent race conditions with other stop requests or cleanup
            container_info = state.running_containers.pop(code_block_id)
            container_obj = container_info.get("container")
            stream_task = container_info.get("stream_task")
            websocket = container_info.get("websocket") # Get websocket for final message
            stop_event = container_info.get("stop_event")
            print(f"Found and removed running container info for {code_block_id} from tracking.")
        else:
            # If not found, it might have finished or been stopped already
            print(f"Stop request for {code_block_id}, but it was not found in running_containers.")
            return # Nothing further to do

    # --- Perform actions outside the lock ---

    # 1. Signal the streaming thread to stop and cancel the asyncio task
    if stop_event:
        print(f"Setting stop event for {code_block_id}")
        stop_event.set()
    if stream_task and not stream_task.done():
        print(f"Cancelling stream task for {code_block_id}")
        stream_task.cancel()
        try:
            # Wait briefly for cancellation to be processed
            await asyncio.wait_for(stream_task, timeout=1.0)
        except asyncio.TimeoutError:
            print(f"Stream task for {code_block_id} did not cancel quickly.")
        except asyncio.CancelledError:
            print(f"Stream task for {code_block_id} cancelled successfully.")
            pass # Expected outcome

    # 2. Stop the Docker container (run blocking calls in executor)
    if container_obj:
        try:
            print(f"Stopping container {container_obj.short_id} ({code_block_id})...")
            # container.stop() is blocking
            await loop.run_in_executor(None, lambda: container_obj.stop(timeout=5))
            print(f"Container {container_obj.short_id} stopped.")
        except Exception as stop_err:
            # If stop fails (e.g., timeout), attempt to kill the container
            print(f"Error stopping container {container_obj.short_id}, attempting kill: {stop_err}")
            try:
                # container.kill() is blocking
                await loop.run_in_executor(None, container_obj.kill)
                print(f"Container {container_obj.short_id} killed.")
            except Exception as kill_err:
                # Ignore "No such container" error if already gone, log others
                 if "No such container" not in str(kill_err):
                     print(f"Error killing container {container_obj.short_id}: {kill_err}")

        # 3. Remove the Docker container (run blocking call in executor)
        try:
            print(f"Removing container {container_obj.short_id} ({code_block_id}) after stop request.")
            # container.remove() is blocking
            await loop.run_in_executor(None, lambda: container_obj.remove(force=True))
        except NotFound:
            pass # Container already removed
        except Exception as rm_err:
            print(f"Error removing container {container_obj.short_id} after stop: {rm_err}")

    # 4. Send final "stopped by user" message if WebSocket is still valid
    if websocket: # Check if websocket reference exists
         try:
             await send_ws_message(websocket, "code_finished", {
                 "code_block_id": code_block_id,
                 "exit_code": -1, # Indicate abnormal termination
                 "error": "Execution stopped by user."
             })
         except Exception as send_err:
              print(f"Error sending stop confirmation for {code_block_id}: {send_err}")
    else:
         print(f"Cannot send stop confirmation for {code_block_id}, WebSocket reference lost.")


# --- Client Disconnect Cleanup ---

async def cleanup_client_containers(client_id: str):
    """
    Stops and cleans up all running Docker containers associated with a specific client ID
    when that client disconnects.

    Args:
        client_id: The ID of the client that disconnected.
    """
    print(f"Cleaning up containers for disconnected client: {client_id}")
    containers_to_stop = []
    # Safely get a list of code_block_ids associated with the disconnected client
    async with state.running_containers_lock:
        # List comprehension to find matching client_id
        ids_for_client = [
            cb_id for cb_id, info in state.running_containers.items()
            if info.get("client_id") == client_id
        ]
        containers_to_stop.extend(ids_for_client)

    # Stop each container concurrently using asyncio.gather
    if containers_to_stop:
        print(f"Found containers to stop for client {client_id}: {containers_to_stop}")
        # Create a list of stop tasks
        stop_tasks = [stop_docker_container(cb_id) for cb_id in containers_to_stop]
        # Run tasks concurrently and gather results (including exceptions)
        results = await asyncio.gather(*stop_tasks, return_exceptions=True)
        # Log any errors that occurred during the cleanup stops
        for i, result in enumerate(results):
             if isinstance(result, Exception):
                 print(f"Error during cleanup stop for {containers_to_stop[i]}: {result}")
        print(f"Finished cleanup for client {client_id}")
    else:
        print(f"No running containers found for client {client_id} during cleanup.")



=== app/llm.py ===
# app/llm.py
import sys
import os # Import os for environment variable check
from langchain_ollama.llms import OllamaLLM
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.output_parsers import StrOutputParser
# from langchain.memory import ConversationBufferMemory # Not used directly here
from langchain_core.runnables import RunnablePassthrough, Runnable, RunnableLambda
from langchain_core.messages import BaseMessage
from typing import List, Callable, Optional

# Use absolute import based on project structure if needed, or relative
# Assuming config is in the same directory or Python path is set correctly
from . import config

# --- LangChain Setup ---

# Global variable to hold the model instance
_model_instance: Optional[OllamaLLM] = None
_last_model_id_used: Optional[str] = None
_last_base_url_used: Optional[str] = None

def get_model() -> OllamaLLM:
    """
    Initializes and returns the Ollama LLM model instance.
    Re-initializes if config changes (relevant with Uvicorn reload).
    """
    global _model_instance, _last_model_id_used, _last_base_url_used

    # Check if config has changed since last initialization
    # This is important because Uvicorn reload might not fully re-import everything
    config_changed = (
        _model_instance is None or
        config.MODEL_ID != _last_model_id_used or
        config.OLLAMA_BASE_URL != _last_base_url_used
    )

    if config_changed:
        print(f"DEBUG get_model: Configuration changed or first init. Initializing OllamaLLM with model='{config.MODEL_ID}' at base_url='{config.OLLAMA_BASE_URL}'")
        try:
            _model_instance = OllamaLLM(model=config.MODEL_ID, base_url=config.OLLAMA_BASE_URL)
            _last_model_id_used = config.MODEL_ID
            _last_base_url_used = config.OLLAMA_BASE_URL
            print(f"Successfully initialized/updated OllamaLLM: {_last_model_id_used} at {_last_base_url_used}")
        except Exception as e:
            print(f"CRITICAL ERROR: OllamaLLM init failed in get_model: {e}")
            # Re-raise the exception so the calling function knows initialization failed
            raise e
    # else:
    #     print(f"DEBUG get_model: Using existing OllamaLLM instance for model='{_last_model_id_used}'")


    if _model_instance is None:
         # This should ideally not happen if the try/except above works, but as a safeguard:
         print("CRITICAL ERROR: _model_instance is None after attempting initialization in get_model.")
         sys.exit(1) # Or raise a more specific error

    return _model_instance

# Define prompt structure (can stay global)
prompt = ChatPromptTemplate.from_messages([
    ("system", "You are a helpful AI assistant chatting in a web interface. Answer the user's questions concisely. Always use katex for math ($...$ or $$...$$). For a literal dollar sign use \\$. When providing code, use standard markdown code blocks (e.g., ```python ... ```)."),
    MessagesPlaceholder(variable_name="history"),
    ("human", "{input}")
])

# Define output parser (can stay global)
output_parser = StrOutputParser()

def create_chain(memory_loader_func: Callable[[dict], List[BaseMessage]]) -> Runnable:
    """
    Creates the LangChain processing chain using a provided memory loading function.
    Ensures the model is initialized before creating the chain.
    """
    try:
        # Get the (potentially re-initialized) model instance
        current_model = get_model()
    except Exception as model_init_error:
        # Propagate the error if model initialization failed
        print(f"ERROR in create_chain: Failed to get model instance: {model_init_error}")
        raise model_init_error # Re-raise to prevent chain creation with bad model

    chain = (
        RunnablePassthrough.assign(history=RunnableLambda(memory_loader_func))
        | prompt
        | current_model # Use the obtained model instance
        | output_parser
    )
    return chain

# Remove the old global initialization attempt
# try:
#     model = OllamaLLM(model=config.MODEL_ID, base_url=config.OLLAMA_BASE_URL)
#     print(f"Successfully initialized OllamaLLM: {config.MODEL_ID} at {config.OLLAMA_BASE_URL}")
# except Exception as e:
#     print(f"CRITICAL ERROR: OllamaLLM init failed: {e}")
#     sys.exit(1)


=== app/main.py ===
# app/main.py
import os
import sys
import uvicorn
import webbrowser
import traceback
from pathlib import Path
import asyncio
import json
from fastapi import (
    FastAPI,
    Request,
    HTTPException,
    WebSocket,
    WebSocketDisconnect
)
from fastapi.responses import HTMLResponse, FileResponse # Added FileResponse
from fastapi.staticfiles import StaticFiles
from fastapi.websockets import WebSocketState

# Assuming these imports point to files relative to this script's location
# Adjust if your project structure is different
from . import config
from . import state
from . import llm
from . import docker_utils
from . import utils # For send_ws_message

# --- FastAPI App Initialization ---
app = FastAPI(title="Tesseracs Chat")

# --- Static Files Setup ---

# Ensure the base static directory exists (e.g., app/static)
if not config.STATIC_DIR or not config.STATIC_DIR.is_dir():
    print(f"CRITICAL ERROR: Base static directory path is invalid or not found: {config.STATIC_DIR}. Exiting.")
    sys.exit(1)
else:
    print(f"Base static directory found: {config.STATIC_DIR}")

# Define the path to the 'dist' directory within the static directory
dist_dir = Path(config.STATIC_DIR) / "dist"

# Ensure the 'dist' directory exists
if not dist_dir.is_dir():
    print(f"CRITICAL ERROR: Bundled assets directory not found: {dist_dir}. Did you run 'npm run build'? Exiting.")
    sys.exit(1)
else:
    print(f"Bundled assets directory found: {dist_dir}")

# Mount the 'dist' directory to serve requests starting with '/dist'
# This allows index.html (served from '/') to find ./dist/input.css etc.
app.mount("/dist", StaticFiles(directory=dist_dir), name="dist_assets")
print(f"Mounted bundled assets directory '{dist_dir}' at '/dist'")

# Optional: Mount the base static directory if you have other assets there
# If you only have index.html and the dist folder, you might not need this.
# If you keep it, ensure it doesn't conflict with other routes.
# app.mount("/static", StaticFiles(directory=config.STATIC_DIR), name="static")
# print(f"Mounted base static directory '{config.STATIC_DIR}' at '/static'")


# --- FastAPI HTTP Routes ---
@app.get("/", response_class=HTMLResponse)
async def get_chat_page(request: Request):
    """Serves the main index.html file."""
    # Serve index.html from the base static directory
    html_file_path = Path(config.STATIC_DIR) / "index.html"
    if not html_file_path.is_file():
        print(f"ERROR: index.html not found at expected location: {html_file_path}")
        raise HTTPException(status_code=404, detail="index.html not found")
    try:
        # Use FileResponse for potentially better handling of static HTML
        return FileResponse(html_file_path)
        # # Alternative: Read and return content
        # with open(html_file_path, "r", encoding="utf-8") as f:
        #     html_content = f.read()
        # return HTMLResponse(content=html_content)
    except Exception as e:
        print(f"ERROR serving index.html: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error serving index.html: {e}")

# --- WebSocket Endpoint ---
@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: str):
    """Handles WebSocket connections for chat and code execution."""
    await websocket.accept()
    print(f"WebSocket connection accepted for client: {client_id}")
    memory = state.get_memory_for_client(client_id)
    # Ensure model instance is handled correctly (singleton or per-request)
    # model_instance = llm.get_model() # Assuming get_model handles initialization

    def load_memory_for_current_client(_):
        """Loads memory variables specific to the current client."""
        loaded_vars = memory.load_memory_variables({})
        return loaded_vars.get("history", [])

    try:
        # Create chain within the connection scope if it depends on client memory
        # Use the model instance already initialized in llm.py
        chain = llm.create_chain(load_memory_for_current_client)
        print(f"LCEL Chain created for client: {client_id}")
    except Exception as chain_init_error:
         print(f"ERROR creating LCEL chain for {client_id}: {chain_init_error}")
         traceback.print_exc()
         await websocket.close(code=1011) # Internal Server Error
         return # Exit websocket handler

    try:
        while True:
            if websocket.client_state != WebSocketState.CONNECTED:
                print(f"WebSocket no longer connected for {client_id} before receive. Breaking loop.")
                break

            received_data = await websocket.receive_text()

            try:
                # Attempt to parse as JSON for potential commands
                message_data = json.loads(received_data)
                message_type = message_data.get("type")
                payload = message_data.get("payload")

                # Check if it looks like a valid command structure
                if message_type and payload and isinstance(payload, dict):
                    code_block_id = payload.get("code_block_id")
                    if not code_block_id:
                        print(f"Received JSON command without code_block_id: {message_data}")
                        continue # Ignore invalid command

                    # Handle 'run_code' command
                    if message_type == "run_code":
                        language = payload.get("language")
                        code = payload.get("code")
                        if language and code is not None:
                            print(f"Received 'run_code' request for block {code_block_id} ({language}) from {client_id}")
                            # Run code execution in background task
                            asyncio.create_task(
                                docker_utils.run_code_in_docker_stream(websocket, client_id, code_block_id, language, code)
                            )
                        else:
                            print(f"Invalid 'run_code' payload received: {payload}")
                            await utils.send_ws_message(websocket, "code_finished", {
                                "code_block_id": code_block_id, "exit_code": -1,
                                "error": "Invalid run_code request payload from client."
                            })

                    # Handle 'stop_code' command
                    elif message_type == "stop_code":
                        print(f"Received 'stop_code' request for block {code_block_id} from {client_id}")
                        # Stop container in background task
                        asyncio.create_task(
                            docker_utils.stop_docker_container(code_block_id)
                        )

                    # Handle unknown command types
                    else:
                        print(f"Received unknown JSON command type '{message_type}' from {client_id}")

                # If not a valid command structure, treat as chat
                else:
                     print(f"Received invalid JSON structure from {client_id}, treating as chat: {received_data[:100]}...")
                     await handle_chat_message(chain, memory, websocket, client_id, received_data)

            # If it's not JSON, treat as a chat message
            except json.JSONDecodeError:
                await handle_chat_message(chain, memory, websocket, client_id, received_data)
            # Catch potential errors during command/chat handling within the loop
            except Exception as handler_exc:
                 print(f"ERROR handling message for {client_id}: {handler_exc}")
                 traceback.print_exc()
                 # Optionally send an error message back to the client
                 try:
                      await utils.send_ws_message(websocket, "error", {"message": f"Server error processing message: {handler_exc}"})
                 except Exception:
                      pass # Ignore if sending error fails

    except WebSocketDisconnect:
        print(f"WebSocket disconnected during receive/process for client: {client_id}")
    except Exception as e:
        print(f"Unknown Error in WebSocket loop for client {client_id}: {e}")
        traceback.print_exc()
    finally:
        print(f"Cleaning up resources for client: {client_id}")
        state.remove_memory_for_client(client_id)
        # Ensure cleanup happens even if connection drops unexpectedly
        await docker_utils.cleanup_client_containers(client_id)
        if websocket.client_state == WebSocketState.CONNECTED:
            try:
                await websocket.close(code=1000)
                print(f"WebSocket closed gracefully for {client_id}")
            except Exception as close_exc:
                print(f"Ignoring error during explicit WebSocket close for {client_id}: {close_exc}")
        else:
             print(f"WebSocket already closed for {client_id} during cleanup.")


async def handle_chat_message(chain, memory, websocket: WebSocket, client_id: str, user_input: str):
    """Handles incoming chat messages, streams response, and saves context."""
    # Add a debug print here to see the config value when the chain is used
    print(f"DEBUG handle_chat_message: Using config.MODEL_ID = {config.MODEL_ID}")
    print(f"Handling chat message from {client_id}: '{user_input[:50]}...'")
    full_response = ""
    try:
        # Stream the response from the language model chain
        async for chunk in chain.astream({"input": user_input}):
            if websocket.client_state != WebSocketState.CONNECTED:
                print(f"WebSocket disconnected during chat stream for {client_id}. Aborting send.")
                return # Stop streaming if client disconnects
            await websocket.send_text(chunk)
            full_response += chunk # Accumulate the full response for memory
    except Exception as chain_exc:
        # Handle errors during the language model processing
        error_msg = f"<ERROR>Error processing message: {chain_exc}"
        print(f"ERROR during chain execution for {client_id}: {chain_exc}")
        traceback.print_exc()
        # Try to send an error message back to the client
        if websocket.client_state == WebSocketState.CONNECTED:
            try:
                await websocket.send_text(error_msg)
            except Exception as send_err:
                 print(f"Error sending chain exception message to {client_id}: {send_err}")
        return # Exit without saving context if the chain failed

    # If streaming finished and client is still connected, send End Of Stream marker
    if websocket.client_state == WebSocketState.CONNECTED:
        try:
            await websocket.send_text("<EOS>")
            print(f"Finished streaming chat response to {client_id}")
            # Save the interaction to memory
            memory.save_context({"input": user_input}, {"output": full_response})
            print(f"Saved chat context to memory for client: {client_id}")
        except Exception as send_eos_err:
             print(f"Error sending <EOS> or saving context for {client_id}: {send_eos_err}")
    else:
         print(f"WebSocket disconnected before sending <EOS> for {client_id}.")


# --- Function to run the server ---
def start_server():
    """Initializes and runs the Uvicorn server."""
    host = "127.0.0.1"
    port = 8001 # Ensure this matches the port you access in the browser
    url = f"http://{host}:{port}"

    print("-" * 30)
    print(f"Starting server at {url}...")
    print(f"Using Ollama base URL: {config.OLLAMA_BASE_URL}")
    # --- ADDED DEBUG PRINT ---
    print(f"DEBUG start_server: Configured Model ID = {config.MODEL_ID}")
    # -------------------------
    print(f"Using Model ID: {config.MODEL_ID}") # Keep original print too
    print(f"Base static directory: {config.STATIC_DIR}")
    print(f"Bundled assets directory: {dist_dir}") # Print dist_dir path
    print(f"Supported execution languages: {list(config.SUPPORTED_LANGUAGES.keys())}")

    # Check Docker availability
    if docker_utils.get_docker_client() is None:
        print("WARNING: Docker client unavailable. Code execution will fail.")
    else:
        print("Docker client available.")
    print("-" * 30)

    # Attempt to open the browser automatically
    print(f"Attempting to open browser at {url}...")
    try:
        webbrowser.open(url)
    except Exception as browser_err:
        print(f"Warning: Could not automatically open browser: {browser_err}")
        print(f"Please navigate to {url} manually.")

    # Run the Uvicorn server
    # Note: reload=True is useful for development but should be False in production
    uvicorn.run(
        "app.main:app",
        host=host,
        port=port,
        log_level="info",
        reload=True # Set to False for production
        # reload_dirs=[str(Path(__file__).parent)] # Optional: Specify dirs to watch for reload
    )

# --- Main Execution Block ---
# Allows running the server script directly
if __name__ == "__main__":
    start_server()


=== app/state.py ===
import asyncio
from langchain.memory import ConversationBufferMemory
from typing import Dict, Any
from docker.models.containers import Container # For type hinting
from fastapi import WebSocket

# --- Global State for WebSocket Connections and Running Containers ---
client_memory: Dict[str, ConversationBufferMemory] = {}

# Stores info about currently running code executions
# Format: { "code_block_id": {"container": Container, "stream_task": asyncio.Task, "client_id": str, "websocket": WebSocket, "stop_event": asyncio.Event} }
running_containers: Dict[str, Dict[str, Any]] = {}
running_containers_lock = asyncio.Lock() # Lock for safe concurrent access

# --- Memory Management Functions ---
def get_memory_for_client(client_id: str) -> ConversationBufferMemory:
    """Retrieves or creates memory for a specific client."""
    global client_memory
    if client_id not in client_memory:
        client_memory[client_id] = ConversationBufferMemory(return_messages=True, memory_key="history")
        print(f"Initialized new memory for client: {client_id}")
    return client_memory[client_id]

def remove_memory_for_client(client_id: str):
    """Removes memory when a client disconnects."""
    global client_memory
    if client_id in client_memory:
        del client_memory[client_id]
        print(f"Removed memory for client: {client_id}")

=== app/utils.py ===
# app/utils.py
import json
import traceback
from fastapi import WebSocket, WebSocketDisconnect
from fastapi.websockets import WebSocketState

async def send_ws_message(websocket: WebSocket, message_type: str, payload: dict):
    """Safely sends a JSON message over the WebSocket."""
    # Check state before sending (no change needed here)
    if websocket.client_state != WebSocketState.CONNECTED:
        print(f"[utils] WebSocket not connected, cannot send {message_type} for {payload.get('code_block_id', 'N/A')}")
        return
    try:
        await websocket.send_json({"type": message_type, "payload": payload})
    except WebSocketDisconnect:
        print(f"[utils] WebSocket disconnected while trying to send {message_type} for {payload.get('code_block_id', 'N/A')}")
    except Exception as e:
        # Catch other potential errors like Runtime Error if connection closed during send
        print(f"[utils] Error sending WebSocket message ({message_type}) for {payload.get('code_block_id', 'N/A')}: {e}")
        # traceback.print_exc() # Optional: uncomment for more detail

=== app/static/index.html ===
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Tesseracs Chat</title>

        <link rel="stylesheet" href="./dist/input.css">

        </head>
<body class="bg-gray-100 flex flex-col h-screen">
    <header class="bg-blue-600 text-white p-4 text-center shadow-md">
        <h1 class="text-2xl font-bold">Tesseracs-Chat</h1>
    </header>

    <div id="chat-history" class="flex-1 overflow-y-auto p-4 space-y-4 flex flex-col bg-white shadow-inner m-4 rounded-lg">
        </div>

    <footer class="p-4 bg-gray-200 border-t border-gray-300">
       <form id="chat-form" class="flex items-center space-x-2">
            <div class="think-checkbox-container">
                <input type="checkbox" id="think-checkbox">
                <label for="think-checkbox">Think</label>
            </div>
            <input type="text" id="message-input" placeholder="Type your message..." autocomplete="off" required
                   class="flex-1 p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            <button type="submit" id="send-button"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                Send
            </button>
        </form>
    </footer>

    <script src="./dist/script.js" defer></script>
</body>
</html>

=== app/static/input.css ===
/* --- Add these imports at the TOP --- */
@import 'prismjs/themes/prism-tomorrow.css';
@import 'katex/dist/katex.min.css';
/* ----------------------------------- */

/* Your Tailwind directives */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* --- General Styles & Scrollbar --- */
html, body {
    height: 100%;
    margin: 0;
    font-family: 'Inter', sans-serif;
    background-color: #f3f4f6; /* Light gray background for the whole page */
}

#chat-history {
    flex: 1;
    overflow-y: auto;
    padding: 1rem; /* Use rem for scalable padding */
    display: flex;
    flex-direction: column;
    background-color: #ffffff; /* White background for chat area */
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
    margin: 1rem; /* Add margin around the chat history */
    border-radius: 0.5rem; /* Rounded corners */
}

/* Custom scrollbar for chat history */
#chat-history::-webkit-scrollbar { width: 8px; }
#chat-history::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
#chat-history::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
#chat-history::-webkit-scrollbar-thumb:hover { background: #555; }

/* --- Message Styling --- */
.message {
    padding: 0.5rem 0.75rem; /* Use rem */
    margin-bottom: 0.5rem;
    border-radius: 0.5rem;
    max-width: 90%;
    word-wrap: break-word;
    line-height: 1.5; /* Improve readability */
}

.user-message {
    background-color: #dbeafe; /* Tailwind blue-100 */
    align-self: flex-end;
    margin-left: auto;
    white-space: pre-wrap; /* Preserve user whitespace */
}

/* Container for a full AI turn (thinking + bubble + code blocks) */
.ai-turn-container {
    display: flex;
    flex-direction: column;
    align-items: flex-start; /* Align items to the left */
    width: 100%; /* Take full width to allow max-width on children */
    margin-bottom: 0.5rem; /* Consistent spacing */
}

.ai-message {
    background-color: #e5e7eb; /* Tailwind gray-200 */
    align-self: flex-start;
    margin-right: auto;
    max-width: 90%; /* Limit width */
    padding: 0.5rem 0.75rem; /* Added padding for consistency */
    border-radius: 0.5rem; /* Added radius for consistency */
}

/* Styling for Markdown elements rendered inside .ai-message */
.ai-message p { margin-bottom: 0.5em; }
.ai-message p:last-child { margin-bottom: 0; }
.ai-message ul, .ai-message ol { margin-left: 1.5em; margin-top: 0.5em; margin-bottom: 0.5em; }
.ai-message li { margin-bottom: 0.25em; }
.ai-message blockquote { border-left: 3px solid #ccc; padding-left: 0.8em; margin-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; color: #555; }
.ai-message code { /* Inline code */
    background-color: rgba(0, 0, 0, 0.06);
    padding: 0.1em 0.3em;
    border-radius: 3px;
    font-family: monospace;
    font-size: 0.9em;
}
/* Avoid double background for code elements within Prism blocks */
.ai-message pre[class*="language-"] code {
    background-color: transparent;
    padding: 0;
    border-radius: 0;
    font-size: inherit; /* Inherit size from pre */
}
.ai-message a { color: #007bff; text-decoration: underline; }
.ai-message a:hover { color: #0056b3; }
.ai-message hr { border: none; border-top: 1px solid #ccc; margin: 1em 0; }
.ai-message table { border-collapse: collapse; margin: 1em 0; width: auto; }
.ai-message th, .ai-message td { border: 1px solid #ccc; padding: 0.3em 0.6em; text-align: left; }
.ai-message th { background-color: #f2f2f2; font-weight: bold; }

/* Code reference style in the main bubble */
.code-reference {
    font-family: monospace;
    background-color: rgba(0, 0, 0, 0.08); /* Light gray background */
    padding: 1px 5px; /* Small padding */
    border-radius: 4px; /* Rounded corners */
    font-size: 0.85em; /* Slightly smaller font */
    white-space: nowrap; /* Prevent breaking */
    margin: 0 2px; /* Add slight spacing around it */
}

/* --- Loading/Thinking Indicators --- */
.loading-dots { display: inline-block; }
.loading-dots::after {
    display: inline-block; position: relative; left: 1px;
    animation: ellipsis 1.5s infinite; content: ".";
    width: 1.5em; text-align: left; vertical-align: bottom;
}
@keyframes ellipsis {
    0% { content: "."; } 33% { content: ".."; } 66% { content: "..."; }
}

/* --- Thinking Area Styling --- */
.thinking-area {
    width: 100%; max-width: 90%; margin-bottom: 4px;
    align-self: flex-start; font-size: 0.9em;
}
.thinking-area details {
    width: 100%; border: 1px dashed #aaa; border-radius: 6px;
    background-color: #f0f0f0; overflow: hidden;
}
.thinking-summary {
    padding: 3px 8px; cursor: pointer; font-weight: normal; color: #444;
    background-color: #e0e0e0; border-bottom: 1px dashed #aaa;
    outline: none; user-select: none; list-style: none; display: block;
    transition: background-color 0.15s ease;
}
.thinking-summary:hover { background-color: #d0d0d0; }
.thinking-summary::-webkit-details-marker { display: none; }
.thinking-summary .dots { display: inline-block; margin-left: 4px; }
.thinking-summary .dots::after { /* Uses ellipsis animation defined above */
    display: inline-block; position: relative; left: 1px;
    animation: ellipsis 1.5s infinite; content: ".";
    width: 1.5em; text-align: left; vertical-align: bottom;
}
.thinking-area details[open] > .thinking-summary .dots { display: none; }
.thinking-area details pre {
    margin: 0; padding: 8px; background-color: #f8f8f8;
    white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word;
    max-height: 200px; overflow-y: auto;
}

/* --- Code Block Area --- */
.code-blocks-area {
    width: 100%; /* Allow blocks to take full width */
    max-width: 90%; /* Match AI bubble width */
    align-self: flex-start; /* Align with AI bubble */
    margin-top: 0.5rem; /* Space above code blocks */
}

.code-block-container {
    margin-bottom: 0.75rem; /* Space between code blocks */
    border-radius: 0.375rem; /* 6px - Applied to the whole container */
    overflow: hidden; /* Crucial: clips children to the container's radius */
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

/* --- Unified Code Block Header Styles --- */
.code-block-header,
.code-output-header {
    display: flex;
    align-items: center;
    background-color: #e5e7eb; /* Tailwind gray-200 (Unified Style) */
    padding: 0.25rem 0.5rem;    /* Unified Style */
    font-size: 0.8em;          /* Unified Style */
    color: #4b5563;            /* Unified Style (Gray-600) */
    gap: 0.625rem;             /* Unified Style (10px) */
}

/* Specific adjustment for Output Header spacing */
.code-output-header {
    margin-top: 0.25rem; /* Keep space above output header */
    /* border-top: none; /* Ensure no top border if previously added */
}

/* --- Header Content Alignment --- */

/* Buttons Div (Shared) */
.code-block-buttons,
.output-header-buttons { /* Combined selector */
    display: flex;
    align-items: center;
    gap: 0.375rem; /* 6px */
    flex-shrink: 0;
}

/* Title (Shared Properties) */
.code-block-title,
.output-header-title { /* Combined selector */
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* Code Header Title Specifics */
.code-block-title {
    flex-shrink: 1; /* Allow title to shrink if needed */
    flex-grow: 1; /* Allow title to grow */
    text-align: left;
}

/* Output Header Title Specifics */
.output-header-title {
    flex-shrink: 0; /* Don't let title shrink */
    margin-right: 0.625rem; /* Space after title, before status */
}

/* Placeholder for alignment in Output Header */
.output-header-button-placeholder {
    display: inline-block;
    width: 24px;
    height: 24px;
    flex-shrink: 0;
}

/* Status Span (Only in Output Header) */
.code-status-span {
    margin-left: auto; /* Pushes this element to the far right */
    text-align: right;
    font-style: italic;
    font-size: 0.9em; /* Relative to header font-size */
    padding: 0 0.3125rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    color: #6b7280; /* Default Idle color */
    flex-shrink: 0; /* Prevent status from shrinking */
}
.code-status-span.running, .code-status-span.stopping { color: #ca8a04; font-weight: 500; }
.code-status-span.success { color: #16a34a; font-weight: 500; }
.code-status-span.error, .code-status-span.stopped { color: #dc2626; font-weight: 500; }


/* --- Code Block Action Buttons (Shared Base Style) --- */
.code-action-btn {
    background-color: #d1d5db; /* Tailwind gray-300 */
    color: #4b5563; /* Gray-600 */
    border: none;
    padding: 0.1875rem 0.4375rem; /* 3px 7px */
    border-radius: 0.25rem; /* 4px */
    cursor: pointer;
    font-size: 0.9em; /* Relative to header font-size */
    line-height: 1.2;
    transition: background-color 0.2s ease, color 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    white-space: nowrap;
}
.code-action-btn:hover { background-color: #9ca3af; color: #1f2937; }
.code-action-btn:disabled { opacity: 0.6; cursor: not-allowed; }
.code-action-btn.copied { background-color: #16a34a; color: white; }

/* --- Button Style Override for Output Header (Ensures consistency) --- */
/* This rule overrides browser defaults/resets for buttons specifically in the output header */
.code-output-header .code-action-btn {
    /* Re-apply key styles from .code-action-btn to ensure they take precedence */
    background-color: #d1d5db;
    color: #4b5563;
    border: none;
    padding: 0.1875rem 0.4375rem;
    border-radius: 0.25rem;
    cursor: pointer;
    font-size: 0.9em;
    line-height: 1.2;
    transition: background-color 0.2s ease, color 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    white-space: nowrap;
}
.code-output-header .code-action-btn:hover {
     background-color: #9ca3af;
     color: #1f2937;
}
/* Add other states (:disabled, .copied) if needed for output header specifically */
/* e.g., .code-output-header .code-action-btn.copied { ... } */


/* Specific Run/Stop Button Styling (Only in Code Header) */
.run-code-btn { /* This class is only applied in the code header */
    padding: 4px; width: 24px; height: 24px; font-size: 1em; /* Relative to header font-size */
    background-color: transparent !important; border: none !important;
    color: #9ca3af; transition: color 0.2s ease;
}
.run-code-btn:hover { color: #4b5563; background-color: transparent !important; }
.run-code-btn[data-status="idle"] { color: #16a34a; }
.run-code-btn[data-status="idle"]:hover { color: #15803d; }
.run-code-btn[data-status="running"] { color: #dc2626; }
.run-code-btn[data-status="running"]:hover { color: #b91c1c; }
.run-code-btn[data-status="stopping"] { color: #f59e0b; cursor: wait; animation: spin 1s linear infinite; }
.run-code-btn[data-status="stopping"]:hover { color: #d97706; }
@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

/* --- Code Area & Output Console --- */

/* Style for the <pre> containing the code input */
.code-block-container > pre[class*="language-"] { /* More specific selector */
    margin: 0;
    border: 1px solid #d1d5db; /* Lighter border for code input */
    border-top: none;
    border-bottom: none !important; /* Remove bottom border if output follows */
    overflow: hidden;
    /* Background comes from Prism theme */
}

/* Style for the editable code element itself */
.code-block-container > pre[class*="language-"] > code[class*="language-"] {
    outline: none;
    white-space: pre-wrap !important;
    word-wrap: break-word !important;
    display: block;
    min-height: 1.5em;
    padding: 0.5em; /* Padding inside code input */
}
.code-block-container > pre[class*="language-"] > code[class*="language-"]:focus {
    background-color: rgba(0, 0, 0, 0.03); /* Slight focus indicator */
}

/* Output Console Container */
.code-output-console {
    background-color: #1f2937; /* Dark background */
    color: #f3f4f6;            /* Light text */
    padding: 0;                /* No padding on container */
    border: 1px solid #4b5563; /* Darker border */
    border-top: none !important;/* No top border */
    max-height: 250px;
    overflow-y: auto;
    font-family: monospace;
    font-size: 0.85em;         /* Slightly smaller than code input */
    line-height: 1.4;
}

/* Style for the <pre> inside the Output Console */
.code-output-console pre {
    margin: 0;
    white-space: pre-wrap;
    word-wrap: break-word;
    color: inherit;
    border: none !important; /* Explicitly remove border */
    padding: 0.5rem;         /* Padding for the output text */
    background-color: transparent; /* Use parent's background */
    outline: none !important;
}

/* Styles for the output text spans */
.code-output-console span { display: inline; white-space: pre-wrap; }
.code-output-console span.stdout-output { color: #ffffff; }
.code-output-console span.stderr-output { color: #f87171; } /* Lighter Red */

/* --- Hide/Show Functionality --- */
.code-block-container > pre.hidden, /* Hides code input pre */
.code-output-console.hidden,        /* Hides output console div */
.code-output-header.hidden          /* Hides output header */
 { display: none !important; }


/* --- Footer & Input --- */
footer { padding: 1rem; background-color: #e5e7eb; border-top: 1px solid #d1d5db; }
#chat-form { display: flex; align-items: center; gap: 0.5rem; }
.think-checkbox-container { display: flex; align-items: center; font-size: 0.9em; color: #4b5563; }
.think-checkbox-container input { margin-right: 4px; cursor: pointer; }
.think-checkbox-container label { cursor: pointer; user-select: none;}
#message-input {
    flex-grow: 1; padding: 0.5rem 0.75rem; border: 1px solid #d1d5db;
    border-radius: 0.5rem; outline: none;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
}
#message-input:focus { border-color: #2563eb; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); }
#send-button {
    background-color: #2563eb; color: white; font-weight: 500; padding: 0.5rem 1rem;
    border-radius: 0.5rem; border: none; cursor: pointer; transition: background-color 0.2s ease;
}
#send-button:hover { background-color: #1d4ed8; }
#send-button:disabled { opacity: 0.6; cursor: not-allowed; }

/* --- Error/System Messages --- */
.error-message {
    background-color: #fee2e2; color: #991b1b; border: 1px solid #fecaca;
    align-self: flex-start; margin-right: auto; padding: 0.5rem 0.75rem;
    border-radius: 0.5rem; max-width: 90%; word-wrap: break-word;
    margin-bottom: 0.5rem; white-space: pre-wrap;
}
.system-message {
    width: 100%; text-align: center; font-size: 0.875rem; color: #6b7280;
    font-style: italic; margin: 0.25rem 0;
}

/* --- KaTeX Specific Styling --- */
span[data-katex-rendered="true"] .katex-display { margin: 0.5em 0; overflow-x: auto; overflow-y: hidden; padding: 0.2em 0; }
span[data-katex-rendered="true"] .katex { line-height: normal; vertical-align: baseline; font-size: 1em; }
.katex-error { color: #cc0000; background-color: #fdd; border: 1px solid #cc0000; padding: 2px 4px; border-radius: 3px; }

/* --- Utility --- */
.hidden { display: none !important; }

/* Add Prism.js theme styles separately */
/* Link to a theme in your HTML or include the theme CSS rules here */
/* e.g., @import url('path/to/prism-theme.css'); */


=== app/static/script.js ===
// --- JS Imports ---
import { marked } from 'marked';
import katex from 'katex';
import Prism from 'prismjs';

// --- Prism Components ---

import 'prismjs/components/prism-clike';
import 'prismjs/components/prism-python';
import 'prismjs/components/prism-javascript';
import 'prismjs/components/prism-css';
import 'prismjs/components/prism-bash';
import 'prismjs/components/prism-json';
import 'prismjs/components/prism-yaml';
import 'prismjs/components/prism-sql';
import 'prismjs/components/prism-java';
import 'prismjs/components/prism-csharp';
import 'prismjs/components/prism-go';
import 'prismjs/components/prism-rust';
import 'prismjs/components/prism-docker';
import 'prismjs/components/prism-typescript';
import 'prismjs/components/prism-c';
import 'prismjs/components/prism-cpp';
// import 'prismjs/components/prism-php'; // not working
// import 'prismjs/components/prism-ruby'; // not working
// --------------------------

// --- Constants and Variables ---
const chatHistory = document.getElementById('chat-history');
const chatForm = document.getElementById('chat-form');
const messageInput = document.getElementById('message-input');
const sendButton = document.getElementById('send-button');
const thinkCheckbox = document.getElementById('think-checkbox');

let websocket;
const clientId = `web-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
let currentTurnId = 0;

const MODE_ANSWER = 'MODE_ANSWER';
const MODE_SEEKING_CODE_LANGUAGE = 'MODE_SEEKING_CODE_LANGUAGE';
const MODE_INSIDE_CODE_BLOCK = 'MODE_INSIDE_CODE_BLOCK';
const MODE_KATEX_BUFFERING_INLINE = 'MODE_KATEX_BUFFERING_INLINE';
const MODE_KATEX_BUFFERING_DISPLAY = 'MODE_KATEX_BUFFERING_DISPLAY';
const MODE_MAYBE_START_DISPLAY_KATEX = 'MODE_MAYBE_START_DISPLAY_KATEX';
const MODE_SEEKING_TAG = 'MODE_SEEKING_TAG';
const MODE_INSIDE_THINK = 'MODE_INSIDE_THINK';
const MODE_MAYBE_END_THINK = 'MODE_MAYBE_END_THINK';
const NO_THINK_PREFIX = "\\no_think";
const MODE_SEEKING_CODE_START_FENCE = 'MODE_SEEKING_CODE_START_FENCE';
const MODE_SEEKING_CODE_END_FENCE = 'MODE_SEEKING_CODE_END_FENCE';

let currentProcessingMode = MODE_ANSWER;
let langBuffer = '';
let currentCodeBlockLang = ''; // Stores the language name (e.g., 'python')
let currentCodeBlockElement = null; // The <code> element
let currentCodeBlockPreElement = null; // The <pre> element wrapping the code
let katexBuffer = '';
let currentKatexMarkerId = null;
let thinkBuffer = '';
let tagBuffer = '';
let fenceBuffer = ''; // Added for fence detection
let currentAiTurnContainer = null;
let currentAnswerElement = null;
let currentThinkingArea = null;
let currentThinkingPreElement = null;
let currentCodeBlocksArea = null;
let codeBlockCounterThisTurn = 0;
let thinkingRequestedForCurrentTurn = false;
let accumulatedAnswerText = '';
let lastAppendedNode = null;
let hasThinkingContentArrivedThisTurn = false;
let firstAnswerTokenReceived = false;

const FENCE = '```';
const THINK_START_TAG = '<think>';
const THINK_END_TAG = '</think>';
const KATEX_PLACEHOLDER_PREFIX = '%%KATEX_PLACEHOLDER_';
const KATEX_RENDERED_ATTR = 'data-katex-rendered';


// --- Utility Functions ---

function scrollToBottom(behavior = 'auto') {
    const isNearBottom = chatHistory.scrollHeight - chatHistory.scrollTop - chatHistory.clientHeight < 100;
    if (isNearBottom) {
        requestAnimationFrame(() => {
            chatHistory.scrollTo({ top: chatHistory.scrollHeight, behavior: behavior });
        });
    }
}

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
};

function getCursorPosition(parentElement) {
    const selection = window.getSelection();
    if (selection.rangeCount === 0) return -1;

    const range = selection.getRangeAt(0);
    if (!parentElement.contains(range.startContainer)) {
        return -1;
    }

    const preSelectionRange = range.cloneRange();
    preSelectionRange.selectNodeContents(parentElement);
    try {
        preSelectionRange.setEnd(range.startContainer, range.startOffset);
    } catch (e) {
        console.error("Error setting preSelectionRange end:", e, "Range:", range);
        return -1;
    }
    return preSelectionRange.toString().length;
}

function setCursorPosition(parentElement, offset) {
    const selection = window.getSelection();
    if (!selection) return;

    const range = document.createRange();
    let charCount = 0;
    let foundStart = false;

    function findNodeAndOffset(node) {
        if (foundStart) return;

        if (node.nodeType === Node.TEXT_NODE) {
            const nextCharCount = charCount + node.length;
            if (!foundStart && offset >= charCount && offset <= nextCharCount) {
                try {
                    const offsetInNode = offset - charCount;
                    range.setStart(node, offsetInNode);
                    foundStart = true;
                } catch (e) {
                    console.error("Error setting range start:", e, "Node:", node, "Offset:", offsetInNode);
                }
            }
            charCount = nextCharCount;
        } else {
            for (let i = 0; i < node.childNodes.length; i++) {
                findNodeAndOffset(node.childNodes[i]);
                if (foundStart) break;
            }
        }
    }

    findNodeAndOffset(parentElement);

    if (foundStart) {
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
    } else {
        range.selectNodeContents(parentElement);
        range.collapse(false);
        selection.removeAllRanges();
        selection.addRange(range);
        console.warn(`Could not set cursor precisely at offset ${offset}. Placed at end.`);
    }
    parentElement.focus();
}

// --- Message Display Functions ---

function addUserMessage(text) {
    const messageElement = document.createElement('div');
    messageElement.classList.add('message', 'user-message');
    messageElement.textContent = text;
    chatHistory.appendChild(messageElement);
    setTimeout(() => scrollToBottom('smooth'), 50);
}

function addSystemMessage(text) {
   const messageElement = document.createElement('div');
   messageElement.classList.add('system-message');
   messageElement.textContent = text;
   chatHistory.appendChild(messageElement);
   setTimeout(() => scrollToBottom('smooth'), 50);
}

function addErrorMessage(text) {
   console.error("[UI ERROR] ", text);
   const messageElement = document.createElement('div');
   messageElement.classList.add('error-message');
   messageElement.textContent = `Error: ${text}`;
   if(currentAiTurnContainer) {
       const target = currentAnswerElement || currentCodeBlocksArea || currentAiTurnContainer;
       target.appendChild(messageElement);
   } else { chatHistory.appendChild(messageElement); }
   setTimeout(() => scrollToBottom('smooth'), 50);
}

function setInputDisabledState(disabled) {
    messageInput.disabled = disabled;
    sendButton.disabled = disabled;
    if (thinkCheckbox) {
        thinkCheckbox.disabled = disabled;
    }
}

function setupNewAiTurn() {
    currentTurnId++;
    codeBlockCounterThisTurn = 0;
    accumulatedAnswerText = '';
    lastAppendedNode = null;
    thinkBuffer = '';
    hasThinkingContentArrivedThisTurn = false;
    firstAnswerTokenReceived = false;

    currentAiTurnContainer = null;
    currentThinkingArea = null;
    currentThinkingPreElement = null;
    currentAnswerElement = null;
    currentCodeBlocksArea = null;

    console.log(`[setupNewAiTurn] Starting setup for Turn ID: ${currentTurnId}. thinkingRequestedForCurrentTurn is: ${thinkingRequestedForCurrentTurn}`);

    currentAiTurnContainer = document.createElement('div');
    currentAiTurnContainer.classList.add('ai-turn-container');
    currentAiTurnContainer.dataset.turnId = currentTurnId;

    currentThinkingArea = document.createElement('div');
    currentThinkingArea.classList.add('thinking-area');
    currentThinkingArea.dataset.turnId = currentTurnId;

    if (!thinkingRequestedForCurrentTurn) {
        console.log("[setupNewAiTurn] Setting thinking area style to display:none because thinkingRequested=false.");
        currentThinkingArea.style.display = 'none';
    } else {
        console.log("[setupNewAiTurn] NOT hiding thinking area initially because thinkingRequested=true.");
    }

    const details = document.createElement('details');
    details.id = `thinking-details-${currentTurnId}`;
    const summary = document.createElement('summary');
    summary.classList.add('thinking-summary');
    const summaryTextSpan = document.createElement('span');
    summaryTextSpan.classList.add('text');
    summaryTextSpan.textContent = 'Show Thinking';
    const summaryDotsSpan = document.createElement('span');
    summaryDotsSpan.classList.add('dots');
    summary.appendChild(summaryTextSpan);
    summary.appendChild(summaryDotsSpan);
    currentThinkingPreElement = document.createElement('pre');
    details.appendChild(summary);
    details.appendChild(currentThinkingPreElement);
    currentThinkingArea.appendChild(details);
    currentAiTurnContainer.appendChild(currentThinkingArea);

    details.addEventListener('toggle', (event) => {
        const textSpan = event.target.querySelector('.thinking-summary .text');
        if (!textSpan) return;
        textSpan.textContent = event.target.open ? 'Hide Thinking' : 'Show Thinking';
    });

    currentAnswerElement = document.createElement('div');
    currentAnswerElement.classList.add('message', 'ai-message');

    if (thinkingRequestedForCurrentTurn) {
        console.log("[setupNewAiTurn] Hiding answer bubble initially because thinkingRequested=true.");
        currentAnswerElement.style.display = 'none';
    } else {
        console.log("[setupNewAiTurn] Showing answer bubble immediately with loading dots because thinkingRequested=false.");
         const loadingSpan = document.createElement('span');
         loadingSpan.classList.add('loading-dots');
         currentAnswerElement.appendChild(loadingSpan);
    }
    currentAiTurnContainer.appendChild(currentAnswerElement);

    currentCodeBlocksArea = document.createElement('div');
    currentCodeBlocksArea.classList.add('code-blocks-area');
    currentAiTurnContainer.appendChild(currentCodeBlocksArea);

    chatHistory.appendChild(currentAiTurnContainer);

    console.log(`[setupNewAiTurn] Finished setup for Turn ID: ${currentTurnId}.`);
}

function appendRawTextToThinkingArea(text) {
    if (text && text.trim().length > 0) {
        // console.log(`[appendRawTextToThinkingArea] Received non-empty raw think text: "${text}" (length: ${text?.length})`);
    } else if (text !== null) {
        // console.log(`[appendRawTextToThinkingArea] Received empty or whitespace raw think text (length: ${text?.length})`);
    }

    // console.log(`[appendRawTextToThinkingArea] Checking condition: !thinkingRequestedForCurrentTurn is ${!thinkingRequestedForCurrentTurn} (value: ${thinkingRequestedForCurrentTurn})`);
    if (!thinkingRequestedForCurrentTurn) {
        // console.log("[appendRawTextToThinkingArea] Condition met (!thinkingRequested). Returning early. Should NOT display thinking.");
        return;
    }

    // console.log("[appendRawTextToThinkingArea] Proceeding because thinking was requested.");

    if (!currentThinkingArea || !currentThinkingPreElement || text.length === 0) {
        return;
    }

    if (!hasThinkingContentArrivedThisTurn) {
        if (currentThinkingArea.style.display === 'none') {
            // console.log("[appendRawTextToThinkingArea] First think chunk (and requested). Making area visible NOW. Display style was: " + currentThinkingArea.style.display);
            currentThinkingArea.style.display = '';
        }
        hasThinkingContentArrivedThisTurn = true;
    }

    try {
        currentThinkingPreElement.appendChild(document.createTextNode(text));
    } catch (appendError) {
         console.error("[appendRawTextToThinkingArea] Error appending text node:", appendError, "Pre Element:", currentThinkingPreElement, "Text:", text);
        return;
    }

    const detailsElement = currentThinkingPreElement.closest('details');
    if (detailsElement && detailsElement.open) {
         const isNearBottom = currentThinkingPreElement.scrollHeight - currentThinkingPreElement.scrollTop - currentThinkingPreElement.clientHeight < 50;
         if(isNearBottom) {
             requestAnimationFrame(() => { currentThinkingPreElement.scrollTop = currentThinkingPreElement.scrollHeight; });
         }
    }
}

function appendCodeReference() {
    if (!currentAnswerElement) {
        console.error("Attempted to append code reference to null answer bubble!");
        return;
    }
    if (codeBlockCounterThisTurn > 0) {
         const refSpan = document.createElement('span');
         refSpan.classList.add('code-reference');
         refSpan.textContent = `[Code ${codeBlockCounterThisTurn}]`;
         currentAnswerElement.appendChild(refSpan);
         lastAppendedNode = refSpan;
    } else {
        console.warn("appendCodeReference called but codeBlockCounterThisTurn is 0.");
    }
}

function formatAnswerBubbleFinal() {
    if (!currentAnswerElement) {
        console.warn("[DEBUG] Skipping final formatting: currentAnswerElement is null.");
        accumulatedAnswerText = ''; lastAppendedNode = null; firstAnswerTokenReceived = false; return;
    }

     if (currentAnswerElement.style.display === 'none' && (currentAnswerElement.hasChildNodes() || accumulatedAnswerText.trim().length > 0)) {
         console.warn("[formatAnswerBubbleFinal] Answer bubble was hidden but contained content. Making visible.");
         currentAnswerElement.style.display = '';
          const loadingDots = currentAnswerElement.querySelector('.loading-dots');
          if (loadingDots) loadingDots.remove();
     }

    const hasVisualContent = currentAnswerElement.hasChildNodes() && !currentAnswerElement.querySelector('.loading-dots');
    const hasAccumulatedContent = accumulatedAnswerText.trim().length > 0;

    if (!hasVisualContent && !hasAccumulatedContent) {
        console.log("[DEBUG] Skipping final formatting: No actual content found.");
         const loadingDots = currentAnswerElement.querySelector('.loading-dots');
         if (loadingDots) loadingDots.remove();
        accumulatedAnswerText = '';
        lastAppendedNode = null;
        return;
    }

    // console.log(`[DEBUG formatAnswerBubbleFinal] Proceeding. Has Visual: ${hasVisualContent}, Has Accumulated: ${hasAccumulatedContent}`);

    try {
        const storedKatexNodes = {};
        let placeholderIndex = 0;
        let textForMarkdown = accumulatedAnswerText;

        const katexSpans = Array.from(currentAnswerElement.children).filter(el => el.matches(`span[${KATEX_RENDERED_ATTR}="true"]`));

        if (katexSpans.length > 0) {
             katexSpans.forEach((el) => {
                 if (!el.parentNode) return;
                 const placeholder = `${KATEX_PLACEHOLDER_PREFIX}${placeholderIndex++}`;
                 storedKatexNodes[placeholder] = el.cloneNode(true);
                 try {
                     el.parentNode.replaceChild(document.createTextNode(placeholder), el);
                 } catch (replaceError) {
                     console.error(`[DEBUG] Error replacing KaTeX node with placeholder ${placeholder}:`, replaceError, "Node:", el);
                     try { el.parentNode.removeChild(el); } catch(removeError) { console.error("Failed to remove problematic KaTeX node:", removeError); }
                 }
             });
             textForMarkdown = currentAnswerElement.innerHTML;
        } else {
             if (hasVisualContent && hasAccumulatedContent) {
                 // console.log("[DEBUG formatAnswerBubbleFinal] No KaTeX found, clearing visual DOM and using accumulated text for Markdown.");
                 currentAnswerElement.innerHTML = '';
             } else if (!hasAccumulatedContent && hasVisualContent) {
                 // console.log("[DEBUG formatAnswerBubbleFinal] No KaTeX found, using existing innerHTML for Markdown.");
                 textForMarkdown = currentAnswerElement.innerHTML;
             }
        }

         if (textForMarkdown.trim().length === 0) {
            // console.log("[DEBUG formatAnswerBubbleFinal] textForMarkdown is empty, skipping marked parse.");
         } else {
             const markdownHtml = marked.parse(textForMarkdown, {
                 mangle: false, headerIds: false, gfm: true, breaks: true, sanitize: false
             });
             currentAnswerElement.innerHTML = markdownHtml;
             lastAppendedNode = null;
         }

         if (Object.keys(storedKatexNodes).length > 0) {
             // console.log("[DEBUG formatAnswerBubbleFinal] Reinserting KaTeX nodes.");
             const walker = document.createTreeWalker(currentAnswerElement, NodeFilter.SHOW_TEXT);
             let node;
             const textNodesContainingPlaceholders = [];
             while (node = walker.nextNode()) {
                 if (node.nodeValue && node.nodeValue.includes(KATEX_PLACEHOLDER_PREFIX)) {
                     textNodesContainingPlaceholders.push(node);
                 }
             }

             textNodesContainingPlaceholders.forEach(textNode => {
                 let currentNodeValue = textNode.nodeValue;
                 let parent = textNode.parentNode;
                 if (!parent) return;
                 let lastNodeInserted = textNode;
                 for (const placeholder in storedKatexNodes) {
                      if (currentNodeValue.includes(placeholder)) {
                           const parts = currentNodeValue.split(placeholder);
                           let firstPart = parts.shift();
                           if (firstPart) {
                               parent.insertBefore(document.createTextNode(firstPart), lastNodeInserted);
                           }
                           const katexNode = storedKatexNodes[placeholder].cloneNode(true);
                           parent.insertBefore(katexNode, lastNodeInserted);
                           currentNodeValue = parts.join(placeholder);
                       }
                 }
                 if (currentNodeValue) {
                     parent.insertBefore(document.createTextNode(currentNodeValue), lastNodeInserted);
                 }
                 parent.removeChild(lastNodeInserted);
             });
         } else {
            // console.log("[DEBUG formatAnswerBubbleFinal] No KaTeX nodes to reinsert.");
         }

    } catch (error) {
        console.error("Error during final Markdown/KaTeX formatting:", error);
        addErrorMessage("Failed to perform final message formatting.");
        if (currentAnswerElement && accumulatedAnswerText.trim().length > 0) {
             console.warn("Attempting fallback to raw accumulated text due to formatting error.");
             currentAnswerElement.textContent = accumulatedAnswerText;
        }
    }
    accumulatedAnswerText = '';
}

function resetStreamingState() {
    // console.log("[DEBUG] Resetting streaming state.");
    currentProcessingMode = MODE_ANSWER;
    langBuffer = ''; currentCodeBlockLang = '';
    currentCodeBlockElement = null; currentCodeBlockPreElement = null;
    katexBuffer = ''; currentKatexMarkerId = null;
    thinkBuffer = ''; tagBuffer = ''; fenceBuffer = ''; // Reset fenceBuffer
    lastAppendedNode = null;
    thinkingRequestedForCurrentTurn = false;
}

function renderAndReplaceKatex(isDisplay, markerId) {

    if (!currentAnswerElement || !markerId || katexBuffer === null || katexBuffer === undefined) {
        console.error("[KaTeX Replace Marker] Error: Invalid state (element, markerId, or buffer). MarkerID:", markerId, "Buffer:", katexBuffer);
        if (markerId && currentAnswerElement) {
             try {
                 const strayMarker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);
                 if (strayMarker?.parentNode) strayMarker.parentNode.removeChild(strayMarker);
             } catch (e) { console.error("Error cleaning stray marker:", e); }
        }
        katexBuffer = '';
        return false;
    }

    const trimmedKatexBuffer = katexBuffer.trim();

    try {
        const stringToRender = trimmedKatexBuffer.length > 0 ? trimmedKatexBuffer : " ";
        const katexHtml = katex.renderToString(stringToRender, {
            displayMode: isDisplay,
            throwOnError: false,
            output: "html",
            strict: false
        });

        if (katexHtml.includes('katex-error') && trimmedKatexBuffer.length > 0) {
            console.warn(`[KaTeX Replace Marker] KaTeX reported a rendering error for buffer: "${trimmedKatexBuffer}". Marker ID: ${markerId}. Raw text will remain.`);
             try {
                 const marker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);
                 if (marker?.parentNode) marker.parentNode.removeChild(marker);
                 else console.warn("Couldn't find marker to clean up after render error.");
             } catch (cleanupError) { console.error("Error during marker cleanup after render error:", cleanupError); }
            katexBuffer = '';
            return false;
        }

        const startMarker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);

        if (!startMarker) {
            console.error(`[KaTeX Replace Marker] Error: Cannot find start marker span with ID: ${markerId}. Aborting replacement. Content might be inconsistent.`);
            katexBuffer = '';
            return false;
        }

        if (!startMarker.parentNode) {
             console.error(`[KaTeX Replace Marker] Error: Start marker span with ID ${markerId} found but has no parent (already removed?). Aborting.`);
             katexBuffer = '';
             return false;
        }

        const parent = startMarker.parentNode;
        let nodesToRemove = [];
        let currentNode = startMarker.nextSibling;

        while (currentNode) {
            nodesToRemove.push(currentNode);
            if (nodesToRemove.length > 1000) {
                console.error("[KaTeX Replace Marker] Error: Excessive node collection limit reached (1000). Aborting replacement.");
                 try { parent.removeChild(startMarker); } catch(e){}
                 katexBuffer = '';
                 return false;
            }
            currentNode = currentNode.nextSibling;
        }

        const katexSpan = document.createElement('span');
        katexSpan.setAttribute(KATEX_RENDERED_ATTR, 'true');
        katexSpan.innerHTML = katexHtml;

        parent.insertBefore(katexSpan, startMarker);
        parent.removeChild(startMarker);

        nodesToRemove.forEach(node => {
            if (node.parentNode === parent) {
                parent.removeChild(node);
            } else {
                console.warn("[KaTeX Replace Marker] Node parent changed or node removed unexpectedly during collection, skipping removal:", node);
            }
        });

        appendToAnswer(null, katexSpan);
        katexBuffer = '';
        return true;

    } catch (error) {
        console.error("[KaTeX Replace Marker] General error during marker-based replacement:", error);
        try {
            const marker = currentAnswerElement?.querySelector(`span[data-katex-start-id="${markerId}"]`);
            if (marker?.parentNode) marker.parentNode.removeChild(marker);
        } catch (cleanupError) { console.error("Error during marker cleanup after general error:", cleanupError); }
        katexBuffer = '';
        return false;
    }
}

function finalizeTurnOnErrorOrClose() {
    console.log("[DEBUG] finalizeTurnOnErrorOrClose called.");
    if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK && currentCodeBlockElement) {
        console.warn("Stream ended unexpectedly inside code block. Finalizing highlight.");
        try { finalizeCodeBlock(true); } catch (e) { console.error("Prism highlight error on close:", e); }
    }
    if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE ||
        currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY ||
        currentProcessingMode === MODE_MAYBE_START_DISPLAY_KATEX) {
        console.warn("Stream ended unexpectedly inside KaTeX block. Processing raw text.");
        if (currentKatexMarkerId) {
            renderAndReplaceKatex(currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY, currentKatexMarkerId);
            currentKatexMarkerId = null;
        }
    }
     if (currentProcessingMode === MODE_INSIDE_THINK || currentProcessingMode === MODE_MAYBE_END_THINK || currentProcessingMode === MODE_SEEKING_TAG) {
         console.warn("Stream ended unexpectedly inside/seeking Think tags. Finishing think buffer:", thinkBuffer);
         if (currentThinkingArea && currentThinkingArea.style.display !== 'none' && currentThinkingPreElement) {
              appendRawTextToThinkingArea("\n--- (Stream ended unexpectedly during thinking) ---");
         }
     }

    formatAnswerBubbleFinal();
    resetStreamingState();
    setInputDisabledState(true);
}

// --- Code Block Functions ---

function createCodeBlockStructure(language) {
    if (!currentCodeBlocksArea) {
        console.error("Code blocks area is null!");
        return;
    }
    codeBlockCounterThisTurn++;
    const currentCodeNumber = codeBlockCounterThisTurn;
    const blockId = `code-block-turn${currentTurnId}-${currentCodeNumber}`;
    const safeLanguage = (language || '').trim().toLowerCase() || 'plain';

    const langAlias = {
        'python': 'python', 'py': 'python',
        'javascript': 'javascript', 'js': 'javascript',
        'html': 'markup', 'xml': 'markup', 'svg': 'markup',
        'css': 'css',
        'bash': 'bash', 'sh': 'bash', 'shell': 'bash',
        'json': 'json',
        'yaml': 'yaml', 'yml': 'yaml',
        'markdown': 'markdown', 'md': 'markdown',
        'sql': 'sql',
        'java': 'java',
        'c': 'c',
        'cpp': 'cpp', 'c++': 'cpp',
        'csharp': 'csharp', 'cs': 'csharp',
        'go': 'go',
        'rust': 'rust',
        'php': 'php',
        'ruby': 'ruby', 'rb': 'ruby',
        'dockerfile': 'docker', 'docker': 'docker',
        'typescript': 'typescript', 'ts': 'typescript',
        'plaintext': 'plain', 'text': 'plain',
       };
    const prismLang = langAlias[safeLanguage] || safeLanguage;
    const displayLang = safeLanguage;
    currentCodeBlockLang = prismLang; // Store the actual Prism language used

    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;

    const container = document.createElement('div');
    container.classList.add('code-block-container');
    container.id = blockId;
    container.dataset.language = safeLanguage;

    const codeHeader = document.createElement('div');
    codeHeader.classList.add('code-block-header');

    const codeButtonsDiv = document.createElement('div');
    codeButtonsDiv.classList.add('code-block-buttons');

    const runStopBtn = document.createElement('button');
    runStopBtn.classList.add('run-code-btn', 'code-action-btn');
    runStopBtn.dataset.status = 'idle';
    runStopBtn.innerHTML = playIconSvg;
    runStopBtn.title = 'Run Code';

    const toggleCodeBtn = document.createElement('button');
    toggleCodeBtn.classList.add('toggle-code-btn', 'code-action-btn');
    toggleCodeBtn.textContent = 'Hide';
    toggleCodeBtn.title = 'Show/Hide Code';

    const copyCodeBtn = document.createElement('button');
    copyCodeBtn.classList.add('copy-code-btn', 'code-action-btn');
    copyCodeBtn.textContent = 'Copy';
    copyCodeBtn.title = 'Copy Code';

    codeButtonsDiv.appendChild(runStopBtn);
    codeButtonsDiv.appendChild(toggleCodeBtn);
    codeButtonsDiv.appendChild(copyCodeBtn);

    const codeTitle = document.createElement('span');
    codeTitle.classList.add('code-block-title');
    codeTitle.textContent = `Code ${currentCodeNumber} (${displayLang})`;
    codeTitle.style.flexGrow = '1';
    codeTitle.style.textAlign = 'left';

    codeHeader.appendChild(codeButtonsDiv);
    codeHeader.appendChild(codeTitle);

    const preElement = document.createElement('pre');
    preElement.classList.add('manual'); // Keep manual class if needed for other styles
    const codeElement = document.createElement('code');
    // IMPORTANT: Set the class required by PrismJS
    codeElement.className = `language-${prismLang}`;
    codeElement.setAttribute('contenteditable', 'true');
    codeElement.setAttribute('spellcheck', 'false');

    currentCodeBlockPreElement = preElement;
    currentCodeBlockElement = codeElement;

    const outputHeader = document.createElement('div');
    outputHeader.classList.add('code-output-header');
    outputHeader.style.display = 'none';

    const outputButtonsDiv = document.createElement('div');
    outputButtonsDiv.classList.add('code-block-buttons');

    const placeholderSpan = document.createElement('span');
    placeholderSpan.classList.add('output-header-button-placeholder');
    outputButtonsDiv.appendChild(placeholderSpan);

    const toggleOutputBtn = document.createElement('button');
    toggleOutputBtn.classList.add('toggle-output-btn', 'code-action-btn');
    toggleOutputBtn.textContent = 'Hide';
    toggleOutputBtn.title = 'Show/Hide Output';

    const copyOutputBtn = document.createElement('button');
    copyOutputBtn.classList.add('copy-output-btn', 'code-action-btn');
    copyOutputBtn.textContent = 'Copy';
    copyOutputBtn.title = 'Copy Output';

    outputButtonsDiv.appendChild(toggleOutputBtn);
    outputButtonsDiv.appendChild(copyOutputBtn);

    const outputTitle = document.createElement('span');
    outputTitle.classList.add('output-header-title');
    outputTitle.textContent = `Output Code ${currentCodeNumber}`;

    const codeStatusSpan = document.createElement('span');
    codeStatusSpan.classList.add('code-status-span');
    codeStatusSpan.textContent = 'Idle';

    outputHeader.appendChild(outputButtonsDiv);
    outputHeader.appendChild(outputTitle);
    outputHeader.appendChild(codeStatusSpan);

    const outputConsoleDiv = document.createElement('div');
    outputConsoleDiv.classList.add('code-output-console');
    outputConsoleDiv.style.display = 'none';
    const outputPre = document.createElement('pre');
    outputConsoleDiv.appendChild(outputPre);

    preElement.appendChild(codeElement);
    container.appendChild(codeHeader);
    container.appendChild(preElement);
    container.appendChild(outputHeader);
    container.appendChild(outputConsoleDiv);

    toggleCodeBtn.addEventListener('click', () => {
        const isHidden = preElement.classList.toggle('hidden');
        toggleCodeBtn.textContent = isHidden ? 'Show' : 'Hide';
    });

    copyCodeBtn.addEventListener('click', async () => {
         if (!codeElement) return;
        try {
            await navigator.clipboard.writeText(codeElement.textContent || '');
            copyCodeBtn.textContent = 'Copied!';
            copyCodeBtn.classList.add('copied');
            setTimeout(() => { copyCodeBtn.textContent = 'Copy'; copyCodeBtn.classList.remove('copied'); }, 1500);
        } catch (err) {
            console.error('Failed to copy code: ', err);
            copyCodeBtn.textContent = 'Error';
            setTimeout(() => { copyCodeBtn.textContent = 'Copy'; }, 1500);
        }
    });

    runStopBtn.addEventListener('click', handleRunStopCodeClick);

    const debouncedHighlight = debounce(() => {
         // console.log(`Highlighting ${blockId} after edit.`);
        const savedPosition = getCursorPosition(codeElement);
        if (savedPosition === -1) { console.warn("Could not save cursor position or cursor not in element. Highlight may cause cursor jump."); }
        try {
            // Remove existing spans before re-highlighting
            // This is simpler than trying to replace nodes in place
            const currentText = codeElement.textContent;
            codeElement.innerHTML = ''; // Clear spans
            codeElement.textContent = currentText; // Restore text

            Prism.highlightElement(codeElement);
            if (savedPosition !== -1) { setCursorPosition(codeElement, savedPosition); }
        } catch (e) {
            console.error("Error during debounced highlighting:", e);
            if (savedPosition !== -1) { setCursorPosition(codeElement, savedPosition); }
        }
    }, 500);
    codeElement.addEventListener('input', debouncedHighlight);
    codeElement.addEventListener('paste', (e) => { setTimeout(debouncedHighlight, 100); });

    toggleOutputBtn.addEventListener('click', () => {
        const isHidden = outputConsoleDiv.classList.toggle('hidden');
        toggleOutputBtn.textContent = isHidden ? 'Show' : 'Hide';
    });

    copyOutputBtn.addEventListener('click', async () => {
        if (!outputPre) return;
        try {
            await navigator.clipboard.writeText(outputPre.textContent || '');
            copyOutputBtn.textContent = 'Copied!';
            copyOutputBtn.classList.add('copied');
            setTimeout(() => { copyOutputBtn.textContent = 'Copy'; copyOutputBtn.classList.remove('copied'); }, 1500);
        } catch (err) {
            console.error('Failed to copy output: ', err);
            copyOutputBtn.textContent = 'Error';
            setTimeout(() => { copyOutputBtn.textContent = 'Copy'; }, 1500);
        }
    });

    currentCodeBlocksArea.appendChild(container);
    lastAppendedNode = null;
}

async function handleRunStopCodeClick(event) {
    const button = event.currentTarget;
    const container = button.closest('.code-block-container');
    if (!container) return;

    const codeBlockId = container.id;
    const language = container.dataset.language;
    const codeElement = container.querySelector('code');
    const outputHeader = container.querySelector('.code-output-header');
    const outputConsoleDiv = container.querySelector('.code-output-console');
    const outputPre = outputConsoleDiv ? outputConsoleDiv.querySelector('pre') : null;
    const statusSpan = outputHeader ? outputHeader.querySelector('.code-status-span') : null;

    if (!language || !codeElement || !outputHeader || !outputConsoleDiv || !outputPre || !statusSpan) {
        console.error(`Missing elements for code block ${codeBlockId}`);
        addErrorMessage(`Cannot run code block ${codeBlockId}: Internal UI error.`);
        return;
    }

    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;
    const stopIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><rect width="100" height="100" rx="15"/></svg>`;
    const stoppingIconSvg = `<svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: block;"><path d="M12 2V6M12 18V22M6 12H2M22 12H18M19.0711 4.92893L16.2426 7.75736M7.75736 16.2426L4.92893 19.0711M19.0711 19.0711L16.2426 16.2426M7.75736 7.75736L4.92893 4.92893" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;

    const code = codeElement.textContent || '';
    const currentStatus = button.dataset.status;

    if (!websocket || websocket.readyState !== WebSocket.OPEN) {
        console.warn("WebSocket not open. Cannot run/stop code.");
        statusSpan.textContent = 'Error: Disconnected';
        statusSpan.className = 'code-status-span error';
        outputHeader.style.display = 'flex';
        addErrorMessage("Cannot run/stop code: Not connected to server.");
        return;
    }

    if (currentStatus === 'idle') {
        console.log(`Requesting run for block ${codeBlockId} (${language})`);
        button.dataset.status = 'running';
        button.innerHTML = stopIconSvg;
        button.title = 'Stop Execution';

        outputPre.innerHTML = '';
        outputHeader.style.display = 'flex';
        outputConsoleDiv.style.display = 'block';
        outputConsoleDiv.classList.remove('hidden');
        const toggleOutputBtn = outputHeader.querySelector('.toggle-output-btn');
        if (toggleOutputBtn) toggleOutputBtn.textContent = 'Hide';

        statusSpan.textContent = 'Running...';
        statusSpan.className = 'code-status-span running';

        websocket.send(JSON.stringify({
            type: 'run_code',
            payload: { code_block_id: codeBlockId, language: language, code: code }
        }));

    } else if (currentStatus === 'running') {
        console.log(`Requesting stop for block ${codeBlockId}`);
        button.dataset.status = 'stopping';
        button.innerHTML = stoppingIconSvg;
        button.title = 'Stopping...';
        button.disabled = true;

        statusSpan.textContent = 'Stopping...';
        statusSpan.className = 'code-status-span stopping';

        websocket.send(JSON.stringify({
            type: 'stop_code',
            payload: { code_block_id: codeBlockId }
        }));
    } else if (currentStatus === 'stopping') {
        console.log(`Already stopping block ${codeBlockId}`);
    }
}

function addCodeOutput(outputPreElement, streamType, text) {
    if (!outputPreElement || !text) return;

    const span = document.createElement('span');
    span.classList.add(streamType === 'stderr' ? 'stderr-output' : 'stdout-output');
    span.textContent = text;
    outputPreElement.appendChild(span);
    outputPreElement.scrollTop = outputPreElement.scrollHeight;
}

function appendToCodeBlock(text) {
    if (currentCodeBlockElement) {
        currentCodeBlockElement.appendChild(document.createTextNode(text));
        if(currentCodeBlockPreElement && !currentCodeBlockPreElement.classList.contains('hidden')) {
            const isNearCodeBottom = currentCodeBlockPreElement.scrollHeight - currentCodeBlockPreElement.scrollTop - currentCodeBlockPreElement.clientHeight < 50;
            if(isNearCodeBottom) {
                requestAnimationFrame(() => { currentCodeBlockPreElement.scrollTop = currentCodeBlockPreElement.scrollHeight; });
            }
        }
    } else {
        console.error("Attempted to append to null code block element!");
    }
}

function appendToAnswer(text = null, node = null) {
    if (!currentAnswerElement) return;

    let isMeaningfulContent = (text && text.trim().length > 0) ||
                                (node && node.nodeType !== Node.COMMENT_NODE && (!node.textContent || node.textContent.trim().length > 0));

    if (!firstAnswerTokenReceived && isMeaningfulContent) {
        // console.log("[appendToAnswer] First meaningful answer content received.");
        if (currentAnswerElement.style.display === 'none') {
            // console.log("[appendToAnswer] Making answer element visible.");
            currentAnswerElement.style.display = '';
        }
        const loadingDots = currentAnswerElement.querySelector('.loading-dots');
        if (loadingDots) {
            // console.log("[appendToAnswer] Removing loading dots.");
            loadingDots.remove();
        }
        firstAnswerTokenReceived = true;
    }

    if (node) {
        if (!node.classList || !node.classList.contains('loading-dots')) {
             currentAnswerElement.appendChild(node);
             lastAppendedNode = node;
        }
    } else if (text !== null && text.length > 0) {
        accumulatedAnswerText += text;
        if (lastAppendedNode && lastAppendedNode.nodeType === Node.TEXT_NODE && lastAppendedNode.parentNode === currentAnswerElement) {
            lastAppendedNode.nodeValue += text;
        } else {
            const textNode = document.createTextNode(text);
            currentAnswerElement.appendChild(textNode);
            lastAppendedNode = textNode;
        }
    }
}

function finalizeCodeBlock(isTruncated = false) {
    if (currentCodeBlockElement) {
        const blockId = currentCodeBlockElement.closest('.code-block-container')?.id;
        const langClass = currentCodeBlockElement.className; // Get the class name

        // --- Add these detailed logs ---
        console.log(`[finalizeCodeBlock] Attempting highlight on element:`, currentCodeBlockElement);
        console.log(`[finalizeCodeBlock] Element class: ${langClass}`);
        console.log(`[finalizeCodeBlock] Prism.languages.python just before highlight:`, Prism.languages.python);
        // -------------------------------

        try {
            // Ensure normalization before final highlight
            currentCodeBlockElement.normalize();
            // Explicitly call highlightElement
            Prism.highlightElement(currentCodeBlockElement);
            console.log(`[finalizeCodeBlock] Highlighting finished successfully for ${blockId}.`); // Log success
        } catch (e) {
            // Log errors specifically from Prism.highlightElement
            console.error(`Prism highlight error on finalize (lang '${currentCodeBlockLang}'):`, e);
        }
    } else {
         console.warn("[finalizeCodeBlock] Called but currentCodeBlockElement is null.");
    }
    // Reset tracking variables AFTER the block logic
    currentCodeBlockElement = null;
    currentCodeBlockPreElement = null;
    currentCodeBlockLang = '';
}


function resetAllCodeButtonsOnErrorOrClose() {
    console.log("Resetting all code run/stop buttons and statuses due to connection issue.");
    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;

    document.querySelectorAll('.code-block-container').forEach(container => {
        const button = container.querySelector('.run-code-btn');
        const outputHeader = container.querySelector('.code-output-header');
        const statusSpan = outputHeader ? outputHeader.querySelector('.code-status-span') : null;

        if (button && button.dataset.status !== 'idle') {
            button.dataset.status = 'idle';
            button.innerHTML = playIconSvg;
            button.title = 'Run Code';
            button.disabled = false;
        }
        if (statusSpan) {
             if (!statusSpan.classList.contains('idle') && !statusSpan.classList.contains('success')) {
                 if (outputHeader) outputHeader.style.display = 'flex';
                 statusSpan.textContent = 'Error: Disconnected';
                 statusSpan.className = 'code-status-span error';
             }
        }
    });
}

// --- WebSocket Handling ---

function connectWebSocket() {

    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${window.location.host}/ws/${clientId}`;
    console.log(`[DEBUG] Attempting to connect to WebSocket: ${wsUrl}`);

    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;

    try {
        const ws = new WebSocket(wsUrl);
        console.log('connectWebSocket: Creating WebSocket object...');

        ws.onopen = (event) => {
            console.log("[DEBUG] WebSocket connection opened. ws object:", ws);
            websocket = ws;

            if (typeof addSystemMessage !== 'function' || typeof setupNewAiTurn !== 'function' || typeof appendToAnswer !== 'function' || typeof formatAnswerBubbleFinal !== 'function' || typeof resetStreamingState !== 'function' || typeof setInputDisabledState !== 'function') {
                console.error("CRITICAL ERROR: One or more required helper functions are not defined when ws.onopen is called. Check script order.");
                alert("Chat initialization failed. Please refresh the page. (Error: Helpers undefined)");
                setInputDisabledState(true);
                return;
            }

            setInputDisabledState(false);
            addSystemMessage("Connected to the chat server.");

            console.log("[DEBUG ws.onopen] Setting up initial AI turn for welcome message.");
            thinkingRequestedForCurrentTurn = false;
            setupNewAiTurn();
            const welcomeMessage = "Hello! How can I help you today?";
            appendToAnswer(welcomeMessage);
            formatAnswerBubbleFinal();
            console.log("[DEBUG ws.onopen] Resetting state after welcome message.");
            resetStreamingState();

            if(messageInput && messageInput.offsetParent !== null) messageInput.focus();
        };

        ws.onmessage = (event) => {
            let isJsonMessage = false;
            let messageData = null;
            try {
                if (typeof event.data === 'string' && event.data.startsWith('{')) {
                    messageData = JSON.parse(event.data);
                    if (messageData && messageData.type && messageData.payload && messageData.payload.code_block_id) {
                        isJsonMessage = true;
                    }
                }
            } catch (e) {
                isJsonMessage = false;
            }

            if (isJsonMessage) {
                // console.log("%c[ws.onmessage] Code Execution JSON received:", "color: blue;", messageData);
                const { type, payload } = messageData;
                const { code_block_id } = payload;
                const container = document.getElementById(code_block_id);

                if (!container) {
                    console.warn(`Received message for unknown code block ID: ${code_block_id}`, payload);
                    return;
                }

                const outputHeader = container.querySelector('.code-output-header');
                const outputConsoleDiv = container.querySelector('.code-output-console');
                const outputPre = outputConsoleDiv ? outputConsoleDiv.querySelector('pre') : null;
                const runStopBtn = container.querySelector('.run-code-btn');
                const statusSpan = outputHeader ? outputHeader.querySelector('.code-status-span') : null;

                if (!outputHeader || !outputPre || !runStopBtn || !statusSpan) {
                     console.error(`Missing elements for code block ${code_block_id}. Cannot process message.`);
                     return;
                }

                switch (type) {
                    case 'code_output':
                        const { stream, data } = payload;
                        if (outputHeader.style.display === 'none') {
                            // console.log(`Showing output header for ${code_block_id} on first output.`);
                            outputHeader.style.display = 'flex';
                        }
                        if (outputConsoleDiv.style.display === 'none') {
                            // console.log(`Showing output console for ${code_block_id} on first output.`);
                            outputConsoleDiv.style.display = 'block';
                            outputConsoleDiv.classList.remove('hidden');
                             const toggleOutputBtn = outputHeader.querySelector('.toggle-output-btn');
                             if (toggleOutputBtn) toggleOutputBtn.textContent = 'Hide';
                        }
                        if (runStopBtn.dataset.status === 'idle'){
                             const stopIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><rect width="100" height="100" rx="15"/></svg>`;
                             console.warn(`Received code output for ${code_block_id} while button was idle. Forcing state to running.`);
                             runStopBtn.dataset.status = 'running';
                             runStopBtn.innerHTML = stopIconSvg;
                             runStopBtn.title = 'Stop Execution';
                             runStopBtn.disabled = false;
                             statusSpan.textContent = 'Running...';
                             statusSpan.className = 'code-status-span running';
                        }
                        addCodeOutput(outputPre, stream, data);
                        break;

                    case 'code_finished':
                        if (outputHeader.style.display === 'none') {
                            // console.log(`Showing output header for ${code_block_id} on finish.`);
                            outputHeader.style.display = 'flex';
                        }
                         if (outputConsoleDiv.style.display === 'none') {
                            // console.log(`Showing output console for ${code_block_id} on finish.`);
                            outputConsoleDiv.style.display = 'block';
                            outputConsoleDiv.classList.remove('hidden');
                              const toggleOutputBtn = outputHeader.querySelector('.toggle-output-btn');
                             if (toggleOutputBtn) toggleOutputBtn.textContent = 'Hide';
                        }

                        const { exit_code, error } = payload;
                        let finishMessage = '';
                        let statusClass = '';

                        if (error) {
                            if (error === "Execution stopped by user.") {
                                finishMessage = 'Stopped'; statusClass = 'stopped';
                            } else if (error.startsWith("Execution timed out")) {
                                 finishMessage = 'Timeout'; statusClass = 'error';
                            } else {
                                 finishMessage = `Error (${exit_code !== undefined ? exit_code : 'N/A'})`; statusClass = 'error';
                                 console.error(`Execution error for ${code_block_id}:`, error);
                            }
                        } else {
                            finishMessage = `Finished (Exit: ${exit_code})`;
                            statusClass = exit_code === 0 ? 'success' : 'error';
                        }

                        statusSpan.textContent = finishMessage;
                        statusSpan.className = `code-status-span ${statusClass}`;

                        runStopBtn.dataset.status = 'idle';
                        runStopBtn.innerHTML = playIconSvg;
                        runStopBtn.title = 'Run Code';
                        runStopBtn.disabled = false;
                        break;

                    default:
                        console.warn(`Received unknown code execution message type: ${type}`, payload);
                }

            } else {
                // console.log("%c[ws.onmessage] RAW chat data received:", "color: magenta;", event.data);
                let chunk = event.data;
                const currentTurnIdForMsg = currentTurnId;

                if (chunk === "<EOS>") {
                    console.log(`%c[ws.onmessage] Turn ${currentTurnIdForMsg}: Received <EOS>. Finalizing turn.`, 'color: green; font-weight: bold;');
                    if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK) {
                         console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received inside code block. Appending fence buffer and finalizing.`);
                         if (fenceBuffer.length > 0) appendToCodeBlock(fenceBuffer);
                         try { finalizeCodeBlock(true); } catch (e) { console.error("Error finalizing code block on EOS:", e); }
                    } else if (currentProcessingMode === MODE_SEEKING_CODE_END_FENCE) {
                         console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received while seeking end fence. Treating '${fenceBuffer}' as code.`);
                         appendToCodeBlock(fenceBuffer);
                         finalizeCodeBlock(true);
                    } else if (currentProcessingMode === MODE_SEEKING_CODE_LANGUAGE && langBuffer.length > 0) {
                         console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received while seeking language. Treating '${FENCE + langBuffer}' as text.`);
                         appendToAnswer(FENCE + langBuffer);
                    } else if (currentProcessingMode === MODE_SEEKING_CODE_START_FENCE && fenceBuffer.length > 0) {
                         console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received while seeking start fence. Treating '${fenceBuffer}' as text.`);
                         appendToAnswer(fenceBuffer);
                    } else if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE || currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY) {
                         console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received inside KaTeX buffer. Attempting render.`);
                         if (currentKatexMarkerId) { renderAndReplaceKatex(currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY, currentKatexMarkerId); currentKatexMarkerId = null; }
                    } else if (currentProcessingMode === MODE_INSIDE_THINK || currentProcessingMode === MODE_MAYBE_END_THINK || currentProcessingMode === MODE_SEEKING_TAG) {
                          console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly inside/seeking Think tags. Last mode: ${currentProcessingMode}`);
                          if (thinkingRequestedForCurrentTurn && currentThinkingArea && currentThinkingPreElement) { appendRawTextToThinkingArea("\n--- (EOS received mid-think) ---"); }
                    }

                    formatAnswerBubbleFinal();
                    resetStreamingState();
                    setInputDisabledState(false);
                    if (messageInput && messageInput.offsetParent !== null) { messageInput.focus(); }
                    setTimeout(() => scrollToBottom('smooth'), 50);
                    return;
                }
                if (chunk.startsWith("<ERROR>")) {
                    const errorMessage = chunk.substring(7);
                    console.error(`[ws.onmessage] Turn ${currentTurnIdForMsg}: Received <ERROR>:`, errorMessage);
                    addErrorMessage(errorMessage);
                    finalizeTurnOnErrorOrClose();
                    resetAllCodeButtonsOnErrorOrClose();
                    setTimeout(() => scrollToBottom('smooth'), 50);
                    return;
                }

                if (chunk.length === 0) {
                     return;
                }

                if (!currentAiTurnContainer) {
                    if (chunk.trim().length > 0) {
                        console.warn(`%c[ws.onmessage] Turn ${currentTurnIdForMsg}: First non-empty chat chunk received, but turn container not set up? Forcing setup.`, 'color: red; font-weight: bold;');
                        setupNewAiTurn();
                    } else {
                        return;
                    }
                }

                let currentPos = 0;
                while (currentPos < chunk.length) {
                    const char = chunk[currentPos];
                    let incrementPos = true;
                    let previousMode = currentProcessingMode;

                    if (char === '\\' && currentPos + 1 < chunk.length) {
                        const nextChar = chunk[currentPos + 1];
                        const escapableChars = '$`*\\<>';
                        if (escapableChars.includes(nextChar)) {
                            if (currentProcessingMode === MODE_INSIDE_THINK) { appendRawTextToThinkingArea(nextChar); }
                            else if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE || currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY) { katexBuffer += nextChar; appendToAnswer(nextChar); }
                            else if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK) { appendToCodeBlock(nextChar); }
                            else { appendToAnswer(nextChar); }
                            currentPos += 2;
                            incrementPos = false;
                            continue;
                        }
                    }

                    switch (currentProcessingMode) {

                        case MODE_ANSWER:
                            if (char === FENCE[0]) {
                                if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                katexBuffer = ''; currentKatexMarkerId = null;
                                fenceBuffer = char;
                                currentProcessingMode = MODE_SEEKING_CODE_START_FENCE;
                            } else if (char === '$') {
                                if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                currentProcessingMode = MODE_MAYBE_START_DISPLAY_KATEX;
                            } else if (char === '<') {
                                 if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                tagBuffer = char;
                                currentProcessingMode = MODE_SEEKING_TAG;
                            } else {
                                if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                appendToAnswer(char);
                            }
                            break;

                        case MODE_SEEKING_CODE_START_FENCE:
                            if (char === FENCE[fenceBuffer.length]) {
                                fenceBuffer += char;
                                if (fenceBuffer === FENCE) {
                                    fenceBuffer = ''; langBuffer = '';
                                    currentProcessingMode = MODE_SEEKING_CODE_LANGUAGE;
                                }
                            } else {
                                appendToAnswer(fenceBuffer);
                                fenceBuffer = '';
                                currentProcessingMode = MODE_ANSWER;
                                incrementPos = false;
                            }
                            break;

                        case MODE_SEEKING_CODE_LANGUAGE:
                             if (char === '\n') {
                                 currentCodeBlockLang = langBuffer.trim(); // Language name stored here
                                 createCodeBlockStructure(currentCodeBlockLang); // Pass language name
                                 appendCodeReference();
                                 langBuffer = '';
                                 currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                             } else if (langBuffer.length > 50) {
                                 console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: Code language line too long. Treating as text.`);
                                 appendToAnswer(FENCE + langBuffer + char);
                                 langBuffer = ''; fenceBuffer = '';
                                 currentProcessingMode = MODE_ANSWER;
                             } else {
                                 langBuffer += char;
                             }
                             break;

                        case MODE_INSIDE_CODE_BLOCK:
                            if (char === FENCE[0]) {
                                fenceBuffer = char;
                                currentProcessingMode = MODE_SEEKING_CODE_END_FENCE;
                            } else {
                                appendToCodeBlock(char);
                            }
                            break;

                        case MODE_SEEKING_CODE_END_FENCE:
                            if (char === FENCE[fenceBuffer.length]) {
                                fenceBuffer += char;
                                if (fenceBuffer === FENCE) {
                                    finalizeCodeBlock(); // Call finalize here
                                    fenceBuffer = '';
                                    currentProcessingMode = MODE_ANSWER;
                                    lastAppendedNode = null;
                                    if (currentPos + 1 < chunk.length && chunk[currentPos + 1] === '\n') {
                                        currentPos++;
                                        incrementPos = true; // Ensure newline is skipped
                                    }
                                }
                            } else {
                                appendToCodeBlock(fenceBuffer); // Append incomplete fence as code
                                fenceBuffer = '';
                                currentProcessingMode = MODE_INSIDE_CODE_BLOCK; // Go back to code mode
                                incrementPos = false; // Re-process current char in code mode
                            }
                            break;

                        case MODE_MAYBE_START_DISPLAY_KATEX:
                            if (char === '$') {
                                currentKatexMarkerId = `katex-marker-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
                                const startMarkerDisp = document.createElement('span');
                                startMarkerDisp.setAttribute('data-katex-start-id', currentKatexMarkerId);
                                startMarkerDisp.style.display = 'none';
                                appendToAnswer(null, startMarkerDisp);
                                appendToAnswer('$$');
                                currentProcessingMode = MODE_KATEX_BUFFERING_DISPLAY;
                                katexBuffer = '';
                            } else {
                                currentKatexMarkerId = `katex-marker-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
                                const startMarkerInline = document.createElement('span');
                                startMarkerInline.setAttribute('data-katex-start-id', currentKatexMarkerId);
                                startMarkerInline.style.display = 'none';
                                appendToAnswer(null, startMarkerInline);
                                appendToAnswer('$');
                                appendToAnswer(char);
                                currentProcessingMode = MODE_KATEX_BUFFERING_INLINE;
                                katexBuffer = char;
                            }
                            break;

                        case MODE_KATEX_BUFFERING_INLINE:
                            if (char === '$') {
                                appendToAnswer('$');
                                if (currentKatexMarkerId) { renderAndReplaceKatex(false, currentKatexMarkerId); currentKatexMarkerId = null; }
                                else { console.error(`Attempted end inline KaTeX Turn ${currentTurnIdForMsg} no marker ID!`); }
                                currentProcessingMode = MODE_ANSWER;
                            } else { katexBuffer += char; appendToAnswer(char); }
                            break;

                        case MODE_KATEX_BUFFERING_DISPLAY:
                             if (char === '$' && currentPos + 1 < chunk.length && chunk[currentPos + 1] === '$') {
                                 appendToAnswer('$$');
                                 if (currentKatexMarkerId) { renderAndReplaceKatex(true, currentKatexMarkerId); currentKatexMarkerId = null; }
                                 else { console.error(`Attempted end display KaTeX Turn ${currentTurnIdForMsg} no marker ID!`); }
                                 currentProcessingMode = MODE_ANSWER; currentPos++;
                             } else { katexBuffer += char; appendToAnswer(char); }
                             break;

                        case MODE_SEEKING_TAG:
                            tagBuffer += char;
                            const lowerTag = tagBuffer.toLowerCase();
                            if (lowerTag === THINK_START_TAG) {
                                thinkBuffer = ''; currentProcessingMode = MODE_INSIDE_THINK; tagBuffer = ''; lastAppendedNode = null;
                            } else if (THINK_START_TAG.startsWith(lowerTag)) { /* Keep buffering */ }
                            else {
                                appendToAnswer(tagBuffer); currentProcessingMode = MODE_ANSWER; tagBuffer = ''; incrementPos = false;
                            }
                            if (tagBuffer.length > 20) {
                                 console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: Tag buffer excessive, treating as text: ${tagBuffer}`);
                                 appendToAnswer(tagBuffer); currentProcessingMode = MODE_ANSWER; tagBuffer = ''; incrementPos = false;
                            }
                            break;

                         case MODE_INSIDE_THINK:
                              if (char === '<') {
                                  tagBuffer = char; currentProcessingMode = MODE_MAYBE_END_THINK;
                              } else { appendRawTextToThinkingArea(char); }
                              break;

                         case MODE_MAYBE_END_THINK:
                              tagBuffer += char;
                              const lowerEndTag = tagBuffer.toLowerCase();
                              if (lowerEndTag === THINK_END_TAG) {
                                  thinkBuffer = ''; tagBuffer = ''; currentProcessingMode = MODE_ANSWER; lastAppendedNode = null;
                              } else if (THINK_END_TAG.startsWith(lowerEndTag)) { /* Keep buffering */ }
                              else {
                                  appendRawTextToThinkingArea(tagBuffer);
                                  currentProcessingMode = MODE_INSIDE_THINK; tagBuffer = ''; incrementPos = false;
                              }
                              if (tagBuffer.length > 20) {
                                   console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: End tag buffer excessive, treating as think text: ${tagBuffer}`);
                                   appendRawTextToThinkingArea(tagBuffer); currentProcessingMode = MODE_INSIDE_THINK; tagBuffer = ''; incrementPos = false;
                              }
                              break;

                        default:
                            console.error(`Unknown processing mode: ${currentProcessingMode} in Turn ${currentTurnIdForMsg}`);
                            appendToAnswer(char);
                            currentProcessingMode = MODE_ANSWER;
                    }

                    if (incrementPos) { currentPos++; }
                }
                scrollToBottom();
            }
        };

        ws.onerror = (event) => {
            console.error("WebSocket error observed:", event);
            addErrorMessage("WebSocket connection error. Please check the server or try refreshing. See console for details.");
            finalizeTurnOnErrorOrClose();
            resetAllCodeButtonsOnErrorOrClose();
            setInputDisabledState(true);
        };

        ws.onclose = (event) => {
            console.log("WebSocket connection closed.", event);
            addSystemMessage(`Connection closed: ${event.reason || 'Normal closure'} (Code: ${event.code})`);
            finalizeTurnOnErrorOrClose();
            resetAllCodeButtonsOnErrorOrClose();
            if (event.code !== 1000 && event.code !== 1005) {
                console.log("Unexpected WebSocket closure. Attempting to reconnect WebSocket in 3 seconds...");
                addSystemMessage("Attempting to reconnect...");
                setInputDisabledState(true);
                setTimeout(() => { websocket = null; resetStreamingState(); currentAiTurnContainer = null; connectWebSocket(); }, 3000);
            } else { setInputDisabledState(true); }
        };

        console.log("[DEBUG] WebSocket object created and handlers assigned.");

     } catch (error) {
         console.error("[DEBUG] CRITICAL Error creating WebSocket object:", error);
         if (typeof addErrorMessage === 'function') { addErrorMessage(`WebSocket Creation Error: ${error.message}. Please check server and refresh.`); }
         else { alert(`WebSocket Creation Error: ${error.message}. Please check server and refresh.`); }
         setInputDisabledState(true);
     }
}

// --- Event Listeners & Initialization ---

if (chatForm) {
    chatForm.addEventListener('submit', (event) => {
        event.preventDefault();
        const userMessage = messageInput.value.trim();
        if (!userMessage) { return; }

        if (!websocket || websocket.readyState !== WebSocket.OPEN) {
            console.warn("[Submit] WebSocket not ready or not defined. State:", websocket?.readyState);
            addErrorMessage("Not connected to the server. Please wait or refresh.");
            return;
        }

        try {
            addUserMessage(userMessage);
            thinkingRequestedForCurrentTurn = thinkCheckbox ? thinkCheckbox.checked : false;
            // console.log(`[Submit] Checkbox checked: ${thinkingRequestedForCurrentTurn}.`);

            let messageToSend = userMessage;
            if (!thinkingRequestedForCurrentTurn) {
                messageToSend = NO_THINK_PREFIX + userMessage;
                // console.log(`[Submit] Prepended '${NO_THINK_PREFIX}'. Prepared message: "${messageToSend.substring(0, 100)}..."`);
            } else {
                // console.log(`[Submit] Prepared raw message (thinking requested): "${messageToSend.substring(0, 100)}..."`);
            }

            setupNewAiTurn();
            // console.log(`[Submit] Sending final message to WebSocket: "${messageToSend.substring(0, 100)}..."`);
            websocket.send(messageToSend);
            // console.log("[Submit] websocket.send() call completed.");

            messageInput.value = '';
            setInputDisabledState(true);
            // console.log("[Submit] Input cleared and disabled.");

        } catch (sendError) {
            console.error("[Submit] !!! ERROR during send attempt or post-send steps:", sendError);
            addErrorMessage(`Failed to send message: ${sendError.message}`);
        }
    });
} else {
    console.error("CRITICAL ERROR: Could not find chat form element with ID 'chat-form'. Messages cannot be sent.");
    if (typeof addErrorMessage === 'function') {
        addErrorMessage("Initialization Error: Chat input form not found.");
    } else {
        alert("Initialization Error: Chat input form not found.");
    }
}

// --- Initial Setup ---
setInputDisabledState(true); // Disable input until WebSocket connects
marked.setOptions({
  gfm: true, breaks: true, sanitize: false, smartLists: true, smartypants: false,
});
connectWebSocket(); // Start WebSocket connection


=== app/static/assets/css/katex.min.css ===
--- CONTENT EXCLUDED (listed in exclude_files) ---


=== app/static/assets/css/prism-tomorrow.min.css ===
code[class*=language-],pre[class*=language-]{color:#ccc;background:0 0;font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#2d2d2d}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.block-comment,.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#999}.token.punctuation{color:#ccc}.token.attr-name,.token.deleted,.token.namespace,.token.tag{color:#e2777a}.token.function-name{color:#6196cc}.token.boolean,.token.function,.token.number{color:#f08d49}.token.class-name,.token.constant,.token.property,.token.symbol{color:#f8c555}.token.atrule,.token.builtin,.token.important,.token.keyword,.token.selector{color:#cc99cd}.token.attr-value,.token.char,.token.regex,.token.string,.token.variable{color:#7ec699}.token.entity,.token.operator,.token.url{color:#67cdcc}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.token.inserted{color:green}

=== app/static/dist/input.css ===
/* node_modules/prismjs/themes/prism-tomorrow.css */
code[class*=language-],
pre[class*=language-] {
  color: #ccc;
  background: none;
  font-family:
    Consolas,
    Monaco,
    "Andale Mono",
    "Ubuntu Mono",
    monospace;
  font-size: 1em;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.5;
  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;
  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}
pre[class*=language-] {
  padding: 1em;
  margin: .5em 0;
  overflow: auto;
}
:not(pre) > code[class*=language-],
pre[class*=language-] {
  background: #2d2d2d;
}
:not(pre) > code[class*=language-] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
}
.token.comment,
.token.block-comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: #999;
}
.token.punctuation {
  color: #ccc;
}
.token.tag,
.token.attr-name,
.token.namespace,
.token.deleted {
  color: #e2777a;
}
.token.function-name {
  color: #6196cc;
}
.token.boolean,
.token.number,
.token.function {
  color: #f08d49;
}
.token.property,
.token.class-name,
.token.constant,
.token.symbol {
  color: #f8c555;
}
.token.selector,
.token.important,
.token.atrule,
.token.keyword,
.token.builtin {
  color: #cc99cd;
}
.token.string,
.token.char,
.token.attr-value,
.token.regex,
.token.variable {
  color: #7ec699;
}
.token.operator,
.token.entity,
.token.url {
  color: #67cdcc;
}
.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}
.token.entity {
  cursor: help;
}
.token.inserted {
  color: green;
}

/* node_modules/katex/dist/katex.min.css */
@font-face {
  font-family: KaTeX_AMS;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_AMS-Regular-U6PRYMIZ.woff2") format("woff2"),
    url("./assets/KaTeX_AMS-Regular-CYEKBG2K.woff") format("woff"),
    url("./assets/KaTeX_AMS-Regular-JKX5W2C4.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Caligraphic;
  font-style: normal;
  font-weight: 700;
  src:
    url("./assets/KaTeX_Caligraphic-Bold-5QL5CMTE.woff2") format("woff2"),
    url("./assets/KaTeX_Caligraphic-Bold-WZ3QSGD3.woff") format("woff"),
    url("./assets/KaTeX_Caligraphic-Bold-ZTS3R3HK.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Caligraphic;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Caligraphic-Regular-KX5MEWCF.woff2") format("woff2"),
    url("./assets/KaTeX_Caligraphic-Regular-3LKEU76G.woff") format("woff"),
    url("./assets/KaTeX_Caligraphic-Regular-A7XRTZ5Q.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Fraktur;
  font-style: normal;
  font-weight: 700;
  src:
    url("./assets/KaTeX_Fraktur-Bold-2QVFK6NQ.woff2") format("woff2"),
    url("./assets/KaTeX_Fraktur-Bold-T4SWXBMT.woff") format("woff"),
    url("./assets/KaTeX_Fraktur-Bold-WGHVTYOR.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Fraktur;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Fraktur-Regular-2PEIFJSJ.woff2") format("woff2"),
    url("./assets/KaTeX_Fraktur-Regular-PQMHCIK6.woff") format("woff"),
    url("./assets/KaTeX_Fraktur-Regular-5U4OPH2X.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Main;
  font-style: normal;
  font-weight: 700;
  src:
    url("./assets/KaTeX_Main-Bold-YP5VVQRP.woff2") format("woff2"),
    url("./assets/KaTeX_Main-Bold-2GA4IZIN.woff") format("woff"),
    url("./assets/KaTeX_Main-Bold-W5FBVCZM.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Main;
  font-style: italic;
  font-weight: 700;
  src:
    url("./assets/KaTeX_Main-BoldItalic-N4V3DX7S.woff2") format("woff2"),
    url("./assets/KaTeX_Main-BoldItalic-4P4C7HJH.woff") format("woff"),
    url("./assets/KaTeX_Main-BoldItalic-ODMLBJJQ.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Main;
  font-style: italic;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Main-Italic-RELBIK7M.woff2") format("woff2"),
    url("./assets/KaTeX_Main-Italic-SASNQFN2.woff") format("woff"),
    url("./assets/KaTeX_Main-Italic-I43T2HSR.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Main;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Main-Regular-ARRPAO67.woff2") format("woff2"),
    url("./assets/KaTeX_Main-Regular-P5I74A2A.woff") format("woff"),
    url("./assets/KaTeX_Main-Regular-W74P5G27.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Math;
  font-style: italic;
  font-weight: 700;
  src:
    url("./assets/KaTeX_Math-BoldItalic-K4WTGH3J.woff2") format("woff2"),
    url("./assets/KaTeX_Math-BoldItalic-6EBV3DK5.woff") format("woff"),
    url("./assets/KaTeX_Math-BoldItalic-VB447A4D.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Math;
  font-style: italic;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Math-Italic-6KGCHLFN.woff2") format("woff2"),
    url("./assets/KaTeX_Math-Italic-KKK3USB2.woff") format("woff"),
    url("./assets/KaTeX_Math-Italic-SON4MRCA.ttf") format("truetype");
}
@font-face {
  font-family: "KaTeX_SansSerif";
  font-style: normal;
  font-weight: 700;
  src:
    url("./assets/KaTeX_SansSerif-Bold-RRNVJFFW.woff2") format("woff2"),
    url("./assets/KaTeX_SansSerif-Bold-X5M5EMOD.woff") format("woff"),
    url("./assets/KaTeX_SansSerif-Bold-STQ6RXC7.ttf") format("truetype");
}
@font-face {
  font-family: "KaTeX_SansSerif";
  font-style: italic;
  font-weight: 400;
  src:
    url("./assets/KaTeX_SansSerif-Italic-HMPFTM52.woff2") format("woff2"),
    url("./assets/KaTeX_SansSerif-Italic-PSN4QKYX.woff") format("woff"),
    url("./assets/KaTeX_SansSerif-Italic-WTBAZBGY.ttf") format("truetype");
}
@font-face {
  font-family: "KaTeX_SansSerif";
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_SansSerif-Regular-XIQ62X4E.woff2") format("woff2"),
    url("./assets/KaTeX_SansSerif-Regular-OQCII6EP.woff") format("woff"),
    url("./assets/KaTeX_SansSerif-Regular-2TL3USAE.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Script;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Script-Regular-APUWIHLP.woff2") format("woff2"),
    url("./assets/KaTeX_Script-Regular-A5IFOEBS.woff") format("woff"),
    url("./assets/KaTeX_Script-Regular-72OLXYNA.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Size1;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Size1-Regular-5LRUTBFT.woff2") format("woff2"),
    url("./assets/KaTeX_Size1-Regular-4HRHTS65.woff") format("woff"),
    url("./assets/KaTeX_Size1-Regular-7K6AASVL.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Size2;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Size2-Regular-LELKET5D.woff2") format("woff2"),
    url("./assets/KaTeX_Size2-Regular-K5ZHAIS6.woff") format("woff"),
    url("./assets/KaTeX_Size2-Regular-222HN3GT.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Size3;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Size3-Regular-WQRQ47UD.woff2") format("woff2"),
    url("./assets/KaTeX_Size3-Regular-TLFPAHDE.woff") format("woff"),
    url("./assets/KaTeX_Size3-Regular-UFCO6WCA.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Size4;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Size4-Regular-CDMV7U5C.woff2") format("woff2"),
    url("./assets/KaTeX_Size4-Regular-PKMWZHNC.woff") format("woff"),
    url("./assets/KaTeX_Size4-Regular-7PGNVPQK.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Typewriter;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Typewriter-Regular-VBYJ4NRC.woff2") format("woff2"),
    url("./assets/KaTeX_Typewriter-Regular-MJMFSK64.woff") format("woff"),
    url("./assets/KaTeX_Typewriter-Regular-3F5K6SQ6.ttf") format("truetype");
}
.katex {
  font:
    normal 1.21em KaTeX_Main,
    Times New Roman,
    serif;
  line-height: 1.2;
  text-indent: 0;
  text-rendering: auto;
}
.katex * {
  -ms-high-contrast-adjust: none !important;
  border-color: currentColor;
}
.katex .katex-version:after {
  content: "0.16.22";
}
.katex .katex-mathml {
  clip: rect(1px, 1px, 1px, 1px);
  border: 0;
  height: 1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
}
.katex .katex-html > .newline {
  display: block;
}
.katex .base {
  position: relative;
  white-space: nowrap;
  width: -webkit-min-content;
  width: -moz-min-content;
  width: min-content;
}
.katex .base,
.katex .strut {
  display: inline-block;
}
.katex .textbf {
  font-weight: 700;
}
.katex .textit {
  font-style: italic;
}
.katex .textrm {
  font-family: KaTeX_Main;
}
.katex .textsf {
  font-family: KaTeX_SansSerif;
}
.katex .texttt {
  font-family: KaTeX_Typewriter;
}
.katex .mathnormal {
  font-family: KaTeX_Math;
  font-style: italic;
}
.katex .mathit {
  font-family: KaTeX_Main;
  font-style: italic;
}
.katex .mathrm {
  font-style: normal;
}
.katex .mathbf {
  font-family: KaTeX_Main;
  font-weight: 700;
}
.katex .boldsymbol {
  font-family: KaTeX_Math;
  font-style: italic;
  font-weight: 700;
}
.katex .amsrm,
.katex .mathbb,
.katex .textbb {
  font-family: KaTeX_AMS;
}
.katex .mathcal {
  font-family: KaTeX_Caligraphic;
}
.katex .mathfrak,
.katex .textfrak {
  font-family: KaTeX_Fraktur;
}
.katex .mathboldfrak,
.katex .textboldfrak {
  font-family: KaTeX_Fraktur;
  font-weight: 700;
}
.katex .mathtt {
  font-family: KaTeX_Typewriter;
}
.katex .mathscr,
.katex .textscr {
  font-family: KaTeX_Script;
}
.katex .mathsf,
.katex .textsf {
  font-family: KaTeX_SansSerif;
}
.katex .mathboldsf,
.katex .textboldsf {
  font-family: KaTeX_SansSerif;
  font-weight: 700;
}
.katex .mathitsf,
.katex .mathsfit,
.katex .textitsf {
  font-family: KaTeX_SansSerif;
  font-style: italic;
}
.katex .mainrm {
  font-family: KaTeX_Main;
  font-style: normal;
}
.katex .vlist-t {
  border-collapse: collapse;
  display: inline-table;
  table-layout: fixed;
}
.katex .vlist-r {
  display: table-row;
}
.katex .vlist {
  display: table-cell;
  position: relative;
  vertical-align: bottom;
}
.katex .vlist > span {
  display: block;
  height: 0;
  position: relative;
}
.katex .vlist > span > span {
  display: inline-block;
}
.katex .vlist > span > .pstrut {
  overflow: hidden;
  width: 0;
}
.katex .vlist-t2 {
  margin-right: -2px;
}
.katex .vlist-s {
  display: table-cell;
  font-size: 1px;
  min-width: 2px;
  vertical-align: bottom;
  width: 2px;
}
.katex .vbox {
  align-items: baseline;
  display: inline-flex;
  flex-direction: column;
}
.katex .hbox {
  width: 100%;
}
.katex .hbox,
.katex .thinbox {
  display: inline-flex;
  flex-direction: row;
}
.katex .thinbox {
  max-width: 0;
  width: 0;
}
.katex .msupsub {
  text-align: left;
}
.katex .mfrac > span > span {
  text-align: center;
}
.katex .mfrac .frac-line {
  border-bottom-style: solid;
  display: inline-block;
  width: 100%;
}
.katex .hdashline,
.katex .hline,
.katex .mfrac .frac-line,
.katex .overline .overline-line,
.katex .rule,
.katex .underline .underline-line {
  min-height: 1px;
}
.katex .mspace {
  display: inline-block;
}
.katex .clap,
.katex .llap,
.katex .rlap {
  position: relative;
  width: 0;
}
.katex .clap > .inner,
.katex .llap > .inner,
.katex .rlap > .inner {
  position: absolute;
}
.katex .clap > .fix,
.katex .llap > .fix,
.katex .rlap > .fix {
  display: inline-block;
}
.katex .llap > .inner {
  right: 0;
}
.katex .clap > .inner,
.katex .rlap > .inner {
  left: 0;
}
.katex .clap > .inner > span {
  margin-left: -50%;
  margin-right: 50%;
}
.katex .rule {
  border: 0 solid;
  display: inline-block;
  position: relative;
}
.katex .hline,
.katex .overline .overline-line,
.katex .underline .underline-line {
  border-bottom-style: solid;
  display: inline-block;
  width: 100%;
}
.katex .hdashline {
  border-bottom-style: dashed;
  display: inline-block;
  width: 100%;
}
.katex .sqrt > .root {
  margin-left: .2777777778em;
  margin-right: -.5555555556em;
}
.katex .fontsize-ensurer.reset-size1.size1,
.katex .sizing.reset-size1.size1 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size1.size2,
.katex .sizing.reset-size1.size2 {
  font-size: 1.2em;
}
.katex .fontsize-ensurer.reset-size1.size3,
.katex .sizing.reset-size1.size3 {
  font-size: 1.4em;
}
.katex .fontsize-ensurer.reset-size1.size4,
.katex .sizing.reset-size1.size4 {
  font-size: 1.6em;
}
.katex .fontsize-ensurer.reset-size1.size5,
.katex .sizing.reset-size1.size5 {
  font-size: 1.8em;
}
.katex .fontsize-ensurer.reset-size1.size6,
.katex .sizing.reset-size1.size6 {
  font-size: 2em;
}
.katex .fontsize-ensurer.reset-size1.size7,
.katex .sizing.reset-size1.size7 {
  font-size: 2.4em;
}
.katex .fontsize-ensurer.reset-size1.size8,
.katex .sizing.reset-size1.size8 {
  font-size: 2.88em;
}
.katex .fontsize-ensurer.reset-size1.size9,
.katex .sizing.reset-size1.size9 {
  font-size: 3.456em;
}
.katex .fontsize-ensurer.reset-size1.size10,
.katex .sizing.reset-size1.size10 {
  font-size: 4.148em;
}
.katex .fontsize-ensurer.reset-size1.size11,
.katex .sizing.reset-size1.size11 {
  font-size: 4.976em;
}
.katex .fontsize-ensurer.reset-size2.size1,
.katex .sizing.reset-size2.size1 {
  font-size: .8333333333em;
}
.katex .fontsize-ensurer.reset-size2.size2,
.katex .sizing.reset-size2.size2 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size2.size3,
.katex .sizing.reset-size2.size3 {
  font-size: 1.1666666667em;
}
.katex .fontsize-ensurer.reset-size2.size4,
.katex .sizing.reset-size2.size4 {
  font-size: 1.3333333333em;
}
.katex .fontsize-ensurer.reset-size2.size5,
.katex .sizing.reset-size2.size5 {
  font-size: 1.5em;
}
.katex .fontsize-ensurer.reset-size2.size6,
.katex .sizing.reset-size2.size6 {
  font-size: 1.6666666667em;
}
.katex .fontsize-ensurer.reset-size2.size7,
.katex .sizing.reset-size2.size7 {
  font-size: 2em;
}
.katex .fontsize-ensurer.reset-size2.size8,
.katex .sizing.reset-size2.size8 {
  font-size: 2.4em;
}
.katex .fontsize-ensurer.reset-size2.size9,
.katex .sizing.reset-size2.size9 {
  font-size: 2.88em;
}
.katex .fontsize-ensurer.reset-size2.size10,
.katex .sizing.reset-size2.size10 {
  font-size: 3.4566666667em;
}
.katex .fontsize-ensurer.reset-size2.size11,
.katex .sizing.reset-size2.size11 {
  font-size: 4.1466666667em;
}
.katex .fontsize-ensurer.reset-size3.size1,
.katex .sizing.reset-size3.size1 {
  font-size: .7142857143em;
}
.katex .fontsize-ensurer.reset-size3.size2,
.katex .sizing.reset-size3.size2 {
  font-size: .8571428571em;
}
.katex .fontsize-ensurer.reset-size3.size3,
.katex .sizing.reset-size3.size3 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size3.size4,
.katex .sizing.reset-size3.size4 {
  font-size: 1.1428571429em;
}
.katex .fontsize-ensurer.reset-size3.size5,
.katex .sizing.reset-size3.size5 {
  font-size: 1.2857142857em;
}
.katex .fontsize-ensurer.reset-size3.size6,
.katex .sizing.reset-size3.size6 {
  font-size: 1.4285714286em;
}
.katex .fontsize-ensurer.reset-size3.size7,
.katex .sizing.reset-size3.size7 {
  font-size: 1.7142857143em;
}
.katex .fontsize-ensurer.reset-size3.size8,
.katex .sizing.reset-size3.size8 {
  font-size: 2.0571428571em;
}
.katex .fontsize-ensurer.reset-size3.size9,
.katex .sizing.reset-size3.size9 {
  font-size: 2.4685714286em;
}
.katex .fontsize-ensurer.reset-size3.size10,
.katex .sizing.reset-size3.size10 {
  font-size: 2.9628571429em;
}
.katex .fontsize-ensurer.reset-size3.size11,
.katex .sizing.reset-size3.size11 {
  font-size: 3.5542857143em;
}
.katex .fontsize-ensurer.reset-size4.size1,
.katex .sizing.reset-size4.size1 {
  font-size: .625em;
}
.katex .fontsize-ensurer.reset-size4.size2,
.katex .sizing.reset-size4.size2 {
  font-size: .75em;
}
.katex .fontsize-ensurer.reset-size4.size3,
.katex .sizing.reset-size4.size3 {
  font-size: .875em;
}
.katex .fontsize-ensurer.reset-size4.size4,
.katex .sizing.reset-size4.size4 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size4.size5,
.katex .sizing.reset-size4.size5 {
  font-size: 1.125em;
}
.katex .fontsize-ensurer.reset-size4.size6,
.katex .sizing.reset-size4.size6 {
  font-size: 1.25em;
}
.katex .fontsize-ensurer.reset-size4.size7,
.katex .sizing.reset-size4.size7 {
  font-size: 1.5em;
}
.katex .fontsize-ensurer.reset-size4.size8,
.katex .sizing.reset-size4.size8 {
  font-size: 1.8em;
}
.katex .fontsize-ensurer.reset-size4.size9,
.katex .sizing.reset-size4.size9 {
  font-size: 2.16em;
}
.katex .fontsize-ensurer.reset-size4.size10,
.katex .sizing.reset-size4.size10 {
  font-size: 2.5925em;
}
.katex .fontsize-ensurer.reset-size4.size11,
.katex .sizing.reset-size4.size11 {
  font-size: 3.11em;
}
.katex .fontsize-ensurer.reset-size5.size1,
.katex .sizing.reset-size5.size1 {
  font-size: .5555555556em;
}
.katex .fontsize-ensurer.reset-size5.size2,
.katex .sizing.reset-size5.size2 {
  font-size: .6666666667em;
}
.katex .fontsize-ensurer.reset-size5.size3,
.katex .sizing.reset-size5.size3 {
  font-size: .7777777778em;
}
.katex .fontsize-ensurer.reset-size5.size4,
.katex .sizing.reset-size5.size4 {
  font-size: .8888888889em;
}
.katex .fontsize-ensurer.reset-size5.size5,
.katex .sizing.reset-size5.size5 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size5.size6,
.katex .sizing.reset-size5.size6 {
  font-size: 1.1111111111em;
}
.katex .fontsize-ensurer.reset-size5.size7,
.katex .sizing.reset-size5.size7 {
  font-size: 1.3333333333em;
}
.katex .fontsize-ensurer.reset-size5.size8,
.katex .sizing.reset-size5.size8 {
  font-size: 1.6em;
}
.katex .fontsize-ensurer.reset-size5.size9,
.katex .sizing.reset-size5.size9 {
  font-size: 1.92em;
}
.katex .fontsize-ensurer.reset-size5.size10,
.katex .sizing.reset-size5.size10 {
  font-size: 2.3044444444em;
}
.katex .fontsize-ensurer.reset-size5.size11,
.katex .sizing.reset-size5.size11 {
  font-size: 2.7644444444em;
}
.katex .fontsize-ensurer.reset-size6.size1,
.katex .sizing.reset-size6.size1 {
  font-size: .5em;
}
.katex .fontsize-ensurer.reset-size6.size2,
.katex .sizing.reset-size6.size2 {
  font-size: .6em;
}
.katex .fontsize-ensurer.reset-size6.size3,
.katex .sizing.reset-size6.size3 {
  font-size: .7em;
}
.katex .fontsize-ensurer.reset-size6.size4,
.katex .sizing.reset-size6.size4 {
  font-size: .8em;
}
.katex .fontsize-ensurer.reset-size6.size5,
.katex .sizing.reset-size6.size5 {
  font-size: .9em;
}
.katex .fontsize-ensurer.reset-size6.size6,
.katex .sizing.reset-size6.size6 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size6.size7,
.katex .sizing.reset-size6.size7 {
  font-size: 1.2em;
}
.katex .fontsize-ensurer.reset-size6.size8,
.katex .sizing.reset-size6.size8 {
  font-size: 1.44em;
}
.katex .fontsize-ensurer.reset-size6.size9,
.katex .sizing.reset-size6.size9 {
  font-size: 1.728em;
}
.katex .fontsize-ensurer.reset-size6.size10,
.katex .sizing.reset-size6.size10 {
  font-size: 2.074em;
}
.katex .fontsize-ensurer.reset-size6.size11,
.katex .sizing.reset-size6.size11 {
  font-size: 2.488em;
}
.katex .fontsize-ensurer.reset-size7.size1,
.katex .sizing.reset-size7.size1 {
  font-size: .4166666667em;
}
.katex .fontsize-ensurer.reset-size7.size2,
.katex .sizing.reset-size7.size2 {
  font-size: .5em;
}
.katex .fontsize-ensurer.reset-size7.size3,
.katex .sizing.reset-size7.size3 {
  font-size: .5833333333em;
}
.katex .fontsize-ensurer.reset-size7.size4,
.katex .sizing.reset-size7.size4 {
  font-size: .6666666667em;
}
.katex .fontsize-ensurer.reset-size7.size5,
.katex .sizing.reset-size7.size5 {
  font-size: .75em;
}
.katex .fontsize-ensurer.reset-size7.size6,
.katex .sizing.reset-size7.size6 {
  font-size: .8333333333em;
}
.katex .fontsize-ensurer.reset-size7.size7,
.katex .sizing.reset-size7.size7 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size7.size8,
.katex .sizing.reset-size7.size8 {
  font-size: 1.2em;
}
.katex .fontsize-ensurer.reset-size7.size9,
.katex .sizing.reset-size7.size9 {
  font-size: 1.44em;
}
.katex .fontsize-ensurer.reset-size7.size10,
.katex .sizing.reset-size7.size10 {
  font-size: 1.7283333333em;
}
.katex .fontsize-ensurer.reset-size7.size11,
.katex .sizing.reset-size7.size11 {
  font-size: 2.0733333333em;
}
.katex .fontsize-ensurer.reset-size8.size1,
.katex .sizing.reset-size8.size1 {
  font-size: .3472222222em;
}
.katex .fontsize-ensurer.reset-size8.size2,
.katex .sizing.reset-size8.size2 {
  font-size: .4166666667em;
}
.katex .fontsize-ensurer.reset-size8.size3,
.katex .sizing.reset-size8.size3 {
  font-size: .4861111111em;
}
.katex .fontsize-ensurer.reset-size8.size4,
.katex .sizing.reset-size8.size4 {
  font-size: .5555555556em;
}
.katex .fontsize-ensurer.reset-size8.size5,
.katex .sizing.reset-size8.size5 {
  font-size: .625em;
}
.katex .fontsize-ensurer.reset-size8.size6,
.katex .sizing.reset-size8.size6 {
  font-size: .6944444444em;
}
.katex .fontsize-ensurer.reset-size8.size7,
.katex .sizing.reset-size8.size7 {
  font-size: .8333333333em;
}
.katex .fontsize-ensurer.reset-size8.size8,
.katex .sizing.reset-size8.size8 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size8.size9,
.katex .sizing.reset-size8.size9 {
  font-size: 1.2em;
}
.katex .fontsize-ensurer.reset-size8.size10,
.katex .sizing.reset-size8.size10 {
  font-size: 1.4402777778em;
}
.katex .fontsize-ensurer.reset-size8.size11,
.katex .sizing.reset-size8.size11 {
  font-size: 1.7277777778em;
}
.katex .fontsize-ensurer.reset-size9.size1,
.katex .sizing.reset-size9.size1 {
  font-size: .2893518519em;
}
.katex .fontsize-ensurer.reset-size9.size2,
.katex .sizing.reset-size9.size2 {
  font-size: .3472222222em;
}
.katex .fontsize-ensurer.reset-size9.size3,
.katex .sizing.reset-size9.size3 {
  font-size: .4050925926em;
}
.katex .fontsize-ensurer.reset-size9.size4,
.katex .sizing.reset-size9.size4 {
  font-size: .462962963em;
}
.katex .fontsize-ensurer.reset-size9.size5,
.katex .sizing.reset-size9.size5 {
  font-size: .5208333333em;
}
.katex .fontsize-ensurer.reset-size9.size6,
.katex .sizing.reset-size9.size6 {
  font-size: .5787037037em;
}
.katex .fontsize-ensurer.reset-size9.size7,
.katex .sizing.reset-size9.size7 {
  font-size: .6944444444em;
}
.katex .fontsize-ensurer.reset-size9.size8,
.katex .sizing.reset-size9.size8 {
  font-size: .8333333333em;
}
.katex .fontsize-ensurer.reset-size9.size9,
.katex .sizing.reset-size9.size9 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size9.size10,
.katex .sizing.reset-size9.size10 {
  font-size: 1.2002314815em;
}
.katex .fontsize-ensurer.reset-size9.size11,
.katex .sizing.reset-size9.size11 {
  font-size: 1.4398148148em;
}
.katex .fontsize-ensurer.reset-size10.size1,
.katex .sizing.reset-size10.size1 {
  font-size: .2410800386em;
}
.katex .fontsize-ensurer.reset-size10.size2,
.katex .sizing.reset-size10.size2 {
  font-size: .2892960463em;
}
.katex .fontsize-ensurer.reset-size10.size3,
.katex .sizing.reset-size10.size3 {
  font-size: .337512054em;
}
.katex .fontsize-ensurer.reset-size10.size4,
.katex .sizing.reset-size10.size4 {
  font-size: .3857280617em;
}
.katex .fontsize-ensurer.reset-size10.size5,
.katex .sizing.reset-size10.size5 {
  font-size: .4339440694em;
}
.katex .fontsize-ensurer.reset-size10.size6,
.katex .sizing.reset-size10.size6 {
  font-size: .4821600771em;
}
.katex .fontsize-ensurer.reset-size10.size7,
.katex .sizing.reset-size10.size7 {
  font-size: .5785920926em;
}
.katex .fontsize-ensurer.reset-size10.size8,
.katex .sizing.reset-size10.size8 {
  font-size: .6943105111em;
}
.katex .fontsize-ensurer.reset-size10.size9,
.katex .sizing.reset-size10.size9 {
  font-size: .8331726133em;
}
.katex .fontsize-ensurer.reset-size10.size10,
.katex .sizing.reset-size10.size10 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size10.size11,
.katex .sizing.reset-size10.size11 {
  font-size: 1.1996142719em;
}
.katex .fontsize-ensurer.reset-size11.size1,
.katex .sizing.reset-size11.size1 {
  font-size: .2009646302em;
}
.katex .fontsize-ensurer.reset-size11.size2,
.katex .sizing.reset-size11.size2 {
  font-size: .2411575563em;
}
.katex .fontsize-ensurer.reset-size11.size3,
.katex .sizing.reset-size11.size3 {
  font-size: .2813504823em;
}
.katex .fontsize-ensurer.reset-size11.size4,
.katex .sizing.reset-size11.size4 {
  font-size: .3215434084em;
}
.katex .fontsize-ensurer.reset-size11.size5,
.katex .sizing.reset-size11.size5 {
  font-size: .3617363344em;
}
.katex .fontsize-ensurer.reset-size11.size6,
.katex .sizing.reset-size11.size6 {
  font-size: .4019292605em;
}
.katex .fontsize-ensurer.reset-size11.size7,
.katex .sizing.reset-size11.size7 {
  font-size: .4823151125em;
}
.katex .fontsize-ensurer.reset-size11.size8,
.katex .sizing.reset-size11.size8 {
  font-size: .578778135em;
}
.katex .fontsize-ensurer.reset-size11.size9,
.katex .sizing.reset-size11.size9 {
  font-size: .6945337621em;
}
.katex .fontsize-ensurer.reset-size11.size10,
.katex .sizing.reset-size11.size10 {
  font-size: .8336012862em;
}
.katex .fontsize-ensurer.reset-size11.size11,
.katex .sizing.reset-size11.size11 {
  font-size: 1em;
}
.katex .delimsizing.size1 {
  font-family: KaTeX_Size1;
}
.katex .delimsizing.size2 {
  font-family: KaTeX_Size2;
}
.katex .delimsizing.size3 {
  font-family: KaTeX_Size3;
}
.katex .delimsizing.size4 {
  font-family: KaTeX_Size4;
}
.katex .delimsizing.mult .delim-size1 > span {
  font-family: KaTeX_Size1;
}
.katex .delimsizing.mult .delim-size4 > span {
  font-family: KaTeX_Size4;
}
.katex .nulldelimiter {
  display: inline-block;
  width: .12em;
}
.katex .delimcenter,
.katex .op-symbol {
  position: relative;
}
.katex .op-symbol.small-op {
  font-family: KaTeX_Size1;
}
.katex .op-symbol.large-op {
  font-family: KaTeX_Size2;
}
.katex .accent > .vlist-t,
.katex .op-limits > .vlist-t {
  text-align: center;
}
.katex .accent .accent-body {
  position: relative;
}
.katex .accent .accent-body:not(.accent-full) {
  width: 0;
}
.katex .overlay {
  display: block;
}
.katex .mtable .vertical-separator {
  display: inline-block;
  min-width: 1px;
}
.katex .mtable .arraycolsep {
  display: inline-block;
}
.katex .mtable .col-align-c > .vlist-t {
  text-align: center;
}
.katex .mtable .col-align-l > .vlist-t {
  text-align: left;
}
.katex .mtable .col-align-r > .vlist-t {
  text-align: right;
}
.katex .svg-align {
  text-align: left;
}
.katex svg {
  fill: currentColor;
  stroke: currentColor;
  fill-rule: nonzero;
  fill-opacity: 1;
  stroke-width: 1;
  stroke-linecap: butt;
  stroke-linejoin: miter;
  stroke-miterlimit: 4;
  stroke-dasharray: none;
  stroke-dashoffset: 0;
  stroke-opacity: 1;
  display: block;
  height: inherit;
  position: absolute;
  width: 100%;
}
.katex svg path {
  stroke: none;
}
.katex img {
  border-style: none;
  max-height: none;
  max-width: none;
  min-height: 0;
  min-width: 0;
}
.katex .stretchy {
  display: block;
  overflow: hidden;
  position: relative;
  width: 100%;
}
.katex .stretchy:after,
.katex .stretchy:before {
  content: "";
}
.katex .hide-tail {
  overflow: hidden;
  position: relative;
  width: 100%;
}
.katex .halfarrow-left {
  left: 0;
  overflow: hidden;
  position: absolute;
  width: 50.2%;
}
.katex .halfarrow-right {
  overflow: hidden;
  position: absolute;
  right: 0;
  width: 50.2%;
}
.katex .brace-left {
  left: 0;
  overflow: hidden;
  position: absolute;
  width: 25.1%;
}
.katex .brace-center {
  left: 25%;
  overflow: hidden;
  position: absolute;
  width: 50%;
}
.katex .brace-right {
  overflow: hidden;
  position: absolute;
  right: 0;
  width: 25.1%;
}
.katex .x-arrow-pad {
  padding: 0 .5em;
}
.katex .cd-arrow-pad {
  padding: 0 .55556em 0 .27778em;
}
.katex .mover,
.katex .munder,
.katex .x-arrow {
  text-align: center;
}
.katex .boxpad {
  padding: 0 .3em;
}
.katex .fbox,
.katex .fcolorbox {
  border: .04em solid;
  box-sizing: border-box;
}
.katex .cancel-pad {
  padding: 0 .2em;
}
.katex .cancel-lap {
  margin-left: -.2em;
  margin-right: -.2em;
}
.katex .sout {
  border-bottom-style: solid;
  border-bottom-width: .08em;
}
.katex .angl {
  border-right: .049em solid;
  border-top: .049em solid;
  box-sizing: border-box;
  margin-right: .03889em;
}
.katex .anglpad {
  padding: 0 .03889em;
}
.katex .eqn-num:before {
  content: "(" counter(katexEqnNo) ")";
  counter-increment: katexEqnNo;
}
.katex .mml-eqn-num:before {
  content: "(" counter(mmlEqnNo) ")";
  counter-increment: mmlEqnNo;
}
.katex .mtr-glue {
  width: 50%;
}
.katex .cd-vert-arrow {
  display: inline-block;
  position: relative;
}
.katex .cd-label-left {
  display: inline-block;
  position: absolute;
  right: calc(50% + .3em);
  text-align: left;
}
.katex .cd-label-right {
  display: inline-block;
  left: calc(50% + .3em);
  position: absolute;
  text-align: right;
}
.katex-display {
  display: block;
  margin: 1em 0;
  text-align: center;
}
.katex-display > .katex {
  display: block;
  text-align: center;
  white-space: nowrap;
}
.katex-display > .katex > .katex-html {
  display: block;
  position: relative;
}
.katex-display > .katex > .katex-html > .tag {
  position: absolute;
  right: 0;
}
.katex-display.leqno > .katex > .katex-html > .tag {
  left: 0;
  right: auto;
}
.katex-display.fleqn > .katex {
  padding-left: 2em;
  text-align: left;
}
body {
  counter-reset: katexEqnNo mmlEqnNo;
}

/* temp_stylePlugin:app\static\input.css */
@tailwind base;
@tailwind components;
@tailwind utilities;
html,
body {
  height: 100%;
  margin: 0;
  font-family: "Inter", sans-serif;
  background-color: #f3f4f6;
}
#chat-history {
  flex: 1;
  overflow-y: auto;
  padding: 1rem;
  display: flex;
  flex-direction: column;
  background-color: #ffffff;
  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
  margin: 1rem;
  border-radius: 0.5rem;
}
#chat-history::-webkit-scrollbar {
  width: 8px;
}
#chat-history::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 10px;
}
#chat-history::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 10px;
}
#chat-history::-webkit-scrollbar-thumb:hover {
  background: #555;
}
.message {
  padding: 0.5rem 0.75rem;
  margin-bottom: 0.5rem;
  border-radius: 0.5rem;
  max-width: 90%;
  word-wrap: break-word;
  line-height: 1.5;
}
.user-message {
  background-color: #dbeafe;
  align-self: flex-end;
  margin-left: auto;
  white-space: pre-wrap;
}
.ai-turn-container {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  width: 100%;
  margin-bottom: 0.5rem;
}
.ai-message {
  background-color: #e5e7eb;
  align-self: flex-start;
  margin-right: auto;
  max-width: 90%;
  padding: 0.5rem 0.75rem;
  border-radius: 0.5rem;
}
.ai-message p {
  margin-bottom: 0.5em;
}
.ai-message p:last-child {
  margin-bottom: 0;
}
.ai-message ul,
.ai-message ol {
  margin-left: 1.5em;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}
.ai-message li {
  margin-bottom: 0.25em;
}
.ai-message blockquote {
  border-left: 3px solid #ccc;
  padding-left: 0.8em;
  margin-left: 0;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  color: #555;
}
.ai-message code {
  background-color: rgba(0, 0, 0, 0.06);
  padding: 0.1em 0.3em;
  border-radius: 3px;
  font-family: monospace;
  font-size: 0.9em;
}
.ai-message pre[class*=language-] code {
  background-color: transparent;
  padding: 0;
  border-radius: 0;
  font-size: inherit;
}
.ai-message a {
  color: #007bff;
  text-decoration: underline;
}
.ai-message a:hover {
  color: #0056b3;
}
.ai-message hr {
  border: none;
  border-top: 1px solid #ccc;
  margin: 1em 0;
}
.ai-message table {
  border-collapse: collapse;
  margin: 1em 0;
  width: auto;
}
.ai-message th,
.ai-message td {
  border: 1px solid #ccc;
  padding: 0.3em 0.6em;
  text-align: left;
}
.ai-message th {
  background-color: #f2f2f2;
  font-weight: bold;
}
.code-reference {
  font-family: monospace;
  background-color: rgba(0, 0, 0, 0.08);
  padding: 1px 5px;
  border-radius: 4px;
  font-size: 0.85em;
  white-space: nowrap;
  margin: 0 2px;
}
.loading-dots {
  display: inline-block;
}
.loading-dots::after {
  display: inline-block;
  position: relative;
  left: 1px;
  animation: ellipsis 1.5s infinite;
  content: ".";
  width: 1.5em;
  text-align: left;
  vertical-align: bottom;
}
@keyframes ellipsis {
  0% {
    content: ".";
  }
  33% {
    content: "..";
  }
  66% {
    content: "...";
  }
}
.thinking-area {
  width: 100%;
  max-width: 90%;
  margin-bottom: 4px;
  align-self: flex-start;
  font-size: 0.9em;
}
.thinking-area details {
  width: 100%;
  border: 1px dashed #aaa;
  border-radius: 6px;
  background-color: #f0f0f0;
  overflow: hidden;
}
.thinking-summary {
  padding: 3px 8px;
  cursor: pointer;
  font-weight: normal;
  color: #444;
  background-color: #e0e0e0;
  border-bottom: 1px dashed #aaa;
  outline: none;
  user-select: none;
  list-style: none;
  display: block;
  transition: background-color 0.15s ease;
}
.thinking-summary:hover {
  background-color: #d0d0d0;
}
.thinking-summary::-webkit-details-marker {
  display: none;
}
.thinking-summary .dots {
  display: inline-block;
  margin-left: 4px;
}
.thinking-summary .dots::after {
  display: inline-block;
  position: relative;
  left: 1px;
  animation: ellipsis 1.5s infinite;
  content: ".";
  width: 1.5em;
  text-align: left;
  vertical-align: bottom;
}
.thinking-area details[open] > .thinking-summary .dots {
  display: none;
}
.thinking-area details pre {
  margin: 0;
  padding: 8px;
  background-color: #f8f8f8;
  white-space: pre-wrap;
  word-wrap: break-word;
  overflow-wrap: break-word;
  max-height: 200px;
  overflow-y: auto;
}
.code-blocks-area {
  width: 100%;
  max-width: 90%;
  align-self: flex-start;
  margin-top: 0.5rem;
}
.code-block-container {
  margin-bottom: 0.75rem;
  border-radius: 0.375rem;
  overflow: hidden;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
}
.code-block-header,
.code-output-header {
  display: flex;
  align-items: center;
  background-color: #e5e7eb;
  padding: 0.25rem 0.5rem;
  font-size: 0.8em;
  color: #4b5563;
  gap: 0.625rem;
}
.code-output-header {
  margin-top: 0.25rem;
}
.code-block-buttons,
.output-header-buttons {
  display: flex;
  align-items: center;
  gap: 0.375rem;
  flex-shrink: 0;
}
.code-block-title,
.output-header-title {
  font-weight: 500;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.code-block-title {
  flex-shrink: 1;
  flex-grow: 1;
  text-align: left;
}
.output-header-title {
  flex-shrink: 0;
  margin-right: 0.625rem;
}
.output-header-button-placeholder {
  display: inline-block;
  width: 24px;
  height: 24px;
  flex-shrink: 0;
}
.code-status-span {
  margin-left: auto;
  text-align: right;
  font-style: italic;
  font-size: 0.9em;
  padding: 0 0.3125rem;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  color: #6b7280;
  flex-shrink: 0;
}
.code-status-span.running,
.code-status-span.stopping {
  color: #ca8a04;
  font-weight: 500;
}
.code-status-span.success {
  color: #16a34a;
  font-weight: 500;
}
.code-status-span.error,
.code-status-span.stopped {
  color: #dc2626;
  font-weight: 500;
}
.code-action-btn {
  background-color: #d1d5db;
  color: #4b5563;
  border: none;
  padding: 0.1875rem 0.4375rem;
  border-radius: 0.25rem;
  cursor: pointer;
  font-size: 0.9em;
  line-height: 1.2;
  transition: background-color 0.2s ease, color 0.2s ease;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  white-space: nowrap;
}
.code-action-btn:hover {
  background-color: #9ca3af;
  color: #1f2937;
}
.code-action-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
.code-action-btn.copied {
  background-color: #16a34a;
  color: white;
}
.code-output-header .code-action-btn {
  background-color: #d1d5db;
  color: #4b5563;
  border: none;
  padding: 0.1875rem 0.4375rem;
  border-radius: 0.25rem;
  cursor: pointer;
  font-size: 0.9em;
  line-height: 1.2;
  transition: background-color 0.2s ease, color 0.2s ease;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  white-space: nowrap;
}
.code-output-header .code-action-btn:hover {
  background-color: #9ca3af;
  color: #1f2937;
}
.run-code-btn {
  padding: 4px;
  width: 24px;
  height: 24px;
  font-size: 1em;
  background-color: transparent !important;
  border: none !important;
  color: #9ca3af;
  transition: color 0.2s ease;
}
.run-code-btn:hover {
  color: #4b5563;
  background-color: transparent !important;
}
.run-code-btn[data-status=idle] {
  color: #16a34a;
}
.run-code-btn[data-status=idle]:hover {
  color: #15803d;
}
.run-code-btn[data-status=running] {
  color: #dc2626;
}
.run-code-btn[data-status=running]:hover {
  color: #b91c1c;
}
.run-code-btn[data-status=stopping] {
  color: #f59e0b;
  cursor: wait;
  animation: spin 1s linear infinite;
}
.run-code-btn[data-status=stopping]:hover {
  color: #d97706;
}
@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
.code-block-container > pre[class*=language-] {
  margin: 0;
  border: 1px solid #d1d5db;
  border-top: none;
  border-bottom: none !important;
  overflow: hidden;
}
.code-block-container > pre[class*=language-] > code[class*=language-] {
  outline: none;
  white-space: pre-wrap !important;
  word-wrap: break-word !important;
  display: block;
  min-height: 1.5em;
  padding: 0.5em;
}
.code-block-container > pre[class*=language-] > code[class*=language-]:focus {
  background-color: rgba(0, 0, 0, 0.03);
}
.code-output-console {
  background-color: #1f2937;
  color: #f3f4f6;
  padding: 0;
  border: 1px solid #4b5563;
  border-top: none !important;
  max-height: 250px;
  overflow-y: auto;
  font-family: monospace;
  font-size: 0.85em;
  line-height: 1.4;
}
.code-output-console pre {
  margin: 0;
  white-space: pre-wrap;
  word-wrap: break-word;
  color: inherit;
  border: none !important;
  padding: 0.5rem;
  background-color: transparent;
  outline: none !important;
}
.code-output-console span {
  display: inline;
  white-space: pre-wrap;
}
.code-output-console span.stdout-output {
  color: #ffffff;
}
.code-output-console span.stderr-output {
  color: #f87171;
}
.code-block-container > pre.hidden,
.code-output-console.hidden,
.code-output-header.hidden {
  display: none !important;
}
footer {
  padding: 1rem;
  background-color: #e5e7eb;
  border-top: 1px solid #d1d5db;
}
#chat-form {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}
.think-checkbox-container {
  display: flex;
  align-items: center;
  font-size: 0.9em;
  color: #4b5563;
}
.think-checkbox-container input {
  margin-right: 4px;
  cursor: pointer;
}
.think-checkbox-container label {
  cursor: pointer;
  user-select: none;
}
#message-input {
  flex-grow: 1;
  padding: 0.5rem 0.75rem;
  border: 1px solid #d1d5db;
  border-radius: 0.5rem;
  outline: none;
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
}
#message-input:focus {
  border-color: #2563eb;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
}
#send-button {
  background-color: #2563eb;
  color: white;
  font-weight: 500;
  padding: 0.5rem 1rem;
  border-radius: 0.5rem;
  border: none;
  cursor: pointer;
  transition: background-color 0.2s ease;
}
#send-button:hover {
  background-color: #1d4ed8;
}
#send-button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
.error-message {
  background-color: #fee2e2;
  color: #991b1b;
  border: 1px solid #fecaca;
  align-self: flex-start;
  margin-right: auto;
  padding: 0.5rem 0.75rem;
  border-radius: 0.5rem;
  max-width: 90%;
  word-wrap: break-word;
  margin-bottom: 0.5rem;
  white-space: pre-wrap;
}
.system-message {
  width: 100%;
  text-align: center;
  font-size: 0.875rem;
  color: #6b7280;
  font-style: italic;
  margin: 0.25rem 0;
}
span[data-katex-rendered=true] .katex-display {
  margin: 0.5em 0;
  overflow-x: auto;
  overflow-y: hidden;
  padding: 0.2em 0;
}
span[data-katex-rendered=true] .katex {
  line-height: normal;
  vertical-align: baseline;
  font-size: 1em;
}
.katex-error {
  color: #cc0000;
  background-color: #fdd;
  border: 1px solid #cc0000;
  padding: 2px 4px;
  border-radius: 3px;
}
.hidden {
  display: none !important;
}
/*# sourceMappingURL=input.css.map */


=== app/static/dist/input.js ===
(() => {
})();
//# sourceMappingURL=input.js.map


=== app/static/dist/script.css ===
/* node_modules/prismjs/themes/prism-tomorrow.css */
code[class*=language-],
pre[class*=language-] {
  color: #ccc;
  background: none;
  font-family:
    Consolas,
    Monaco,
    "Andale Mono",
    "Ubuntu Mono",
    monospace;
  font-size: 1em;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.5;
  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;
  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}
pre[class*=language-] {
  padding: 1em;
  margin: .5em 0;
  overflow: auto;
}
:not(pre) > code[class*=language-],
pre[class*=language-] {
  background: #2d2d2d;
}
:not(pre) > code[class*=language-] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
}
.token.comment,
.token.block-comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: #999;
}
.token.punctuation {
  color: #ccc;
}
.token.tag,
.token.attr-name,
.token.namespace,
.token.deleted {
  color: #e2777a;
}
.token.function-name {
  color: #6196cc;
}
.token.boolean,
.token.number,
.token.function {
  color: #f08d49;
}
.token.property,
.token.class-name,
.token.constant,
.token.symbol {
  color: #f8c555;
}
.token.selector,
.token.important,
.token.atrule,
.token.keyword,
.token.builtin {
  color: #cc99cd;
}
.token.string,
.token.char,
.token.attr-value,
.token.regex,
.token.variable {
  color: #7ec699;
}
.token.operator,
.token.entity,
.token.url {
  color: #67cdcc;
}
.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}
.token.entity {
  cursor: help;
}
.token.inserted {
  color: green;
}

/* node_modules/katex/dist/katex.min.css */
@font-face {
  font-family: KaTeX_AMS;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_AMS-Regular-U6PRYMIZ.woff2") format("woff2"),
    url("./assets/KaTeX_AMS-Regular-CYEKBG2K.woff") format("woff"),
    url("./assets/KaTeX_AMS-Regular-JKX5W2C4.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Caligraphic;
  font-style: normal;
  font-weight: 700;
  src:
    url("./assets/KaTeX_Caligraphic-Bold-5QL5CMTE.woff2") format("woff2"),
    url("./assets/KaTeX_Caligraphic-Bold-WZ3QSGD3.woff") format("woff"),
    url("./assets/KaTeX_Caligraphic-Bold-ZTS3R3HK.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Caligraphic;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Caligraphic-Regular-KX5MEWCF.woff2") format("woff2"),
    url("./assets/KaTeX_Caligraphic-Regular-3LKEU76G.woff") format("woff"),
    url("./assets/KaTeX_Caligraphic-Regular-A7XRTZ5Q.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Fraktur;
  font-style: normal;
  font-weight: 700;
  src:
    url("./assets/KaTeX_Fraktur-Bold-2QVFK6NQ.woff2") format("woff2"),
    url("./assets/KaTeX_Fraktur-Bold-T4SWXBMT.woff") format("woff"),
    url("./assets/KaTeX_Fraktur-Bold-WGHVTYOR.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Fraktur;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Fraktur-Regular-2PEIFJSJ.woff2") format("woff2"),
    url("./assets/KaTeX_Fraktur-Regular-PQMHCIK6.woff") format("woff"),
    url("./assets/KaTeX_Fraktur-Regular-5U4OPH2X.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Main;
  font-style: normal;
  font-weight: 700;
  src:
    url("./assets/KaTeX_Main-Bold-YP5VVQRP.woff2") format("woff2"),
    url("./assets/KaTeX_Main-Bold-2GA4IZIN.woff") format("woff"),
    url("./assets/KaTeX_Main-Bold-W5FBVCZM.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Main;
  font-style: italic;
  font-weight: 700;
  src:
    url("./assets/KaTeX_Main-BoldItalic-N4V3DX7S.woff2") format("woff2"),
    url("./assets/KaTeX_Main-BoldItalic-4P4C7HJH.woff") format("woff"),
    url("./assets/KaTeX_Main-BoldItalic-ODMLBJJQ.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Main;
  font-style: italic;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Main-Italic-RELBIK7M.woff2") format("woff2"),
    url("./assets/KaTeX_Main-Italic-SASNQFN2.woff") format("woff"),
    url("./assets/KaTeX_Main-Italic-I43T2HSR.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Main;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Main-Regular-ARRPAO67.woff2") format("woff2"),
    url("./assets/KaTeX_Main-Regular-P5I74A2A.woff") format("woff"),
    url("./assets/KaTeX_Main-Regular-W74P5G27.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Math;
  font-style: italic;
  font-weight: 700;
  src:
    url("./assets/KaTeX_Math-BoldItalic-K4WTGH3J.woff2") format("woff2"),
    url("./assets/KaTeX_Math-BoldItalic-6EBV3DK5.woff") format("woff"),
    url("./assets/KaTeX_Math-BoldItalic-VB447A4D.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Math;
  font-style: italic;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Math-Italic-6KGCHLFN.woff2") format("woff2"),
    url("./assets/KaTeX_Math-Italic-KKK3USB2.woff") format("woff"),
    url("./assets/KaTeX_Math-Italic-SON4MRCA.ttf") format("truetype");
}
@font-face {
  font-family: "KaTeX_SansSerif";
  font-style: normal;
  font-weight: 700;
  src:
    url("./assets/KaTeX_SansSerif-Bold-RRNVJFFW.woff2") format("woff2"),
    url("./assets/KaTeX_SansSerif-Bold-X5M5EMOD.woff") format("woff"),
    url("./assets/KaTeX_SansSerif-Bold-STQ6RXC7.ttf") format("truetype");
}
@font-face {
  font-family: "KaTeX_SansSerif";
  font-style: italic;
  font-weight: 400;
  src:
    url("./assets/KaTeX_SansSerif-Italic-HMPFTM52.woff2") format("woff2"),
    url("./assets/KaTeX_SansSerif-Italic-PSN4QKYX.woff") format("woff"),
    url("./assets/KaTeX_SansSerif-Italic-WTBAZBGY.ttf") format("truetype");
}
@font-face {
  font-family: "KaTeX_SansSerif";
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_SansSerif-Regular-XIQ62X4E.woff2") format("woff2"),
    url("./assets/KaTeX_SansSerif-Regular-OQCII6EP.woff") format("woff"),
    url("./assets/KaTeX_SansSerif-Regular-2TL3USAE.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Script;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Script-Regular-APUWIHLP.woff2") format("woff2"),
    url("./assets/KaTeX_Script-Regular-A5IFOEBS.woff") format("woff"),
    url("./assets/KaTeX_Script-Regular-72OLXYNA.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Size1;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Size1-Regular-5LRUTBFT.woff2") format("woff2"),
    url("./assets/KaTeX_Size1-Regular-4HRHTS65.woff") format("woff"),
    url("./assets/KaTeX_Size1-Regular-7K6AASVL.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Size2;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Size2-Regular-LELKET5D.woff2") format("woff2"),
    url("./assets/KaTeX_Size2-Regular-K5ZHAIS6.woff") format("woff"),
    url("./assets/KaTeX_Size2-Regular-222HN3GT.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Size3;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Size3-Regular-WQRQ47UD.woff2") format("woff2"),
    url("./assets/KaTeX_Size3-Regular-TLFPAHDE.woff") format("woff"),
    url("./assets/KaTeX_Size3-Regular-UFCO6WCA.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Size4;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Size4-Regular-CDMV7U5C.woff2") format("woff2"),
    url("./assets/KaTeX_Size4-Regular-PKMWZHNC.woff") format("woff"),
    url("./assets/KaTeX_Size4-Regular-7PGNVPQK.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Typewriter;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Typewriter-Regular-VBYJ4NRC.woff2") format("woff2"),
    url("./assets/KaTeX_Typewriter-Regular-MJMFSK64.woff") format("woff"),
    url("./assets/KaTeX_Typewriter-Regular-3F5K6SQ6.ttf") format("truetype");
}
.katex {
  font:
    normal 1.21em KaTeX_Main,
    Times New Roman,
    serif;
  line-height: 1.2;
  text-indent: 0;
  text-rendering: auto;
}
.katex * {
  -ms-high-contrast-adjust: none !important;
  border-color: currentColor;
}
.katex .katex-version:after {
  content: "0.16.22";
}
.katex .katex-mathml {
  clip: rect(1px, 1px, 1px, 1px);
  border: 0;
  height: 1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
}
.katex .katex-html > .newline {
  display: block;
}
.katex .base {
  position: relative;
  white-space: nowrap;
  width: -webkit-min-content;
  width: -moz-min-content;
  width: min-content;
}
.katex .base,
.katex .strut {
  display: inline-block;
}
.katex .textbf {
  font-weight: 700;
}
.katex .textit {
  font-style: italic;
}
.katex .textrm {
  font-family: KaTeX_Main;
}
.katex .textsf {
  font-family: KaTeX_SansSerif;
}
.katex .texttt {
  font-family: KaTeX_Typewriter;
}
.katex .mathnormal {
  font-family: KaTeX_Math;
  font-style: italic;
}
.katex .mathit {
  font-family: KaTeX_Main;
  font-style: italic;
}
.katex .mathrm {
  font-style: normal;
}
.katex .mathbf {
  font-family: KaTeX_Main;
  font-weight: 700;
}
.katex .boldsymbol {
  font-family: KaTeX_Math;
  font-style: italic;
  font-weight: 700;
}
.katex .amsrm,
.katex .mathbb,
.katex .textbb {
  font-family: KaTeX_AMS;
}
.katex .mathcal {
  font-family: KaTeX_Caligraphic;
}
.katex .mathfrak,
.katex .textfrak {
  font-family: KaTeX_Fraktur;
}
.katex .mathboldfrak,
.katex .textboldfrak {
  font-family: KaTeX_Fraktur;
  font-weight: 700;
}
.katex .mathtt {
  font-family: KaTeX_Typewriter;
}
.katex .mathscr,
.katex .textscr {
  font-family: KaTeX_Script;
}
.katex .mathsf,
.katex .textsf {
  font-family: KaTeX_SansSerif;
}
.katex .mathboldsf,
.katex .textboldsf {
  font-family: KaTeX_SansSerif;
  font-weight: 700;
}
.katex .mathitsf,
.katex .mathsfit,
.katex .textitsf {
  font-family: KaTeX_SansSerif;
  font-style: italic;
}
.katex .mainrm {
  font-family: KaTeX_Main;
  font-style: normal;
}
.katex .vlist-t {
  border-collapse: collapse;
  display: inline-table;
  table-layout: fixed;
}
.katex .vlist-r {
  display: table-row;
}
.katex .vlist {
  display: table-cell;
  position: relative;
  vertical-align: bottom;
}
.katex .vlist > span {
  display: block;
  height: 0;
  position: relative;
}
.katex .vlist > span > span {
  display: inline-block;
}
.katex .vlist > span > .pstrut {
  overflow: hidden;
  width: 0;
}
.katex .vlist-t2 {
  margin-right: -2px;
}
.katex .vlist-s {
  display: table-cell;
  font-size: 1px;
  min-width: 2px;
  vertical-align: bottom;
  width: 2px;
}
.katex .vbox {
  align-items: baseline;
  display: inline-flex;
  flex-direction: column;
}
.katex .hbox {
  width: 100%;
}
.katex .hbox,
.katex .thinbox {
  display: inline-flex;
  flex-direction: row;
}
.katex .thinbox {
  max-width: 0;
  width: 0;
}
.katex .msupsub {
  text-align: left;
}
.katex .mfrac > span > span {
  text-align: center;
}
.katex .mfrac .frac-line {
  border-bottom-style: solid;
  display: inline-block;
  width: 100%;
}
.katex .hdashline,
.katex .hline,
.katex .mfrac .frac-line,
.katex .overline .overline-line,
.katex .rule,
.katex .underline .underline-line {
  min-height: 1px;
}
.katex .mspace {
  display: inline-block;
}
.katex .clap,
.katex .llap,
.katex .rlap {
  position: relative;
  width: 0;
}
.katex .clap > .inner,
.katex .llap > .inner,
.katex .rlap > .inner {
  position: absolute;
}
.katex .clap > .fix,
.katex .llap > .fix,
.katex .rlap > .fix {
  display: inline-block;
}
.katex .llap > .inner {
  right: 0;
}
.katex .clap > .inner,
.katex .rlap > .inner {
  left: 0;
}
.katex .clap > .inner > span {
  margin-left: -50%;
  margin-right: 50%;
}
.katex .rule {
  border: 0 solid;
  display: inline-block;
  position: relative;
}
.katex .hline,
.katex .overline .overline-line,
.katex .underline .underline-line {
  border-bottom-style: solid;
  display: inline-block;
  width: 100%;
}
.katex .hdashline {
  border-bottom-style: dashed;
  display: inline-block;
  width: 100%;
}
.katex .sqrt > .root {
  margin-left: .2777777778em;
  margin-right: -.5555555556em;
}
.katex .fontsize-ensurer.reset-size1.size1,
.katex .sizing.reset-size1.size1 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size1.size2,
.katex .sizing.reset-size1.size2 {
  font-size: 1.2em;
}
.katex .fontsize-ensurer.reset-size1.size3,
.katex .sizing.reset-size1.size3 {
  font-size: 1.4em;
}
.katex .fontsize-ensurer.reset-size1.size4,
.katex .sizing.reset-size1.size4 {
  font-size: 1.6em;
}
.katex .fontsize-ensurer.reset-size1.size5,
.katex .sizing.reset-size1.size5 {
  font-size: 1.8em;
}
.katex .fontsize-ensurer.reset-size1.size6,
.katex .sizing.reset-size1.size6 {
  font-size: 2em;
}
.katex .fontsize-ensurer.reset-size1.size7,
.katex .sizing.reset-size1.size7 {
  font-size: 2.4em;
}
.katex .fontsize-ensurer.reset-size1.size8,
.katex .sizing.reset-size1.size8 {
  font-size: 2.88em;
}
.katex .fontsize-ensurer.reset-size1.size9,
.katex .sizing.reset-size1.size9 {
  font-size: 3.456em;
}
.katex .fontsize-ensurer.reset-size1.size10,
.katex .sizing.reset-size1.size10 {
  font-size: 4.148em;
}
.katex .fontsize-ensurer.reset-size1.size11,
.katex .sizing.reset-size1.size11 {
  font-size: 4.976em;
}
.katex .fontsize-ensurer.reset-size2.size1,
.katex .sizing.reset-size2.size1 {
  font-size: .8333333333em;
}
.katex .fontsize-ensurer.reset-size2.size2,
.katex .sizing.reset-size2.size2 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size2.size3,
.katex .sizing.reset-size2.size3 {
  font-size: 1.1666666667em;
}
.katex .fontsize-ensurer.reset-size2.size4,
.katex .sizing.reset-size2.size4 {
  font-size: 1.3333333333em;
}
.katex .fontsize-ensurer.reset-size2.size5,
.katex .sizing.reset-size2.size5 {
  font-size: 1.5em;
}
.katex .fontsize-ensurer.reset-size2.size6,
.katex .sizing.reset-size2.size6 {
  font-size: 1.6666666667em;
}
.katex .fontsize-ensurer.reset-size2.size7,
.katex .sizing.reset-size2.size7 {
  font-size: 2em;
}
.katex .fontsize-ensurer.reset-size2.size8,
.katex .sizing.reset-size2.size8 {
  font-size: 2.4em;
}
.katex .fontsize-ensurer.reset-size2.size9,
.katex .sizing.reset-size2.size9 {
  font-size: 2.88em;
}
.katex .fontsize-ensurer.reset-size2.size10,
.katex .sizing.reset-size2.size10 {
  font-size: 3.4566666667em;
}
.katex .fontsize-ensurer.reset-size2.size11,
.katex .sizing.reset-size2.size11 {
  font-size: 4.1466666667em;
}
.katex .fontsize-ensurer.reset-size3.size1,
.katex .sizing.reset-size3.size1 {
  font-size: .7142857143em;
}
.katex .fontsize-ensurer.reset-size3.size2,
.katex .sizing.reset-size3.size2 {
  font-size: .8571428571em;
}
.katex .fontsize-ensurer.reset-size3.size3,
.katex .sizing.reset-size3.size3 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size3.size4,
.katex .sizing.reset-size3.size4 {
  font-size: 1.1428571429em;
}
.katex .fontsize-ensurer.reset-size3.size5,
.katex .sizing.reset-size3.size5 {
  font-size: 1.2857142857em;
}
.katex .fontsize-ensurer.reset-size3.size6,
.katex .sizing.reset-size3.size6 {
  font-size: 1.4285714286em;
}
.katex .fontsize-ensurer.reset-size3.size7,
.katex .sizing.reset-size3.size7 {
  font-size: 1.7142857143em;
}
.katex .fontsize-ensurer.reset-size3.size8,
.katex .sizing.reset-size3.size8 {
  font-size: 2.0571428571em;
}
.katex .fontsize-ensurer.reset-size3.size9,
.katex .sizing.reset-size3.size9 {
  font-size: 2.4685714286em;
}
.katex .fontsize-ensurer.reset-size3.size10,
.katex .sizing.reset-size3.size10 {
  font-size: 2.9628571429em;
}
.katex .fontsize-ensurer.reset-size3.size11,
.katex .sizing.reset-size3.size11 {
  font-size: 3.5542857143em;
}
.katex .fontsize-ensurer.reset-size4.size1,
.katex .sizing.reset-size4.size1 {
  font-size: .625em;
}
.katex .fontsize-ensurer.reset-size4.size2,
.katex .sizing.reset-size4.size2 {
  font-size: .75em;
}
.katex .fontsize-ensurer.reset-size4.size3,
.katex .sizing.reset-size4.size3 {
  font-size: .875em;
}
.katex .fontsize-ensurer.reset-size4.size4,
.katex .sizing.reset-size4.size4 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size4.size5,
.katex .sizing.reset-size4.size5 {
  font-size: 1.125em;
}
.katex .fontsize-ensurer.reset-size4.size6,
.katex .sizing.reset-size4.size6 {
  font-size: 1.25em;
}
.katex .fontsize-ensurer.reset-size4.size7,
.katex .sizing.reset-size4.size7 {
  font-size: 1.5em;
}
.katex .fontsize-ensurer.reset-size4.size8,
.katex .sizing.reset-size4.size8 {
  font-size: 1.8em;
}
.katex .fontsize-ensurer.reset-size4.size9,
.katex .sizing.reset-size4.size9 {
  font-size: 2.16em;
}
.katex .fontsize-ensurer.reset-size4.size10,
.katex .sizing.reset-size4.size10 {
  font-size: 2.5925em;
}
.katex .fontsize-ensurer.reset-size4.size11,
.katex .sizing.reset-size4.size11 {
  font-size: 3.11em;
}
.katex .fontsize-ensurer.reset-size5.size1,
.katex .sizing.reset-size5.size1 {
  font-size: .5555555556em;
}
.katex .fontsize-ensurer.reset-size5.size2,
.katex .sizing.reset-size5.size2 {
  font-size: .6666666667em;
}
.katex .fontsize-ensurer.reset-size5.size3,
.katex .sizing.reset-size5.size3 {
  font-size: .7777777778em;
}
.katex .fontsize-ensurer.reset-size5.size4,
.katex .sizing.reset-size5.size4 {
  font-size: .8888888889em;
}
.katex .fontsize-ensurer.reset-size5.size5,
.katex .sizing.reset-size5.size5 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size5.size6,
.katex .sizing.reset-size5.size6 {
  font-size: 1.1111111111em;
}
.katex .fontsize-ensurer.reset-size5.size7,
.katex .sizing.reset-size5.size7 {
  font-size: 1.3333333333em;
}
.katex .fontsize-ensurer.reset-size5.size8,
.katex .sizing.reset-size5.size8 {
  font-size: 1.6em;
}
.katex .fontsize-ensurer.reset-size5.size9,
.katex .sizing.reset-size5.size9 {
  font-size: 1.92em;
}
.katex .fontsize-ensurer.reset-size5.size10,
.katex .sizing.reset-size5.size10 {
  font-size: 2.3044444444em;
}
.katex .fontsize-ensurer.reset-size5.size11,
.katex .sizing.reset-size5.size11 {
  font-size: 2.7644444444em;
}
.katex .fontsize-ensurer.reset-size6.size1,
.katex .sizing.reset-size6.size1 {
  font-size: .5em;
}
.katex .fontsize-ensurer.reset-size6.size2,
.katex .sizing.reset-size6.size2 {
  font-size: .6em;
}
.katex .fontsize-ensurer.reset-size6.size3,
.katex .sizing.reset-size6.size3 {
  font-size: .7em;
}
.katex .fontsize-ensurer.reset-size6.size4,
.katex .sizing.reset-size6.size4 {
  font-size: .8em;
}
.katex .fontsize-ensurer.reset-size6.size5,
.katex .sizing.reset-size6.size5 {
  font-size: .9em;
}
.katex .fontsize-ensurer.reset-size6.size6,
.katex .sizing.reset-size6.size6 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size6.size7,
.katex .sizing.reset-size6.size7 {
  font-size: 1.2em;
}
.katex .fontsize-ensurer.reset-size6.size8,
.katex .sizing.reset-size6.size8 {
  font-size: 1.44em;
}
.katex .fontsize-ensurer.reset-size6.size9,
.katex .sizing.reset-size6.size9 {
  font-size: 1.728em;
}
.katex .fontsize-ensurer.reset-size6.size10,
.katex .sizing.reset-size6.size10 {
  font-size: 2.074em;
}
.katex .fontsize-ensurer.reset-size6.size11,
.katex .sizing.reset-size6.size11 {
  font-size: 2.488em;
}
.katex .fontsize-ensurer.reset-size7.size1,
.katex .sizing.reset-size7.size1 {
  font-size: .4166666667em;
}
.katex .fontsize-ensurer.reset-size7.size2,
.katex .sizing.reset-size7.size2 {
  font-size: .5em;
}
.katex .fontsize-ensurer.reset-size7.size3,
.katex .sizing.reset-size7.size3 {
  font-size: .5833333333em;
}
.katex .fontsize-ensurer.reset-size7.size4,
.katex .sizing.reset-size7.size4 {
  font-size: .6666666667em;
}
.katex .fontsize-ensurer.reset-size7.size5,
.katex .sizing.reset-size7.size5 {
  font-size: .75em;
}
.katex .fontsize-ensurer.reset-size7.size6,
.katex .sizing.reset-size7.size6 {
  font-size: .8333333333em;
}
.katex .fontsize-ensurer.reset-size7.size7,
.katex .sizing.reset-size7.size7 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size7.size8,
.katex .sizing.reset-size7.size8 {
  font-size: 1.2em;
}
.katex .fontsize-ensurer.reset-size7.size9,
.katex .sizing.reset-size7.size9 {
  font-size: 1.44em;
}
.katex .fontsize-ensurer.reset-size7.size10,
.katex .sizing.reset-size7.size10 {
  font-size: 1.7283333333em;
}
.katex .fontsize-ensurer.reset-size7.size11,
.katex .sizing.reset-size7.size11 {
  font-size: 2.0733333333em;
}
.katex .fontsize-ensurer.reset-size8.size1,
.katex .sizing.reset-size8.size1 {
  font-size: .3472222222em;
}
.katex .fontsize-ensurer.reset-size8.size2,
.katex .sizing.reset-size8.size2 {
  font-size: .4166666667em;
}
.katex .fontsize-ensurer.reset-size8.size3,
.katex .sizing.reset-size8.size3 {
  font-size: .4861111111em;
}
.katex .fontsize-ensurer.reset-size8.size4,
.katex .sizing.reset-size8.size4 {
  font-size: .5555555556em;
}
.katex .fontsize-ensurer.reset-size8.size5,
.katex .sizing.reset-size8.size5 {
  font-size: .625em;
}
.katex .fontsize-ensurer.reset-size8.size6,
.katex .sizing.reset-size8.size6 {
  font-size: .6944444444em;
}
.katex .fontsize-ensurer.reset-size8.size7,
.katex .sizing.reset-size8.size7 {
  font-size: .8333333333em;
}
.katex .fontsize-ensurer.reset-size8.size8,
.katex .sizing.reset-size8.size8 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size8.size9,
.katex .sizing.reset-size8.size9 {
  font-size: 1.2em;
}
.katex .fontsize-ensurer.reset-size8.size10,
.katex .sizing.reset-size8.size10 {
  font-size: 1.4402777778em;
}
.katex .fontsize-ensurer.reset-size8.size11,
.katex .sizing.reset-size8.size11 {
  font-size: 1.7277777778em;
}
.katex .fontsize-ensurer.reset-size9.size1,
.katex .sizing.reset-size9.size1 {
  font-size: .2893518519em;
}
.katex .fontsize-ensurer.reset-size9.size2,
.katex .sizing.reset-size9.size2 {
  font-size: .3472222222em;
}
.katex .fontsize-ensurer.reset-size9.size3,
.katex .sizing.reset-size9.size3 {
  font-size: .4050925926em;
}
.katex .fontsize-ensurer.reset-size9.size4,
.katex .sizing.reset-size9.size4 {
  font-size: .462962963em;
}
.katex .fontsize-ensurer.reset-size9.size5,
.katex .sizing.reset-size9.size5 {
  font-size: .5208333333em;
}
.katex .fontsize-ensurer.reset-size9.size6,
.katex .sizing.reset-size9.size6 {
  font-size: .5787037037em;
}
.katex .fontsize-ensurer.reset-size9.size7,
.katex .sizing.reset-size9.size7 {
  font-size: .6944444444em;
}
.katex .fontsize-ensurer.reset-size9.size8,
.katex .sizing.reset-size9.size8 {
  font-size: .8333333333em;
}
.katex .fontsize-ensurer.reset-size9.size9,
.katex .sizing.reset-size9.size9 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size9.size10,
.katex .sizing.reset-size9.size10 {
  font-size: 1.2002314815em;
}
.katex .fontsize-ensurer.reset-size9.size11,
.katex .sizing.reset-size9.size11 {
  font-size: 1.4398148148em;
}
.katex .fontsize-ensurer.reset-size10.size1,
.katex .sizing.reset-size10.size1 {
  font-size: .2410800386em;
}
.katex .fontsize-ensurer.reset-size10.size2,
.katex .sizing.reset-size10.size2 {
  font-size: .2892960463em;
}
.katex .fontsize-ensurer.reset-size10.size3,
.katex .sizing.reset-size10.size3 {
  font-size: .337512054em;
}
.katex .fontsize-ensurer.reset-size10.size4,
.katex .sizing.reset-size10.size4 {
  font-size: .3857280617em;
}
.katex .fontsize-ensurer.reset-size10.size5,
.katex .sizing.reset-size10.size5 {
  font-size: .4339440694em;
}
.katex .fontsize-ensurer.reset-size10.size6,
.katex .sizing.reset-size10.size6 {
  font-size: .4821600771em;
}
.katex .fontsize-ensurer.reset-size10.size7,
.katex .sizing.reset-size10.size7 {
  font-size: .5785920926em;
}
.katex .fontsize-ensurer.reset-size10.size8,
.katex .sizing.reset-size10.size8 {
  font-size: .6943105111em;
}
.katex .fontsize-ensurer.reset-size10.size9,
.katex .sizing.reset-size10.size9 {
  font-size: .8331726133em;
}
.katex .fontsize-ensurer.reset-size10.size10,
.katex .sizing.reset-size10.size10 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size10.size11,
.katex .sizing.reset-size10.size11 {
  font-size: 1.1996142719em;
}
.katex .fontsize-ensurer.reset-size11.size1,
.katex .sizing.reset-size11.size1 {
  font-size: .2009646302em;
}
.katex .fontsize-ensurer.reset-size11.size2,
.katex .sizing.reset-size11.size2 {
  font-size: .2411575563em;
}
.katex .fontsize-ensurer.reset-size11.size3,
.katex .sizing.reset-size11.size3 {
  font-size: .2813504823em;
}
.katex .fontsize-ensurer.reset-size11.size4,
.katex .sizing.reset-size11.size4 {
  font-size: .3215434084em;
}
.katex .fontsize-ensurer.reset-size11.size5,
.katex .sizing.reset-size11.size5 {
  font-size: .3617363344em;
}
.katex .fontsize-ensurer.reset-size11.size6,
.katex .sizing.reset-size11.size6 {
  font-size: .4019292605em;
}
.katex .fontsize-ensurer.reset-size11.size7,
.katex .sizing.reset-size11.size7 {
  font-size: .4823151125em;
}
.katex .fontsize-ensurer.reset-size11.size8,
.katex .sizing.reset-size11.size8 {
  font-size: .578778135em;
}
.katex .fontsize-ensurer.reset-size11.size9,
.katex .sizing.reset-size11.size9 {
  font-size: .6945337621em;
}
.katex .fontsize-ensurer.reset-size11.size10,
.katex .sizing.reset-size11.size10 {
  font-size: .8336012862em;
}
.katex .fontsize-ensurer.reset-size11.size11,
.katex .sizing.reset-size11.size11 {
  font-size: 1em;
}
.katex .delimsizing.size1 {
  font-family: KaTeX_Size1;
}
.katex .delimsizing.size2 {
  font-family: KaTeX_Size2;
}
.katex .delimsizing.size3 {
  font-family: KaTeX_Size3;
}
.katex .delimsizing.size4 {
  font-family: KaTeX_Size4;
}
.katex .delimsizing.mult .delim-size1 > span {
  font-family: KaTeX_Size1;
}
.katex .delimsizing.mult .delim-size4 > span {
  font-family: KaTeX_Size4;
}
.katex .nulldelimiter {
  display: inline-block;
  width: .12em;
}
.katex .delimcenter,
.katex .op-symbol {
  position: relative;
}
.katex .op-symbol.small-op {
  font-family: KaTeX_Size1;
}
.katex .op-symbol.large-op {
  font-family: KaTeX_Size2;
}
.katex .accent > .vlist-t,
.katex .op-limits > .vlist-t {
  text-align: center;
}
.katex .accent .accent-body {
  position: relative;
}
.katex .accent .accent-body:not(.accent-full) {
  width: 0;
}
.katex .overlay {
  display: block;
}
.katex .mtable .vertical-separator {
  display: inline-block;
  min-width: 1px;
}
.katex .mtable .arraycolsep {
  display: inline-block;
}
.katex .mtable .col-align-c > .vlist-t {
  text-align: center;
}
.katex .mtable .col-align-l > .vlist-t {
  text-align: left;
}
.katex .mtable .col-align-r > .vlist-t {
  text-align: right;
}
.katex .svg-align {
  text-align: left;
}
.katex svg {
  fill: currentColor;
  stroke: currentColor;
  fill-rule: nonzero;
  fill-opacity: 1;
  stroke-width: 1;
  stroke-linecap: butt;
  stroke-linejoin: miter;
  stroke-miterlimit: 4;
  stroke-dasharray: none;
  stroke-dashoffset: 0;
  stroke-opacity: 1;
  display: block;
  height: inherit;
  position: absolute;
  width: 100%;
}
.katex svg path {
  stroke: none;
}
.katex img {
  border-style: none;
  max-height: none;
  max-width: none;
  min-height: 0;
  min-width: 0;
}
.katex .stretchy {
  display: block;
  overflow: hidden;
  position: relative;
  width: 100%;
}
.katex .stretchy:after,
.katex .stretchy:before {
  content: "";
}
.katex .hide-tail {
  overflow: hidden;
  position: relative;
  width: 100%;
}
.katex .halfarrow-left {
  left: 0;
  overflow: hidden;
  position: absolute;
  width: 50.2%;
}
.katex .halfarrow-right {
  overflow: hidden;
  position: absolute;
  right: 0;
  width: 50.2%;
}
.katex .brace-left {
  left: 0;
  overflow: hidden;
  position: absolute;
  width: 25.1%;
}
.katex .brace-center {
  left: 25%;
  overflow: hidden;
  position: absolute;
  width: 50%;
}
.katex .brace-right {
  overflow: hidden;
  position: absolute;
  right: 0;
  width: 25.1%;
}
.katex .x-arrow-pad {
  padding: 0 .5em;
}
.katex .cd-arrow-pad {
  padding: 0 .55556em 0 .27778em;
}
.katex .mover,
.katex .munder,
.katex .x-arrow {
  text-align: center;
}
.katex .boxpad {
  padding: 0 .3em;
}
.katex .fbox,
.katex .fcolorbox {
  border: .04em solid;
  box-sizing: border-box;
}
.katex .cancel-pad {
  padding: 0 .2em;
}
.katex .cancel-lap {
  margin-left: -.2em;
  margin-right: -.2em;
}
.katex .sout {
  border-bottom-style: solid;
  border-bottom-width: .08em;
}
.katex .angl {
  border-right: .049em solid;
  border-top: .049em solid;
  box-sizing: border-box;
  margin-right: .03889em;
}
.katex .anglpad {
  padding: 0 .03889em;
}
.katex .eqn-num:before {
  content: "(" counter(katexEqnNo) ")";
  counter-increment: katexEqnNo;
}
.katex .mml-eqn-num:before {
  content: "(" counter(mmlEqnNo) ")";
  counter-increment: mmlEqnNo;
}
.katex .mtr-glue {
  width: 50%;
}
.katex .cd-vert-arrow {
  display: inline-block;
  position: relative;
}
.katex .cd-label-left {
  display: inline-block;
  position: absolute;
  right: calc(50% + .3em);
  text-align: left;
}
.katex .cd-label-right {
  display: inline-block;
  left: calc(50% + .3em);
  position: absolute;
  text-align: right;
}
.katex-display {
  display: block;
  margin: 1em 0;
  text-align: center;
}
.katex-display > .katex {
  display: block;
  text-align: center;
  white-space: nowrap;
}
.katex-display > .katex > .katex-html {
  display: block;
  position: relative;
}
.katex-display > .katex > .katex-html > .tag {
  position: absolute;
  right: 0;
}
.katex-display.leqno > .katex > .katex-html > .tag {
  left: 0;
  right: auto;
}
.katex-display.fleqn > .katex {
  padding-left: 2em;
  text-align: left;
}
body {
  counter-reset: katexEqnNo mmlEqnNo;
}

/* temp_stylePlugin:app\static\input.css */
@tailwind base;
@tailwind components;
@tailwind utilities;
html,
body {
  height: 100%;
  margin: 0;
  font-family: "Inter", sans-serif;
  background-color: #f3f4f6;
}
#chat-history {
  flex: 1;
  overflow-y: auto;
  padding: 1rem;
  display: flex;
  flex-direction: column;
  background-color: #ffffff;
  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
  margin: 1rem;
  border-radius: 0.5rem;
}
#chat-history::-webkit-scrollbar {
  width: 8px;
}
#chat-history::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 10px;
}
#chat-history::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 10px;
}
#chat-history::-webkit-scrollbar-thumb:hover {
  background: #555;
}
.message {
  padding: 0.5rem 0.75rem;
  margin-bottom: 0.5rem;
  border-radius: 0.5rem;
  max-width: 90%;
  word-wrap: break-word;
  line-height: 1.5;
}
.user-message {
  background-color: #dbeafe;
  align-self: flex-end;
  margin-left: auto;
  white-space: pre-wrap;
}
.ai-turn-container {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  width: 100%;
  margin-bottom: 0.5rem;
}
.ai-message {
  background-color: #e5e7eb;
  align-self: flex-start;
  margin-right: auto;
  max-width: 90%;
  padding: 0.5rem 0.75rem;
  border-radius: 0.5rem;
}
.ai-message p {
  margin-bottom: 0.5em;
}
.ai-message p:last-child {
  margin-bottom: 0;
}
.ai-message ul,
.ai-message ol {
  margin-left: 1.5em;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}
.ai-message li {
  margin-bottom: 0.25em;
}
.ai-message blockquote {
  border-left: 3px solid #ccc;
  padding-left: 0.8em;
  margin-left: 0;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  color: #555;
}
.ai-message code {
  background-color: rgba(0, 0, 0, 0.06);
  padding: 0.1em 0.3em;
  border-radius: 3px;
  font-family: monospace;
  font-size: 0.9em;
}
.ai-message pre[class*=language-] code {
  background-color: transparent;
  padding: 0;
  border-radius: 0;
  font-size: inherit;
}
.ai-message a {
  color: #007bff;
  text-decoration: underline;
}
.ai-message a:hover {
  color: #0056b3;
}
.ai-message hr {
  border: none;
  border-top: 1px solid #ccc;
  margin: 1em 0;
}
.ai-message table {
  border-collapse: collapse;
  margin: 1em 0;
  width: auto;
}
.ai-message th,
.ai-message td {
  border: 1px solid #ccc;
  padding: 0.3em 0.6em;
  text-align: left;
}
.ai-message th {
  background-color: #f2f2f2;
  font-weight: bold;
}
.code-reference {
  font-family: monospace;
  background-color: rgba(0, 0, 0, 0.08);
  padding: 1px 5px;
  border-radius: 4px;
  font-size: 0.85em;
  white-space: nowrap;
  margin: 0 2px;
}
.loading-dots {
  display: inline-block;
}
.loading-dots::after {
  display: inline-block;
  position: relative;
  left: 1px;
  animation: ellipsis 1.5s infinite;
  content: ".";
  width: 1.5em;
  text-align: left;
  vertical-align: bottom;
}
@keyframes ellipsis {
  0% {
    content: ".";
  }
  33% {
    content: "..";
  }
  66% {
    content: "...";
  }
}
.thinking-area {
  width: 100%;
  max-width: 90%;
  margin-bottom: 4px;
  align-self: flex-start;
  font-size: 0.9em;
}
.thinking-area details {
  width: 100%;
  border: 1px dashed #aaa;
  border-radius: 6px;
  background-color: #f0f0f0;
  overflow: hidden;
}
.thinking-summary {
  padding: 3px 8px;
  cursor: pointer;
  font-weight: normal;
  color: #444;
  background-color: #e0e0e0;
  border-bottom: 1px dashed #aaa;
  outline: none;
  user-select: none;
  list-style: none;
  display: block;
  transition: background-color 0.15s ease;
}
.thinking-summary:hover {
  background-color: #d0d0d0;
}
.thinking-summary::-webkit-details-marker {
  display: none;
}
.thinking-summary .dots {
  display: inline-block;
  margin-left: 4px;
}
.thinking-summary .dots::after {
  display: inline-block;
  position: relative;
  left: 1px;
  animation: ellipsis 1.5s infinite;
  content: ".";
  width: 1.5em;
  text-align: left;
  vertical-align: bottom;
}
.thinking-area details[open] > .thinking-summary .dots {
  display: none;
}
.thinking-area details pre {
  margin: 0;
  padding: 8px;
  background-color: #f8f8f8;
  white-space: pre-wrap;
  word-wrap: break-word;
  overflow-wrap: break-word;
  max-height: 200px;
  overflow-y: auto;
}
.code-blocks-area {
  width: 100%;
  max-width: 90%;
  align-self: flex-start;
  margin-top: 0.5rem;
}
.code-block-container {
  margin-bottom: 0.75rem;
  border-radius: 0.375rem;
  overflow: hidden;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
}
.code-block-header,
.code-output-header {
  display: flex;
  align-items: center;
  background-color: #e5e7eb;
  padding: 0.25rem 0.5rem;
  font-size: 0.8em;
  color: #4b5563;
  gap: 0.625rem;
}
.code-output-header {
  margin-top: 0.25rem;
}
.code-block-buttons,
.output-header-buttons {
  display: flex;
  align-items: center;
  gap: 0.375rem;
  flex-shrink: 0;
}
.code-block-title,
.output-header-title {
  font-weight: 500;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.code-block-title {
  flex-shrink: 1;
  flex-grow: 1;
  text-align: left;
}
.output-header-title {
  flex-shrink: 0;
  margin-right: 0.625rem;
}
.output-header-button-placeholder {
  display: inline-block;
  width: 24px;
  height: 24px;
  flex-shrink: 0;
}
.code-status-span {
  margin-left: auto;
  text-align: right;
  font-style: italic;
  font-size: 0.9em;
  padding: 0 0.3125rem;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  color: #6b7280;
  flex-shrink: 0;
}
.code-status-span.running,
.code-status-span.stopping {
  color: #ca8a04;
  font-weight: 500;
}
.code-status-span.success {
  color: #16a34a;
  font-weight: 500;
}
.code-status-span.error,
.code-status-span.stopped {
  color: #dc2626;
  font-weight: 500;
}
.code-action-btn {
  background-color: #d1d5db;
  color: #4b5563;
  border: none;
  padding: 0.1875rem 0.4375rem;
  border-radius: 0.25rem;
  cursor: pointer;
  font-size: 0.9em;
  line-height: 1.2;
  transition: background-color 0.2s ease, color 0.2s ease;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  white-space: nowrap;
}
.code-action-btn:hover {
  background-color: #9ca3af;
  color: #1f2937;
}
.code-action-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
.code-action-btn.copied {
  background-color: #16a34a;
  color: white;
}
.code-output-header .code-action-btn {
  background-color: #d1d5db;
  color: #4b5563;
  border: none;
  padding: 0.1875rem 0.4375rem;
  border-radius: 0.25rem;
  cursor: pointer;
  font-size: 0.9em;
  line-height: 1.2;
  transition: background-color 0.2s ease, color 0.2s ease;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  white-space: nowrap;
}
.code-output-header .code-action-btn:hover {
  background-color: #9ca3af;
  color: #1f2937;
}
.run-code-btn {
  padding: 4px;
  width: 24px;
  height: 24px;
  font-size: 1em;
  background-color: transparent !important;
  border: none !important;
  color: #9ca3af;
  transition: color 0.2s ease;
}
.run-code-btn:hover {
  color: #4b5563;
  background-color: transparent !important;
}
.run-code-btn[data-status=idle] {
  color: #16a34a;
}
.run-code-btn[data-status=idle]:hover {
  color: #15803d;
}
.run-code-btn[data-status=running] {
  color: #dc2626;
}
.run-code-btn[data-status=running]:hover {
  color: #b91c1c;
}
.run-code-btn[data-status=stopping] {
  color: #f59e0b;
  cursor: wait;
  animation: spin 1s linear infinite;
}
.run-code-btn[data-status=stopping]:hover {
  color: #d97706;
}
@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
.code-block-container > pre[class*=language-] {
  margin: 0;
  border: 1px solid #d1d5db;
  border-top: none;
  border-bottom: none !important;
  overflow: hidden;
}
.code-block-container > pre[class*=language-] > code[class*=language-] {
  outline: none;
  white-space: pre-wrap !important;
  word-wrap: break-word !important;
  display: block;
  min-height: 1.5em;
  padding: 0.5em;
}
.code-block-container > pre[class*=language-] > code[class*=language-]:focus {
  background-color: rgba(0, 0, 0, 0.03);
}
.code-output-console {
  background-color: #1f2937;
  color: #f3f4f6;
  padding: 0;
  border: 1px solid #4b5563;
  border-top: none !important;
  max-height: 250px;
  overflow-y: auto;
  font-family: monospace;
  font-size: 0.85em;
  line-height: 1.4;
}
.code-output-console pre {
  margin: 0;
  white-space: pre-wrap;
  word-wrap: break-word;
  color: inherit;
  border: none !important;
  padding: 0.5rem;
  background-color: transparent;
  outline: none !important;
}
.code-output-console span {
  display: inline;
  white-space: pre-wrap;
}
.code-output-console span.stdout-output {
  color: #ffffff;
}
.code-output-console span.stderr-output {
  color: #f87171;
}
.code-block-container > pre.hidden,
.code-output-console.hidden,
.code-output-header.hidden {
  display: none !important;
}
footer {
  padding: 1rem;
  background-color: #e5e7eb;
  border-top: 1px solid #d1d5db;
}
#chat-form {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}
.think-checkbox-container {
  display: flex;
  align-items: center;
  font-size: 0.9em;
  color: #4b5563;
}
.think-checkbox-container input {
  margin-right: 4px;
  cursor: pointer;
}
.think-checkbox-container label {
  cursor: pointer;
  user-select: none;
}
#message-input {
  flex-grow: 1;
  padding: 0.5rem 0.75rem;
  border: 1px solid #d1d5db;
  border-radius: 0.5rem;
  outline: none;
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
}
#message-input:focus {
  border-color: #2563eb;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
}
#send-button {
  background-color: #2563eb;
  color: white;
  font-weight: 500;
  padding: 0.5rem 1rem;
  border-radius: 0.5rem;
  border: none;
  cursor: pointer;
  transition: background-color 0.2s ease;
}
#send-button:hover {
  background-color: #1d4ed8;
}
#send-button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
.error-message {
  background-color: #fee2e2;
  color: #991b1b;
  border: 1px solid #fecaca;
  align-self: flex-start;
  margin-right: auto;
  padding: 0.5rem 0.75rem;
  border-radius: 0.5rem;
  max-width: 90%;
  word-wrap: break-word;
  margin-bottom: 0.5rem;
  white-space: pre-wrap;
}
.system-message {
  width: 100%;
  text-align: center;
  font-size: 0.875rem;
  color: #6b7280;
  font-style: italic;
  margin: 0.25rem 0;
}
span[data-katex-rendered=true] .katex-display {
  margin: 0.5em 0;
  overflow-x: auto;
  overflow-y: hidden;
  padding: 0.2em 0;
}
span[data-katex-rendered=true] .katex {
  line-height: normal;
  vertical-align: baseline;
  font-size: 1em;
}
.katex-error {
  color: #cc0000;
  background-color: #fdd;
  border: 1px solid #cc0000;
  padding: 2px 4px;
  border-radius: 3px;
}
.hidden {
  display: none !important;
}

/* temp_stylePlugin:node_modules\prismjs\themes\prism-tomorrow.css */
code[class*=language-],
pre[class*=language-] {
  color: #ccc;
  background: none;
  font-family:
    Consolas,
    Monaco,
    "Andale Mono",
    "Ubuntu Mono",
    monospace;
  font-size: 1em;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.5;
  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;
  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}
pre[class*=language-] {
  padding: 1em;
  margin: .5em 0;
  overflow: auto;
}
:not(pre) > code[class*=language-],
pre[class*=language-] {
  background: #2d2d2d;
}
:not(pre) > code[class*=language-] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
}
.token.comment,
.token.block-comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: #999;
}
.token.punctuation {
  color: #ccc;
}
.token.tag,
.token.attr-name,
.token.namespace,
.token.deleted {
  color: #e2777a;
}
.token.function-name {
  color: #6196cc;
}
.token.boolean,
.token.number,
.token.function {
  color: #f08d49;
}
.token.property,
.token.class-name,
.token.constant,
.token.symbol {
  color: #f8c555;
}
.token.selector,
.token.important,
.token.atrule,
.token.keyword,
.token.builtin {
  color: #cc99cd;
}
.token.string,
.token.char,
.token.attr-value,
.token.regex,
.token.variable {
  color: #7ec699;
}
.token.operator,
.token.entity,
.token.url {
  color: #67cdcc;
}
.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}
.token.entity {
  cursor: help;
}
.token.inserted {
  color: green;
}

/* temp_stylePlugin:node_modules\katex\dist\katex.min.css */
@font-face {
  font-family: KaTeX_AMS;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_AMS-Regular-U6PRYMIZ.woff2") format("woff2"),
    url("./assets/KaTeX_AMS-Regular-CYEKBG2K.woff") format("woff"),
    url("./assets/KaTeX_AMS-Regular-JKX5W2C4.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Caligraphic;
  font-style: normal;
  font-weight: 700;
  src:
    url("./assets/KaTeX_Caligraphic-Bold-5QL5CMTE.woff2") format("woff2"),
    url("./assets/KaTeX_Caligraphic-Bold-WZ3QSGD3.woff") format("woff"),
    url("./assets/KaTeX_Caligraphic-Bold-ZTS3R3HK.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Caligraphic;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Caligraphic-Regular-KX5MEWCF.woff2") format("woff2"),
    url("./assets/KaTeX_Caligraphic-Regular-3LKEU76G.woff") format("woff"),
    url("./assets/KaTeX_Caligraphic-Regular-A7XRTZ5Q.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Fraktur;
  font-style: normal;
  font-weight: 700;
  src:
    url("./assets/KaTeX_Fraktur-Bold-2QVFK6NQ.woff2") format("woff2"),
    url("./assets/KaTeX_Fraktur-Bold-T4SWXBMT.woff") format("woff"),
    url("./assets/KaTeX_Fraktur-Bold-WGHVTYOR.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Fraktur;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Fraktur-Regular-2PEIFJSJ.woff2") format("woff2"),
    url("./assets/KaTeX_Fraktur-Regular-PQMHCIK6.woff") format("woff"),
    url("./assets/KaTeX_Fraktur-Regular-5U4OPH2X.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Main;
  font-style: normal;
  font-weight: 700;
  src:
    url("./assets/KaTeX_Main-Bold-YP5VVQRP.woff2") format("woff2"),
    url("./assets/KaTeX_Main-Bold-2GA4IZIN.woff") format("woff"),
    url("./assets/KaTeX_Main-Bold-W5FBVCZM.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Main;
  font-style: italic;
  font-weight: 700;
  src:
    url("./assets/KaTeX_Main-BoldItalic-N4V3DX7S.woff2") format("woff2"),
    url("./assets/KaTeX_Main-BoldItalic-4P4C7HJH.woff") format("woff"),
    url("./assets/KaTeX_Main-BoldItalic-ODMLBJJQ.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Main;
  font-style: italic;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Main-Italic-RELBIK7M.woff2") format("woff2"),
    url("./assets/KaTeX_Main-Italic-SASNQFN2.woff") format("woff"),
    url("./assets/KaTeX_Main-Italic-I43T2HSR.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Main;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Main-Regular-ARRPAO67.woff2") format("woff2"),
    url("./assets/KaTeX_Main-Regular-P5I74A2A.woff") format("woff"),
    url("./assets/KaTeX_Main-Regular-W74P5G27.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Math;
  font-style: italic;
  font-weight: 700;
  src:
    url("./assets/KaTeX_Math-BoldItalic-K4WTGH3J.woff2") format("woff2"),
    url("./assets/KaTeX_Math-BoldItalic-6EBV3DK5.woff") format("woff"),
    url("./assets/KaTeX_Math-BoldItalic-VB447A4D.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Math;
  font-style: italic;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Math-Italic-6KGCHLFN.woff2") format("woff2"),
    url("./assets/KaTeX_Math-Italic-KKK3USB2.woff") format("woff"),
    url("./assets/KaTeX_Math-Italic-SON4MRCA.ttf") format("truetype");
}
@font-face {
  font-family: "KaTeX_SansSerif";
  font-style: normal;
  font-weight: 700;
  src:
    url("./assets/KaTeX_SansSerif-Bold-RRNVJFFW.woff2") format("woff2"),
    url("./assets/KaTeX_SansSerif-Bold-X5M5EMOD.woff") format("woff"),
    url("./assets/KaTeX_SansSerif-Bold-STQ6RXC7.ttf") format("truetype");
}
@font-face {
  font-family: "KaTeX_SansSerif";
  font-style: italic;
  font-weight: 400;
  src:
    url("./assets/KaTeX_SansSerif-Italic-HMPFTM52.woff2") format("woff2"),
    url("./assets/KaTeX_SansSerif-Italic-PSN4QKYX.woff") format("woff"),
    url("./assets/KaTeX_SansSerif-Italic-WTBAZBGY.ttf") format("truetype");
}
@font-face {
  font-family: "KaTeX_SansSerif";
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_SansSerif-Regular-XIQ62X4E.woff2") format("woff2"),
    url("./assets/KaTeX_SansSerif-Regular-OQCII6EP.woff") format("woff"),
    url("./assets/KaTeX_SansSerif-Regular-2TL3USAE.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Script;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Script-Regular-APUWIHLP.woff2") format("woff2"),
    url("./assets/KaTeX_Script-Regular-A5IFOEBS.woff") format("woff"),
    url("./assets/KaTeX_Script-Regular-72OLXYNA.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Size1;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Size1-Regular-5LRUTBFT.woff2") format("woff2"),
    url("./assets/KaTeX_Size1-Regular-4HRHTS65.woff") format("woff"),
    url("./assets/KaTeX_Size1-Regular-7K6AASVL.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Size2;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Size2-Regular-LELKET5D.woff2") format("woff2"),
    url("./assets/KaTeX_Size2-Regular-K5ZHAIS6.woff") format("woff"),
    url("./assets/KaTeX_Size2-Regular-222HN3GT.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Size3;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Size3-Regular-WQRQ47UD.woff2") format("woff2"),
    url("./assets/KaTeX_Size3-Regular-TLFPAHDE.woff") format("woff"),
    url("./assets/KaTeX_Size3-Regular-UFCO6WCA.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Size4;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Size4-Regular-CDMV7U5C.woff2") format("woff2"),
    url("./assets/KaTeX_Size4-Regular-PKMWZHNC.woff") format("woff"),
    url("./assets/KaTeX_Size4-Regular-7PGNVPQK.ttf") format("truetype");
}
@font-face {
  font-family: KaTeX_Typewriter;
  font-style: normal;
  font-weight: 400;
  src:
    url("./assets/KaTeX_Typewriter-Regular-VBYJ4NRC.woff2") format("woff2"),
    url("./assets/KaTeX_Typewriter-Regular-MJMFSK64.woff") format("woff"),
    url("./assets/KaTeX_Typewriter-Regular-3F5K6SQ6.ttf") format("truetype");
}
.katex {
  font:
    normal 1.21em KaTeX_Main,
    Times New Roman,
    serif;
  line-height: 1.2;
  text-indent: 0;
  text-rendering: auto;
}
.katex * {
  -ms-high-contrast-adjust: none !important;
  border-color: currentColor;
}
.katex .katex-version:after {
  content: "0.16.22";
}
.katex .katex-mathml {
  clip: rect(1px, 1px, 1px, 1px);
  border: 0;
  height: 1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
}
.katex .katex-html > .newline {
  display: block;
}
.katex .base {
  position: relative;
  white-space: nowrap;
  width: -webkit-min-content;
  width: -moz-min-content;
  width: min-content;
}
.katex .base,
.katex .strut {
  display: inline-block;
}
.katex .textbf {
  font-weight: 700;
}
.katex .textit {
  font-style: italic;
}
.katex .textrm {
  font-family: KaTeX_Main;
}
.katex .textsf {
  font-family: KaTeX_SansSerif;
}
.katex .texttt {
  font-family: KaTeX_Typewriter;
}
.katex .mathnormal {
  font-family: KaTeX_Math;
  font-style: italic;
}
.katex .mathit {
  font-family: KaTeX_Main;
  font-style: italic;
}
.katex .mathrm {
  font-style: normal;
}
.katex .mathbf {
  font-family: KaTeX_Main;
  font-weight: 700;
}
.katex .boldsymbol {
  font-family: KaTeX_Math;
  font-style: italic;
  font-weight: 700;
}
.katex .amsrm,
.katex .mathbb,
.katex .textbb {
  font-family: KaTeX_AMS;
}
.katex .mathcal {
  font-family: KaTeX_Caligraphic;
}
.katex .mathfrak,
.katex .textfrak {
  font-family: KaTeX_Fraktur;
}
.katex .mathboldfrak,
.katex .textboldfrak {
  font-family: KaTeX_Fraktur;
  font-weight: 700;
}
.katex .mathtt {
  font-family: KaTeX_Typewriter;
}
.katex .mathscr,
.katex .textscr {
  font-family: KaTeX_Script;
}
.katex .mathsf,
.katex .textsf {
  font-family: KaTeX_SansSerif;
}
.katex .mathboldsf,
.katex .textboldsf {
  font-family: KaTeX_SansSerif;
  font-weight: 700;
}
.katex .mathitsf,
.katex .mathsfit,
.katex .textitsf {
  font-family: KaTeX_SansSerif;
  font-style: italic;
}
.katex .mainrm {
  font-family: KaTeX_Main;
  font-style: normal;
}
.katex .vlist-t {
  border-collapse: collapse;
  display: inline-table;
  table-layout: fixed;
}
.katex .vlist-r {
  display: table-row;
}
.katex .vlist {
  display: table-cell;
  position: relative;
  vertical-align: bottom;
}
.katex .vlist > span {
  display: block;
  height: 0;
  position: relative;
}
.katex .vlist > span > span {
  display: inline-block;
}
.katex .vlist > span > .pstrut {
  overflow: hidden;
  width: 0;
}
.katex .vlist-t2 {
  margin-right: -2px;
}
.katex .vlist-s {
  display: table-cell;
  font-size: 1px;
  min-width: 2px;
  vertical-align: bottom;
  width: 2px;
}
.katex .vbox {
  align-items: baseline;
  display: inline-flex;
  flex-direction: column;
}
.katex .hbox {
  width: 100%;
}
.katex .hbox,
.katex .thinbox {
  display: inline-flex;
  flex-direction: row;
}
.katex .thinbox {
  max-width: 0;
  width: 0;
}
.katex .msupsub {
  text-align: left;
}
.katex .mfrac > span > span {
  text-align: center;
}
.katex .mfrac .frac-line {
  border-bottom-style: solid;
  display: inline-block;
  width: 100%;
}
.katex .hdashline,
.katex .hline,
.katex .mfrac .frac-line,
.katex .overline .overline-line,
.katex .rule,
.katex .underline .underline-line {
  min-height: 1px;
}
.katex .mspace {
  display: inline-block;
}
.katex .clap,
.katex .llap,
.katex .rlap {
  position: relative;
  width: 0;
}
.katex .clap > .inner,
.katex .llap > .inner,
.katex .rlap > .inner {
  position: absolute;
}
.katex .clap > .fix,
.katex .llap > .fix,
.katex .rlap > .fix {
  display: inline-block;
}
.katex .llap > .inner {
  right: 0;
}
.katex .clap > .inner,
.katex .rlap > .inner {
  left: 0;
}
.katex .clap > .inner > span {
  margin-left: -50%;
  margin-right: 50%;
}
.katex .rule {
  border: 0 solid;
  display: inline-block;
  position: relative;
}
.katex .hline,
.katex .overline .overline-line,
.katex .underline .underline-line {
  border-bottom-style: solid;
  display: inline-block;
  width: 100%;
}
.katex .hdashline {
  border-bottom-style: dashed;
  display: inline-block;
  width: 100%;
}
.katex .sqrt > .root {
  margin-left: .2777777778em;
  margin-right: -.5555555556em;
}
.katex .fontsize-ensurer.reset-size1.size1,
.katex .sizing.reset-size1.size1 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size1.size2,
.katex .sizing.reset-size1.size2 {
  font-size: 1.2em;
}
.katex .fontsize-ensurer.reset-size1.size3,
.katex .sizing.reset-size1.size3 {
  font-size: 1.4em;
}
.katex .fontsize-ensurer.reset-size1.size4,
.katex .sizing.reset-size1.size4 {
  font-size: 1.6em;
}
.katex .fontsize-ensurer.reset-size1.size5,
.katex .sizing.reset-size1.size5 {
  font-size: 1.8em;
}
.katex .fontsize-ensurer.reset-size1.size6,
.katex .sizing.reset-size1.size6 {
  font-size: 2em;
}
.katex .fontsize-ensurer.reset-size1.size7,
.katex .sizing.reset-size1.size7 {
  font-size: 2.4em;
}
.katex .fontsize-ensurer.reset-size1.size8,
.katex .sizing.reset-size1.size8 {
  font-size: 2.88em;
}
.katex .fontsize-ensurer.reset-size1.size9,
.katex .sizing.reset-size1.size9 {
  font-size: 3.456em;
}
.katex .fontsize-ensurer.reset-size1.size10,
.katex .sizing.reset-size1.size10 {
  font-size: 4.148em;
}
.katex .fontsize-ensurer.reset-size1.size11,
.katex .sizing.reset-size1.size11 {
  font-size: 4.976em;
}
.katex .fontsize-ensurer.reset-size2.size1,
.katex .sizing.reset-size2.size1 {
  font-size: .8333333333em;
}
.katex .fontsize-ensurer.reset-size2.size2,
.katex .sizing.reset-size2.size2 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size2.size3,
.katex .sizing.reset-size2.size3 {
  font-size: 1.1666666667em;
}
.katex .fontsize-ensurer.reset-size2.size4,
.katex .sizing.reset-size2.size4 {
  font-size: 1.3333333333em;
}
.katex .fontsize-ensurer.reset-size2.size5,
.katex .sizing.reset-size2.size5 {
  font-size: 1.5em;
}
.katex .fontsize-ensurer.reset-size2.size6,
.katex .sizing.reset-size2.size6 {
  font-size: 1.6666666667em;
}
.katex .fontsize-ensurer.reset-size2.size7,
.katex .sizing.reset-size2.size7 {
  font-size: 2em;
}
.katex .fontsize-ensurer.reset-size2.size8,
.katex .sizing.reset-size2.size8 {
  font-size: 2.4em;
}
.katex .fontsize-ensurer.reset-size2.size9,
.katex .sizing.reset-size2.size9 {
  font-size: 2.88em;
}
.katex .fontsize-ensurer.reset-size2.size10,
.katex .sizing.reset-size2.size10 {
  font-size: 3.4566666667em;
}
.katex .fontsize-ensurer.reset-size2.size11,
.katex .sizing.reset-size2.size11 {
  font-size: 4.1466666667em;
}
.katex .fontsize-ensurer.reset-size3.size1,
.katex .sizing.reset-size3.size1 {
  font-size: .7142857143em;
}
.katex .fontsize-ensurer.reset-size3.size2,
.katex .sizing.reset-size3.size2 {
  font-size: .8571428571em;
}
.katex .fontsize-ensurer.reset-size3.size3,
.katex .sizing.reset-size3.size3 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size3.size4,
.katex .sizing.reset-size3.size4 {
  font-size: 1.1428571429em;
}
.katex .fontsize-ensurer.reset-size3.size5,
.katex .sizing.reset-size3.size5 {
  font-size: 1.2857142857em;
}
.katex .fontsize-ensurer.reset-size3.size6,
.katex .sizing.reset-size3.size6 {
  font-size: 1.4285714286em;
}
.katex .fontsize-ensurer.reset-size3.size7,
.katex .sizing.reset-size3.size7 {
  font-size: 1.7142857143em;
}
.katex .fontsize-ensurer.reset-size3.size8,
.katex .sizing.reset-size3.size8 {
  font-size: 2.0571428571em;
}
.katex .fontsize-ensurer.reset-size3.size9,
.katex .sizing.reset-size3.size9 {
  font-size: 2.4685714286em;
}
.katex .fontsize-ensurer.reset-size3.size10,
.katex .sizing.reset-size3.size10 {
  font-size: 2.9628571429em;
}
.katex .fontsize-ensurer.reset-size3.size11,
.katex .sizing.reset-size3.size11 {
  font-size: 3.5542857143em;
}
.katex .fontsize-ensurer.reset-size4.size1,
.katex .sizing.reset-size4.size1 {
  font-size: .625em;
}
.katex .fontsize-ensurer.reset-size4.size2,
.katex .sizing.reset-size4.size2 {
  font-size: .75em;
}
.katex .fontsize-ensurer.reset-size4.size3,
.katex .sizing.reset-size4.size3 {
  font-size: .875em;
}
.katex .fontsize-ensurer.reset-size4.size4,
.katex .sizing.reset-size4.size4 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size4.size5,
.katex .sizing.reset-size4.size5 {
  font-size: 1.125em;
}
.katex .fontsize-ensurer.reset-size4.size6,
.katex .sizing.reset-size4.size6 {
  font-size: 1.25em;
}
.katex .fontsize-ensurer.reset-size4.size7,
.katex .sizing.reset-size4.size7 {
  font-size: 1.5em;
}
.katex .fontsize-ensurer.reset-size4.size8,
.katex .sizing.reset-size4.size8 {
  font-size: 1.8em;
}
.katex .fontsize-ensurer.reset-size4.size9,
.katex .sizing.reset-size4.size9 {
  font-size: 2.16em;
}
.katex .fontsize-ensurer.reset-size4.size10,
.katex .sizing.reset-size4.size10 {
  font-size: 2.5925em;
}
.katex .fontsize-ensurer.reset-size4.size11,
.katex .sizing.reset-size4.size11 {
  font-size: 3.11em;
}
.katex .fontsize-ensurer.reset-size5.size1,
.katex .sizing.reset-size5.size1 {
  font-size: .5555555556em;
}
.katex .fontsize-ensurer.reset-size5.size2,
.katex .sizing.reset-size5.size2 {
  font-size: .6666666667em;
}
.katex .fontsize-ensurer.reset-size5.size3,
.katex .sizing.reset-size5.size3 {
  font-size: .7777777778em;
}
.katex .fontsize-ensurer.reset-size5.size4,
.katex .sizing.reset-size5.size4 {
  font-size: .8888888889em;
}
.katex .fontsize-ensurer.reset-size5.size5,
.katex .sizing.reset-size5.size5 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size5.size6,
.katex .sizing.reset-size5.size6 {
  font-size: 1.1111111111em;
}
.katex .fontsize-ensurer.reset-size5.size7,
.katex .sizing.reset-size5.size7 {
  font-size: 1.3333333333em;
}
.katex .fontsize-ensurer.reset-size5.size8,
.katex .sizing.reset-size5.size8 {
  font-size: 1.6em;
}
.katex .fontsize-ensurer.reset-size5.size9,
.katex .sizing.reset-size5.size9 {
  font-size: 1.92em;
}
.katex .fontsize-ensurer.reset-size5.size10,
.katex .sizing.reset-size5.size10 {
  font-size: 2.3044444444em;
}
.katex .fontsize-ensurer.reset-size5.size11,
.katex .sizing.reset-size5.size11 {
  font-size: 2.7644444444em;
}
.katex .fontsize-ensurer.reset-size6.size1,
.katex .sizing.reset-size6.size1 {
  font-size: .5em;
}
.katex .fontsize-ensurer.reset-size6.size2,
.katex .sizing.reset-size6.size2 {
  font-size: .6em;
}
.katex .fontsize-ensurer.reset-size6.size3,
.katex .sizing.reset-size6.size3 {
  font-size: .7em;
}
.katex .fontsize-ensurer.reset-size6.size4,
.katex .sizing.reset-size6.size4 {
  font-size: .8em;
}
.katex .fontsize-ensurer.reset-size6.size5,
.katex .sizing.reset-size6.size5 {
  font-size: .9em;
}
.katex .fontsize-ensurer.reset-size6.size6,
.katex .sizing.reset-size6.size6 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size6.size7,
.katex .sizing.reset-size6.size7 {
  font-size: 1.2em;
}
.katex .fontsize-ensurer.reset-size6.size8,
.katex .sizing.reset-size6.size8 {
  font-size: 1.44em;
}
.katex .fontsize-ensurer.reset-size6.size9,
.katex .sizing.reset-size6.size9 {
  font-size: 1.728em;
}
.katex .fontsize-ensurer.reset-size6.size10,
.katex .sizing.reset-size6.size10 {
  font-size: 2.074em;
}
.katex .fontsize-ensurer.reset-size6.size11,
.katex .sizing.reset-size6.size11 {
  font-size: 2.488em;
}
.katex .fontsize-ensurer.reset-size7.size1,
.katex .sizing.reset-size7.size1 {
  font-size: .4166666667em;
}
.katex .fontsize-ensurer.reset-size7.size2,
.katex .sizing.reset-size7.size2 {
  font-size: .5em;
}
.katex .fontsize-ensurer.reset-size7.size3,
.katex .sizing.reset-size7.size3 {
  font-size: .5833333333em;
}
.katex .fontsize-ensurer.reset-size7.size4,
.katex .sizing.reset-size7.size4 {
  font-size: .6666666667em;
}
.katex .fontsize-ensurer.reset-size7.size5,
.katex .sizing.reset-size7.size5 {
  font-size: .75em;
}
.katex .fontsize-ensurer.reset-size7.size6,
.katex .sizing.reset-size7.size6 {
  font-size: .8333333333em;
}
.katex .fontsize-ensurer.reset-size7.size7,
.katex .sizing.reset-size7.size7 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size7.size8,
.katex .sizing.reset-size7.size8 {
  font-size: 1.2em;
}
.katex .fontsize-ensurer.reset-size7.size9,
.katex .sizing.reset-size7.size9 {
  font-size: 1.44em;
}
.katex .fontsize-ensurer.reset-size7.size10,
.katex .sizing.reset-size7.size10 {
  font-size: 1.7283333333em;
}
.katex .fontsize-ensurer.reset-size7.size11,
.katex .sizing.reset-size7.size11 {
  font-size: 2.0733333333em;
}
.katex .fontsize-ensurer.reset-size8.size1,
.katex .sizing.reset-size8.size1 {
  font-size: .3472222222em;
}
.katex .fontsize-ensurer.reset-size8.size2,
.katex .sizing.reset-size8.size2 {
  font-size: .4166666667em;
}
.katex .fontsize-ensurer.reset-size8.size3,
.katex .sizing.reset-size8.size3 {
  font-size: .4861111111em;
}
.katex .fontsize-ensurer.reset-size8.size4,
.katex .sizing.reset-size8.size4 {
  font-size: .5555555556em;
}
.katex .fontsize-ensurer.reset-size8.size5,
.katex .sizing.reset-size8.size5 {
  font-size: .625em;
}
.katex .fontsize-ensurer.reset-size8.size6,
.katex .sizing.reset-size8.size6 {
  font-size: .6944444444em;
}
.katex .fontsize-ensurer.reset-size8.size7,
.katex .sizing.reset-size8.size7 {
  font-size: .8333333333em;
}
.katex .fontsize-ensurer.reset-size8.size8,
.katex .sizing.reset-size8.size8 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size8.size9,
.katex .sizing.reset-size8.size9 {
  font-size: 1.2em;
}
.katex .fontsize-ensurer.reset-size8.size10,
.katex .sizing.reset-size8.size10 {
  font-size: 1.4402777778em;
}
.katex .fontsize-ensurer.reset-size8.size11,
.katex .sizing.reset-size8.size11 {
  font-size: 1.7277777778em;
}
.katex .fontsize-ensurer.reset-size9.size1,
.katex .sizing.reset-size9.size1 {
  font-size: .2893518519em;
}
.katex .fontsize-ensurer.reset-size9.size2,
.katex .sizing.reset-size9.size2 {
  font-size: .3472222222em;
}
.katex .fontsize-ensurer.reset-size9.size3,
.katex .sizing.reset-size9.size3 {
  font-size: .4050925926em;
}
.katex .fontsize-ensurer.reset-size9.size4,
.katex .sizing.reset-size9.size4 {
  font-size: .462962963em;
}
.katex .fontsize-ensurer.reset-size9.size5,
.katex .sizing.reset-size9.size5 {
  font-size: .5208333333em;
}
.katex .fontsize-ensurer.reset-size9.size6,
.katex .sizing.reset-size9.size6 {
  font-size: .5787037037em;
}
.katex .fontsize-ensurer.reset-size9.size7,
.katex .sizing.reset-size9.size7 {
  font-size: .6944444444em;
}
.katex .fontsize-ensurer.reset-size9.size8,
.katex .sizing.reset-size9.size8 {
  font-size: .8333333333em;
}
.katex .fontsize-ensurer.reset-size9.size9,
.katex .sizing.reset-size9.size9 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size9.size10,
.katex .sizing.reset-size9.size10 {
  font-size: 1.2002314815em;
}
.katex .fontsize-ensurer.reset-size9.size11,
.katex .sizing.reset-size9.size11 {
  font-size: 1.4398148148em;
}
.katex .fontsize-ensurer.reset-size10.size1,
.katex .sizing.reset-size10.size1 {
  font-size: .2410800386em;
}
.katex .fontsize-ensurer.reset-size10.size2,
.katex .sizing.reset-size10.size2 {
  font-size: .2892960463em;
}
.katex .fontsize-ensurer.reset-size10.size3,
.katex .sizing.reset-size10.size3 {
  font-size: .337512054em;
}
.katex .fontsize-ensurer.reset-size10.size4,
.katex .sizing.reset-size10.size4 {
  font-size: .3857280617em;
}
.katex .fontsize-ensurer.reset-size10.size5,
.katex .sizing.reset-size10.size5 {
  font-size: .4339440694em;
}
.katex .fontsize-ensurer.reset-size10.size6,
.katex .sizing.reset-size10.size6 {
  font-size: .4821600771em;
}
.katex .fontsize-ensurer.reset-size10.size7,
.katex .sizing.reset-size10.size7 {
  font-size: .5785920926em;
}
.katex .fontsize-ensurer.reset-size10.size8,
.katex .sizing.reset-size10.size8 {
  font-size: .6943105111em;
}
.katex .fontsize-ensurer.reset-size10.size9,
.katex .sizing.reset-size10.size9 {
  font-size: .8331726133em;
}
.katex .fontsize-ensurer.reset-size10.size10,
.katex .sizing.reset-size10.size10 {
  font-size: 1em;
}
.katex .fontsize-ensurer.reset-size10.size11,
.katex .sizing.reset-size10.size11 {
  font-size: 1.1996142719em;
}
.katex .fontsize-ensurer.reset-size11.size1,
.katex .sizing.reset-size11.size1 {
  font-size: .2009646302em;
}
.katex .fontsize-ensurer.reset-size11.size2,
.katex .sizing.reset-size11.size2 {
  font-size: .2411575563em;
}
.katex .fontsize-ensurer.reset-size11.size3,
.katex .sizing.reset-size11.size3 {
  font-size: .2813504823em;
}
.katex .fontsize-ensurer.reset-size11.size4,
.katex .sizing.reset-size11.size4 {
  font-size: .3215434084em;
}
.katex .fontsize-ensurer.reset-size11.size5,
.katex .sizing.reset-size11.size5 {
  font-size: .3617363344em;
}
.katex .fontsize-ensurer.reset-size11.size6,
.katex .sizing.reset-size11.size6 {
  font-size: .4019292605em;
}
.katex .fontsize-ensurer.reset-size11.size7,
.katex .sizing.reset-size11.size7 {
  font-size: .4823151125em;
}
.katex .fontsize-ensurer.reset-size11.size8,
.katex .sizing.reset-size11.size8 {
  font-size: .578778135em;
}
.katex .fontsize-ensurer.reset-size11.size9,
.katex .sizing.reset-size11.size9 {
  font-size: .6945337621em;
}
.katex .fontsize-ensurer.reset-size11.size10,
.katex .sizing.reset-size11.size10 {
  font-size: .8336012862em;
}
.katex .fontsize-ensurer.reset-size11.size11,
.katex .sizing.reset-size11.size11 {
  font-size: 1em;
}
.katex .delimsizing.size1 {
  font-family: KaTeX_Size1;
}
.katex .delimsizing.size2 {
  font-family: KaTeX_Size2;
}
.katex .delimsizing.size3 {
  font-family: KaTeX_Size3;
}
.katex .delimsizing.size4 {
  font-family: KaTeX_Size4;
}
.katex .delimsizing.mult .delim-size1 > span {
  font-family: KaTeX_Size1;
}
.katex .delimsizing.mult .delim-size4 > span {
  font-family: KaTeX_Size4;
}
.katex .nulldelimiter {
  display: inline-block;
  width: .12em;
}
.katex .delimcenter,
.katex .op-symbol {
  position: relative;
}
.katex .op-symbol.small-op {
  font-family: KaTeX_Size1;
}
.katex .op-symbol.large-op {
  font-family: KaTeX_Size2;
}
.katex .accent > .vlist-t,
.katex .op-limits > .vlist-t {
  text-align: center;
}
.katex .accent .accent-body {
  position: relative;
}
.katex .accent .accent-body:not(.accent-full) {
  width: 0;
}
.katex .overlay {
  display: block;
}
.katex .mtable .vertical-separator {
  display: inline-block;
  min-width: 1px;
}
.katex .mtable .arraycolsep {
  display: inline-block;
}
.katex .mtable .col-align-c > .vlist-t {
  text-align: center;
}
.katex .mtable .col-align-l > .vlist-t {
  text-align: left;
}
.katex .mtable .col-align-r > .vlist-t {
  text-align: right;
}
.katex .svg-align {
  text-align: left;
}
.katex svg {
  fill: currentColor;
  stroke: currentColor;
  fill-rule: nonzero;
  fill-opacity: 1;
  stroke-width: 1;
  stroke-linecap: butt;
  stroke-linejoin: miter;
  stroke-miterlimit: 4;
  stroke-dasharray: none;
  stroke-dashoffset: 0;
  stroke-opacity: 1;
  display: block;
  height: inherit;
  position: absolute;
  width: 100%;
}
.katex svg path {
  stroke: none;
}
.katex img {
  border-style: none;
  max-height: none;
  max-width: none;
  min-height: 0;
  min-width: 0;
}
.katex .stretchy {
  display: block;
  overflow: hidden;
  position: relative;
  width: 100%;
}
.katex .stretchy:after,
.katex .stretchy:before {
  content: "";
}
.katex .hide-tail {
  overflow: hidden;
  position: relative;
  width: 100%;
}
.katex .halfarrow-left {
  left: 0;
  overflow: hidden;
  position: absolute;
  width: 50.2%;
}
.katex .halfarrow-right {
  overflow: hidden;
  position: absolute;
  right: 0;
  width: 50.2%;
}
.katex .brace-left {
  left: 0;
  overflow: hidden;
  position: absolute;
  width: 25.1%;
}
.katex .brace-center {
  left: 25%;
  overflow: hidden;
  position: absolute;
  width: 50%;
}
.katex .brace-right {
  overflow: hidden;
  position: absolute;
  right: 0;
  width: 25.1%;
}
.katex .x-arrow-pad {
  padding: 0 .5em;
}
.katex .cd-arrow-pad {
  padding: 0 .55556em 0 .27778em;
}
.katex .mover,
.katex .munder,
.katex .x-arrow {
  text-align: center;
}
.katex .boxpad {
  padding: 0 .3em;
}
.katex .fbox,
.katex .fcolorbox {
  border: .04em solid;
  box-sizing: border-box;
}
.katex .cancel-pad {
  padding: 0 .2em;
}
.katex .cancel-lap {
  margin-left: -.2em;
  margin-right: -.2em;
}
.katex .sout {
  border-bottom-style: solid;
  border-bottom-width: .08em;
}
.katex .angl {
  border-right: .049em solid;
  border-top: .049em solid;
  box-sizing: border-box;
  margin-right: .03889em;
}
.katex .anglpad {
  padding: 0 .03889em;
}
.katex .eqn-num:before {
  content: "(" counter(katexEqnNo) ")";
  counter-increment: katexEqnNo;
}
.katex .mml-eqn-num:before {
  content: "(" counter(mmlEqnNo) ")";
  counter-increment: mmlEqnNo;
}
.katex .mtr-glue {
  width: 50%;
}
.katex .cd-vert-arrow {
  display: inline-block;
  position: relative;
}
.katex .cd-label-left {
  display: inline-block;
  position: absolute;
  right: calc(50% + .3em);
  text-align: left;
}
.katex .cd-label-right {
  display: inline-block;
  left: calc(50% + .3em);
  position: absolute;
  text-align: right;
}
.katex-display {
  display: block;
  margin: 1em 0;
  text-align: center;
}
.katex-display > .katex {
  display: block;
  text-align: center;
  white-space: nowrap;
}
.katex-display > .katex > .katex-html {
  display: block;
  position: relative;
}
.katex-display > .katex > .katex-html > .tag {
  position: absolute;
  right: 0;
}
.katex-display.leqno > .katex > .katex-html > .tag {
  left: 0;
  right: auto;
}
.katex-display.fleqn > .katex {
  padding-left: 2em;
  text-align: left;
}
body {
  counter-reset: katexEqnNo mmlEqnNo;
}
/*# sourceMappingURL=script.css.map */


=== app/static/dist/script.js ===
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/marked/lib/marked.esm.js
  function _getDefaults() {
    return {
      async: false,
      breaks: false,
      extensions: null,
      gfm: true,
      hooks: null,
      pedantic: false,
      renderer: null,
      silent: false,
      tokenizer: null,
      walkTokens: null
    };
  }
  function changeDefaults(newDefaults) {
    _defaults = newDefaults;
  }
  function edit(regex, opt = "") {
    let source = typeof regex === "string" ? regex : regex.source;
    const obj = {
      replace: (name, val) => {
        let valSource = typeof val === "string" ? val : val.source;
        valSource = valSource.replace(other.caret, "$1");
        source = source.replace(name, valSource);
        return obj;
      },
      getRegex: () => {
        return new RegExp(source, opt);
      }
    };
    return obj;
  }
  function escape(html2, encode) {
    if (encode) {
      if (other.escapeTest.test(html2)) {
        return html2.replace(other.escapeReplace, getEscapeReplacement);
      }
    } else {
      if (other.escapeTestNoEncode.test(html2)) {
        return html2.replace(other.escapeReplaceNoEncode, getEscapeReplacement);
      }
    }
    return html2;
  }
  function cleanUrl(href) {
    try {
      href = encodeURI(href).replace(other.percentDecode, "%");
    } catch {
      return null;
    }
    return href;
  }
  function splitCells(tableRow, count) {
    const row = tableRow.replace(other.findPipe, (match, offset, str) => {
      let escaped = false;
      let curr = offset;
      while (--curr >= 0 && str[curr] === "\\")
        escaped = !escaped;
      if (escaped) {
        return "|";
      } else {
        return " |";
      }
    }), cells = row.split(other.splitPipe);
    let i = 0;
    if (!cells[0].trim()) {
      cells.shift();
    }
    if (cells.length > 0 && !cells.at(-1)?.trim()) {
      cells.pop();
    }
    if (count) {
      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count)
          cells.push("");
      }
    }
    for (; i < cells.length; i++) {
      cells[i] = cells[i].trim().replace(other.slashPipe, "|");
    }
    return cells;
  }
  function rtrim(str, c, invert) {
    const l = str.length;
    if (l === 0) {
      return "";
    }
    let suffLen = 0;
    while (suffLen < l) {
      const currChar = str.charAt(l - suffLen - 1);
      if (currChar === c && true) {
        suffLen++;
      } else {
        break;
      }
    }
    return str.slice(0, l - suffLen);
  }
  function findClosingBracket(str, b) {
    if (str.indexOf(b[1]) === -1) {
      return -1;
    }
    let level = 0;
    for (let i = 0; i < str.length; i++) {
      if (str[i] === "\\") {
        i++;
      } else if (str[i] === b[0]) {
        level++;
      } else if (str[i] === b[1]) {
        level--;
        if (level < 0) {
          return i;
        }
      }
    }
    if (level > 0) {
      return -2;
    }
    return -1;
  }
  function outputLink(cap, link2, raw, lexer2, rules) {
    const href = link2.href;
    const title = link2.title || null;
    const text2 = cap[1].replace(rules.other.outputLinkReplace, "$1");
    lexer2.state.inLink = true;
    const token = {
      type: cap[0].charAt(0) === "!" ? "image" : "link",
      raw,
      href,
      title,
      text: text2,
      tokens: lexer2.inlineTokens(text2)
    };
    lexer2.state.inLink = false;
    return token;
  }
  function indentCodeCompensation(raw, text2, rules) {
    const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);
    if (matchIndentToCode === null) {
      return text2;
    }
    const indentToCode = matchIndentToCode[1];
    return text2.split("\n").map((node) => {
      const matchIndentInNode = node.match(rules.other.beginningSpace);
      if (matchIndentInNode === null) {
        return node;
      }
      const [indentInNode] = matchIndentInNode;
      if (indentInNode.length >= indentToCode.length) {
        return node.slice(indentToCode.length);
      }
      return node;
    }).join("\n");
  }
  function marked(src, opt) {
    return markedInstance.parse(src, opt);
  }
  var _defaults, noopTest, other, newline, blockCode, fences, hr, heading, bullet, lheadingCore, lheading, lheadingGfm, _paragraph, blockText, _blockLabel, def, list, _tag, _comment, html, paragraph, blockquote, blockNormal, gfmTable, blockGfm, blockPedantic, escape$1, inlineCode, br, inlineText, _punctuation, _punctuationOrSpace, _notPunctuationOrSpace, punctuation, _punctuationGfmStrongEm, _punctuationOrSpaceGfmStrongEm, _notPunctuationOrSpaceGfmStrongEm, blockSkip, emStrongLDelimCore, emStrongLDelim, emStrongLDelimGfm, emStrongRDelimAstCore, emStrongRDelimAst, emStrongRDelimAstGfm, emStrongRDelimUnd, anyPunctuation, autolink, _inlineComment, tag, _inlineLabel, link, reflink, nolink, reflinkSearch, inlineNormal, inlinePedantic, inlineGfm, inlineBreaks, block, inline, escapeReplacements, getEscapeReplacement, _Tokenizer, _Lexer, _Renderer, _TextRenderer, _Parser, _Hooks, Marked, markedInstance, options, setOptions, use, walkTokens, parseInline, parser, lexer;
  var init_marked_esm = __esm({
    "node_modules/marked/lib/marked.esm.js"() {
      _defaults = _getDefaults();
      noopTest = { exec: () => null };
      other = {
        codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
        outputLinkReplace: /\\([\[\]])/g,
        indentCodeCompensation: /^(\s+)(?:```)/,
        beginningSpace: /^\s+/,
        endingHash: /#$/,
        startingSpaceChar: /^ /,
        endingSpaceChar: / $/,
        nonSpaceChar: /[^ ]/,
        newLineCharGlobal: /\n/g,
        tabCharGlobal: /\t/g,
        multipleSpaceGlobal: /\s+/g,
        blankLine: /^[ \t]*$/,
        doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
        blockquoteStart: /^ {0,3}>/,
        blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
        blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
        listReplaceTabs: /^\t+/,
        listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
        listIsTask: /^\[[ xX]\] /,
        listReplaceTask: /^\[[ xX]\] +/,
        anyLine: /\n.*\n/,
        hrefBrackets: /^<(.*)>$/,
        tableDelimiter: /[:|]/,
        tableAlignChars: /^\||\| *$/g,
        tableRowBlankLine: /\n[ \t]*$/,
        tableAlignRight: /^ *-+: *$/,
        tableAlignCenter: /^ *:-+: *$/,
        tableAlignLeft: /^ *:-+ *$/,
        startATag: /^<a /i,
        endATag: /^<\/a>/i,
        startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
        endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
        startAngleBracket: /^</,
        endAngleBracket: />$/,
        pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
        unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
        escapeTest: /[&<>"']/,
        escapeReplace: /[&<>"']/g,
        escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
        escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
        unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
        caret: /(^|[^\[])\^/g,
        percentDecode: /%25/g,
        findPipe: /\|/g,
        splitPipe: / \|/,
        slashPipe: /\\\|/g,
        carriageReturn: /\r\n|\r/g,
        spaceLine: /^ +$/gm,
        notSpaceStart: /^\S*/,
        endingNewline: /\n$/,
        listItemRegex: (bull) => new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`),
        nextBulletRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),
        hrRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
        fencesBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`),
        headingBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),
        htmlBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, "i")
      };
      newline = /^(?:[ \t]*(?:\n|$))+/;
      blockCode = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
      fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
      hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
      heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
      bullet = /(?:[*+-]|\d{1,9}[.)])/;
      lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/;
      lheading = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex();
      lheadingGfm = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex();
      _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
      blockText = /^[^\n]+/;
      _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
      def = edit(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
      list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex();
      _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
      _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
      html = edit("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
      paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
      blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex();
      blockNormal = {
        blockquote,
        code: blockCode,
        def,
        fences,
        heading,
        hr,
        html,
        lheading,
        list,
        newline,
        paragraph,
        table: noopTest,
        text: blockText
      };
      gfmTable = edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex();
      blockGfm = {
        ...blockNormal,
        lheading: lheadingGfm,
        table: gfmTable,
        paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
      };
      blockPedantic = {
        ...blockNormal,
        html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
        def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
        heading: /^(#{1,6})(.*)(?:\n+|$)/,
        fences: noopTest,
        // fences not supported
        lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
        paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
      };
      escape$1 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
      inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
      br = /^( {2,}|\\)\n(?!\s*$)/;
      inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
      _punctuation = /[\p{P}\p{S}]/u;
      _punctuationOrSpace = /[\s\p{P}\p{S}]/u;
      _notPunctuationOrSpace = /[^\s\p{P}\p{S}]/u;
      punctuation = edit(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, _punctuationOrSpace).getRegex();
      _punctuationGfmStrongEm = /(?!~)[\p{P}\p{S}]/u;
      _punctuationOrSpaceGfmStrongEm = /(?!~)[\s\p{P}\p{S}]/u;
      _notPunctuationOrSpaceGfmStrongEm = /(?:[^\s\p{P}\p{S}]|~)/u;
      blockSkip = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g;
      emStrongLDelimCore = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/;
      emStrongLDelim = edit(emStrongLDelimCore, "u").replace(/punct/g, _punctuation).getRegex();
      emStrongLDelimGfm = edit(emStrongLDelimCore, "u").replace(/punct/g, _punctuationGfmStrongEm).getRegex();
      emStrongRDelimAstCore = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)";
      emStrongRDelimAst = edit(emStrongRDelimAstCore, "gu").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();
      emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, "gu").replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm).replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm).replace(/punct/g, _punctuationGfmStrongEm).getRegex();
      emStrongRDelimUnd = edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();
      anyPunctuation = edit(/\\(punct)/, "gu").replace(/punct/g, _punctuation).getRegex();
      autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
      _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex();
      tag = edit("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
      _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
      link = edit(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
      reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex();
      nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex();
      reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex();
      inlineNormal = {
        _backpedal: noopTest,
        // only used for GFM url
        anyPunctuation,
        autolink,
        blockSkip,
        br,
        code: inlineCode,
        del: noopTest,
        emStrongLDelim,
        emStrongRDelimAst,
        emStrongRDelimUnd,
        escape: escape$1,
        link,
        nolink,
        punctuation,
        reflink,
        reflinkSearch,
        tag,
        text: inlineText,
        url: noopTest
      };
      inlinePedantic = {
        ...inlineNormal,
        link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
        reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
      };
      inlineGfm = {
        ...inlineNormal,
        emStrongRDelimAst: emStrongRDelimAstGfm,
        emStrongLDelim: emStrongLDelimGfm,
        url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
        _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
        del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
        text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
      };
      inlineBreaks = {
        ...inlineGfm,
        br: edit(br).replace("{2,}", "*").getRegex(),
        text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
      };
      block = {
        normal: blockNormal,
        gfm: blockGfm,
        pedantic: blockPedantic
      };
      inline = {
        normal: inlineNormal,
        gfm: inlineGfm,
        breaks: inlineBreaks,
        pedantic: inlinePedantic
      };
      escapeReplacements = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      getEscapeReplacement = (ch) => escapeReplacements[ch];
      _Tokenizer = class {
        options;
        rules;
        // set by the lexer
        lexer;
        // set by the lexer
        constructor(options2) {
          this.options = options2 || _defaults;
        }
        space(src) {
          const cap = this.rules.block.newline.exec(src);
          if (cap && cap[0].length > 0) {
            return {
              type: "space",
              raw: cap[0]
            };
          }
        }
        code(src) {
          const cap = this.rules.block.code.exec(src);
          if (cap) {
            const text2 = cap[0].replace(this.rules.other.codeRemoveIndent, "");
            return {
              type: "code",
              raw: cap[0],
              codeBlockStyle: "indented",
              text: !this.options.pedantic ? rtrim(text2, "\n") : text2
            };
          }
        }
        fences(src) {
          const cap = this.rules.block.fences.exec(src);
          if (cap) {
            const raw = cap[0];
            const text2 = indentCodeCompensation(raw, cap[3] || "", this.rules);
            return {
              type: "code",
              raw,
              lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : cap[2],
              text: text2
            };
          }
        }
        heading(src) {
          const cap = this.rules.block.heading.exec(src);
          if (cap) {
            let text2 = cap[2].trim();
            if (this.rules.other.endingHash.test(text2)) {
              const trimmed = rtrim(text2, "#");
              if (this.options.pedantic) {
                text2 = trimmed.trim();
              } else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {
                text2 = trimmed.trim();
              }
            }
            return {
              type: "heading",
              raw: cap[0],
              depth: cap[1].length,
              text: text2,
              tokens: this.lexer.inline(text2)
            };
          }
        }
        hr(src) {
          const cap = this.rules.block.hr.exec(src);
          if (cap) {
            return {
              type: "hr",
              raw: rtrim(cap[0], "\n")
            };
          }
        }
        blockquote(src) {
          const cap = this.rules.block.blockquote.exec(src);
          if (cap) {
            let lines = rtrim(cap[0], "\n").split("\n");
            let raw = "";
            let text2 = "";
            const tokens = [];
            while (lines.length > 0) {
              let inBlockquote = false;
              const currentLines = [];
              let i;
              for (i = 0; i < lines.length; i++) {
                if (this.rules.other.blockquoteStart.test(lines[i])) {
                  currentLines.push(lines[i]);
                  inBlockquote = true;
                } else if (!inBlockquote) {
                  currentLines.push(lines[i]);
                } else {
                  break;
                }
              }
              lines = lines.slice(i);
              const currentRaw = currentLines.join("\n");
              const currentText = currentRaw.replace(this.rules.other.blockquoteSetextReplace, "\n    $1").replace(this.rules.other.blockquoteSetextReplace2, "");
              raw = raw ? `${raw}
${currentRaw}` : currentRaw;
              text2 = text2 ? `${text2}
${currentText}` : currentText;
              const top = this.lexer.state.top;
              this.lexer.state.top = true;
              this.lexer.blockTokens(currentText, tokens, true);
              this.lexer.state.top = top;
              if (lines.length === 0) {
                break;
              }
              const lastToken = tokens.at(-1);
              if (lastToken?.type === "code") {
                break;
              } else if (lastToken?.type === "blockquote") {
                const oldToken = lastToken;
                const newText = oldToken.raw + "\n" + lines.join("\n");
                const newToken = this.blockquote(newText);
                tokens[tokens.length - 1] = newToken;
                raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;
                text2 = text2.substring(0, text2.length - oldToken.text.length) + newToken.text;
                break;
              } else if (lastToken?.type === "list") {
                const oldToken = lastToken;
                const newText = oldToken.raw + "\n" + lines.join("\n");
                const newToken = this.list(newText);
                tokens[tokens.length - 1] = newToken;
                raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;
                text2 = text2.substring(0, text2.length - oldToken.raw.length) + newToken.raw;
                lines = newText.substring(tokens.at(-1).raw.length).split("\n");
                continue;
              }
            }
            return {
              type: "blockquote",
              raw,
              tokens,
              text: text2
            };
          }
        }
        list(src) {
          let cap = this.rules.block.list.exec(src);
          if (cap) {
            let bull = cap[1].trim();
            const isordered = bull.length > 1;
            const list2 = {
              type: "list",
              raw: "",
              ordered: isordered,
              start: isordered ? +bull.slice(0, -1) : "",
              loose: false,
              items: []
            };
            bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
            if (this.options.pedantic) {
              bull = isordered ? bull : "[*+-]";
            }
            const itemRegex = this.rules.other.listItemRegex(bull);
            let endsWithBlankLine = false;
            while (src) {
              let endEarly = false;
              let raw = "";
              let itemContents = "";
              if (!(cap = itemRegex.exec(src))) {
                break;
              }
              if (this.rules.block.hr.test(src)) {
                break;
              }
              raw = cap[0];
              src = src.substring(raw.length);
              let line = cap[2].split("\n", 1)[0].replace(this.rules.other.listReplaceTabs, (t) => " ".repeat(3 * t.length));
              let nextLine = src.split("\n", 1)[0];
              let blankLine = !line.trim();
              let indent = 0;
              if (this.options.pedantic) {
                indent = 2;
                itemContents = line.trimStart();
              } else if (blankLine) {
                indent = cap[1].length + 1;
              } else {
                indent = cap[2].search(this.rules.other.nonSpaceChar);
                indent = indent > 4 ? 1 : indent;
                itemContents = line.slice(indent);
                indent += cap[1].length;
              }
              if (blankLine && this.rules.other.blankLine.test(nextLine)) {
                raw += nextLine + "\n";
                src = src.substring(nextLine.length + 1);
                endEarly = true;
              }
              if (!endEarly) {
                const nextBulletRegex = this.rules.other.nextBulletRegex(indent);
                const hrRegex = this.rules.other.hrRegex(indent);
                const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);
                const headingBeginRegex = this.rules.other.headingBeginRegex(indent);
                const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);
                while (src) {
                  const rawLine = src.split("\n", 1)[0];
                  let nextLineWithoutTabs;
                  nextLine = rawLine;
                  if (this.options.pedantic) {
                    nextLine = nextLine.replace(this.rules.other.listReplaceNesting, "  ");
                    nextLineWithoutTabs = nextLine;
                  } else {
                    nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, "    ");
                  }
                  if (fencesBeginRegex.test(nextLine)) {
                    break;
                  }
                  if (headingBeginRegex.test(nextLine)) {
                    break;
                  }
                  if (htmlBeginRegex.test(nextLine)) {
                    break;
                  }
                  if (nextBulletRegex.test(nextLine)) {
                    break;
                  }
                  if (hrRegex.test(nextLine)) {
                    break;
                  }
                  if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) {
                    itemContents += "\n" + nextLineWithoutTabs.slice(indent);
                  } else {
                    if (blankLine) {
                      break;
                    }
                    if (line.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4) {
                      break;
                    }
                    if (fencesBeginRegex.test(line)) {
                      break;
                    }
                    if (headingBeginRegex.test(line)) {
                      break;
                    }
                    if (hrRegex.test(line)) {
                      break;
                    }
                    itemContents += "\n" + nextLine;
                  }
                  if (!blankLine && !nextLine.trim()) {
                    blankLine = true;
                  }
                  raw += rawLine + "\n";
                  src = src.substring(rawLine.length + 1);
                  line = nextLineWithoutTabs.slice(indent);
                }
              }
              if (!list2.loose) {
                if (endsWithBlankLine) {
                  list2.loose = true;
                } else if (this.rules.other.doubleBlankLine.test(raw)) {
                  endsWithBlankLine = true;
                }
              }
              let istask = null;
              let ischecked;
              if (this.options.gfm) {
                istask = this.rules.other.listIsTask.exec(itemContents);
                if (istask) {
                  ischecked = istask[0] !== "[ ] ";
                  itemContents = itemContents.replace(this.rules.other.listReplaceTask, "");
                }
              }
              list2.items.push({
                type: "list_item",
                raw,
                task: !!istask,
                checked: ischecked,
                loose: false,
                text: itemContents,
                tokens: []
              });
              list2.raw += raw;
            }
            const lastItem = list2.items.at(-1);
            if (lastItem) {
              lastItem.raw = lastItem.raw.trimEnd();
              lastItem.text = lastItem.text.trimEnd();
            } else {
              return;
            }
            list2.raw = list2.raw.trimEnd();
            for (let i = 0; i < list2.items.length; i++) {
              this.lexer.state.top = false;
              list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
              if (!list2.loose) {
                const spacers = list2.items[i].tokens.filter((t) => t.type === "space");
                const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => this.rules.other.anyLine.test(t.raw));
                list2.loose = hasMultipleLineBreaks;
              }
            }
            if (list2.loose) {
              for (let i = 0; i < list2.items.length; i++) {
                list2.items[i].loose = true;
              }
            }
            return list2;
          }
        }
        html(src) {
          const cap = this.rules.block.html.exec(src);
          if (cap) {
            const token = {
              type: "html",
              block: true,
              raw: cap[0],
              pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
              text: cap[0]
            };
            return token;
          }
        }
        def(src) {
          const cap = this.rules.block.def.exec(src);
          if (cap) {
            const tag2 = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " ");
            const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "";
            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : cap[3];
            return {
              type: "def",
              tag: tag2,
              raw: cap[0],
              href,
              title
            };
          }
        }
        table(src) {
          const cap = this.rules.block.table.exec(src);
          if (!cap) {
            return;
          }
          if (!this.rules.other.tableDelimiter.test(cap[2])) {
            return;
          }
          const headers = splitCells(cap[1]);
          const aligns = cap[2].replace(this.rules.other.tableAlignChars, "").split("|");
          const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, "").split("\n") : [];
          const item = {
            type: "table",
            raw: cap[0],
            header: [],
            align: [],
            rows: []
          };
          if (headers.length !== aligns.length) {
            return;
          }
          for (const align of aligns) {
            if (this.rules.other.tableAlignRight.test(align)) {
              item.align.push("right");
            } else if (this.rules.other.tableAlignCenter.test(align)) {
              item.align.push("center");
            } else if (this.rules.other.tableAlignLeft.test(align)) {
              item.align.push("left");
            } else {
              item.align.push(null);
            }
          }
          for (let i = 0; i < headers.length; i++) {
            item.header.push({
              text: headers[i],
              tokens: this.lexer.inline(headers[i]),
              header: true,
              align: item.align[i]
            });
          }
          for (const row of rows) {
            item.rows.push(splitCells(row, item.header.length).map((cell, i) => {
              return {
                text: cell,
                tokens: this.lexer.inline(cell),
                header: false,
                align: item.align[i]
              };
            }));
          }
          return item;
        }
        lheading(src) {
          const cap = this.rules.block.lheading.exec(src);
          if (cap) {
            return {
              type: "heading",
              raw: cap[0],
              depth: cap[2].charAt(0) === "=" ? 1 : 2,
              text: cap[1],
              tokens: this.lexer.inline(cap[1])
            };
          }
        }
        paragraph(src) {
          const cap = this.rules.block.paragraph.exec(src);
          if (cap) {
            const text2 = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
            return {
              type: "paragraph",
              raw: cap[0],
              text: text2,
              tokens: this.lexer.inline(text2)
            };
          }
        }
        text(src) {
          const cap = this.rules.block.text.exec(src);
          if (cap) {
            return {
              type: "text",
              raw: cap[0],
              text: cap[0],
              tokens: this.lexer.inline(cap[0])
            };
          }
        }
        escape(src) {
          const cap = this.rules.inline.escape.exec(src);
          if (cap) {
            return {
              type: "escape",
              raw: cap[0],
              text: cap[1]
            };
          }
        }
        tag(src) {
          const cap = this.rules.inline.tag.exec(src);
          if (cap) {
            if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {
              this.lexer.state.inLink = true;
            } else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {
              this.lexer.state.inLink = false;
            }
            if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {
              this.lexer.state.inRawBlock = true;
            } else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {
              this.lexer.state.inRawBlock = false;
            }
            return {
              type: "html",
              raw: cap[0],
              inLink: this.lexer.state.inLink,
              inRawBlock: this.lexer.state.inRawBlock,
              block: false,
              text: cap[0]
            };
          }
        }
        link(src) {
          const cap = this.rules.inline.link.exec(src);
          if (cap) {
            const trimmedUrl = cap[2].trim();
            if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {
              if (!this.rules.other.endAngleBracket.test(trimmedUrl)) {
                return;
              }
              const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
              if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
                return;
              }
            } else {
              const lastParenIndex = findClosingBracket(cap[2], "()");
              if (lastParenIndex === -2) {
                return;
              }
              if (lastParenIndex > -1) {
                const start = cap[0].indexOf("!") === 0 ? 5 : 4;
                const linkLen = start + cap[1].length + lastParenIndex;
                cap[2] = cap[2].substring(0, lastParenIndex);
                cap[0] = cap[0].substring(0, linkLen).trim();
                cap[3] = "";
              }
            }
            let href = cap[2];
            let title = "";
            if (this.options.pedantic) {
              const link2 = this.rules.other.pedanticHrefTitle.exec(href);
              if (link2) {
                href = link2[1];
                title = link2[3];
              }
            } else {
              title = cap[3] ? cap[3].slice(1, -1) : "";
            }
            href = href.trim();
            if (this.rules.other.startAngleBracket.test(href)) {
              if (this.options.pedantic && !this.rules.other.endAngleBracket.test(trimmedUrl)) {
                href = href.slice(1);
              } else {
                href = href.slice(1, -1);
              }
            }
            return outputLink(cap, {
              href: href ? href.replace(this.rules.inline.anyPunctuation, "$1") : href,
              title: title ? title.replace(this.rules.inline.anyPunctuation, "$1") : title
            }, cap[0], this.lexer, this.rules);
          }
        }
        reflink(src, links) {
          let cap;
          if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
            const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, " ");
            const link2 = links[linkString.toLowerCase()];
            if (!link2) {
              const text2 = cap[0].charAt(0);
              return {
                type: "text",
                raw: text2,
                text: text2
              };
            }
            return outputLink(cap, link2, cap[0], this.lexer, this.rules);
          }
        }
        emStrong(src, maskedSrc, prevChar = "") {
          let match = this.rules.inline.emStrongLDelim.exec(src);
          if (!match)
            return;
          if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric))
            return;
          const nextChar = match[1] || match[2] || "";
          if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
            const lLength = [...match[0]].length - 1;
            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
            const endReg = match[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
            endReg.lastIndex = 0;
            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
            while ((match = endReg.exec(maskedSrc)) != null) {
              rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
              if (!rDelim)
                continue;
              rLength = [...rDelim].length;
              if (match[3] || match[4]) {
                delimTotal += rLength;
                continue;
              } else if (match[5] || match[6]) {
                if (lLength % 3 && !((lLength + rLength) % 3)) {
                  midDelimTotal += rLength;
                  continue;
                }
              }
              delimTotal -= rLength;
              if (delimTotal > 0)
                continue;
              rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
              const lastCharLength = [...match[0]][0].length;
              const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
              if (Math.min(lLength, rLength) % 2) {
                const text3 = raw.slice(1, -1);
                return {
                  type: "em",
                  raw,
                  text: text3,
                  tokens: this.lexer.inlineTokens(text3)
                };
              }
              const text2 = raw.slice(2, -2);
              return {
                type: "strong",
                raw,
                text: text2,
                tokens: this.lexer.inlineTokens(text2)
              };
            }
          }
        }
        codespan(src) {
          const cap = this.rules.inline.code.exec(src);
          if (cap) {
            let text2 = cap[2].replace(this.rules.other.newLineCharGlobal, " ");
            const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text2);
            const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text2) && this.rules.other.endingSpaceChar.test(text2);
            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
              text2 = text2.substring(1, text2.length - 1);
            }
            return {
              type: "codespan",
              raw: cap[0],
              text: text2
            };
          }
        }
        br(src) {
          const cap = this.rules.inline.br.exec(src);
          if (cap) {
            return {
              type: "br",
              raw: cap[0]
            };
          }
        }
        del(src) {
          const cap = this.rules.inline.del.exec(src);
          if (cap) {
            return {
              type: "del",
              raw: cap[0],
              text: cap[2],
              tokens: this.lexer.inlineTokens(cap[2])
            };
          }
        }
        autolink(src) {
          const cap = this.rules.inline.autolink.exec(src);
          if (cap) {
            let text2, href;
            if (cap[2] === "@") {
              text2 = cap[1];
              href = "mailto:" + text2;
            } else {
              text2 = cap[1];
              href = text2;
            }
            return {
              type: "link",
              raw: cap[0],
              text: text2,
              href,
              tokens: [
                {
                  type: "text",
                  raw: text2,
                  text: text2
                }
              ]
            };
          }
        }
        url(src) {
          let cap;
          if (cap = this.rules.inline.url.exec(src)) {
            let text2, href;
            if (cap[2] === "@") {
              text2 = cap[0];
              href = "mailto:" + text2;
            } else {
              let prevCapZero;
              do {
                prevCapZero = cap[0];
                cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? "";
              } while (prevCapZero !== cap[0]);
              text2 = cap[0];
              if (cap[1] === "www.") {
                href = "http://" + cap[0];
              } else {
                href = cap[0];
              }
            }
            return {
              type: "link",
              raw: cap[0],
              text: text2,
              href,
              tokens: [
                {
                  type: "text",
                  raw: text2,
                  text: text2
                }
              ]
            };
          }
        }
        inlineText(src) {
          const cap = this.rules.inline.text.exec(src);
          if (cap) {
            const escaped = this.lexer.state.inRawBlock;
            return {
              type: "text",
              raw: cap[0],
              text: cap[0],
              escaped
            };
          }
        }
      };
      _Lexer = class __Lexer {
        tokens;
        options;
        state;
        tokenizer;
        inlineQueue;
        constructor(options2) {
          this.tokens = [];
          this.tokens.links = /* @__PURE__ */ Object.create(null);
          this.options = options2 || _defaults;
          this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
          this.tokenizer = this.options.tokenizer;
          this.tokenizer.options = this.options;
          this.tokenizer.lexer = this;
          this.inlineQueue = [];
          this.state = {
            inLink: false,
            inRawBlock: false,
            top: true
          };
          const rules = {
            other,
            block: block.normal,
            inline: inline.normal
          };
          if (this.options.pedantic) {
            rules.block = block.pedantic;
            rules.inline = inline.pedantic;
          } else if (this.options.gfm) {
            rules.block = block.gfm;
            if (this.options.breaks) {
              rules.inline = inline.breaks;
            } else {
              rules.inline = inline.gfm;
            }
          }
          this.tokenizer.rules = rules;
        }
        /**
         * Expose Rules
         */
        static get rules() {
          return {
            block,
            inline
          };
        }
        /**
         * Static Lex Method
         */
        static lex(src, options2) {
          const lexer2 = new __Lexer(options2);
          return lexer2.lex(src);
        }
        /**
         * Static Lex Inline Method
         */
        static lexInline(src, options2) {
          const lexer2 = new __Lexer(options2);
          return lexer2.inlineTokens(src);
        }
        /**
         * Preprocessing
         */
        lex(src) {
          src = src.replace(other.carriageReturn, "\n");
          this.blockTokens(src, this.tokens);
          for (let i = 0; i < this.inlineQueue.length; i++) {
            const next = this.inlineQueue[i];
            this.inlineTokens(next.src, next.tokens);
          }
          this.inlineQueue = [];
          return this.tokens;
        }
        blockTokens(src, tokens = [], lastParagraphClipped = false) {
          if (this.options.pedantic) {
            src = src.replace(other.tabCharGlobal, "    ").replace(other.spaceLine, "");
          }
          while (src) {
            let token;
            if (this.options.extensions?.block?.some((extTokenizer) => {
              if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                return true;
              }
              return false;
            })) {
              continue;
            }
            if (token = this.tokenizer.space(src)) {
              src = src.substring(token.raw.length);
              const lastToken = tokens.at(-1);
              if (token.raw.length === 1 && lastToken !== void 0) {
                lastToken.raw += "\n";
              } else {
                tokens.push(token);
              }
              continue;
            }
            if (token = this.tokenizer.code(src)) {
              src = src.substring(token.raw.length);
              const lastToken = tokens.at(-1);
              if (lastToken?.type === "paragraph" || lastToken?.type === "text") {
                lastToken.raw += "\n" + token.raw;
                lastToken.text += "\n" + token.text;
                this.inlineQueue.at(-1).src = lastToken.text;
              } else {
                tokens.push(token);
              }
              continue;
            }
            if (token = this.tokenizer.fences(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.heading(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.hr(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.blockquote(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.list(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.html(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.def(src)) {
              src = src.substring(token.raw.length);
              const lastToken = tokens.at(-1);
              if (lastToken?.type === "paragraph" || lastToken?.type === "text") {
                lastToken.raw += "\n" + token.raw;
                lastToken.text += "\n" + token.raw;
                this.inlineQueue.at(-1).src = lastToken.text;
              } else if (!this.tokens.links[token.tag]) {
                this.tokens.links[token.tag] = {
                  href: token.href,
                  title: token.title
                };
              }
              continue;
            }
            if (token = this.tokenizer.table(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.lheading(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            let cutSrc = src;
            if (this.options.extensions?.startBlock) {
              let startIndex = Infinity;
              const tempSrc = src.slice(1);
              let tempStart;
              this.options.extensions.startBlock.forEach((getStartIndex) => {
                tempStart = getStartIndex.call({ lexer: this }, tempSrc);
                if (typeof tempStart === "number" && tempStart >= 0) {
                  startIndex = Math.min(startIndex, tempStart);
                }
              });
              if (startIndex < Infinity && startIndex >= 0) {
                cutSrc = src.substring(0, startIndex + 1);
              }
            }
            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
              const lastToken = tokens.at(-1);
              if (lastParagraphClipped && lastToken?.type === "paragraph") {
                lastToken.raw += "\n" + token.raw;
                lastToken.text += "\n" + token.text;
                this.inlineQueue.pop();
                this.inlineQueue.at(-1).src = lastToken.text;
              } else {
                tokens.push(token);
              }
              lastParagraphClipped = cutSrc.length !== src.length;
              src = src.substring(token.raw.length);
              continue;
            }
            if (token = this.tokenizer.text(src)) {
              src = src.substring(token.raw.length);
              const lastToken = tokens.at(-1);
              if (lastToken?.type === "text") {
                lastToken.raw += "\n" + token.raw;
                lastToken.text += "\n" + token.text;
                this.inlineQueue.pop();
                this.inlineQueue.at(-1).src = lastToken.text;
              } else {
                tokens.push(token);
              }
              continue;
            }
            if (src) {
              const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
              if (this.options.silent) {
                console.error(errMsg);
                break;
              } else {
                throw new Error(errMsg);
              }
            }
          }
          this.state.top = true;
          return tokens;
        }
        inline(src, tokens = []) {
          this.inlineQueue.push({ src, tokens });
          return tokens;
        }
        /**
         * Lexing/Compiling
         */
        inlineTokens(src, tokens = []) {
          let maskedSrc = src;
          let match = null;
          if (this.tokens.links) {
            const links = Object.keys(this.tokens.links);
            if (links.length > 0) {
              while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
                if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
                  maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
                }
              }
            }
          }
          while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
            maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
          }
          while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
          }
          let keepPrevChar = false;
          let prevChar = "";
          while (src) {
            if (!keepPrevChar) {
              prevChar = "";
            }
            keepPrevChar = false;
            let token;
            if (this.options.extensions?.inline?.some((extTokenizer) => {
              if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                return true;
              }
              return false;
            })) {
              continue;
            }
            if (token = this.tokenizer.escape(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.tag(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.link(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.reflink(src, this.tokens.links)) {
              src = src.substring(token.raw.length);
              const lastToken = tokens.at(-1);
              if (token.type === "text" && lastToken?.type === "text") {
                lastToken.raw += token.raw;
                lastToken.text += token.text;
              } else {
                tokens.push(token);
              }
              continue;
            }
            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.codespan(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.br(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.del(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.autolink(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (!this.state.inLink && (token = this.tokenizer.url(src))) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            let cutSrc = src;
            if (this.options.extensions?.startInline) {
              let startIndex = Infinity;
              const tempSrc = src.slice(1);
              let tempStart;
              this.options.extensions.startInline.forEach((getStartIndex) => {
                tempStart = getStartIndex.call({ lexer: this }, tempSrc);
                if (typeof tempStart === "number" && tempStart >= 0) {
                  startIndex = Math.min(startIndex, tempStart);
                }
              });
              if (startIndex < Infinity && startIndex >= 0) {
                cutSrc = src.substring(0, startIndex + 1);
              }
            }
            if (token = this.tokenizer.inlineText(cutSrc)) {
              src = src.substring(token.raw.length);
              if (token.raw.slice(-1) !== "_") {
                prevChar = token.raw.slice(-1);
              }
              keepPrevChar = true;
              const lastToken = tokens.at(-1);
              if (lastToken?.type === "text") {
                lastToken.raw += token.raw;
                lastToken.text += token.text;
              } else {
                tokens.push(token);
              }
              continue;
            }
            if (src) {
              const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
              if (this.options.silent) {
                console.error(errMsg);
                break;
              } else {
                throw new Error(errMsg);
              }
            }
          }
          return tokens;
        }
      };
      _Renderer = class {
        options;
        parser;
        // set by the parser
        constructor(options2) {
          this.options = options2 || _defaults;
        }
        space(token) {
          return "";
        }
        code({ text: text2, lang, escaped }) {
          const langString = (lang || "").match(other.notSpaceStart)?.[0];
          const code = text2.replace(other.endingNewline, "") + "\n";
          if (!langString) {
            return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
          }
          return '<pre><code class="language-' + escape(langString) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
        }
        blockquote({ tokens }) {
          const body = this.parser.parse(tokens);
          return `<blockquote>
${body}</blockquote>
`;
        }
        html({ text: text2 }) {
          return text2;
        }
        heading({ tokens, depth }) {
          return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>
`;
        }
        hr(token) {
          return "<hr>\n";
        }
        list(token) {
          const ordered = token.ordered;
          const start = token.start;
          let body = "";
          for (let j = 0; j < token.items.length; j++) {
            const item = token.items[j];
            body += this.listitem(item);
          }
          const type = ordered ? "ol" : "ul";
          const startAttr = ordered && start !== 1 ? ' start="' + start + '"' : "";
          return "<" + type + startAttr + ">\n" + body + "</" + type + ">\n";
        }
        listitem(item) {
          let itemBody = "";
          if (item.task) {
            const checkbox = this.checkbox({ checked: !!item.checked });
            if (item.loose) {
              if (item.tokens[0]?.type === "paragraph") {
                item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                  item.tokens[0].tokens[0].text = checkbox + " " + escape(item.tokens[0].tokens[0].text);
                  item.tokens[0].tokens[0].escaped = true;
                }
              } else {
                item.tokens.unshift({
                  type: "text",
                  raw: checkbox + " ",
                  text: checkbox + " ",
                  escaped: true
                });
              }
            } else {
              itemBody += checkbox + " ";
            }
          }
          itemBody += this.parser.parse(item.tokens, !!item.loose);
          return `<li>${itemBody}</li>
`;
        }
        checkbox({ checked }) {
          return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
        }
        paragraph({ tokens }) {
          return `<p>${this.parser.parseInline(tokens)}</p>
`;
        }
        table(token) {
          let header = "";
          let cell = "";
          for (let j = 0; j < token.header.length; j++) {
            cell += this.tablecell(token.header[j]);
          }
          header += this.tablerow({ text: cell });
          let body = "";
          for (let j = 0; j < token.rows.length; j++) {
            const row = token.rows[j];
            cell = "";
            for (let k = 0; k < row.length; k++) {
              cell += this.tablecell(row[k]);
            }
            body += this.tablerow({ text: cell });
          }
          if (body)
            body = `<tbody>${body}</tbody>`;
          return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
        }
        tablerow({ text: text2 }) {
          return `<tr>
${text2}</tr>
`;
        }
        tablecell(token) {
          const content = this.parser.parseInline(token.tokens);
          const type = token.header ? "th" : "td";
          const tag2 = token.align ? `<${type} align="${token.align}">` : `<${type}>`;
          return tag2 + content + `</${type}>
`;
        }
        /**
         * span level renderer
         */
        strong({ tokens }) {
          return `<strong>${this.parser.parseInline(tokens)}</strong>`;
        }
        em({ tokens }) {
          return `<em>${this.parser.parseInline(tokens)}</em>`;
        }
        codespan({ text: text2 }) {
          return `<code>${escape(text2, true)}</code>`;
        }
        br(token) {
          return "<br>";
        }
        del({ tokens }) {
          return `<del>${this.parser.parseInline(tokens)}</del>`;
        }
        link({ href, title, tokens }) {
          const text2 = this.parser.parseInline(tokens);
          const cleanHref = cleanUrl(href);
          if (cleanHref === null) {
            return text2;
          }
          href = cleanHref;
          let out = '<a href="' + href + '"';
          if (title) {
            out += ' title="' + escape(title) + '"';
          }
          out += ">" + text2 + "</a>";
          return out;
        }
        image({ href, title, text: text2, tokens }) {
          if (tokens) {
            text2 = this.parser.parseInline(tokens, this.parser.textRenderer);
          }
          const cleanHref = cleanUrl(href);
          if (cleanHref === null) {
            return escape(text2);
          }
          href = cleanHref;
          let out = `<img src="${href}" alt="${text2}"`;
          if (title) {
            out += ` title="${escape(title)}"`;
          }
          out += ">";
          return out;
        }
        text(token) {
          return "tokens" in token && token.tokens ? this.parser.parseInline(token.tokens) : "escaped" in token && token.escaped ? token.text : escape(token.text);
        }
      };
      _TextRenderer = class {
        // no need for block level renderers
        strong({ text: text2 }) {
          return text2;
        }
        em({ text: text2 }) {
          return text2;
        }
        codespan({ text: text2 }) {
          return text2;
        }
        del({ text: text2 }) {
          return text2;
        }
        html({ text: text2 }) {
          return text2;
        }
        text({ text: text2 }) {
          return text2;
        }
        link({ text: text2 }) {
          return "" + text2;
        }
        image({ text: text2 }) {
          return "" + text2;
        }
        br() {
          return "";
        }
      };
      _Parser = class __Parser {
        options;
        renderer;
        textRenderer;
        constructor(options2) {
          this.options = options2 || _defaults;
          this.options.renderer = this.options.renderer || new _Renderer();
          this.renderer = this.options.renderer;
          this.renderer.options = this.options;
          this.renderer.parser = this;
          this.textRenderer = new _TextRenderer();
        }
        /**
         * Static Parse Method
         */
        static parse(tokens, options2) {
          const parser2 = new __Parser(options2);
          return parser2.parse(tokens);
        }
        /**
         * Static Parse Inline Method
         */
        static parseInline(tokens, options2) {
          const parser2 = new __Parser(options2);
          return parser2.parseInline(tokens);
        }
        /**
         * Parse Loop
         */
        parse(tokens, top = true) {
          let out = "";
          for (let i = 0; i < tokens.length; i++) {
            const anyToken = tokens[i];
            if (this.options.extensions?.renderers?.[anyToken.type]) {
              const genericToken = anyToken;
              const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
              if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
                out += ret || "";
                continue;
              }
            }
            const token = anyToken;
            switch (token.type) {
              case "space": {
                out += this.renderer.space(token);
                continue;
              }
              case "hr": {
                out += this.renderer.hr(token);
                continue;
              }
              case "heading": {
                out += this.renderer.heading(token);
                continue;
              }
              case "code": {
                out += this.renderer.code(token);
                continue;
              }
              case "table": {
                out += this.renderer.table(token);
                continue;
              }
              case "blockquote": {
                out += this.renderer.blockquote(token);
                continue;
              }
              case "list": {
                out += this.renderer.list(token);
                continue;
              }
              case "html": {
                out += this.renderer.html(token);
                continue;
              }
              case "paragraph": {
                out += this.renderer.paragraph(token);
                continue;
              }
              case "text": {
                let textToken = token;
                let body = this.renderer.text(textToken);
                while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
                  textToken = tokens[++i];
                  body += "\n" + this.renderer.text(textToken);
                }
                if (top) {
                  out += this.renderer.paragraph({
                    type: "paragraph",
                    raw: body,
                    text: body,
                    tokens: [{ type: "text", raw: body, text: body, escaped: true }]
                  });
                } else {
                  out += body;
                }
                continue;
              }
              default: {
                const errMsg = 'Token with "' + token.type + '" type was not found.';
                if (this.options.silent) {
                  console.error(errMsg);
                  return "";
                } else {
                  throw new Error(errMsg);
                }
              }
            }
          }
          return out;
        }
        /**
         * Parse Inline Tokens
         */
        parseInline(tokens, renderer = this.renderer) {
          let out = "";
          for (let i = 0; i < tokens.length; i++) {
            const anyToken = tokens[i];
            if (this.options.extensions?.renderers?.[anyToken.type]) {
              const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);
              if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(anyToken.type)) {
                out += ret || "";
                continue;
              }
            }
            const token = anyToken;
            switch (token.type) {
              case "escape": {
                out += renderer.text(token);
                break;
              }
              case "html": {
                out += renderer.html(token);
                break;
              }
              case "link": {
                out += renderer.link(token);
                break;
              }
              case "image": {
                out += renderer.image(token);
                break;
              }
              case "strong": {
                out += renderer.strong(token);
                break;
              }
              case "em": {
                out += renderer.em(token);
                break;
              }
              case "codespan": {
                out += renderer.codespan(token);
                break;
              }
              case "br": {
                out += renderer.br(token);
                break;
              }
              case "del": {
                out += renderer.del(token);
                break;
              }
              case "text": {
                out += renderer.text(token);
                break;
              }
              default: {
                const errMsg = 'Token with "' + token.type + '" type was not found.';
                if (this.options.silent) {
                  console.error(errMsg);
                  return "";
                } else {
                  throw new Error(errMsg);
                }
              }
            }
          }
          return out;
        }
      };
      _Hooks = class {
        options;
        block;
        constructor(options2) {
          this.options = options2 || _defaults;
        }
        static passThroughHooks = /* @__PURE__ */ new Set([
          "preprocess",
          "postprocess",
          "processAllTokens"
        ]);
        /**
         * Process markdown before marked
         */
        preprocess(markdown) {
          return markdown;
        }
        /**
         * Process HTML after marked is finished
         */
        postprocess(html2) {
          return html2;
        }
        /**
         * Process all tokens before walk tokens
         */
        processAllTokens(tokens) {
          return tokens;
        }
        /**
         * Provide function to tokenize markdown
         */
        provideLexer() {
          return this.block ? _Lexer.lex : _Lexer.lexInline;
        }
        /**
         * Provide function to parse tokens
         */
        provideParser() {
          return this.block ? _Parser.parse : _Parser.parseInline;
        }
      };
      Marked = class {
        defaults = _getDefaults();
        options = this.setOptions;
        parse = this.parseMarkdown(true);
        parseInline = this.parseMarkdown(false);
        Parser = _Parser;
        Renderer = _Renderer;
        TextRenderer = _TextRenderer;
        Lexer = _Lexer;
        Tokenizer = _Tokenizer;
        Hooks = _Hooks;
        constructor(...args) {
          this.use(...args);
        }
        /**
         * Run callback for every token
         */
        walkTokens(tokens, callback) {
          let values = [];
          for (const token of tokens) {
            values = values.concat(callback.call(this, token));
            switch (token.type) {
              case "table": {
                const tableToken = token;
                for (const cell of tableToken.header) {
                  values = values.concat(this.walkTokens(cell.tokens, callback));
                }
                for (const row of tableToken.rows) {
                  for (const cell of row) {
                    values = values.concat(this.walkTokens(cell.tokens, callback));
                  }
                }
                break;
              }
              case "list": {
                const listToken = token;
                values = values.concat(this.walkTokens(listToken.items, callback));
                break;
              }
              default: {
                const genericToken = token;
                if (this.defaults.extensions?.childTokens?.[genericToken.type]) {
                  this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
                    const tokens2 = genericToken[childTokens].flat(Infinity);
                    values = values.concat(this.walkTokens(tokens2, callback));
                  });
                } else if (genericToken.tokens) {
                  values = values.concat(this.walkTokens(genericToken.tokens, callback));
                }
              }
            }
          }
          return values;
        }
        use(...args) {
          const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
          args.forEach((pack) => {
            const opts = { ...pack };
            opts.async = this.defaults.async || opts.async || false;
            if (pack.extensions) {
              pack.extensions.forEach((ext) => {
                if (!ext.name) {
                  throw new Error("extension name required");
                }
                if ("renderer" in ext) {
                  const prevRenderer = extensions.renderers[ext.name];
                  if (prevRenderer) {
                    extensions.renderers[ext.name] = function(...args2) {
                      let ret = ext.renderer.apply(this, args2);
                      if (ret === false) {
                        ret = prevRenderer.apply(this, args2);
                      }
                      return ret;
                    };
                  } else {
                    extensions.renderers[ext.name] = ext.renderer;
                  }
                }
                if ("tokenizer" in ext) {
                  if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                    throw new Error("extension level must be 'block' or 'inline'");
                  }
                  const extLevel = extensions[ext.level];
                  if (extLevel) {
                    extLevel.unshift(ext.tokenizer);
                  } else {
                    extensions[ext.level] = [ext.tokenizer];
                  }
                  if (ext.start) {
                    if (ext.level === "block") {
                      if (extensions.startBlock) {
                        extensions.startBlock.push(ext.start);
                      } else {
                        extensions.startBlock = [ext.start];
                      }
                    } else if (ext.level === "inline") {
                      if (extensions.startInline) {
                        extensions.startInline.push(ext.start);
                      } else {
                        extensions.startInline = [ext.start];
                      }
                    }
                  }
                }
                if ("childTokens" in ext && ext.childTokens) {
                  extensions.childTokens[ext.name] = ext.childTokens;
                }
              });
              opts.extensions = extensions;
            }
            if (pack.renderer) {
              const renderer = this.defaults.renderer || new _Renderer(this.defaults);
              for (const prop in pack.renderer) {
                if (!(prop in renderer)) {
                  throw new Error(`renderer '${prop}' does not exist`);
                }
                if (["options", "parser"].includes(prop)) {
                  continue;
                }
                const rendererProp = prop;
                const rendererFunc = pack.renderer[rendererProp];
                const prevRenderer = renderer[rendererProp];
                renderer[rendererProp] = (...args2) => {
                  let ret = rendererFunc.apply(renderer, args2);
                  if (ret === false) {
                    ret = prevRenderer.apply(renderer, args2);
                  }
                  return ret || "";
                };
              }
              opts.renderer = renderer;
            }
            if (pack.tokenizer) {
              const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
              for (const prop in pack.tokenizer) {
                if (!(prop in tokenizer)) {
                  throw new Error(`tokenizer '${prop}' does not exist`);
                }
                if (["options", "rules", "lexer"].includes(prop)) {
                  continue;
                }
                const tokenizerProp = prop;
                const tokenizerFunc = pack.tokenizer[tokenizerProp];
                const prevTokenizer = tokenizer[tokenizerProp];
                tokenizer[tokenizerProp] = (...args2) => {
                  let ret = tokenizerFunc.apply(tokenizer, args2);
                  if (ret === false) {
                    ret = prevTokenizer.apply(tokenizer, args2);
                  }
                  return ret;
                };
              }
              opts.tokenizer = tokenizer;
            }
            if (pack.hooks) {
              const hooks = this.defaults.hooks || new _Hooks();
              for (const prop in pack.hooks) {
                if (!(prop in hooks)) {
                  throw new Error(`hook '${prop}' does not exist`);
                }
                if (["options", "block"].includes(prop)) {
                  continue;
                }
                const hooksProp = prop;
                const hooksFunc = pack.hooks[hooksProp];
                const prevHook = hooks[hooksProp];
                if (_Hooks.passThroughHooks.has(prop)) {
                  hooks[hooksProp] = (arg) => {
                    if (this.defaults.async) {
                      return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                        return prevHook.call(hooks, ret2);
                      });
                    }
                    const ret = hooksFunc.call(hooks, arg);
                    return prevHook.call(hooks, ret);
                  };
                } else {
                  hooks[hooksProp] = (...args2) => {
                    let ret = hooksFunc.apply(hooks, args2);
                    if (ret === false) {
                      ret = prevHook.apply(hooks, args2);
                    }
                    return ret;
                  };
                }
              }
              opts.hooks = hooks;
            }
            if (pack.walkTokens) {
              const walkTokens2 = this.defaults.walkTokens;
              const packWalktokens = pack.walkTokens;
              opts.walkTokens = function(token) {
                let values = [];
                values.push(packWalktokens.call(this, token));
                if (walkTokens2) {
                  values = values.concat(walkTokens2.call(this, token));
                }
                return values;
              };
            }
            this.defaults = { ...this.defaults, ...opts };
          });
          return this;
        }
        setOptions(opt) {
          this.defaults = { ...this.defaults, ...opt };
          return this;
        }
        lexer(src, options2) {
          return _Lexer.lex(src, options2 ?? this.defaults);
        }
        parser(tokens, options2) {
          return _Parser.parse(tokens, options2 ?? this.defaults);
        }
        parseMarkdown(blockType) {
          const parse = (src, options2) => {
            const origOpt = { ...options2 };
            const opt = { ...this.defaults, ...origOpt };
            const throwError = this.onError(!!opt.silent, !!opt.async);
            if (this.defaults.async === true && origOpt.async === false) {
              return throwError(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
            }
            if (typeof src === "undefined" || src === null) {
              return throwError(new Error("marked(): input parameter is undefined or null"));
            }
            if (typeof src !== "string") {
              return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
            }
            if (opt.hooks) {
              opt.hooks.options = opt;
              opt.hooks.block = blockType;
            }
            const lexer2 = opt.hooks ? opt.hooks.provideLexer() : blockType ? _Lexer.lex : _Lexer.lexInline;
            const parser2 = opt.hooks ? opt.hooks.provideParser() : blockType ? _Parser.parse : _Parser.parseInline;
            if (opt.async) {
              return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html2) => opt.hooks ? opt.hooks.postprocess(html2) : html2).catch(throwError);
            }
            try {
              if (opt.hooks) {
                src = opt.hooks.preprocess(src);
              }
              let tokens = lexer2(src, opt);
              if (opt.hooks) {
                tokens = opt.hooks.processAllTokens(tokens);
              }
              if (opt.walkTokens) {
                this.walkTokens(tokens, opt.walkTokens);
              }
              let html2 = parser2(tokens, opt);
              if (opt.hooks) {
                html2 = opt.hooks.postprocess(html2);
              }
              return html2;
            } catch (e) {
              return throwError(e);
            }
          };
          return parse;
        }
        onError(silent, async) {
          return (e) => {
            e.message += "\nPlease report this to https://github.com/markedjs/marked.";
            if (silent) {
              const msg = "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
              if (async) {
                return Promise.resolve(msg);
              }
              return msg;
            }
            if (async) {
              return Promise.reject(e);
            }
            throw e;
          };
        }
      };
      markedInstance = new Marked();
      marked.options = marked.setOptions = function(options2) {
        markedInstance.setOptions(options2);
        marked.defaults = markedInstance.defaults;
        changeDefaults(marked.defaults);
        return marked;
      };
      marked.getDefaults = _getDefaults;
      marked.defaults = _defaults;
      marked.use = function(...args) {
        markedInstance.use(...args);
        marked.defaults = markedInstance.defaults;
        changeDefaults(marked.defaults);
        return marked;
      };
      marked.walkTokens = function(tokens, callback) {
        return markedInstance.walkTokens(tokens, callback);
      };
      marked.parseInline = markedInstance.parseInline;
      marked.Parser = _Parser;
      marked.parser = _Parser.parse;
      marked.Renderer = _Renderer;
      marked.TextRenderer = _TextRenderer;
      marked.Lexer = _Lexer;
      marked.lexer = _Lexer.lex;
      marked.Tokenizer = _Tokenizer;
      marked.Hooks = _Hooks;
      marked.parse = marked;
      options = marked.options;
      setOptions = marked.setOptions;
      use = marked.use;
      walkTokens = marked.walkTokens;
      parseInline = marked.parseInline;
      parser = _Parser.parse;
      lexer = _Lexer.lex;
    }
  });

  // node_modules/katex/dist/katex.mjs
  function escape2(text2) {
    return String(text2).replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
  }
  function getDefaultValue(schema) {
    if (schema.default) {
      return schema.default;
    }
    var type = schema.type;
    var defaultType = Array.isArray(type) ? type[0] : type;
    if (typeof defaultType !== "string") {
      return defaultType.enum[0];
    }
    switch (defaultType) {
      case "boolean":
        return false;
      case "string":
        return "";
      case "number":
        return 0;
      case "object":
        return {};
    }
  }
  function scriptFromCodepoint(codepoint) {
    for (var i = 0; i < scriptData.length; i++) {
      var script = scriptData[i];
      for (var _i = 0; _i < script.blocks.length; _i++) {
        var block2 = script.blocks[_i];
        if (codepoint >= block2[0] && codepoint <= block2[1]) {
          return script.name;
        }
      }
    }
    return null;
  }
  function supportedCodepoint(codepoint) {
    for (var i = 0; i < allBlocks.length; i += 2) {
      if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {
        return true;
      }
    }
    return false;
  }
  function setFontMetrics(fontName, metrics) {
    fontMetricsData[fontName] = metrics;
  }
  function getCharacterMetrics(character, font, mode) {
    if (!fontMetricsData[font]) {
      throw new Error("Font metrics not found for font: " + font + ".");
    }
    var ch = character.charCodeAt(0);
    var metrics = fontMetricsData[font][ch];
    if (!metrics && character[0] in extraCharacterMap) {
      ch = extraCharacterMap[character[0]].charCodeAt(0);
      metrics = fontMetricsData[font][ch];
    }
    if (!metrics && mode === "text") {
      if (supportedCodepoint(ch)) {
        metrics = fontMetricsData[font][77];
      }
    }
    if (metrics) {
      return {
        depth: metrics[0],
        height: metrics[1],
        italic: metrics[2],
        skew: metrics[3],
        width: metrics[4]
      };
    }
  }
  function getGlobalMetrics(size) {
    var sizeIndex;
    if (size >= 5) {
      sizeIndex = 0;
    } else if (size >= 3) {
      sizeIndex = 1;
    } else {
      sizeIndex = 2;
    }
    if (!fontMetricsBySizeIndex[sizeIndex]) {
      var metrics = fontMetricsBySizeIndex[sizeIndex] = {
        cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
      };
      for (var key in sigmasAndXis) {
        if (sigmasAndXis.hasOwnProperty(key)) {
          metrics[key] = sigmasAndXis[key][sizeIndex];
        }
      }
    }
    return fontMetricsBySizeIndex[sizeIndex];
  }
  function assertSymbolDomNode(group) {
    if (group instanceof SymbolNode) {
      return group;
    } else {
      throw new Error("Expected symbolNode but got " + String(group) + ".");
    }
  }
  function assertSpan(group) {
    if (group instanceof Span) {
      return group;
    } else {
      throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
    }
  }
  function defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {
    symbols[mode][name] = {
      font,
      group,
      replace
    };
    if (acceptUnicodeChar && replace) {
      symbols[mode][replace] = symbols[mode][name];
    }
  }
  function defineFunction(_ref) {
    var {
      type,
      names,
      props,
      handler,
      htmlBuilder: htmlBuilder3,
      mathmlBuilder: mathmlBuilder3
    } = _ref;
    var data = {
      type,
      numArgs: props.numArgs,
      argTypes: props.argTypes,
      allowedInArgument: !!props.allowedInArgument,
      allowedInText: !!props.allowedInText,
      allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
      numOptionalArgs: props.numOptionalArgs || 0,
      infix: !!props.infix,
      primitive: !!props.primitive,
      handler
    };
    for (var i = 0; i < names.length; ++i) {
      _functions[names[i]] = data;
    }
    if (type) {
      if (htmlBuilder3) {
        _htmlGroupBuilders[type] = htmlBuilder3;
      }
      if (mathmlBuilder3) {
        _mathmlGroupBuilders[type] = mathmlBuilder3;
      }
    }
  }
  function defineFunctionBuilders(_ref2) {
    var {
      type,
      htmlBuilder: htmlBuilder3,
      mathmlBuilder: mathmlBuilder3
    } = _ref2;
    defineFunction({
      type,
      names: [],
      props: {
        numArgs: 0
      },
      handler() {
        throw new Error("Should never be called.");
      },
      htmlBuilder: htmlBuilder3,
      mathmlBuilder: mathmlBuilder3
    });
  }
  function buildHTMLUnbreakable(children, options2) {
    var body = makeSpan$1(["base"], children, options2);
    var strut = makeSpan$1(["strut"]);
    strut.style.height = makeEm(body.height + body.depth);
    if (body.depth) {
      strut.style.verticalAlign = makeEm(-body.depth);
    }
    body.children.unshift(strut);
    return body;
  }
  function buildHTML(tree, options2) {
    var tag2 = null;
    if (tree.length === 1 && tree[0].type === "tag") {
      tag2 = tree[0].tag;
      tree = tree[0].body;
    }
    var expression = buildExpression$1(tree, options2, "root");
    var eqnNum;
    if (expression.length === 2 && expression[1].hasClass("tag")) {
      eqnNum = expression.pop();
    }
    var children = [];
    var parts = [];
    for (var i = 0; i < expression.length; i++) {
      parts.push(expression[i]);
      if (expression[i].hasClass("mbin") || expression[i].hasClass("mrel") || expression[i].hasClass("allowbreak")) {
        var nobreak = false;
        while (i < expression.length - 1 && expression[i + 1].hasClass("mspace") && !expression[i + 1].hasClass("newline")) {
          i++;
          parts.push(expression[i]);
          if (expression[i].hasClass("nobreak")) {
            nobreak = true;
          }
        }
        if (!nobreak) {
          children.push(buildHTMLUnbreakable(parts, options2));
          parts = [];
        }
      } else if (expression[i].hasClass("newline")) {
        parts.pop();
        if (parts.length > 0) {
          children.push(buildHTMLUnbreakable(parts, options2));
          parts = [];
        }
        children.push(expression[i]);
      }
    }
    if (parts.length > 0) {
      children.push(buildHTMLUnbreakable(parts, options2));
    }
    var tagChild;
    if (tag2) {
      tagChild = buildHTMLUnbreakable(buildExpression$1(tag2, options2, true));
      tagChild.classes = ["tag"];
      children.push(tagChild);
    } else if (eqnNum) {
      children.push(eqnNum);
    }
    var htmlNode = makeSpan$1(["katex-html"], children);
    htmlNode.setAttribute("aria-hidden", "true");
    if (tagChild) {
      var strut = tagChild.children[0];
      strut.style.height = makeEm(htmlNode.height + htmlNode.depth);
      if (htmlNode.depth) {
        strut.style.verticalAlign = makeEm(-htmlNode.depth);
      }
    }
    return htmlNode;
  }
  function newDocumentFragment(children) {
    return new DocumentFragment(children);
  }
  function isNumberPunctuation(group) {
    if (!group) {
      return false;
    }
    if (group.type === "mi" && group.children.length === 1) {
      var child = group.children[0];
      return child instanceof TextNode && child.text === ".";
    } else if (group.type === "mo" && group.children.length === 1 && group.getAttribute("separator") === "true" && group.getAttribute("lspace") === "0em" && group.getAttribute("rspace") === "0em") {
      var _child = group.children[0];
      return _child instanceof TextNode && _child.text === ",";
    } else {
      return false;
    }
  }
  function buildMathML(tree, texExpression, options2, isDisplayMode, forMathmlOnly) {
    var expression = buildExpression2(tree, options2);
    var wrapper;
    if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
      wrapper = expression[0];
    } else {
      wrapper = new mathMLTree.MathNode("mrow", expression);
    }
    var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
    annotation.setAttribute("encoding", "application/x-tex");
    var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
    var math2 = new mathMLTree.MathNode("math", [semantics]);
    math2.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
    if (isDisplayMode) {
      math2.setAttribute("display", "block");
    }
    var wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
    return buildCommon.makeSpan([wrapperClass], [math2]);
  }
  function assertNodeType(node, type) {
    if (!node || node.type !== type) {
      throw new Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
    }
    return node;
  }
  function assertSymbolNodeType(node) {
    var typedNode = checkSymbolNodeType(node);
    if (!typedNode) {
      throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
    }
    return typedNode;
  }
  function checkSymbolNodeType(node) {
    if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
      return node;
    }
    return null;
  }
  function htmlBuilder$9(group, options2) {
    var elements = buildExpression$1(group.body, options2, true);
    return makeSpan2([group.mclass], elements, options2);
  }
  function mathmlBuilder$8(group, options2) {
    var node;
    var inner2 = buildExpression2(group.body, options2);
    if (group.mclass === "minner") {
      node = new mathMLTree.MathNode("mpadded", inner2);
    } else if (group.mclass === "mord") {
      if (group.isCharacterBox) {
        node = inner2[0];
        node.type = "mi";
      } else {
        node = new mathMLTree.MathNode("mi", inner2);
      }
    } else {
      if (group.isCharacterBox) {
        node = inner2[0];
        node.type = "mo";
      } else {
        node = new mathMLTree.MathNode("mo", inner2);
      }
      if (group.mclass === "mbin") {
        node.attributes.lspace = "0.22em";
        node.attributes.rspace = "0.22em";
      } else if (group.mclass === "mpunct") {
        node.attributes.lspace = "0em";
        node.attributes.rspace = "0.17em";
      } else if (group.mclass === "mopen" || group.mclass === "mclose") {
        node.attributes.lspace = "0em";
        node.attributes.rspace = "0em";
      } else if (group.mclass === "minner") {
        node.attributes.lspace = "0.0556em";
        node.attributes.width = "+0.1111em";
      }
    }
    return node;
  }
  function cdArrow(arrowChar, labels, parser2) {
    var funcName = cdArrowFunctionName[arrowChar];
    switch (funcName) {
      case "\\\\cdrightarrow":
      case "\\\\cdleftarrow":
        return parser2.callFunction(funcName, [labels[0]], [labels[1]]);
      case "\\uparrow":
      case "\\downarrow": {
        var leftLabel = parser2.callFunction("\\\\cdleft", [labels[0]], []);
        var bareArrow = {
          type: "atom",
          text: funcName,
          mode: "math",
          family: "rel"
        };
        var sizedArrow = parser2.callFunction("\\Big", [bareArrow], []);
        var rightLabel = parser2.callFunction("\\\\cdright", [labels[1]], []);
        var arrowGroup = {
          type: "ordgroup",
          mode: "math",
          body: [leftLabel, sizedArrow, rightLabel]
        };
        return parser2.callFunction("\\\\cdparent", [arrowGroup], []);
      }
      case "\\\\cdlongequal":
        return parser2.callFunction("\\\\cdlongequal", [], []);
      case "\\Vert": {
        var arrow = {
          type: "textord",
          text: "\\Vert",
          mode: "math"
        };
        return parser2.callFunction("\\Big", [arrow], []);
      }
      default:
        return {
          type: "textord",
          text: " ",
          mode: "math"
        };
    }
  }
  function parseCD(parser2) {
    var parsedRows = [];
    parser2.gullet.beginGroup();
    parser2.gullet.macros.set("\\cr", "\\\\\\relax");
    parser2.gullet.beginGroup();
    while (true) {
      parsedRows.push(parser2.parseExpression(false, "\\\\"));
      parser2.gullet.endGroup();
      parser2.gullet.beginGroup();
      var next = parser2.fetch().text;
      if (next === "&" || next === "\\\\") {
        parser2.consume();
      } else if (next === "\\end") {
        if (parsedRows[parsedRows.length - 1].length === 0) {
          parsedRows.pop();
        }
        break;
      } else {
        throw new ParseError("Expected \\\\ or \\cr or \\end", parser2.nextToken);
      }
    }
    var row = [];
    var body = [row];
    for (var i = 0; i < parsedRows.length; i++) {
      var rowNodes = parsedRows[i];
      var cell = newCell();
      for (var j = 0; j < rowNodes.length; j++) {
        if (!isStartOfArrow(rowNodes[j])) {
          cell.body.push(rowNodes[j]);
        } else {
          row.push(cell);
          j += 1;
          var arrowChar = assertSymbolNodeType(rowNodes[j]).text;
          var labels = new Array(2);
          labels[0] = {
            type: "ordgroup",
            mode: "math",
            body: []
          };
          labels[1] = {
            type: "ordgroup",
            mode: "math",
            body: []
          };
          if ("=|.".indexOf(arrowChar) > -1) ;
          else if ("<>AV".indexOf(arrowChar) > -1) {
            for (var labelNum = 0; labelNum < 2; labelNum++) {
              var inLabel = true;
              for (var k = j + 1; k < rowNodes.length; k++) {
                if (isLabelEnd(rowNodes[k], arrowChar)) {
                  inLabel = false;
                  j = k;
                  break;
                }
                if (isStartOfArrow(rowNodes[k])) {
                  throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k]);
                }
                labels[labelNum].body.push(rowNodes[k]);
              }
              if (inLabel) {
                throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j]);
              }
            }
          } else {
            throw new ParseError('Expected one of "<>AV=|." after @', rowNodes[j]);
          }
          var arrow = cdArrow(arrowChar, labels, parser2);
          var wrappedArrow = {
            type: "styling",
            body: [arrow],
            mode: "math",
            style: "display"
            // CD is always displaystyle.
          };
          row.push(wrappedArrow);
          cell = newCell();
        }
      }
      if (i % 2 === 0) {
        row.push(cell);
      } else {
        row.shift();
      }
      row = [];
      body.push(row);
    }
    parser2.gullet.endGroup();
    parser2.gullet.endGroup();
    var cols = new Array(body[0].length).fill({
      type: "align",
      align: "c",
      pregap: 0.25,
      // CD package sets \enskip between columns.
      postgap: 0.25
      // So pre and post each get half an \enskip, i.e. 0.25em.
    });
    return {
      type: "array",
      mode: "math",
      body,
      arraystretch: 1,
      addJot: true,
      rowGaps: [null],
      cols,
      colSeparationType: "CD",
      hLinesBeforeRow: new Array(body.length + 1).fill([])
    };
  }
  function checkDelimiter(delim, context) {
    var symDelim = checkSymbolNodeType(delim);
    if (symDelim && utils.contains(delimiters, symDelim.text)) {
      return symDelim;
    } else if (symDelim) {
      throw new ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
    } else {
      throw new ParseError("Invalid delimiter type '" + delim.type + "'", delim);
    }
  }
  function assertParsed(group) {
    if (!group.body) {
      throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
    }
  }
  function defineEnvironment(_ref) {
    var {
      type,
      names,
      props,
      handler,
      htmlBuilder: htmlBuilder3,
      mathmlBuilder: mathmlBuilder3
    } = _ref;
    var data = {
      type,
      numArgs: props.numArgs || 0,
      allowedInText: false,
      numOptionalArgs: 0,
      handler
    };
    for (var i = 0; i < names.length; ++i) {
      _environments[names[i]] = data;
    }
    if (htmlBuilder3) {
      _htmlGroupBuilders[type] = htmlBuilder3;
    }
    if (mathmlBuilder3) {
      _mathmlGroupBuilders[type] = mathmlBuilder3;
    }
  }
  function defineMacro(name, body) {
    _macros[name] = body;
  }
  function getHLines(parser2) {
    var hlineInfo = [];
    parser2.consumeSpaces();
    var nxt = parser2.fetch().text;
    if (nxt === "\\relax") {
      parser2.consume();
      parser2.consumeSpaces();
      nxt = parser2.fetch().text;
    }
    while (nxt === "\\hline" || nxt === "\\hdashline") {
      parser2.consume();
      hlineInfo.push(nxt === "\\hdashline");
      parser2.consumeSpaces();
      nxt = parser2.fetch().text;
    }
    return hlineInfo;
  }
  function getAutoTag(name) {
    if (name.indexOf("ed") === -1) {
      return name.indexOf("*") === -1;
    }
  }
  function parseArray(parser2, _ref, style) {
    var {
      hskipBeforeAndAfter,
      addJot,
      cols,
      arraystretch,
      colSeparationType,
      autoTag,
      singleRow,
      emptySingleRow,
      maxNumCols,
      leqno
    } = _ref;
    parser2.gullet.beginGroup();
    if (!singleRow) {
      parser2.gullet.macros.set("\\cr", "\\\\\\relax");
    }
    if (!arraystretch) {
      var stretch = parser2.gullet.expandMacroAsText("\\arraystretch");
      if (stretch == null) {
        arraystretch = 1;
      } else {
        arraystretch = parseFloat(stretch);
        if (!arraystretch || arraystretch < 0) {
          throw new ParseError("Invalid \\arraystretch: " + stretch);
        }
      }
    }
    parser2.gullet.beginGroup();
    var row = [];
    var body = [row];
    var rowGaps = [];
    var hLinesBeforeRow = [];
    var tags = autoTag != null ? [] : void 0;
    function beginRow() {
      if (autoTag) {
        parser2.gullet.macros.set("\\@eqnsw", "1", true);
      }
    }
    function endRow() {
      if (tags) {
        if (parser2.gullet.macros.get("\\df@tag")) {
          tags.push(parser2.subparse([new Token("\\df@tag")]));
          parser2.gullet.macros.set("\\df@tag", void 0, true);
        } else {
          tags.push(Boolean(autoTag) && parser2.gullet.macros.get("\\@eqnsw") === "1");
        }
      }
    }
    beginRow();
    hLinesBeforeRow.push(getHLines(parser2));
    while (true) {
      var cell = parser2.parseExpression(false, singleRow ? "\\end" : "\\\\");
      parser2.gullet.endGroup();
      parser2.gullet.beginGroup();
      cell = {
        type: "ordgroup",
        mode: parser2.mode,
        body: cell
      };
      if (style) {
        cell = {
          type: "styling",
          mode: parser2.mode,
          style,
          body: [cell]
        };
      }
      row.push(cell);
      var next = parser2.fetch().text;
      if (next === "&") {
        if (maxNumCols && row.length === maxNumCols) {
          if (singleRow || colSeparationType) {
            throw new ParseError("Too many tab characters: &", parser2.nextToken);
          } else {
            parser2.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
          }
        }
        parser2.consume();
      } else if (next === "\\end") {
        endRow();
        if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
          body.pop();
        }
        if (hLinesBeforeRow.length < body.length + 1) {
          hLinesBeforeRow.push([]);
        }
        break;
      } else if (next === "\\\\") {
        parser2.consume();
        var size = void 0;
        if (parser2.gullet.future().text !== " ") {
          size = parser2.parseSizeGroup(true);
        }
        rowGaps.push(size ? size.value : null);
        endRow();
        hLinesBeforeRow.push(getHLines(parser2));
        row = [];
        body.push(row);
        beginRow();
      } else {
        throw new ParseError("Expected & or \\\\ or \\cr or \\end", parser2.nextToken);
      }
    }
    parser2.gullet.endGroup();
    parser2.gullet.endGroup();
    return {
      type: "array",
      mode: parser2.mode,
      addJot,
      arraystretch,
      body,
      cols,
      rowGaps,
      hskipBeforeAndAfter,
      hLinesBeforeRow,
      colSeparationType,
      tags,
      leqno
    };
  }
  function dCellStyle(envName) {
    if (envName.slice(0, 1) === "d") {
      return "display";
    } else {
      return "text";
    }
  }
  function sizingGroup(value, options2, baseOptions) {
    var inner2 = buildExpression$1(value, options2, false);
    var multiplier = options2.sizeMultiplier / baseOptions.sizeMultiplier;
    for (var i = 0; i < inner2.length; i++) {
      var pos = inner2[i].classes.indexOf("sizing");
      if (pos < 0) {
        Array.prototype.push.apply(inner2[i].classes, options2.sizingClasses(baseOptions));
      } else if (inner2[i].classes[pos + 1] === "reset-size" + options2.size) {
        inner2[i].classes[pos + 1] = "reset-size" + baseOptions.size;
      }
      inner2[i].height *= multiplier;
      inner2[i].depth *= multiplier;
    }
    return buildCommon.makeFragment(inner2);
  }
  var SourceLocation, Token, ParseError, contains, deflt, uppercase, hyphenate, ESCAPE_LOOKUP, ESCAPE_REGEX, getBaseElem, isCharacterBox, assert, protocolFromUrl, utils, SETTINGS_SCHEMA, Settings, Style, D, Dc, T, Tc, S, Sc, SS, SSc, styles, sup, sub, fracNum, fracDen, cramp, text$1, Style$1, scriptData, allBlocks, hLinePad, sqrtMain, sqrtSize1, sqrtSize2, sqrtSize3, sqrtSize4, phasePath, sqrtTall, sqrtPath, innerPath, path, tallDelim, DocumentFragment, fontMetricsData, sigmasAndXis, extraCharacterMap, fontMetricsBySizeIndex, sizeStyleMap, sizeMultipliers, sizeAtStyle, Options, ptPerUnit, relativeUnit, validUnit, calculateSize, makeEm, createClass, initNode, toNode, invalidAttributeNameRegex, toMarkup, Span, Anchor, Img, iCombinations, SymbolNode, SvgNode, PathNode, LineNode, ATOMS, NON_ATOMS, symbols, math, text, main, ams, accent, bin, close, inner, mathord, op, open, punct, rel, spacing, textord, ligatures, mathTextSymbols, ch, i, textSymbols, _ch, _i, letters, _ch2, _i2, wideChar, _ch3, _i3, _ch4, _i4, extraLatin, _ch5, _i5, wideLatinLetterData, wideNumeralData, wideCharacterFont, lookupSymbol, makeSymbol, mathsym, boldsymbol, makeOrd, canCombine, tryCombineChars, sizeElementFromChildren, makeSpan$2, makeSvgSpan, makeLineSpan, makeAnchor, makeFragment, wrapFragment, getVListChildrenAndDepth, makeVList, makeGlue, retrieveTextFontName, fontMap, svgData, staticSvg, buildCommon, thinspace, mediumspace, thickspace, spacings, tightSpacings, _functions, _htmlGroupBuilders, _mathmlGroupBuilders, normalizeArgument, ordargument, makeSpan$1, binLeftCanceller, binRightCanceller, styleMap$1, DomEnum, buildExpression$1, traverseNonSpaceNodes, checkPartialGroup, getOutermostNode, getTypeOfDomTree, makeNullDelimiter, buildGroup$1, MathNode, TextNode, SpaceNode, mathMLTree, makeText, makeRow, getVariant, buildExpression2, buildExpressionRow, buildGroup2, optionsFromSettings, displayWrap, buildTree, buildHTMLTree, stretchyCodePoint, mathMLnode, katexImagesData, groupLength, svgSpan, encloseSpan, stretchy, htmlBuilder$a, mathmlBuilder$9, NON_STRETCHY_ACCENT_REGEX, paddedNode, makeSpan2, binrelClass, cdArrowFunctionName, newCell, isStartOfArrow, isLabelEnd, htmlBuilder$8, mathmlBuilder$7, globalMap, checkControlSequence, getRHS, letCommand, getMetrics, styleWrap, centerSpan, makeSmallDelim, mathrmSize, makeLargeDelim, makeGlyphSpan, makeInner, lapInEms, lap, verts, doubleVerts, makeStackedDelim, vbPad, emPad, sqrtSvg, makeSqrtImage, stackLargeDelimiters, stackAlwaysDelimiters, stackNeverDelimiters, sizeToMaxHeight, makeSizedDelim, stackNeverDelimiterSequence, stackAlwaysDelimiterSequence, stackLargeDelimiterSequence, delimTypeToFont, traverseSequence, makeCustomSizedDelim, makeLeftRightDelim, delimiter, delimiterSizes, delimiters, htmlBuilder$7, mathmlBuilder$6, _environments, _macros, validateAmsEnvironmentContext, htmlBuilder$6, alignMap, mathmlBuilder$5, alignedHandler, environments, htmlBuilder$5, mathmlBuilder$4, fontAliases, adjustStyle, htmlBuilder$4, mathmlBuilder$3, stylArray, delimFromValue, htmlBuilder$3, mathmlBuilder$2, sizeData, chooseMathStyle, assembleSupSub, noSuccessor, htmlBuilder$2, mathmlBuilder$1, singleCharBigOps, singleCharIntegrals, htmlBuilder$1, mathmlBuilder2, sizeFuncs, htmlBuilder2, styleMap, htmlBuilderDelegate, defaultVariant, cssSpace, regularSpace, pad, textFontFamilies, textFontWeights, textFontShapes, optionsWithFont, makeVerb, functions, spaceRegexString, controlWordRegexString, controlSymbolRegexString, controlWordWhitespaceRegexString, controlSpaceRegexString, combiningDiacriticalMarkString, combiningDiacriticalMarksEndRegex, tokenRegexString, Lexer, Namespace, macros, digitToNumber, newcommand, dotsByToken, spaceAfterDots, latexRaiseA, braketHelper, implicitCommands, MacroExpander, unicodeSubRegEx, uSubsAndSups, unicodeAccents, unicodeSymbols, Parser, parseTree, render, renderToString, generateParseTree, renderError, renderToDomTree, renderToHTMLTree, version, __domTree, katex;
  var init_katex = __esm({
    "node_modules/katex/dist/katex.mjs"() {
      SourceLocation = class _SourceLocation {
        // The + prefix indicates that these fields aren't writeable
        // Lexer holding the input string.
        // Start offset, zero-based inclusive.
        // End offset, zero-based exclusive.
        constructor(lexer2, start, end) {
          this.lexer = void 0;
          this.start = void 0;
          this.end = void 0;
          this.lexer = lexer2;
          this.start = start;
          this.end = end;
        }
        /**
         * Merges two `SourceLocation`s from location providers, given they are
         * provided in order of appearance.
         * - Returns the first one's location if only the first is provided.
         * - Returns a merged range of the first and the last if both are provided
         *   and their lexers match.
         * - Otherwise, returns null.
         */
        static range(first, second) {
          if (!second) {
            return first && first.loc;
          } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
            return null;
          } else {
            return new _SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
          }
        }
      };
      Token = class _Token {
        // don't expand the token
        // used in \noexpand
        constructor(text2, loc) {
          this.text = void 0;
          this.loc = void 0;
          this.noexpand = void 0;
          this.treatAsRelax = void 0;
          this.text = text2;
          this.loc = loc;
        }
        /**
         * Given a pair of tokens (this and endToken), compute a `Token` encompassing
         * the whole input range enclosed by these two.
         */
        range(endToken, text2) {
          return new _Token(text2, SourceLocation.range(this, endToken));
        }
      };
      ParseError = class _ParseError {
        // Error start position based on passed-in Token or ParseNode.
        // Length of affected text based on passed-in Token or ParseNode.
        // The underlying error message without any context added.
        constructor(message, token) {
          this.name = void 0;
          this.position = void 0;
          this.length = void 0;
          this.rawMessage = void 0;
          var error = "KaTeX parse error: " + message;
          var start;
          var end;
          var loc = token && token.loc;
          if (loc && loc.start <= loc.end) {
            var input = loc.lexer.input;
            start = loc.start;
            end = loc.end;
            if (start === input.length) {
              error += " at end of input: ";
            } else {
              error += " at position " + (start + 1) + ": ";
            }
            var underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332");
            var left;
            if (start > 15) {
              left = "\u2026" + input.slice(start - 15, start);
            } else {
              left = input.slice(0, start);
            }
            var right;
            if (end + 15 < input.length) {
              right = input.slice(end, end + 15) + "\u2026";
            } else {
              right = input.slice(end);
            }
            error += left + underlined + right;
          }
          var self2 = new Error(error);
          self2.name = "ParseError";
          self2.__proto__ = _ParseError.prototype;
          self2.position = start;
          if (start != null && end != null) {
            self2.length = end - start;
          }
          self2.rawMessage = message;
          return self2;
        }
      };
      ParseError.prototype.__proto__ = Error.prototype;
      contains = function contains2(list2, elem) {
        return list2.indexOf(elem) !== -1;
      };
      deflt = function deflt2(setting, defaultIfUndefined) {
        return setting === void 0 ? defaultIfUndefined : setting;
      };
      uppercase = /([A-Z])/g;
      hyphenate = function hyphenate2(str) {
        return str.replace(uppercase, "-$1").toLowerCase();
      };
      ESCAPE_LOOKUP = {
        "&": "&amp;",
        ">": "&gt;",
        "<": "&lt;",
        '"': "&quot;",
        "'": "&#x27;"
      };
      ESCAPE_REGEX = /[&><"']/g;
      getBaseElem = function getBaseElem2(group) {
        if (group.type === "ordgroup") {
          if (group.body.length === 1) {
            return getBaseElem2(group.body[0]);
          } else {
            return group;
          }
        } else if (group.type === "color") {
          if (group.body.length === 1) {
            return getBaseElem2(group.body[0]);
          } else {
            return group;
          }
        } else if (group.type === "font") {
          return getBaseElem2(group.body);
        } else {
          return group;
        }
      };
      isCharacterBox = function isCharacterBox2(group) {
        var baseElem = getBaseElem(group);
        return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
      };
      assert = function assert2(value) {
        if (!value) {
          throw new Error("Expected non-null, but got " + String(value));
        }
        return value;
      };
      protocolFromUrl = function protocolFromUrl2(url) {
        var protocol = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);
        if (!protocol) {
          return "_relative";
        }
        if (protocol[2] !== ":") {
          return null;
        }
        if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol[1])) {
          return null;
        }
        return protocol[1].toLowerCase();
      };
      utils = {
        contains,
        deflt,
        escape: escape2,
        hyphenate,
        getBaseElem,
        isCharacterBox,
        protocolFromUrl
      };
      SETTINGS_SCHEMA = {
        displayMode: {
          type: "boolean",
          description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
          cli: "-d, --display-mode"
        },
        output: {
          type: {
            enum: ["htmlAndMathml", "html", "mathml"]
          },
          description: "Determines the markup language of the output.",
          cli: "-F, --format <type>"
        },
        leqno: {
          type: "boolean",
          description: "Render display math in leqno style (left-justified tags)."
        },
        fleqn: {
          type: "boolean",
          description: "Render display math flush left."
        },
        throwOnError: {
          type: "boolean",
          default: true,
          cli: "-t, --no-throw-on-error",
          cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
        },
        errorColor: {
          type: "string",
          default: "#cc0000",
          cli: "-c, --error-color <color>",
          cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
          cliProcessor: (color) => "#" + color
        },
        macros: {
          type: "object",
          cli: "-m, --macro <def>",
          cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
          cliDefault: [],
          cliProcessor: (def2, defs) => {
            defs.push(def2);
            return defs;
          }
        },
        minRuleThickness: {
          type: "number",
          description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
          processor: (t) => Math.max(0, t),
          cli: "--min-rule-thickness <size>",
          cliProcessor: parseFloat
        },
        colorIsTextColor: {
          type: "boolean",
          description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
          cli: "-b, --color-is-text-color"
        },
        strict: {
          type: [{
            enum: ["warn", "ignore", "error"]
          }, "boolean", "function"],
          description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
          cli: "-S, --strict",
          cliDefault: false
        },
        trust: {
          type: ["boolean", "function"],
          description: "Trust the input, enabling all HTML features such as \\url.",
          cli: "-T, --trust"
        },
        maxSize: {
          type: "number",
          default: Infinity,
          description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
          processor: (s) => Math.max(0, s),
          cli: "-s, --max-size <n>",
          cliProcessor: parseInt
        },
        maxExpand: {
          type: "number",
          default: 1e3,
          description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
          processor: (n) => Math.max(0, n),
          cli: "-e, --max-expand <n>",
          cliProcessor: (n) => n === "Infinity" ? Infinity : parseInt(n)
        },
        globalGroup: {
          type: "boolean",
          cli: false
        }
      };
      Settings = class {
        constructor(options2) {
          this.displayMode = void 0;
          this.output = void 0;
          this.leqno = void 0;
          this.fleqn = void 0;
          this.throwOnError = void 0;
          this.errorColor = void 0;
          this.macros = void 0;
          this.minRuleThickness = void 0;
          this.colorIsTextColor = void 0;
          this.strict = void 0;
          this.trust = void 0;
          this.maxSize = void 0;
          this.maxExpand = void 0;
          this.globalGroup = void 0;
          options2 = options2 || {};
          for (var prop in SETTINGS_SCHEMA) {
            if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {
              var schema = SETTINGS_SCHEMA[prop];
              this[prop] = options2[prop] !== void 0 ? schema.processor ? schema.processor(options2[prop]) : options2[prop] : getDefaultValue(schema);
            }
          }
        }
        /**
         * Report nonstrict (non-LaTeX-compatible) input.
         * Can safely not be called if `this.strict` is false in JavaScript.
         */
        reportNonstrict(errorCode, errorMsg, token) {
          var strict = this.strict;
          if (typeof strict === "function") {
            strict = strict(errorCode, errorMsg, token);
          }
          if (!strict || strict === "ignore") {
            return;
          } else if (strict === true || strict === "error") {
            throw new ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
          } else if (strict === "warn") {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
          } else {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
          }
        }
        /**
         * Check whether to apply strict (LaTeX-adhering) behavior for unusual
         * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
         * instead, "error" translates to a return value of `true`, while "ignore"
         * translates to a return value of `false`.  May still print a warning:
         * "warn" prints a warning and returns `false`.
         * This is for the second category of `errorCode`s listed in the README.
         */
        useStrictBehavior(errorCode, errorMsg, token) {
          var strict = this.strict;
          if (typeof strict === "function") {
            try {
              strict = strict(errorCode, errorMsg, token);
            } catch (error) {
              strict = "error";
            }
          }
          if (!strict || strict === "ignore") {
            return false;
          } else if (strict === true || strict === "error") {
            return true;
          } else if (strict === "warn") {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
            return false;
          } else {
            typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
            return false;
          }
        }
        /**
         * Check whether to test potentially dangerous input, and return
         * `true` (trusted) or `false` (untrusted).  The sole argument `context`
         * should be an object with `command` field specifying the relevant LaTeX
         * command (as a string starting with `\`), and any other arguments, etc.
         * If `context` has a `url` field, a `protocol` field will automatically
         * get added by this function (changing the specified object).
         */
        isTrusted(context) {
          if (context.url && !context.protocol) {
            var protocol = utils.protocolFromUrl(context.url);
            if (protocol == null) {
              return false;
            }
            context.protocol = protocol;
          }
          var trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
          return Boolean(trust);
        }
      };
      Style = class {
        constructor(id, size, cramped) {
          this.id = void 0;
          this.size = void 0;
          this.cramped = void 0;
          this.id = id;
          this.size = size;
          this.cramped = cramped;
        }
        /**
         * Get the style of a superscript given a base in the current style.
         */
        sup() {
          return styles[sup[this.id]];
        }
        /**
         * Get the style of a subscript given a base in the current style.
         */
        sub() {
          return styles[sub[this.id]];
        }
        /**
         * Get the style of a fraction numerator given the fraction in the current
         * style.
         */
        fracNum() {
          return styles[fracNum[this.id]];
        }
        /**
         * Get the style of a fraction denominator given the fraction in the current
         * style.
         */
        fracDen() {
          return styles[fracDen[this.id]];
        }
        /**
         * Get the cramped version of a style (in particular, cramping a cramped style
         * doesn't change the style).
         */
        cramp() {
          return styles[cramp[this.id]];
        }
        /**
         * Get a text or display version of this style.
         */
        text() {
          return styles[text$1[this.id]];
        }
        /**
         * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
         */
        isTight() {
          return this.size >= 2;
        }
      };
      D = 0;
      Dc = 1;
      T = 2;
      Tc = 3;
      S = 4;
      Sc = 5;
      SS = 6;
      SSc = 7;
      styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)];
      sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
      sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
      fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
      fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
      cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
      text$1 = [D, Dc, T, Tc, T, Tc, T, Tc];
      Style$1 = {
        DISPLAY: styles[D],
        TEXT: styles[T],
        SCRIPT: styles[S],
        SCRIPTSCRIPT: styles[SS]
      };
      scriptData = [{
        // Latin characters beyond the Latin-1 characters we have metrics for.
        // Needed for Czech, Hungarian and Turkish text, for example.
        name: "latin",
        blocks: [
          [256, 591],
          // Latin Extended-A and Latin Extended-B
          [768, 879]
          // Combining Diacritical marks
        ]
      }, {
        // The Cyrillic script used by Russian and related languages.
        // A Cyrillic subset used to be supported as explicitly defined
        // symbols in symbols.js
        name: "cyrillic",
        blocks: [[1024, 1279]]
      }, {
        // Armenian
        name: "armenian",
        blocks: [[1328, 1423]]
      }, {
        // The Brahmic scripts of South and Southeast Asia
        // Devanagari (0900–097F)
        // Bengali (0980–09FF)
        // Gurmukhi (0A00–0A7F)
        // Gujarati (0A80–0AFF)
        // Oriya (0B00–0B7F)
        // Tamil (0B80–0BFF)
        // Telugu (0C00–0C7F)
        // Kannada (0C80–0CFF)
        // Malayalam (0D00–0D7F)
        // Sinhala (0D80–0DFF)
        // Thai (0E00–0E7F)
        // Lao (0E80–0EFF)
        // Tibetan (0F00–0FFF)
        // Myanmar (1000–109F)
        name: "brahmic",
        blocks: [[2304, 4255]]
      }, {
        name: "georgian",
        blocks: [[4256, 4351]]
      }, {
        // Chinese and Japanese.
        // The "k" in cjk is for Korean, but we've separated Korean out
        name: "cjk",
        blocks: [
          [12288, 12543],
          // CJK symbols and punctuation, Hiragana, Katakana
          [19968, 40879],
          // CJK ideograms
          [65280, 65376]
          // Fullwidth punctuation
          // TODO: add halfwidth Katakana and Romanji glyphs
        ]
      }, {
        // Korean
        name: "hangul",
        blocks: [[44032, 55215]]
      }];
      allBlocks = [];
      scriptData.forEach((s) => s.blocks.forEach((b) => allBlocks.push(...b)));
      hLinePad = 80;
      sqrtMain = function sqrtMain2(extraVinculum, hLinePad2) {
        return "M95," + (622 + extraVinculum + hLinePad2) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraVinculum / 2.075 + " -" + extraVinculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraVinculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
      };
      sqrtSize1 = function sqrtSize12(extraVinculum, hLinePad2) {
        return "M263," + (601 + extraVinculum + hLinePad2) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraVinculum / 2.084 + " -" + extraVinculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraVinculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
      };
      sqrtSize2 = function sqrtSize22(extraVinculum, hLinePad2) {
        return "M983 " + (10 + extraVinculum + hLinePad2) + "\nl" + extraVinculum / 3.13 + " -" + extraVinculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraVinculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
      };
      sqrtSize3 = function sqrtSize32(extraVinculum, hLinePad2) {
        return "M424," + (2398 + extraVinculum + hLinePad2) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraVinculum / 4.223 + " -" + extraVinculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraVinculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraVinculum) + " " + hLinePad2 + "\nh400000v" + (40 + extraVinculum) + "h-400000z";
      };
      sqrtSize4 = function sqrtSize42(extraVinculum, hLinePad2) {
        return "M473," + (2713 + extraVinculum + hLinePad2) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraVinculum / 5.298 + " -" + extraVinculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraVinculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "H1017.7z";
      };
      phasePath = function phasePath2(y) {
        var x = y / 2;
        return "M400000 " + y + " H0 L" + x + " 0 l65 45 L145 " + (y - 80) + " H400000z";
      };
      sqrtTall = function sqrtTall2(extraVinculum, hLinePad2, viewBoxHeight) {
        var vertSegment = viewBoxHeight - 54 - hLinePad2 - extraVinculum;
        return "M702 " + (extraVinculum + hLinePad2) + "H400000" + (40 + extraVinculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad2 + "H400000v" + (40 + extraVinculum) + "H742z";
      };
      sqrtPath = function sqrtPath2(size, extraVinculum, viewBoxHeight) {
        extraVinculum = 1e3 * extraVinculum;
        var path2 = "";
        switch (size) {
          case "sqrtMain":
            path2 = sqrtMain(extraVinculum, hLinePad);
            break;
          case "sqrtSize1":
            path2 = sqrtSize1(extraVinculum, hLinePad);
            break;
          case "sqrtSize2":
            path2 = sqrtSize2(extraVinculum, hLinePad);
            break;
          case "sqrtSize3":
            path2 = sqrtSize3(extraVinculum, hLinePad);
            break;
          case "sqrtSize4":
            path2 = sqrtSize4(extraVinculum, hLinePad);
            break;
          case "sqrtTall":
            path2 = sqrtTall(extraVinculum, hLinePad, viewBoxHeight);
        }
        return path2;
      };
      innerPath = function innerPath2(name, height) {
        switch (name) {
          case "\u239C":
            return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
          case "\u2223":
            return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
          case "\u2225":
            return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");
          case "\u239F":
            return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
          case "\u23A2":
            return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
          case "\u23A5":
            return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
          case "\u23AA":
            return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
          case "\u23D0":
            return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
          case "\u2016":
            return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");
          default:
            return "";
        }
      };
      path = {
        // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
        doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
        // doublerightarrow is from glyph U+21D2 in font KaTeX Main
        doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
        // leftarrow is from glyph U+2190 in font KaTeX Main
        leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
        // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
        leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
        leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
        // overgroup is from the MnSymbol package (public domain)
        leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
        leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
        // Harpoons are from glyph U+21BD in font KaTeX Main
        leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
        leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
        leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
        leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
        // hook is from glyph U+21A9 in font KaTeX Main
        lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
        leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
        leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
        // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
        leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
        longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
        midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
        midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
        oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
        oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
        oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
        oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
        rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
        rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
        rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
        rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
        rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
        rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
        rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
        rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
        rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
        righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
        rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
        rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
        // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
        twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
        twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
        // tilde1 is a modified version of a glyph from the MnSymbol package
        tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
        // ditto tilde2, tilde3, & tilde4
        tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
        tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
        tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
        // vec is from glyph U+20D7 in font KaTeX Main
        vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
        // widehat1 is a modified version of a glyph from the MnSymbol package
        widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
        // ditto widehat2, widehat3, & widehat4
        widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
        // widecheck paths are all inverted versions of widehat
        widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
        widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
        // The next ten paths support reaction arrows from the mhchem package.
        // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
        // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
        baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
        // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
        rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
        // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
        // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
        baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
        rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
        shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
        shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
      };
      tallDelim = function tallDelim2(label, midHeight) {
        switch (label) {
          case "lbrack":
            return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";
          case "rbrack":
            return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";
          case "vert":
            return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";
          case "doublevert":
            return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";
          case "lfloor":
            return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
          case "rfloor":
            return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
          case "lceil":
            return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";
          case "rceil":
            return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";
          case "lparen":
            return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";
          case "rparen":
            return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";
          default:
            throw new Error("Unknown stretchy delimiter.");
        }
      };
      DocumentFragment = class {
        // HtmlDomNode
        // Never used; needed for satisfying interface.
        constructor(children) {
          this.children = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          this.children = children;
          this.classes = [];
          this.height = 0;
          this.depth = 0;
          this.maxFontSize = 0;
          this.style = {};
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        /** Convert the fragment into a node. */
        toNode() {
          var frag = document.createDocumentFragment();
          for (var i = 0; i < this.children.length; i++) {
            frag.appendChild(this.children[i].toNode());
          }
          return frag;
        }
        /** Convert the fragment into HTML markup. */
        toMarkup() {
          var markup = "";
          for (var i = 0; i < this.children.length; i++) {
            markup += this.children[i].toMarkup();
          }
          return markup;
        }
        /**
         * Converts the math node into a string, similar to innerText. Applies to
         * MathDomNode's only.
         */
        toText() {
          var toText = (child) => child.toText();
          return this.children.map(toText).join("");
        }
      };
      fontMetricsData = {
        "AMS-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.68889, 0, 0, 0.72222],
          "66": [0, 0.68889, 0, 0, 0.66667],
          "67": [0, 0.68889, 0, 0, 0.72222],
          "68": [0, 0.68889, 0, 0, 0.72222],
          "69": [0, 0.68889, 0, 0, 0.66667],
          "70": [0, 0.68889, 0, 0, 0.61111],
          "71": [0, 0.68889, 0, 0, 0.77778],
          "72": [0, 0.68889, 0, 0, 0.77778],
          "73": [0, 0.68889, 0, 0, 0.38889],
          "74": [0.16667, 0.68889, 0, 0, 0.5],
          "75": [0, 0.68889, 0, 0, 0.77778],
          "76": [0, 0.68889, 0, 0, 0.66667],
          "77": [0, 0.68889, 0, 0, 0.94445],
          "78": [0, 0.68889, 0, 0, 0.72222],
          "79": [0.16667, 0.68889, 0, 0, 0.77778],
          "80": [0, 0.68889, 0, 0, 0.61111],
          "81": [0.16667, 0.68889, 0, 0, 0.77778],
          "82": [0, 0.68889, 0, 0, 0.72222],
          "83": [0, 0.68889, 0, 0, 0.55556],
          "84": [0, 0.68889, 0, 0, 0.66667],
          "85": [0, 0.68889, 0, 0, 0.72222],
          "86": [0, 0.68889, 0, 0, 0.72222],
          "87": [0, 0.68889, 0, 0, 1],
          "88": [0, 0.68889, 0, 0, 0.72222],
          "89": [0, 0.68889, 0, 0, 0.72222],
          "90": [0, 0.68889, 0, 0, 0.66667],
          "107": [0, 0.68889, 0, 0, 0.55556],
          "160": [0, 0, 0, 0, 0.25],
          "165": [0, 0.675, 0.025, 0, 0.75],
          "174": [0.15559, 0.69224, 0, 0, 0.94666],
          "240": [0, 0.68889, 0, 0, 0.55556],
          "295": [0, 0.68889, 0, 0, 0.54028],
          "710": [0, 0.825, 0, 0, 2.33334],
          "732": [0, 0.9, 0, 0, 2.33334],
          "770": [0, 0.825, 0, 0, 2.33334],
          "771": [0, 0.9, 0, 0, 2.33334],
          "989": [0.08167, 0.58167, 0, 0, 0.77778],
          "1008": [0, 0.43056, 0.04028, 0, 0.66667],
          "8245": [0, 0.54986, 0, 0, 0.275],
          "8463": [0, 0.68889, 0, 0, 0.54028],
          "8487": [0, 0.68889, 0, 0, 0.72222],
          "8498": [0, 0.68889, 0, 0, 0.55556],
          "8502": [0, 0.68889, 0, 0, 0.66667],
          "8503": [0, 0.68889, 0, 0, 0.44445],
          "8504": [0, 0.68889, 0, 0, 0.66667],
          "8513": [0, 0.68889, 0, 0, 0.63889],
          "8592": [-0.03598, 0.46402, 0, 0, 0.5],
          "8594": [-0.03598, 0.46402, 0, 0, 0.5],
          "8602": [-0.13313, 0.36687, 0, 0, 1],
          "8603": [-0.13313, 0.36687, 0, 0, 1],
          "8606": [0.01354, 0.52239, 0, 0, 1],
          "8608": [0.01354, 0.52239, 0, 0, 1],
          "8610": [0.01354, 0.52239, 0, 0, 1.11111],
          "8611": [0.01354, 0.52239, 0, 0, 1.11111],
          "8619": [0, 0.54986, 0, 0, 1],
          "8620": [0, 0.54986, 0, 0, 1],
          "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
          "8622": [-0.13313, 0.36687, 0, 0, 1],
          "8624": [0, 0.69224, 0, 0, 0.5],
          "8625": [0, 0.69224, 0, 0, 0.5],
          "8630": [0, 0.43056, 0, 0, 1],
          "8631": [0, 0.43056, 0, 0, 1],
          "8634": [0.08198, 0.58198, 0, 0, 0.77778],
          "8635": [0.08198, 0.58198, 0, 0, 0.77778],
          "8638": [0.19444, 0.69224, 0, 0, 0.41667],
          "8639": [0.19444, 0.69224, 0, 0, 0.41667],
          "8642": [0.19444, 0.69224, 0, 0, 0.41667],
          "8643": [0.19444, 0.69224, 0, 0, 0.41667],
          "8644": [0.1808, 0.675, 0, 0, 1],
          "8646": [0.1808, 0.675, 0, 0, 1],
          "8647": [0.1808, 0.675, 0, 0, 1],
          "8648": [0.19444, 0.69224, 0, 0, 0.83334],
          "8649": [0.1808, 0.675, 0, 0, 1],
          "8650": [0.19444, 0.69224, 0, 0, 0.83334],
          "8651": [0.01354, 0.52239, 0, 0, 1],
          "8652": [0.01354, 0.52239, 0, 0, 1],
          "8653": [-0.13313, 0.36687, 0, 0, 1],
          "8654": [-0.13313, 0.36687, 0, 0, 1],
          "8655": [-0.13313, 0.36687, 0, 0, 1],
          "8666": [0.13667, 0.63667, 0, 0, 1],
          "8667": [0.13667, 0.63667, 0, 0, 1],
          "8669": [-0.13313, 0.37788, 0, 0, 1],
          "8672": [-0.064, 0.437, 0, 0, 1.334],
          "8674": [-0.064, 0.437, 0, 0, 1.334],
          "8705": [0, 0.825, 0, 0, 0.5],
          "8708": [0, 0.68889, 0, 0, 0.55556],
          "8709": [0.08167, 0.58167, 0, 0, 0.77778],
          "8717": [0, 0.43056, 0, 0, 0.42917],
          "8722": [-0.03598, 0.46402, 0, 0, 0.5],
          "8724": [0.08198, 0.69224, 0, 0, 0.77778],
          "8726": [0.08167, 0.58167, 0, 0, 0.77778],
          "8733": [0, 0.69224, 0, 0, 0.77778],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8737": [0, 0.69224, 0, 0, 0.72222],
          "8738": [0.03517, 0.52239, 0, 0, 0.72222],
          "8739": [0.08167, 0.58167, 0, 0, 0.22222],
          "8740": [0.25142, 0.74111, 0, 0, 0.27778],
          "8741": [0.08167, 0.58167, 0, 0, 0.38889],
          "8742": [0.25142, 0.74111, 0, 0, 0.5],
          "8756": [0, 0.69224, 0, 0, 0.66667],
          "8757": [0, 0.69224, 0, 0, 0.66667],
          "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
          "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8774": [0.30274, 0.79383, 0, 0, 0.77778],
          "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
          "8778": [0.08167, 0.58167, 0, 0, 0.77778],
          "8782": [0.06062, 0.54986, 0, 0, 0.77778],
          "8783": [0.06062, 0.54986, 0, 0, 0.77778],
          "8785": [0.08198, 0.58198, 0, 0, 0.77778],
          "8786": [0.08198, 0.58198, 0, 0, 0.77778],
          "8787": [0.08198, 0.58198, 0, 0, 0.77778],
          "8790": [0, 0.69224, 0, 0, 0.77778],
          "8791": [0.22958, 0.72958, 0, 0, 0.77778],
          "8796": [0.08198, 0.91667, 0, 0, 0.77778],
          "8806": [0.25583, 0.75583, 0, 0, 0.77778],
          "8807": [0.25583, 0.75583, 0, 0, 0.77778],
          "8808": [0.25142, 0.75726, 0, 0, 0.77778],
          "8809": [0.25142, 0.75726, 0, 0, 0.77778],
          "8812": [0.25583, 0.75583, 0, 0, 0.5],
          "8814": [0.20576, 0.70576, 0, 0, 0.77778],
          "8815": [0.20576, 0.70576, 0, 0, 0.77778],
          "8816": [0.30274, 0.79383, 0, 0, 0.77778],
          "8817": [0.30274, 0.79383, 0, 0, 0.77778],
          "8818": [0.22958, 0.72958, 0, 0, 0.77778],
          "8819": [0.22958, 0.72958, 0, 0, 0.77778],
          "8822": [0.1808, 0.675, 0, 0, 0.77778],
          "8823": [0.1808, 0.675, 0, 0, 0.77778],
          "8828": [0.13667, 0.63667, 0, 0, 0.77778],
          "8829": [0.13667, 0.63667, 0, 0, 0.77778],
          "8830": [0.22958, 0.72958, 0, 0, 0.77778],
          "8831": [0.22958, 0.72958, 0, 0, 0.77778],
          "8832": [0.20576, 0.70576, 0, 0, 0.77778],
          "8833": [0.20576, 0.70576, 0, 0, 0.77778],
          "8840": [0.30274, 0.79383, 0, 0, 0.77778],
          "8841": [0.30274, 0.79383, 0, 0, 0.77778],
          "8842": [0.13597, 0.63597, 0, 0, 0.77778],
          "8843": [0.13597, 0.63597, 0, 0, 0.77778],
          "8847": [0.03517, 0.54986, 0, 0, 0.77778],
          "8848": [0.03517, 0.54986, 0, 0, 0.77778],
          "8858": [0.08198, 0.58198, 0, 0, 0.77778],
          "8859": [0.08198, 0.58198, 0, 0, 0.77778],
          "8861": [0.08198, 0.58198, 0, 0, 0.77778],
          "8862": [0, 0.675, 0, 0, 0.77778],
          "8863": [0, 0.675, 0, 0, 0.77778],
          "8864": [0, 0.675, 0, 0, 0.77778],
          "8865": [0, 0.675, 0, 0, 0.77778],
          "8872": [0, 0.69224, 0, 0, 0.61111],
          "8873": [0, 0.69224, 0, 0, 0.72222],
          "8874": [0, 0.69224, 0, 0, 0.88889],
          "8876": [0, 0.68889, 0, 0, 0.61111],
          "8877": [0, 0.68889, 0, 0, 0.61111],
          "8878": [0, 0.68889, 0, 0, 0.72222],
          "8879": [0, 0.68889, 0, 0, 0.72222],
          "8882": [0.03517, 0.54986, 0, 0, 0.77778],
          "8883": [0.03517, 0.54986, 0, 0, 0.77778],
          "8884": [0.13667, 0.63667, 0, 0, 0.77778],
          "8885": [0.13667, 0.63667, 0, 0, 0.77778],
          "8888": [0, 0.54986, 0, 0, 1.11111],
          "8890": [0.19444, 0.43056, 0, 0, 0.55556],
          "8891": [0.19444, 0.69224, 0, 0, 0.61111],
          "8892": [0.19444, 0.69224, 0, 0, 0.61111],
          "8901": [0, 0.54986, 0, 0, 0.27778],
          "8903": [0.08167, 0.58167, 0, 0, 0.77778],
          "8905": [0.08167, 0.58167, 0, 0, 0.77778],
          "8906": [0.08167, 0.58167, 0, 0, 0.77778],
          "8907": [0, 0.69224, 0, 0, 0.77778],
          "8908": [0, 0.69224, 0, 0, 0.77778],
          "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
          "8910": [0, 0.54986, 0, 0, 0.76042],
          "8911": [0, 0.54986, 0, 0, 0.76042],
          "8912": [0.03517, 0.54986, 0, 0, 0.77778],
          "8913": [0.03517, 0.54986, 0, 0, 0.77778],
          "8914": [0, 0.54986, 0, 0, 0.66667],
          "8915": [0, 0.54986, 0, 0, 0.66667],
          "8916": [0, 0.69224, 0, 0, 0.66667],
          "8918": [0.0391, 0.5391, 0, 0, 0.77778],
          "8919": [0.0391, 0.5391, 0, 0, 0.77778],
          "8920": [0.03517, 0.54986, 0, 0, 1.33334],
          "8921": [0.03517, 0.54986, 0, 0, 1.33334],
          "8922": [0.38569, 0.88569, 0, 0, 0.77778],
          "8923": [0.38569, 0.88569, 0, 0, 0.77778],
          "8926": [0.13667, 0.63667, 0, 0, 0.77778],
          "8927": [0.13667, 0.63667, 0, 0, 0.77778],
          "8928": [0.30274, 0.79383, 0, 0, 0.77778],
          "8929": [0.30274, 0.79383, 0, 0, 0.77778],
          "8934": [0.23222, 0.74111, 0, 0, 0.77778],
          "8935": [0.23222, 0.74111, 0, 0, 0.77778],
          "8936": [0.23222, 0.74111, 0, 0, 0.77778],
          "8937": [0.23222, 0.74111, 0, 0, 0.77778],
          "8938": [0.20576, 0.70576, 0, 0, 0.77778],
          "8939": [0.20576, 0.70576, 0, 0, 0.77778],
          "8940": [0.30274, 0.79383, 0, 0, 0.77778],
          "8941": [0.30274, 0.79383, 0, 0, 0.77778],
          "8994": [0.19444, 0.69224, 0, 0, 0.77778],
          "8995": [0.19444, 0.69224, 0, 0, 0.77778],
          "9416": [0.15559, 0.69224, 0, 0, 0.90222],
          "9484": [0, 0.69224, 0, 0, 0.5],
          "9488": [0, 0.69224, 0, 0, 0.5],
          "9492": [0, 0.37788, 0, 0, 0.5],
          "9496": [0, 0.37788, 0, 0, 0.5],
          "9585": [0.19444, 0.68889, 0, 0, 0.88889],
          "9586": [0.19444, 0.74111, 0, 0, 0.88889],
          "9632": [0, 0.675, 0, 0, 0.77778],
          "9633": [0, 0.675, 0, 0, 0.77778],
          "9650": [0, 0.54986, 0, 0, 0.72222],
          "9651": [0, 0.54986, 0, 0, 0.72222],
          "9654": [0.03517, 0.54986, 0, 0, 0.77778],
          "9660": [0, 0.54986, 0, 0, 0.72222],
          "9661": [0, 0.54986, 0, 0, 0.72222],
          "9664": [0.03517, 0.54986, 0, 0, 0.77778],
          "9674": [0.11111, 0.69224, 0, 0, 0.66667],
          "9733": [0.19444, 0.69224, 0, 0, 0.94445],
          "10003": [0, 0.69224, 0, 0, 0.83334],
          "10016": [0, 0.69224, 0, 0, 0.83334],
          "10731": [0.11111, 0.69224, 0, 0, 0.66667],
          "10846": [0.19444, 0.75583, 0, 0, 0.61111],
          "10877": [0.13667, 0.63667, 0, 0, 0.77778],
          "10878": [0.13667, 0.63667, 0, 0, 0.77778],
          "10885": [0.25583, 0.75583, 0, 0, 0.77778],
          "10886": [0.25583, 0.75583, 0, 0, 0.77778],
          "10887": [0.13597, 0.63597, 0, 0, 0.77778],
          "10888": [0.13597, 0.63597, 0, 0, 0.77778],
          "10889": [0.26167, 0.75726, 0, 0, 0.77778],
          "10890": [0.26167, 0.75726, 0, 0, 0.77778],
          "10891": [0.48256, 0.98256, 0, 0, 0.77778],
          "10892": [0.48256, 0.98256, 0, 0, 0.77778],
          "10901": [0.13667, 0.63667, 0, 0, 0.77778],
          "10902": [0.13667, 0.63667, 0, 0, 0.77778],
          "10933": [0.25142, 0.75726, 0, 0, 0.77778],
          "10934": [0.25142, 0.75726, 0, 0, 0.77778],
          "10935": [0.26167, 0.75726, 0, 0, 0.77778],
          "10936": [0.26167, 0.75726, 0, 0, 0.77778],
          "10937": [0.26167, 0.75726, 0, 0, 0.77778],
          "10938": [0.26167, 0.75726, 0, 0, 0.77778],
          "10949": [0.25583, 0.75583, 0, 0, 0.77778],
          "10950": [0.25583, 0.75583, 0, 0, 0.77778],
          "10955": [0.28481, 0.79383, 0, 0, 0.77778],
          "10956": [0.28481, 0.79383, 0, 0, 0.77778],
          "57350": [0.08167, 0.58167, 0, 0, 0.22222],
          "57351": [0.08167, 0.58167, 0, 0, 0.38889],
          "57352": [0.08167, 0.58167, 0, 0, 0.77778],
          "57353": [0, 0.43056, 0.04028, 0, 0.66667],
          "57356": [0.25142, 0.75726, 0, 0, 0.77778],
          "57357": [0.25142, 0.75726, 0, 0, 0.77778],
          "57358": [0.41951, 0.91951, 0, 0, 0.77778],
          "57359": [0.30274, 0.79383, 0, 0, 0.77778],
          "57360": [0.30274, 0.79383, 0, 0, 0.77778],
          "57361": [0.41951, 0.91951, 0, 0, 0.77778],
          "57366": [0.25142, 0.75726, 0, 0, 0.77778],
          "57367": [0.25142, 0.75726, 0, 0, 0.77778],
          "57368": [0.25142, 0.75726, 0, 0, 0.77778],
          "57369": [0.25142, 0.75726, 0, 0, 0.77778],
          "57370": [0.13597, 0.63597, 0, 0, 0.77778],
          "57371": [0.13597, 0.63597, 0, 0, 0.77778]
        },
        "Caligraphic-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.68333, 0, 0.19445, 0.79847],
          "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
          "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
          "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
          "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
          "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
          "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
          "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
          "73": [0, 0.68333, 0.07382, 0, 0.54452],
          "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
          "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
          "76": [0, 0.68333, 0, 0.13889, 0.68972],
          "77": [0, 0.68333, 0, 0.13889, 1.2009],
          "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
          "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
          "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
          "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
          "82": [0, 0.68333, 0, 0.08334, 0.8475],
          "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
          "84": [0, 0.68333, 0.25417, 0, 0.54464],
          "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
          "86": [0, 0.68333, 0.08222, 0, 0.61278],
          "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
          "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
          "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
          "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
          "160": [0, 0, 0, 0, 0.25]
        },
        "Fraktur-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69141, 0, 0, 0.29574],
          "34": [0, 0.69141, 0, 0, 0.21471],
          "38": [0, 0.69141, 0, 0, 0.73786],
          "39": [0, 0.69141, 0, 0, 0.21201],
          "40": [0.24982, 0.74947, 0, 0, 0.38865],
          "41": [0.24982, 0.74947, 0, 0, 0.38865],
          "42": [0, 0.62119, 0, 0, 0.27764],
          "43": [0.08319, 0.58283, 0, 0, 0.75623],
          "44": [0, 0.10803, 0, 0, 0.27764],
          "45": [0.08319, 0.58283, 0, 0, 0.75623],
          "46": [0, 0.10803, 0, 0, 0.27764],
          "47": [0.24982, 0.74947, 0, 0, 0.50181],
          "48": [0, 0.47534, 0, 0, 0.50181],
          "49": [0, 0.47534, 0, 0, 0.50181],
          "50": [0, 0.47534, 0, 0, 0.50181],
          "51": [0.18906, 0.47534, 0, 0, 0.50181],
          "52": [0.18906, 0.47534, 0, 0, 0.50181],
          "53": [0.18906, 0.47534, 0, 0, 0.50181],
          "54": [0, 0.69141, 0, 0, 0.50181],
          "55": [0.18906, 0.47534, 0, 0, 0.50181],
          "56": [0, 0.69141, 0, 0, 0.50181],
          "57": [0.18906, 0.47534, 0, 0, 0.50181],
          "58": [0, 0.47534, 0, 0, 0.21606],
          "59": [0.12604, 0.47534, 0, 0, 0.21606],
          "61": [-0.13099, 0.36866, 0, 0, 0.75623],
          "63": [0, 0.69141, 0, 0, 0.36245],
          "65": [0, 0.69141, 0, 0, 0.7176],
          "66": [0, 0.69141, 0, 0, 0.88397],
          "67": [0, 0.69141, 0, 0, 0.61254],
          "68": [0, 0.69141, 0, 0, 0.83158],
          "69": [0, 0.69141, 0, 0, 0.66278],
          "70": [0.12604, 0.69141, 0, 0, 0.61119],
          "71": [0, 0.69141, 0, 0, 0.78539],
          "72": [0.06302, 0.69141, 0, 0, 0.7203],
          "73": [0, 0.69141, 0, 0, 0.55448],
          "74": [0.12604, 0.69141, 0, 0, 0.55231],
          "75": [0, 0.69141, 0, 0, 0.66845],
          "76": [0, 0.69141, 0, 0, 0.66602],
          "77": [0, 0.69141, 0, 0, 1.04953],
          "78": [0, 0.69141, 0, 0, 0.83212],
          "79": [0, 0.69141, 0, 0, 0.82699],
          "80": [0.18906, 0.69141, 0, 0, 0.82753],
          "81": [0.03781, 0.69141, 0, 0, 0.82699],
          "82": [0, 0.69141, 0, 0, 0.82807],
          "83": [0, 0.69141, 0, 0, 0.82861],
          "84": [0, 0.69141, 0, 0, 0.66899],
          "85": [0, 0.69141, 0, 0, 0.64576],
          "86": [0, 0.69141, 0, 0, 0.83131],
          "87": [0, 0.69141, 0, 0, 1.04602],
          "88": [0, 0.69141, 0, 0, 0.71922],
          "89": [0.18906, 0.69141, 0, 0, 0.83293],
          "90": [0.12604, 0.69141, 0, 0, 0.60201],
          "91": [0.24982, 0.74947, 0, 0, 0.27764],
          "93": [0.24982, 0.74947, 0, 0, 0.27764],
          "94": [0, 0.69141, 0, 0, 0.49965],
          "97": [0, 0.47534, 0, 0, 0.50046],
          "98": [0, 0.69141, 0, 0, 0.51315],
          "99": [0, 0.47534, 0, 0, 0.38946],
          "100": [0, 0.62119, 0, 0, 0.49857],
          "101": [0, 0.47534, 0, 0, 0.40053],
          "102": [0.18906, 0.69141, 0, 0, 0.32626],
          "103": [0.18906, 0.47534, 0, 0, 0.5037],
          "104": [0.18906, 0.69141, 0, 0, 0.52126],
          "105": [0, 0.69141, 0, 0, 0.27899],
          "106": [0, 0.69141, 0, 0, 0.28088],
          "107": [0, 0.69141, 0, 0, 0.38946],
          "108": [0, 0.69141, 0, 0, 0.27953],
          "109": [0, 0.47534, 0, 0, 0.76676],
          "110": [0, 0.47534, 0, 0, 0.52666],
          "111": [0, 0.47534, 0, 0, 0.48885],
          "112": [0.18906, 0.52396, 0, 0, 0.50046],
          "113": [0.18906, 0.47534, 0, 0, 0.48912],
          "114": [0, 0.47534, 0, 0, 0.38919],
          "115": [0, 0.47534, 0, 0, 0.44266],
          "116": [0, 0.62119, 0, 0, 0.33301],
          "117": [0, 0.47534, 0, 0, 0.5172],
          "118": [0, 0.52396, 0, 0, 0.5118],
          "119": [0, 0.52396, 0, 0, 0.77351],
          "120": [0.18906, 0.47534, 0, 0, 0.38865],
          "121": [0.18906, 0.47534, 0, 0, 0.49884],
          "122": [0.18906, 0.47534, 0, 0, 0.39054],
          "160": [0, 0, 0, 0, 0.25],
          "8216": [0, 0.69141, 0, 0, 0.21471],
          "8217": [0, 0.69141, 0, 0, 0.21471],
          "58112": [0, 0.62119, 0, 0, 0.49749],
          "58113": [0, 0.62119, 0, 0, 0.4983],
          "58114": [0.18906, 0.69141, 0, 0, 0.33328],
          "58115": [0.18906, 0.69141, 0, 0, 0.32923],
          "58116": [0.18906, 0.47534, 0, 0, 0.50343],
          "58117": [0, 0.69141, 0, 0, 0.33301],
          "58118": [0, 0.62119, 0, 0, 0.33409],
          "58119": [0, 0.47534, 0, 0, 0.50073]
        },
        "Main-Bold": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.35],
          "34": [0, 0.69444, 0, 0, 0.60278],
          "35": [0.19444, 0.69444, 0, 0, 0.95833],
          "36": [0.05556, 0.75, 0, 0, 0.575],
          "37": [0.05556, 0.75, 0, 0, 0.95833],
          "38": [0, 0.69444, 0, 0, 0.89444],
          "39": [0, 0.69444, 0, 0, 0.31944],
          "40": [0.25, 0.75, 0, 0, 0.44722],
          "41": [0.25, 0.75, 0, 0, 0.44722],
          "42": [0, 0.75, 0, 0, 0.575],
          "43": [0.13333, 0.63333, 0, 0, 0.89444],
          "44": [0.19444, 0.15556, 0, 0, 0.31944],
          "45": [0, 0.44444, 0, 0, 0.38333],
          "46": [0, 0.15556, 0, 0, 0.31944],
          "47": [0.25, 0.75, 0, 0, 0.575],
          "48": [0, 0.64444, 0, 0, 0.575],
          "49": [0, 0.64444, 0, 0, 0.575],
          "50": [0, 0.64444, 0, 0, 0.575],
          "51": [0, 0.64444, 0, 0, 0.575],
          "52": [0, 0.64444, 0, 0, 0.575],
          "53": [0, 0.64444, 0, 0, 0.575],
          "54": [0, 0.64444, 0, 0, 0.575],
          "55": [0, 0.64444, 0, 0, 0.575],
          "56": [0, 0.64444, 0, 0, 0.575],
          "57": [0, 0.64444, 0, 0, 0.575],
          "58": [0, 0.44444, 0, 0, 0.31944],
          "59": [0.19444, 0.44444, 0, 0, 0.31944],
          "60": [0.08556, 0.58556, 0, 0, 0.89444],
          "61": [-0.10889, 0.39111, 0, 0, 0.89444],
          "62": [0.08556, 0.58556, 0, 0, 0.89444],
          "63": [0, 0.69444, 0, 0, 0.54305],
          "64": [0, 0.69444, 0, 0, 0.89444],
          "65": [0, 0.68611, 0, 0, 0.86944],
          "66": [0, 0.68611, 0, 0, 0.81805],
          "67": [0, 0.68611, 0, 0, 0.83055],
          "68": [0, 0.68611, 0, 0, 0.88194],
          "69": [0, 0.68611, 0, 0, 0.75555],
          "70": [0, 0.68611, 0, 0, 0.72361],
          "71": [0, 0.68611, 0, 0, 0.90416],
          "72": [0, 0.68611, 0, 0, 0.9],
          "73": [0, 0.68611, 0, 0, 0.43611],
          "74": [0, 0.68611, 0, 0, 0.59444],
          "75": [0, 0.68611, 0, 0, 0.90138],
          "76": [0, 0.68611, 0, 0, 0.69166],
          "77": [0, 0.68611, 0, 0, 1.09166],
          "78": [0, 0.68611, 0, 0, 0.9],
          "79": [0, 0.68611, 0, 0, 0.86388],
          "80": [0, 0.68611, 0, 0, 0.78611],
          "81": [0.19444, 0.68611, 0, 0, 0.86388],
          "82": [0, 0.68611, 0, 0, 0.8625],
          "83": [0, 0.68611, 0, 0, 0.63889],
          "84": [0, 0.68611, 0, 0, 0.8],
          "85": [0, 0.68611, 0, 0, 0.88472],
          "86": [0, 0.68611, 0.01597, 0, 0.86944],
          "87": [0, 0.68611, 0.01597, 0, 1.18888],
          "88": [0, 0.68611, 0, 0, 0.86944],
          "89": [0, 0.68611, 0.02875, 0, 0.86944],
          "90": [0, 0.68611, 0, 0, 0.70277],
          "91": [0.25, 0.75, 0, 0, 0.31944],
          "92": [0.25, 0.75, 0, 0, 0.575],
          "93": [0.25, 0.75, 0, 0, 0.31944],
          "94": [0, 0.69444, 0, 0, 0.575],
          "95": [0.31, 0.13444, 0.03194, 0, 0.575],
          "97": [0, 0.44444, 0, 0, 0.55902],
          "98": [0, 0.69444, 0, 0, 0.63889],
          "99": [0, 0.44444, 0, 0, 0.51111],
          "100": [0, 0.69444, 0, 0, 0.63889],
          "101": [0, 0.44444, 0, 0, 0.52708],
          "102": [0, 0.69444, 0.10903, 0, 0.35139],
          "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
          "104": [0, 0.69444, 0, 0, 0.63889],
          "105": [0, 0.69444, 0, 0, 0.31944],
          "106": [0.19444, 0.69444, 0, 0, 0.35139],
          "107": [0, 0.69444, 0, 0, 0.60694],
          "108": [0, 0.69444, 0, 0, 0.31944],
          "109": [0, 0.44444, 0, 0, 0.95833],
          "110": [0, 0.44444, 0, 0, 0.63889],
          "111": [0, 0.44444, 0, 0, 0.575],
          "112": [0.19444, 0.44444, 0, 0, 0.63889],
          "113": [0.19444, 0.44444, 0, 0, 0.60694],
          "114": [0, 0.44444, 0, 0, 0.47361],
          "115": [0, 0.44444, 0, 0, 0.45361],
          "116": [0, 0.63492, 0, 0, 0.44722],
          "117": [0, 0.44444, 0, 0, 0.63889],
          "118": [0, 0.44444, 0.01597, 0, 0.60694],
          "119": [0, 0.44444, 0.01597, 0, 0.83055],
          "120": [0, 0.44444, 0, 0, 0.60694],
          "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
          "122": [0, 0.44444, 0, 0, 0.51111],
          "123": [0.25, 0.75, 0, 0, 0.575],
          "124": [0.25, 0.75, 0, 0, 0.31944],
          "125": [0.25, 0.75, 0, 0, 0.575],
          "126": [0.35, 0.34444, 0, 0, 0.575],
          "160": [0, 0, 0, 0, 0.25],
          "163": [0, 0.69444, 0, 0, 0.86853],
          "168": [0, 0.69444, 0, 0, 0.575],
          "172": [0, 0.44444, 0, 0, 0.76666],
          "176": [0, 0.69444, 0, 0, 0.86944],
          "177": [0.13333, 0.63333, 0, 0, 0.89444],
          "184": [0.17014, 0, 0, 0, 0.51111],
          "198": [0, 0.68611, 0, 0, 1.04166],
          "215": [0.13333, 0.63333, 0, 0, 0.89444],
          "216": [0.04861, 0.73472, 0, 0, 0.89444],
          "223": [0, 0.69444, 0, 0, 0.59722],
          "230": [0, 0.44444, 0, 0, 0.83055],
          "247": [0.13333, 0.63333, 0, 0, 0.89444],
          "248": [0.09722, 0.54167, 0, 0, 0.575],
          "305": [0, 0.44444, 0, 0, 0.31944],
          "338": [0, 0.68611, 0, 0, 1.16944],
          "339": [0, 0.44444, 0, 0, 0.89444],
          "567": [0.19444, 0.44444, 0, 0, 0.35139],
          "710": [0, 0.69444, 0, 0, 0.575],
          "711": [0, 0.63194, 0, 0, 0.575],
          "713": [0, 0.59611, 0, 0, 0.575],
          "714": [0, 0.69444, 0, 0, 0.575],
          "715": [0, 0.69444, 0, 0, 0.575],
          "728": [0, 0.69444, 0, 0, 0.575],
          "729": [0, 0.69444, 0, 0, 0.31944],
          "730": [0, 0.69444, 0, 0, 0.86944],
          "732": [0, 0.69444, 0, 0, 0.575],
          "733": [0, 0.69444, 0, 0, 0.575],
          "915": [0, 0.68611, 0, 0, 0.69166],
          "916": [0, 0.68611, 0, 0, 0.95833],
          "920": [0, 0.68611, 0, 0, 0.89444],
          "923": [0, 0.68611, 0, 0, 0.80555],
          "926": [0, 0.68611, 0, 0, 0.76666],
          "928": [0, 0.68611, 0, 0, 0.9],
          "931": [0, 0.68611, 0, 0, 0.83055],
          "933": [0, 0.68611, 0, 0, 0.89444],
          "934": [0, 0.68611, 0, 0, 0.83055],
          "936": [0, 0.68611, 0, 0, 0.89444],
          "937": [0, 0.68611, 0, 0, 0.83055],
          "8211": [0, 0.44444, 0.03194, 0, 0.575],
          "8212": [0, 0.44444, 0.03194, 0, 1.14999],
          "8216": [0, 0.69444, 0, 0, 0.31944],
          "8217": [0, 0.69444, 0, 0, 0.31944],
          "8220": [0, 0.69444, 0, 0, 0.60278],
          "8221": [0, 0.69444, 0, 0, 0.60278],
          "8224": [0.19444, 0.69444, 0, 0, 0.51111],
          "8225": [0.19444, 0.69444, 0, 0, 0.51111],
          "8242": [0, 0.55556, 0, 0, 0.34444],
          "8407": [0, 0.72444, 0.15486, 0, 0.575],
          "8463": [0, 0.69444, 0, 0, 0.66759],
          "8465": [0, 0.69444, 0, 0, 0.83055],
          "8467": [0, 0.69444, 0, 0, 0.47361],
          "8472": [0.19444, 0.44444, 0, 0, 0.74027],
          "8476": [0, 0.69444, 0, 0, 0.83055],
          "8501": [0, 0.69444, 0, 0, 0.70277],
          "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8593": [0.19444, 0.69444, 0, 0, 0.575],
          "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8595": [0.19444, 0.69444, 0, 0, 0.575],
          "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8597": [0.25, 0.75, 0, 0, 0.575],
          "8598": [0.19444, 0.69444, 0, 0, 1.14999],
          "8599": [0.19444, 0.69444, 0, 0, 1.14999],
          "8600": [0.19444, 0.69444, 0, 0, 1.14999],
          "8601": [0.19444, 0.69444, 0, 0, 1.14999],
          "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8657": [0.19444, 0.69444, 0, 0, 0.70277],
          "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8659": [0.19444, 0.69444, 0, 0, 0.70277],
          "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
          "8661": [0.25, 0.75, 0, 0, 0.70277],
          "8704": [0, 0.69444, 0, 0, 0.63889],
          "8706": [0, 0.69444, 0.06389, 0, 0.62847],
          "8707": [0, 0.69444, 0, 0, 0.63889],
          "8709": [0.05556, 0.75, 0, 0, 0.575],
          "8711": [0, 0.68611, 0, 0, 0.95833],
          "8712": [0.08556, 0.58556, 0, 0, 0.76666],
          "8715": [0.08556, 0.58556, 0, 0, 0.76666],
          "8722": [0.13333, 0.63333, 0, 0, 0.89444],
          "8723": [0.13333, 0.63333, 0, 0, 0.89444],
          "8725": [0.25, 0.75, 0, 0, 0.575],
          "8726": [0.25, 0.75, 0, 0, 0.575],
          "8727": [-0.02778, 0.47222, 0, 0, 0.575],
          "8728": [-0.02639, 0.47361, 0, 0, 0.575],
          "8729": [-0.02639, 0.47361, 0, 0, 0.575],
          "8730": [0.18, 0.82, 0, 0, 0.95833],
          "8733": [0, 0.44444, 0, 0, 0.89444],
          "8734": [0, 0.44444, 0, 0, 1.14999],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8739": [0.25, 0.75, 0, 0, 0.31944],
          "8741": [0.25, 0.75, 0, 0, 0.575],
          "8743": [0, 0.55556, 0, 0, 0.76666],
          "8744": [0, 0.55556, 0, 0, 0.76666],
          "8745": [0, 0.55556, 0, 0, 0.76666],
          "8746": [0, 0.55556, 0, 0, 0.76666],
          "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
          "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
          "8768": [0.19444, 0.69444, 0, 0, 0.31944],
          "8771": [222e-5, 0.50222, 0, 0, 0.89444],
          "8773": [0.027, 0.638, 0, 0, 0.894],
          "8776": [0.02444, 0.52444, 0, 0, 0.89444],
          "8781": [222e-5, 0.50222, 0, 0, 0.89444],
          "8801": [222e-5, 0.50222, 0, 0, 0.89444],
          "8804": [0.19667, 0.69667, 0, 0, 0.89444],
          "8805": [0.19667, 0.69667, 0, 0, 0.89444],
          "8810": [0.08556, 0.58556, 0, 0, 1.14999],
          "8811": [0.08556, 0.58556, 0, 0, 1.14999],
          "8826": [0.08556, 0.58556, 0, 0, 0.89444],
          "8827": [0.08556, 0.58556, 0, 0, 0.89444],
          "8834": [0.08556, 0.58556, 0, 0, 0.89444],
          "8835": [0.08556, 0.58556, 0, 0, 0.89444],
          "8838": [0.19667, 0.69667, 0, 0, 0.89444],
          "8839": [0.19667, 0.69667, 0, 0, 0.89444],
          "8846": [0, 0.55556, 0, 0, 0.76666],
          "8849": [0.19667, 0.69667, 0, 0, 0.89444],
          "8850": [0.19667, 0.69667, 0, 0, 0.89444],
          "8851": [0, 0.55556, 0, 0, 0.76666],
          "8852": [0, 0.55556, 0, 0, 0.76666],
          "8853": [0.13333, 0.63333, 0, 0, 0.89444],
          "8854": [0.13333, 0.63333, 0, 0, 0.89444],
          "8855": [0.13333, 0.63333, 0, 0, 0.89444],
          "8856": [0.13333, 0.63333, 0, 0, 0.89444],
          "8857": [0.13333, 0.63333, 0, 0, 0.89444],
          "8866": [0, 0.69444, 0, 0, 0.70277],
          "8867": [0, 0.69444, 0, 0, 0.70277],
          "8868": [0, 0.69444, 0, 0, 0.89444],
          "8869": [0, 0.69444, 0, 0, 0.89444],
          "8900": [-0.02639, 0.47361, 0, 0, 0.575],
          "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
          "8902": [-0.02778, 0.47222, 0, 0, 0.575],
          "8968": [0.25, 0.75, 0, 0, 0.51111],
          "8969": [0.25, 0.75, 0, 0, 0.51111],
          "8970": [0.25, 0.75, 0, 0, 0.51111],
          "8971": [0.25, 0.75, 0, 0, 0.51111],
          "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
          "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
          "9651": [0.19444, 0.69444, 0, 0, 1.02222],
          "9657": [-0.02778, 0.47222, 0, 0, 0.575],
          "9661": [0.19444, 0.69444, 0, 0, 1.02222],
          "9667": [-0.02778, 0.47222, 0, 0, 0.575],
          "9711": [0.19444, 0.69444, 0, 0, 1.14999],
          "9824": [0.12963, 0.69444, 0, 0, 0.89444],
          "9825": [0.12963, 0.69444, 0, 0, 0.89444],
          "9826": [0.12963, 0.69444, 0, 0, 0.89444],
          "9827": [0.12963, 0.69444, 0, 0, 0.89444],
          "9837": [0, 0.75, 0, 0, 0.44722],
          "9838": [0.19444, 0.69444, 0, 0, 0.44722],
          "9839": [0.19444, 0.69444, 0, 0, 0.44722],
          "10216": [0.25, 0.75, 0, 0, 0.44722],
          "10217": [0.25, 0.75, 0, 0, 0.44722],
          "10815": [0, 0.68611, 0, 0, 0.9],
          "10927": [0.19667, 0.69667, 0, 0, 0.89444],
          "10928": [0.19667, 0.69667, 0, 0, 0.89444],
          "57376": [0.19444, 0.69444, 0, 0, 0]
        },
        "Main-BoldItalic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.11417, 0, 0.38611],
          "34": [0, 0.69444, 0.07939, 0, 0.62055],
          "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
          "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
          "38": [0, 0.69444, 0.08528, 0, 0.88555],
          "39": [0, 0.69444, 0.12945, 0, 0.35555],
          "40": [0.25, 0.75, 0.15806, 0, 0.47333],
          "41": [0.25, 0.75, 0.03306, 0, 0.47333],
          "42": [0, 0.75, 0.14333, 0, 0.59111],
          "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
          "44": [0.19444, 0.14722, 0, 0, 0.35555],
          "45": [0, 0.44444, 0.02611, 0, 0.41444],
          "46": [0, 0.14722, 0, 0, 0.35555],
          "47": [0.25, 0.75, 0.15806, 0, 0.59111],
          "48": [0, 0.64444, 0.13167, 0, 0.59111],
          "49": [0, 0.64444, 0.13167, 0, 0.59111],
          "50": [0, 0.64444, 0.13167, 0, 0.59111],
          "51": [0, 0.64444, 0.13167, 0, 0.59111],
          "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
          "53": [0, 0.64444, 0.13167, 0, 0.59111],
          "54": [0, 0.64444, 0.13167, 0, 0.59111],
          "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
          "56": [0, 0.64444, 0.13167, 0, 0.59111],
          "57": [0, 0.64444, 0.13167, 0, 0.59111],
          "58": [0, 0.44444, 0.06695, 0, 0.35555],
          "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
          "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
          "63": [0, 0.69444, 0.11472, 0, 0.59111],
          "64": [0, 0.69444, 0.09208, 0, 0.88555],
          "65": [0, 0.68611, 0, 0, 0.86555],
          "66": [0, 0.68611, 0.0992, 0, 0.81666],
          "67": [0, 0.68611, 0.14208, 0, 0.82666],
          "68": [0, 0.68611, 0.09062, 0, 0.87555],
          "69": [0, 0.68611, 0.11431, 0, 0.75666],
          "70": [0, 0.68611, 0.12903, 0, 0.72722],
          "71": [0, 0.68611, 0.07347, 0, 0.89527],
          "72": [0, 0.68611, 0.17208, 0, 0.8961],
          "73": [0, 0.68611, 0.15681, 0, 0.47166],
          "74": [0, 0.68611, 0.145, 0, 0.61055],
          "75": [0, 0.68611, 0.14208, 0, 0.89499],
          "76": [0, 0.68611, 0, 0, 0.69777],
          "77": [0, 0.68611, 0.17208, 0, 1.07277],
          "78": [0, 0.68611, 0.17208, 0, 0.8961],
          "79": [0, 0.68611, 0.09062, 0, 0.85499],
          "80": [0, 0.68611, 0.0992, 0, 0.78721],
          "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
          "82": [0, 0.68611, 0.02559, 0, 0.85944],
          "83": [0, 0.68611, 0.11264, 0, 0.64999],
          "84": [0, 0.68611, 0.12903, 0, 0.7961],
          "85": [0, 0.68611, 0.17208, 0, 0.88083],
          "86": [0, 0.68611, 0.18625, 0, 0.86555],
          "87": [0, 0.68611, 0.18625, 0, 1.15999],
          "88": [0, 0.68611, 0.15681, 0, 0.86555],
          "89": [0, 0.68611, 0.19803, 0, 0.86555],
          "90": [0, 0.68611, 0.14208, 0, 0.70888],
          "91": [0.25, 0.75, 0.1875, 0, 0.35611],
          "93": [0.25, 0.75, 0.09972, 0, 0.35611],
          "94": [0, 0.69444, 0.06709, 0, 0.59111],
          "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
          "97": [0, 0.44444, 0.09426, 0, 0.59111],
          "98": [0, 0.69444, 0.07861, 0, 0.53222],
          "99": [0, 0.44444, 0.05222, 0, 0.53222],
          "100": [0, 0.69444, 0.10861, 0, 0.59111],
          "101": [0, 0.44444, 0.085, 0, 0.53222],
          "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
          "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
          "104": [0, 0.69444, 0.09426, 0, 0.59111],
          "105": [0, 0.69326, 0.11387, 0, 0.35555],
          "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
          "107": [0, 0.69444, 0.11111, 0, 0.53222],
          "108": [0, 0.69444, 0.10861, 0, 0.29666],
          "109": [0, 0.44444, 0.09426, 0, 0.94444],
          "110": [0, 0.44444, 0.09426, 0, 0.64999],
          "111": [0, 0.44444, 0.07861, 0, 0.59111],
          "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
          "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
          "114": [0, 0.44444, 0.11111, 0, 0.50167],
          "115": [0, 0.44444, 0.08167, 0, 0.48694],
          "116": [0, 0.63492, 0.09639, 0, 0.385],
          "117": [0, 0.44444, 0.09426, 0, 0.62055],
          "118": [0, 0.44444, 0.11111, 0, 0.53222],
          "119": [0, 0.44444, 0.11111, 0, 0.76777],
          "120": [0, 0.44444, 0.12583, 0, 0.56055],
          "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
          "122": [0, 0.44444, 0.13889, 0, 0.49055],
          "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.69444, 0.11473, 0, 0.59111],
          "176": [0, 0.69444, 0, 0, 0.94888],
          "184": [0.17014, 0, 0, 0, 0.53222],
          "198": [0, 0.68611, 0.11431, 0, 1.02277],
          "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
          "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
          "230": [0, 0.44444, 0.085, 0, 0.82666],
          "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
          "305": [0, 0.44444, 0.09426, 0, 0.35555],
          "338": [0, 0.68611, 0.11431, 0, 1.14054],
          "339": [0, 0.44444, 0.085, 0, 0.82666],
          "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
          "710": [0, 0.69444, 0.06709, 0, 0.59111],
          "711": [0, 0.63194, 0.08271, 0, 0.59111],
          "713": [0, 0.59444, 0.10444, 0, 0.59111],
          "714": [0, 0.69444, 0.08528, 0, 0.59111],
          "715": [0, 0.69444, 0, 0, 0.59111],
          "728": [0, 0.69444, 0.10333, 0, 0.59111],
          "729": [0, 0.69444, 0.12945, 0, 0.35555],
          "730": [0, 0.69444, 0, 0, 0.94888],
          "732": [0, 0.69444, 0.11472, 0, 0.59111],
          "733": [0, 0.69444, 0.11472, 0, 0.59111],
          "915": [0, 0.68611, 0.12903, 0, 0.69777],
          "916": [0, 0.68611, 0, 0, 0.94444],
          "920": [0, 0.68611, 0.09062, 0, 0.88555],
          "923": [0, 0.68611, 0, 0, 0.80666],
          "926": [0, 0.68611, 0.15092, 0, 0.76777],
          "928": [0, 0.68611, 0.17208, 0, 0.8961],
          "931": [0, 0.68611, 0.11431, 0, 0.82666],
          "933": [0, 0.68611, 0.10778, 0, 0.88555],
          "934": [0, 0.68611, 0.05632, 0, 0.82666],
          "936": [0, 0.68611, 0.10778, 0, 0.88555],
          "937": [0, 0.68611, 0.0992, 0, 0.82666],
          "8211": [0, 0.44444, 0.09811, 0, 0.59111],
          "8212": [0, 0.44444, 0.09811, 0, 1.18221],
          "8216": [0, 0.69444, 0.12945, 0, 0.35555],
          "8217": [0, 0.69444, 0.12945, 0, 0.35555],
          "8220": [0, 0.69444, 0.16772, 0, 0.62055],
          "8221": [0, 0.69444, 0.07939, 0, 0.62055]
        },
        "Main-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.12417, 0, 0.30667],
          "34": [0, 0.69444, 0.06961, 0, 0.51444],
          "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
          "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
          "38": [0, 0.69444, 0.09694, 0, 0.76666],
          "39": [0, 0.69444, 0.12417, 0, 0.30667],
          "40": [0.25, 0.75, 0.16194, 0, 0.40889],
          "41": [0.25, 0.75, 0.03694, 0, 0.40889],
          "42": [0, 0.75, 0.14917, 0, 0.51111],
          "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
          "44": [0.19444, 0.10556, 0, 0, 0.30667],
          "45": [0, 0.43056, 0.02826, 0, 0.35778],
          "46": [0, 0.10556, 0, 0, 0.30667],
          "47": [0.25, 0.75, 0.16194, 0, 0.51111],
          "48": [0, 0.64444, 0.13556, 0, 0.51111],
          "49": [0, 0.64444, 0.13556, 0, 0.51111],
          "50": [0, 0.64444, 0.13556, 0, 0.51111],
          "51": [0, 0.64444, 0.13556, 0, 0.51111],
          "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
          "53": [0, 0.64444, 0.13556, 0, 0.51111],
          "54": [0, 0.64444, 0.13556, 0, 0.51111],
          "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
          "56": [0, 0.64444, 0.13556, 0, 0.51111],
          "57": [0, 0.64444, 0.13556, 0, 0.51111],
          "58": [0, 0.43056, 0.0582, 0, 0.30667],
          "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
          "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
          "63": [0, 0.69444, 0.1225, 0, 0.51111],
          "64": [0, 0.69444, 0.09597, 0, 0.76666],
          "65": [0, 0.68333, 0, 0, 0.74333],
          "66": [0, 0.68333, 0.10257, 0, 0.70389],
          "67": [0, 0.68333, 0.14528, 0, 0.71555],
          "68": [0, 0.68333, 0.09403, 0, 0.755],
          "69": [0, 0.68333, 0.12028, 0, 0.67833],
          "70": [0, 0.68333, 0.13305, 0, 0.65277],
          "71": [0, 0.68333, 0.08722, 0, 0.77361],
          "72": [0, 0.68333, 0.16389, 0, 0.74333],
          "73": [0, 0.68333, 0.15806, 0, 0.38555],
          "74": [0, 0.68333, 0.14028, 0, 0.525],
          "75": [0, 0.68333, 0.14528, 0, 0.76888],
          "76": [0, 0.68333, 0, 0, 0.62722],
          "77": [0, 0.68333, 0.16389, 0, 0.89666],
          "78": [0, 0.68333, 0.16389, 0, 0.74333],
          "79": [0, 0.68333, 0.09403, 0, 0.76666],
          "80": [0, 0.68333, 0.10257, 0, 0.67833],
          "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
          "82": [0, 0.68333, 0.03868, 0, 0.72944],
          "83": [0, 0.68333, 0.11972, 0, 0.56222],
          "84": [0, 0.68333, 0.13305, 0, 0.71555],
          "85": [0, 0.68333, 0.16389, 0, 0.74333],
          "86": [0, 0.68333, 0.18361, 0, 0.74333],
          "87": [0, 0.68333, 0.18361, 0, 0.99888],
          "88": [0, 0.68333, 0.15806, 0, 0.74333],
          "89": [0, 0.68333, 0.19383, 0, 0.74333],
          "90": [0, 0.68333, 0.14528, 0, 0.61333],
          "91": [0.25, 0.75, 0.1875, 0, 0.30667],
          "93": [0.25, 0.75, 0.10528, 0, 0.30667],
          "94": [0, 0.69444, 0.06646, 0, 0.51111],
          "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
          "97": [0, 0.43056, 0.07671, 0, 0.51111],
          "98": [0, 0.69444, 0.06312, 0, 0.46],
          "99": [0, 0.43056, 0.05653, 0, 0.46],
          "100": [0, 0.69444, 0.10333, 0, 0.51111],
          "101": [0, 0.43056, 0.07514, 0, 0.46],
          "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
          "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
          "104": [0, 0.69444, 0.07671, 0, 0.51111],
          "105": [0, 0.65536, 0.1019, 0, 0.30667],
          "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
          "107": [0, 0.69444, 0.10764, 0, 0.46],
          "108": [0, 0.69444, 0.10333, 0, 0.25555],
          "109": [0, 0.43056, 0.07671, 0, 0.81777],
          "110": [0, 0.43056, 0.07671, 0, 0.56222],
          "111": [0, 0.43056, 0.06312, 0, 0.51111],
          "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
          "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
          "114": [0, 0.43056, 0.10764, 0, 0.42166],
          "115": [0, 0.43056, 0.08208, 0, 0.40889],
          "116": [0, 0.61508, 0.09486, 0, 0.33222],
          "117": [0, 0.43056, 0.07671, 0, 0.53666],
          "118": [0, 0.43056, 0.10764, 0, 0.46],
          "119": [0, 0.43056, 0.10764, 0, 0.66444],
          "120": [0, 0.43056, 0.12042, 0, 0.46389],
          "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
          "122": [0, 0.43056, 0.12292, 0, 0.40889],
          "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.66786, 0.10474, 0, 0.51111],
          "176": [0, 0.69444, 0, 0, 0.83129],
          "184": [0.17014, 0, 0, 0, 0.46],
          "198": [0, 0.68333, 0.12028, 0, 0.88277],
          "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
          "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
          "230": [0, 0.43056, 0.07514, 0, 0.71555],
          "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
          "338": [0, 0.68333, 0.12028, 0, 0.98499],
          "339": [0, 0.43056, 0.07514, 0, 0.71555],
          "710": [0, 0.69444, 0.06646, 0, 0.51111],
          "711": [0, 0.62847, 0.08295, 0, 0.51111],
          "713": [0, 0.56167, 0.10333, 0, 0.51111],
          "714": [0, 0.69444, 0.09694, 0, 0.51111],
          "715": [0, 0.69444, 0, 0, 0.51111],
          "728": [0, 0.69444, 0.10806, 0, 0.51111],
          "729": [0, 0.66786, 0.11752, 0, 0.30667],
          "730": [0, 0.69444, 0, 0, 0.83129],
          "732": [0, 0.66786, 0.11585, 0, 0.51111],
          "733": [0, 0.69444, 0.1225, 0, 0.51111],
          "915": [0, 0.68333, 0.13305, 0, 0.62722],
          "916": [0, 0.68333, 0, 0, 0.81777],
          "920": [0, 0.68333, 0.09403, 0, 0.76666],
          "923": [0, 0.68333, 0, 0, 0.69222],
          "926": [0, 0.68333, 0.15294, 0, 0.66444],
          "928": [0, 0.68333, 0.16389, 0, 0.74333],
          "931": [0, 0.68333, 0.12028, 0, 0.71555],
          "933": [0, 0.68333, 0.11111, 0, 0.76666],
          "934": [0, 0.68333, 0.05986, 0, 0.71555],
          "936": [0, 0.68333, 0.11111, 0, 0.76666],
          "937": [0, 0.68333, 0.10257, 0, 0.71555],
          "8211": [0, 0.43056, 0.09208, 0, 0.51111],
          "8212": [0, 0.43056, 0.09208, 0, 1.02222],
          "8216": [0, 0.69444, 0.12417, 0, 0.30667],
          "8217": [0, 0.69444, 0.12417, 0, 0.30667],
          "8220": [0, 0.69444, 0.1685, 0, 0.51444],
          "8221": [0, 0.69444, 0.06961, 0, 0.51444],
          "8463": [0, 0.68889, 0, 0, 0.54028]
        },
        "Main-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.27778],
          "34": [0, 0.69444, 0, 0, 0.5],
          "35": [0.19444, 0.69444, 0, 0, 0.83334],
          "36": [0.05556, 0.75, 0, 0, 0.5],
          "37": [0.05556, 0.75, 0, 0, 0.83334],
          "38": [0, 0.69444, 0, 0, 0.77778],
          "39": [0, 0.69444, 0, 0, 0.27778],
          "40": [0.25, 0.75, 0, 0, 0.38889],
          "41": [0.25, 0.75, 0, 0, 0.38889],
          "42": [0, 0.75, 0, 0, 0.5],
          "43": [0.08333, 0.58333, 0, 0, 0.77778],
          "44": [0.19444, 0.10556, 0, 0, 0.27778],
          "45": [0, 0.43056, 0, 0, 0.33333],
          "46": [0, 0.10556, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0, 0, 0.5],
          "48": [0, 0.64444, 0, 0, 0.5],
          "49": [0, 0.64444, 0, 0, 0.5],
          "50": [0, 0.64444, 0, 0, 0.5],
          "51": [0, 0.64444, 0, 0, 0.5],
          "52": [0, 0.64444, 0, 0, 0.5],
          "53": [0, 0.64444, 0, 0, 0.5],
          "54": [0, 0.64444, 0, 0, 0.5],
          "55": [0, 0.64444, 0, 0, 0.5],
          "56": [0, 0.64444, 0, 0, 0.5],
          "57": [0, 0.64444, 0, 0, 0.5],
          "58": [0, 0.43056, 0, 0, 0.27778],
          "59": [0.19444, 0.43056, 0, 0, 0.27778],
          "60": [0.0391, 0.5391, 0, 0, 0.77778],
          "61": [-0.13313, 0.36687, 0, 0, 0.77778],
          "62": [0.0391, 0.5391, 0, 0, 0.77778],
          "63": [0, 0.69444, 0, 0, 0.47222],
          "64": [0, 0.69444, 0, 0, 0.77778],
          "65": [0, 0.68333, 0, 0, 0.75],
          "66": [0, 0.68333, 0, 0, 0.70834],
          "67": [0, 0.68333, 0, 0, 0.72222],
          "68": [0, 0.68333, 0, 0, 0.76389],
          "69": [0, 0.68333, 0, 0, 0.68056],
          "70": [0, 0.68333, 0, 0, 0.65278],
          "71": [0, 0.68333, 0, 0, 0.78472],
          "72": [0, 0.68333, 0, 0, 0.75],
          "73": [0, 0.68333, 0, 0, 0.36111],
          "74": [0, 0.68333, 0, 0, 0.51389],
          "75": [0, 0.68333, 0, 0, 0.77778],
          "76": [0, 0.68333, 0, 0, 0.625],
          "77": [0, 0.68333, 0, 0, 0.91667],
          "78": [0, 0.68333, 0, 0, 0.75],
          "79": [0, 0.68333, 0, 0, 0.77778],
          "80": [0, 0.68333, 0, 0, 0.68056],
          "81": [0.19444, 0.68333, 0, 0, 0.77778],
          "82": [0, 0.68333, 0, 0, 0.73611],
          "83": [0, 0.68333, 0, 0, 0.55556],
          "84": [0, 0.68333, 0, 0, 0.72222],
          "85": [0, 0.68333, 0, 0, 0.75],
          "86": [0, 0.68333, 0.01389, 0, 0.75],
          "87": [0, 0.68333, 0.01389, 0, 1.02778],
          "88": [0, 0.68333, 0, 0, 0.75],
          "89": [0, 0.68333, 0.025, 0, 0.75],
          "90": [0, 0.68333, 0, 0, 0.61111],
          "91": [0.25, 0.75, 0, 0, 0.27778],
          "92": [0.25, 0.75, 0, 0, 0.5],
          "93": [0.25, 0.75, 0, 0, 0.27778],
          "94": [0, 0.69444, 0, 0, 0.5],
          "95": [0.31, 0.12056, 0.02778, 0, 0.5],
          "97": [0, 0.43056, 0, 0, 0.5],
          "98": [0, 0.69444, 0, 0, 0.55556],
          "99": [0, 0.43056, 0, 0, 0.44445],
          "100": [0, 0.69444, 0, 0, 0.55556],
          "101": [0, 0.43056, 0, 0, 0.44445],
          "102": [0, 0.69444, 0.07778, 0, 0.30556],
          "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
          "104": [0, 0.69444, 0, 0, 0.55556],
          "105": [0, 0.66786, 0, 0, 0.27778],
          "106": [0.19444, 0.66786, 0, 0, 0.30556],
          "107": [0, 0.69444, 0, 0, 0.52778],
          "108": [0, 0.69444, 0, 0, 0.27778],
          "109": [0, 0.43056, 0, 0, 0.83334],
          "110": [0, 0.43056, 0, 0, 0.55556],
          "111": [0, 0.43056, 0, 0, 0.5],
          "112": [0.19444, 0.43056, 0, 0, 0.55556],
          "113": [0.19444, 0.43056, 0, 0, 0.52778],
          "114": [0, 0.43056, 0, 0, 0.39167],
          "115": [0, 0.43056, 0, 0, 0.39445],
          "116": [0, 0.61508, 0, 0, 0.38889],
          "117": [0, 0.43056, 0, 0, 0.55556],
          "118": [0, 0.43056, 0.01389, 0, 0.52778],
          "119": [0, 0.43056, 0.01389, 0, 0.72222],
          "120": [0, 0.43056, 0, 0, 0.52778],
          "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
          "122": [0, 0.43056, 0, 0, 0.44445],
          "123": [0.25, 0.75, 0, 0, 0.5],
          "124": [0.25, 0.75, 0, 0, 0.27778],
          "125": [0.25, 0.75, 0, 0, 0.5],
          "126": [0.35, 0.31786, 0, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "163": [0, 0.69444, 0, 0, 0.76909],
          "167": [0.19444, 0.69444, 0, 0, 0.44445],
          "168": [0, 0.66786, 0, 0, 0.5],
          "172": [0, 0.43056, 0, 0, 0.66667],
          "176": [0, 0.69444, 0, 0, 0.75],
          "177": [0.08333, 0.58333, 0, 0, 0.77778],
          "182": [0.19444, 0.69444, 0, 0, 0.61111],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "198": [0, 0.68333, 0, 0, 0.90278],
          "215": [0.08333, 0.58333, 0, 0, 0.77778],
          "216": [0.04861, 0.73194, 0, 0, 0.77778],
          "223": [0, 0.69444, 0, 0, 0.5],
          "230": [0, 0.43056, 0, 0, 0.72222],
          "247": [0.08333, 0.58333, 0, 0, 0.77778],
          "248": [0.09722, 0.52778, 0, 0, 0.5],
          "305": [0, 0.43056, 0, 0, 0.27778],
          "338": [0, 0.68333, 0, 0, 1.01389],
          "339": [0, 0.43056, 0, 0, 0.77778],
          "567": [0.19444, 0.43056, 0, 0, 0.30556],
          "710": [0, 0.69444, 0, 0, 0.5],
          "711": [0, 0.62847, 0, 0, 0.5],
          "713": [0, 0.56778, 0, 0, 0.5],
          "714": [0, 0.69444, 0, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0, 0, 0.5],
          "729": [0, 0.66786, 0, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.75],
          "732": [0, 0.66786, 0, 0, 0.5],
          "733": [0, 0.69444, 0, 0, 0.5],
          "915": [0, 0.68333, 0, 0, 0.625],
          "916": [0, 0.68333, 0, 0, 0.83334],
          "920": [0, 0.68333, 0, 0, 0.77778],
          "923": [0, 0.68333, 0, 0, 0.69445],
          "926": [0, 0.68333, 0, 0, 0.66667],
          "928": [0, 0.68333, 0, 0, 0.75],
          "931": [0, 0.68333, 0, 0, 0.72222],
          "933": [0, 0.68333, 0, 0, 0.77778],
          "934": [0, 0.68333, 0, 0, 0.72222],
          "936": [0, 0.68333, 0, 0, 0.77778],
          "937": [0, 0.68333, 0, 0, 0.72222],
          "8211": [0, 0.43056, 0.02778, 0, 0.5],
          "8212": [0, 0.43056, 0.02778, 0, 1],
          "8216": [0, 0.69444, 0, 0, 0.27778],
          "8217": [0, 0.69444, 0, 0, 0.27778],
          "8220": [0, 0.69444, 0, 0, 0.5],
          "8221": [0, 0.69444, 0, 0, 0.5],
          "8224": [0.19444, 0.69444, 0, 0, 0.44445],
          "8225": [0.19444, 0.69444, 0, 0, 0.44445],
          "8230": [0, 0.123, 0, 0, 1.172],
          "8242": [0, 0.55556, 0, 0, 0.275],
          "8407": [0, 0.71444, 0.15382, 0, 0.5],
          "8463": [0, 0.68889, 0, 0, 0.54028],
          "8465": [0, 0.69444, 0, 0, 0.72222],
          "8467": [0, 0.69444, 0, 0.11111, 0.41667],
          "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
          "8476": [0, 0.69444, 0, 0, 0.72222],
          "8501": [0, 0.69444, 0, 0, 0.61111],
          "8592": [-0.13313, 0.36687, 0, 0, 1],
          "8593": [0.19444, 0.69444, 0, 0, 0.5],
          "8594": [-0.13313, 0.36687, 0, 0, 1],
          "8595": [0.19444, 0.69444, 0, 0, 0.5],
          "8596": [-0.13313, 0.36687, 0, 0, 1],
          "8597": [0.25, 0.75, 0, 0, 0.5],
          "8598": [0.19444, 0.69444, 0, 0, 1],
          "8599": [0.19444, 0.69444, 0, 0, 1],
          "8600": [0.19444, 0.69444, 0, 0, 1],
          "8601": [0.19444, 0.69444, 0, 0, 1],
          "8614": [0.011, 0.511, 0, 0, 1],
          "8617": [0.011, 0.511, 0, 0, 1.126],
          "8618": [0.011, 0.511, 0, 0, 1.126],
          "8636": [-0.13313, 0.36687, 0, 0, 1],
          "8637": [-0.13313, 0.36687, 0, 0, 1],
          "8640": [-0.13313, 0.36687, 0, 0, 1],
          "8641": [-0.13313, 0.36687, 0, 0, 1],
          "8652": [0.011, 0.671, 0, 0, 1],
          "8656": [-0.13313, 0.36687, 0, 0, 1],
          "8657": [0.19444, 0.69444, 0, 0, 0.61111],
          "8658": [-0.13313, 0.36687, 0, 0, 1],
          "8659": [0.19444, 0.69444, 0, 0, 0.61111],
          "8660": [-0.13313, 0.36687, 0, 0, 1],
          "8661": [0.25, 0.75, 0, 0, 0.61111],
          "8704": [0, 0.69444, 0, 0, 0.55556],
          "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
          "8707": [0, 0.69444, 0, 0, 0.55556],
          "8709": [0.05556, 0.75, 0, 0, 0.5],
          "8711": [0, 0.68333, 0, 0, 0.83334],
          "8712": [0.0391, 0.5391, 0, 0, 0.66667],
          "8715": [0.0391, 0.5391, 0, 0, 0.66667],
          "8722": [0.08333, 0.58333, 0, 0, 0.77778],
          "8723": [0.08333, 0.58333, 0, 0, 0.77778],
          "8725": [0.25, 0.75, 0, 0, 0.5],
          "8726": [0.25, 0.75, 0, 0, 0.5],
          "8727": [-0.03472, 0.46528, 0, 0, 0.5],
          "8728": [-0.05555, 0.44445, 0, 0, 0.5],
          "8729": [-0.05555, 0.44445, 0, 0, 0.5],
          "8730": [0.2, 0.8, 0, 0, 0.83334],
          "8733": [0, 0.43056, 0, 0, 0.77778],
          "8734": [0, 0.43056, 0, 0, 1],
          "8736": [0, 0.69224, 0, 0, 0.72222],
          "8739": [0.25, 0.75, 0, 0, 0.27778],
          "8741": [0.25, 0.75, 0, 0, 0.5],
          "8743": [0, 0.55556, 0, 0, 0.66667],
          "8744": [0, 0.55556, 0, 0, 0.66667],
          "8745": [0, 0.55556, 0, 0, 0.66667],
          "8746": [0, 0.55556, 0, 0, 0.66667],
          "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
          "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
          "8768": [0.19444, 0.69444, 0, 0, 0.27778],
          "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8773": [-0.022, 0.589, 0, 0, 0.778],
          "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
          "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8784": [-0.133, 0.673, 0, 0, 0.778],
          "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
          "8804": [0.13597, 0.63597, 0, 0, 0.77778],
          "8805": [0.13597, 0.63597, 0, 0, 0.77778],
          "8810": [0.0391, 0.5391, 0, 0, 1],
          "8811": [0.0391, 0.5391, 0, 0, 1],
          "8826": [0.0391, 0.5391, 0, 0, 0.77778],
          "8827": [0.0391, 0.5391, 0, 0, 0.77778],
          "8834": [0.0391, 0.5391, 0, 0, 0.77778],
          "8835": [0.0391, 0.5391, 0, 0, 0.77778],
          "8838": [0.13597, 0.63597, 0, 0, 0.77778],
          "8839": [0.13597, 0.63597, 0, 0, 0.77778],
          "8846": [0, 0.55556, 0, 0, 0.66667],
          "8849": [0.13597, 0.63597, 0, 0, 0.77778],
          "8850": [0.13597, 0.63597, 0, 0, 0.77778],
          "8851": [0, 0.55556, 0, 0, 0.66667],
          "8852": [0, 0.55556, 0, 0, 0.66667],
          "8853": [0.08333, 0.58333, 0, 0, 0.77778],
          "8854": [0.08333, 0.58333, 0, 0, 0.77778],
          "8855": [0.08333, 0.58333, 0, 0, 0.77778],
          "8856": [0.08333, 0.58333, 0, 0, 0.77778],
          "8857": [0.08333, 0.58333, 0, 0, 0.77778],
          "8866": [0, 0.69444, 0, 0, 0.61111],
          "8867": [0, 0.69444, 0, 0, 0.61111],
          "8868": [0, 0.69444, 0, 0, 0.77778],
          "8869": [0, 0.69444, 0, 0, 0.77778],
          "8872": [0.249, 0.75, 0, 0, 0.867],
          "8900": [-0.05555, 0.44445, 0, 0, 0.5],
          "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
          "8902": [-0.03472, 0.46528, 0, 0, 0.5],
          "8904": [5e-3, 0.505, 0, 0, 0.9],
          "8942": [0.03, 0.903, 0, 0, 0.278],
          "8943": [-0.19, 0.313, 0, 0, 1.172],
          "8945": [-0.1, 0.823, 0, 0, 1.282],
          "8968": [0.25, 0.75, 0, 0, 0.44445],
          "8969": [0.25, 0.75, 0, 0, 0.44445],
          "8970": [0.25, 0.75, 0, 0, 0.44445],
          "8971": [0.25, 0.75, 0, 0, 0.44445],
          "8994": [-0.14236, 0.35764, 0, 0, 1],
          "8995": [-0.14236, 0.35764, 0, 0, 1],
          "9136": [0.244, 0.744, 0, 0, 0.412],
          "9137": [0.244, 0.745, 0, 0, 0.412],
          "9651": [0.19444, 0.69444, 0, 0, 0.88889],
          "9657": [-0.03472, 0.46528, 0, 0, 0.5],
          "9661": [0.19444, 0.69444, 0, 0, 0.88889],
          "9667": [-0.03472, 0.46528, 0, 0, 0.5],
          "9711": [0.19444, 0.69444, 0, 0, 1],
          "9824": [0.12963, 0.69444, 0, 0, 0.77778],
          "9825": [0.12963, 0.69444, 0, 0, 0.77778],
          "9826": [0.12963, 0.69444, 0, 0, 0.77778],
          "9827": [0.12963, 0.69444, 0, 0, 0.77778],
          "9837": [0, 0.75, 0, 0, 0.38889],
          "9838": [0.19444, 0.69444, 0, 0, 0.38889],
          "9839": [0.19444, 0.69444, 0, 0, 0.38889],
          "10216": [0.25, 0.75, 0, 0, 0.38889],
          "10217": [0.25, 0.75, 0, 0, 0.38889],
          "10222": [0.244, 0.744, 0, 0, 0.412],
          "10223": [0.244, 0.745, 0, 0, 0.412],
          "10229": [0.011, 0.511, 0, 0, 1.609],
          "10230": [0.011, 0.511, 0, 0, 1.638],
          "10231": [0.011, 0.511, 0, 0, 1.859],
          "10232": [0.024, 0.525, 0, 0, 1.609],
          "10233": [0.024, 0.525, 0, 0, 1.638],
          "10234": [0.024, 0.525, 0, 0, 1.858],
          "10236": [0.011, 0.511, 0, 0, 1.638],
          "10815": [0, 0.68333, 0, 0, 0.75],
          "10927": [0.13597, 0.63597, 0, 0, 0.77778],
          "10928": [0.13597, 0.63597, 0, 0, 0.77778],
          "57376": [0.19444, 0.69444, 0, 0, 0]
        },
        "Math-BoldItalic": {
          "32": [0, 0, 0, 0, 0.25],
          "48": [0, 0.44444, 0, 0, 0.575],
          "49": [0, 0.44444, 0, 0, 0.575],
          "50": [0, 0.44444, 0, 0, 0.575],
          "51": [0.19444, 0.44444, 0, 0, 0.575],
          "52": [0.19444, 0.44444, 0, 0, 0.575],
          "53": [0.19444, 0.44444, 0, 0, 0.575],
          "54": [0, 0.64444, 0, 0, 0.575],
          "55": [0.19444, 0.44444, 0, 0, 0.575],
          "56": [0, 0.64444, 0, 0, 0.575],
          "57": [0.19444, 0.44444, 0, 0, 0.575],
          "65": [0, 0.68611, 0, 0, 0.86944],
          "66": [0, 0.68611, 0.04835, 0, 0.8664],
          "67": [0, 0.68611, 0.06979, 0, 0.81694],
          "68": [0, 0.68611, 0.03194, 0, 0.93812],
          "69": [0, 0.68611, 0.05451, 0, 0.81007],
          "70": [0, 0.68611, 0.15972, 0, 0.68889],
          "71": [0, 0.68611, 0, 0, 0.88673],
          "72": [0, 0.68611, 0.08229, 0, 0.98229],
          "73": [0, 0.68611, 0.07778, 0, 0.51111],
          "74": [0, 0.68611, 0.10069, 0, 0.63125],
          "75": [0, 0.68611, 0.06979, 0, 0.97118],
          "76": [0, 0.68611, 0, 0, 0.75555],
          "77": [0, 0.68611, 0.11424, 0, 1.14201],
          "78": [0, 0.68611, 0.11424, 0, 0.95034],
          "79": [0, 0.68611, 0.03194, 0, 0.83666],
          "80": [0, 0.68611, 0.15972, 0, 0.72309],
          "81": [0.19444, 0.68611, 0, 0, 0.86861],
          "82": [0, 0.68611, 421e-5, 0, 0.87235],
          "83": [0, 0.68611, 0.05382, 0, 0.69271],
          "84": [0, 0.68611, 0.15972, 0, 0.63663],
          "85": [0, 0.68611, 0.11424, 0, 0.80027],
          "86": [0, 0.68611, 0.25555, 0, 0.67778],
          "87": [0, 0.68611, 0.15972, 0, 1.09305],
          "88": [0, 0.68611, 0.07778, 0, 0.94722],
          "89": [0, 0.68611, 0.25555, 0, 0.67458],
          "90": [0, 0.68611, 0.06979, 0, 0.77257],
          "97": [0, 0.44444, 0, 0, 0.63287],
          "98": [0, 0.69444, 0, 0, 0.52083],
          "99": [0, 0.44444, 0, 0, 0.51342],
          "100": [0, 0.69444, 0, 0, 0.60972],
          "101": [0, 0.44444, 0, 0, 0.55361],
          "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
          "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
          "104": [0, 0.69444, 0, 0, 0.66759],
          "105": [0, 0.69326, 0, 0, 0.4048],
          "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
          "107": [0, 0.69444, 0.01852, 0, 0.6037],
          "108": [0, 0.69444, 88e-4, 0, 0.34815],
          "109": [0, 0.44444, 0, 0, 1.0324],
          "110": [0, 0.44444, 0, 0, 0.71296],
          "111": [0, 0.44444, 0, 0, 0.58472],
          "112": [0.19444, 0.44444, 0, 0, 0.60092],
          "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
          "114": [0, 0.44444, 0.03194, 0, 0.5287],
          "115": [0, 0.44444, 0, 0, 0.53125],
          "116": [0, 0.63492, 0, 0, 0.41528],
          "117": [0, 0.44444, 0, 0, 0.68102],
          "118": [0, 0.44444, 0.03704, 0, 0.56666],
          "119": [0, 0.44444, 0.02778, 0, 0.83148],
          "120": [0, 0.44444, 0, 0, 0.65903],
          "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
          "122": [0, 0.44444, 0.04213, 0, 0.55509],
          "160": [0, 0, 0, 0, 0.25],
          "915": [0, 0.68611, 0.15972, 0, 0.65694],
          "916": [0, 0.68611, 0, 0, 0.95833],
          "920": [0, 0.68611, 0.03194, 0, 0.86722],
          "923": [0, 0.68611, 0, 0, 0.80555],
          "926": [0, 0.68611, 0.07458, 0, 0.84125],
          "928": [0, 0.68611, 0.08229, 0, 0.98229],
          "931": [0, 0.68611, 0.05451, 0, 0.88507],
          "933": [0, 0.68611, 0.15972, 0, 0.67083],
          "934": [0, 0.68611, 0, 0, 0.76666],
          "936": [0, 0.68611, 0.11653, 0, 0.71402],
          "937": [0, 0.68611, 0.04835, 0, 0.8789],
          "945": [0, 0.44444, 0, 0, 0.76064],
          "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
          "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
          "948": [0, 0.69444, 0.03819, 0, 0.52222],
          "949": [0, 0.44444, 0, 0, 0.52882],
          "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
          "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
          "952": [0, 0.69444, 0.03194, 0, 0.5618],
          "953": [0, 0.44444, 0, 0, 0.41204],
          "954": [0, 0.44444, 0, 0, 0.66759],
          "955": [0, 0.69444, 0, 0, 0.67083],
          "956": [0.19444, 0.44444, 0, 0, 0.70787],
          "957": [0, 0.44444, 0.06898, 0, 0.57685],
          "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
          "959": [0, 0.44444, 0, 0, 0.58472],
          "960": [0, 0.44444, 0.03704, 0, 0.68241],
          "961": [0.19444, 0.44444, 0, 0, 0.6118],
          "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
          "963": [0, 0.44444, 0.03704, 0, 0.68588],
          "964": [0, 0.44444, 0.13472, 0, 0.52083],
          "965": [0, 0.44444, 0.03704, 0, 0.63055],
          "966": [0.19444, 0.44444, 0, 0, 0.74722],
          "967": [0.19444, 0.44444, 0, 0, 0.71805],
          "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
          "969": [0, 0.44444, 0.03704, 0, 0.71782],
          "977": [0, 0.69444, 0, 0, 0.69155],
          "981": [0.19444, 0.69444, 0, 0, 0.7125],
          "982": [0, 0.44444, 0.03194, 0, 0.975],
          "1009": [0.19444, 0.44444, 0, 0, 0.6118],
          "1013": [0, 0.44444, 0, 0, 0.48333],
          "57649": [0, 0.44444, 0, 0, 0.39352],
          "57911": [0.19444, 0.44444, 0, 0, 0.43889]
        },
        "Math-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "48": [0, 0.43056, 0, 0, 0.5],
          "49": [0, 0.43056, 0, 0, 0.5],
          "50": [0, 0.43056, 0, 0, 0.5],
          "51": [0.19444, 0.43056, 0, 0, 0.5],
          "52": [0.19444, 0.43056, 0, 0, 0.5],
          "53": [0.19444, 0.43056, 0, 0, 0.5],
          "54": [0, 0.64444, 0, 0, 0.5],
          "55": [0.19444, 0.43056, 0, 0, 0.5],
          "56": [0, 0.64444, 0, 0, 0.5],
          "57": [0.19444, 0.43056, 0, 0, 0.5],
          "65": [0, 0.68333, 0, 0.13889, 0.75],
          "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
          "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
          "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
          "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
          "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
          "71": [0, 0.68333, 0, 0.08334, 0.78625],
          "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
          "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
          "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
          "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
          "76": [0, 0.68333, 0, 0.02778, 0.68056],
          "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
          "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
          "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
          "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
          "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
          "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
          "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
          "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
          "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
          "86": [0, 0.68333, 0.22222, 0, 0.58333],
          "87": [0, 0.68333, 0.13889, 0, 0.94445],
          "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
          "89": [0, 0.68333, 0.22222, 0, 0.58056],
          "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
          "97": [0, 0.43056, 0, 0, 0.52859],
          "98": [0, 0.69444, 0, 0, 0.42917],
          "99": [0, 0.43056, 0, 0.05556, 0.43276],
          "100": [0, 0.69444, 0, 0.16667, 0.52049],
          "101": [0, 0.43056, 0, 0.05556, 0.46563],
          "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
          "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
          "104": [0, 0.69444, 0, 0, 0.57616],
          "105": [0, 0.65952, 0, 0, 0.34451],
          "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
          "107": [0, 0.69444, 0.03148, 0, 0.5206],
          "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
          "109": [0, 0.43056, 0, 0, 0.87801],
          "110": [0, 0.43056, 0, 0, 0.60023],
          "111": [0, 0.43056, 0, 0.05556, 0.48472],
          "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
          "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
          "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
          "115": [0, 0.43056, 0, 0.05556, 0.46875],
          "116": [0, 0.61508, 0, 0.08334, 0.36111],
          "117": [0, 0.43056, 0, 0.02778, 0.57246],
          "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
          "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
          "120": [0, 0.43056, 0, 0.02778, 0.57153],
          "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
          "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
          "160": [0, 0, 0, 0, 0.25],
          "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
          "916": [0, 0.68333, 0, 0.16667, 0.83334],
          "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
          "923": [0, 0.68333, 0, 0.16667, 0.69445],
          "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
          "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
          "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
          "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
          "934": [0, 0.68333, 0, 0.08334, 0.66667],
          "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
          "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
          "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
          "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
          "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
          "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
          "949": [0, 0.43056, 0, 0.08334, 0.46632],
          "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
          "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
          "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
          "953": [0, 0.43056, 0, 0.05556, 0.35394],
          "954": [0, 0.43056, 0, 0, 0.57616],
          "955": [0, 0.69444, 0, 0, 0.58334],
          "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
          "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
          "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
          "959": [0, 0.43056, 0, 0.05556, 0.48472],
          "960": [0, 0.43056, 0.03588, 0, 0.57003],
          "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
          "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
          "963": [0, 0.43056, 0.03588, 0, 0.57141],
          "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
          "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
          "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
          "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
          "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
          "969": [0, 0.43056, 0.03588, 0, 0.62245],
          "977": [0, 0.69444, 0, 0.08334, 0.59144],
          "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
          "982": [0, 0.43056, 0.02778, 0, 0.82813],
          "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
          "1013": [0, 0.43056, 0, 0.05556, 0.4059],
          "57649": [0, 0.43056, 0, 0.02778, 0.32246],
          "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
        },
        "SansSerif-Bold": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.36667],
          "34": [0, 0.69444, 0, 0, 0.55834],
          "35": [0.19444, 0.69444, 0, 0, 0.91667],
          "36": [0.05556, 0.75, 0, 0, 0.55],
          "37": [0.05556, 0.75, 0, 0, 1.02912],
          "38": [0, 0.69444, 0, 0, 0.83056],
          "39": [0, 0.69444, 0, 0, 0.30556],
          "40": [0.25, 0.75, 0, 0, 0.42778],
          "41": [0.25, 0.75, 0, 0, 0.42778],
          "42": [0, 0.75, 0, 0, 0.55],
          "43": [0.11667, 0.61667, 0, 0, 0.85556],
          "44": [0.10556, 0.13056, 0, 0, 0.30556],
          "45": [0, 0.45833, 0, 0, 0.36667],
          "46": [0, 0.13056, 0, 0, 0.30556],
          "47": [0.25, 0.75, 0, 0, 0.55],
          "48": [0, 0.69444, 0, 0, 0.55],
          "49": [0, 0.69444, 0, 0, 0.55],
          "50": [0, 0.69444, 0, 0, 0.55],
          "51": [0, 0.69444, 0, 0, 0.55],
          "52": [0, 0.69444, 0, 0, 0.55],
          "53": [0, 0.69444, 0, 0, 0.55],
          "54": [0, 0.69444, 0, 0, 0.55],
          "55": [0, 0.69444, 0, 0, 0.55],
          "56": [0, 0.69444, 0, 0, 0.55],
          "57": [0, 0.69444, 0, 0, 0.55],
          "58": [0, 0.45833, 0, 0, 0.30556],
          "59": [0.10556, 0.45833, 0, 0, 0.30556],
          "61": [-0.09375, 0.40625, 0, 0, 0.85556],
          "63": [0, 0.69444, 0, 0, 0.51945],
          "64": [0, 0.69444, 0, 0, 0.73334],
          "65": [0, 0.69444, 0, 0, 0.73334],
          "66": [0, 0.69444, 0, 0, 0.73334],
          "67": [0, 0.69444, 0, 0, 0.70278],
          "68": [0, 0.69444, 0, 0, 0.79445],
          "69": [0, 0.69444, 0, 0, 0.64167],
          "70": [0, 0.69444, 0, 0, 0.61111],
          "71": [0, 0.69444, 0, 0, 0.73334],
          "72": [0, 0.69444, 0, 0, 0.79445],
          "73": [0, 0.69444, 0, 0, 0.33056],
          "74": [0, 0.69444, 0, 0, 0.51945],
          "75": [0, 0.69444, 0, 0, 0.76389],
          "76": [0, 0.69444, 0, 0, 0.58056],
          "77": [0, 0.69444, 0, 0, 0.97778],
          "78": [0, 0.69444, 0, 0, 0.79445],
          "79": [0, 0.69444, 0, 0, 0.79445],
          "80": [0, 0.69444, 0, 0, 0.70278],
          "81": [0.10556, 0.69444, 0, 0, 0.79445],
          "82": [0, 0.69444, 0, 0, 0.70278],
          "83": [0, 0.69444, 0, 0, 0.61111],
          "84": [0, 0.69444, 0, 0, 0.73334],
          "85": [0, 0.69444, 0, 0, 0.76389],
          "86": [0, 0.69444, 0.01528, 0, 0.73334],
          "87": [0, 0.69444, 0.01528, 0, 1.03889],
          "88": [0, 0.69444, 0, 0, 0.73334],
          "89": [0, 0.69444, 0.0275, 0, 0.73334],
          "90": [0, 0.69444, 0, 0, 0.67223],
          "91": [0.25, 0.75, 0, 0, 0.34306],
          "93": [0.25, 0.75, 0, 0, 0.34306],
          "94": [0, 0.69444, 0, 0, 0.55],
          "95": [0.35, 0.10833, 0.03056, 0, 0.55],
          "97": [0, 0.45833, 0, 0, 0.525],
          "98": [0, 0.69444, 0, 0, 0.56111],
          "99": [0, 0.45833, 0, 0, 0.48889],
          "100": [0, 0.69444, 0, 0, 0.56111],
          "101": [0, 0.45833, 0, 0, 0.51111],
          "102": [0, 0.69444, 0.07639, 0, 0.33611],
          "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
          "104": [0, 0.69444, 0, 0, 0.56111],
          "105": [0, 0.69444, 0, 0, 0.25556],
          "106": [0.19444, 0.69444, 0, 0, 0.28611],
          "107": [0, 0.69444, 0, 0, 0.53056],
          "108": [0, 0.69444, 0, 0, 0.25556],
          "109": [0, 0.45833, 0, 0, 0.86667],
          "110": [0, 0.45833, 0, 0, 0.56111],
          "111": [0, 0.45833, 0, 0, 0.55],
          "112": [0.19444, 0.45833, 0, 0, 0.56111],
          "113": [0.19444, 0.45833, 0, 0, 0.56111],
          "114": [0, 0.45833, 0.01528, 0, 0.37222],
          "115": [0, 0.45833, 0, 0, 0.42167],
          "116": [0, 0.58929, 0, 0, 0.40417],
          "117": [0, 0.45833, 0, 0, 0.56111],
          "118": [0, 0.45833, 0.01528, 0, 0.5],
          "119": [0, 0.45833, 0.01528, 0, 0.74445],
          "120": [0, 0.45833, 0, 0, 0.5],
          "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
          "122": [0, 0.45833, 0, 0, 0.47639],
          "126": [0.35, 0.34444, 0, 0, 0.55],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.69444, 0, 0, 0.55],
          "176": [0, 0.69444, 0, 0, 0.73334],
          "180": [0, 0.69444, 0, 0, 0.55],
          "184": [0.17014, 0, 0, 0, 0.48889],
          "305": [0, 0.45833, 0, 0, 0.25556],
          "567": [0.19444, 0.45833, 0, 0, 0.28611],
          "710": [0, 0.69444, 0, 0, 0.55],
          "711": [0, 0.63542, 0, 0, 0.55],
          "713": [0, 0.63778, 0, 0, 0.55],
          "728": [0, 0.69444, 0, 0, 0.55],
          "729": [0, 0.69444, 0, 0, 0.30556],
          "730": [0, 0.69444, 0, 0, 0.73334],
          "732": [0, 0.69444, 0, 0, 0.55],
          "733": [0, 0.69444, 0, 0, 0.55],
          "915": [0, 0.69444, 0, 0, 0.58056],
          "916": [0, 0.69444, 0, 0, 0.91667],
          "920": [0, 0.69444, 0, 0, 0.85556],
          "923": [0, 0.69444, 0, 0, 0.67223],
          "926": [0, 0.69444, 0, 0, 0.73334],
          "928": [0, 0.69444, 0, 0, 0.79445],
          "931": [0, 0.69444, 0, 0, 0.79445],
          "933": [0, 0.69444, 0, 0, 0.85556],
          "934": [0, 0.69444, 0, 0, 0.79445],
          "936": [0, 0.69444, 0, 0, 0.85556],
          "937": [0, 0.69444, 0, 0, 0.79445],
          "8211": [0, 0.45833, 0.03056, 0, 0.55],
          "8212": [0, 0.45833, 0.03056, 0, 1.10001],
          "8216": [0, 0.69444, 0, 0, 0.30556],
          "8217": [0, 0.69444, 0, 0, 0.30556],
          "8220": [0, 0.69444, 0, 0, 0.55834],
          "8221": [0, 0.69444, 0, 0, 0.55834]
        },
        "SansSerif-Italic": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0.05733, 0, 0.31945],
          "34": [0, 0.69444, 316e-5, 0, 0.5],
          "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
          "36": [0.05556, 0.75, 0.11156, 0, 0.5],
          "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
          "38": [0, 0.69444, 0.03058, 0, 0.75834],
          "39": [0, 0.69444, 0.07816, 0, 0.27778],
          "40": [0.25, 0.75, 0.13164, 0, 0.38889],
          "41": [0.25, 0.75, 0.02536, 0, 0.38889],
          "42": [0, 0.75, 0.11775, 0, 0.5],
          "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
          "44": [0.125, 0.08333, 0, 0, 0.27778],
          "45": [0, 0.44444, 0.01946, 0, 0.33333],
          "46": [0, 0.08333, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0.13164, 0, 0.5],
          "48": [0, 0.65556, 0.11156, 0, 0.5],
          "49": [0, 0.65556, 0.11156, 0, 0.5],
          "50": [0, 0.65556, 0.11156, 0, 0.5],
          "51": [0, 0.65556, 0.11156, 0, 0.5],
          "52": [0, 0.65556, 0.11156, 0, 0.5],
          "53": [0, 0.65556, 0.11156, 0, 0.5],
          "54": [0, 0.65556, 0.11156, 0, 0.5],
          "55": [0, 0.65556, 0.11156, 0, 0.5],
          "56": [0, 0.65556, 0.11156, 0, 0.5],
          "57": [0, 0.65556, 0.11156, 0, 0.5],
          "58": [0, 0.44444, 0.02502, 0, 0.27778],
          "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
          "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
          "63": [0, 0.69444, 0.11809, 0, 0.47222],
          "64": [0, 0.69444, 0.07555, 0, 0.66667],
          "65": [0, 0.69444, 0, 0, 0.66667],
          "66": [0, 0.69444, 0.08293, 0, 0.66667],
          "67": [0, 0.69444, 0.11983, 0, 0.63889],
          "68": [0, 0.69444, 0.07555, 0, 0.72223],
          "69": [0, 0.69444, 0.11983, 0, 0.59722],
          "70": [0, 0.69444, 0.13372, 0, 0.56945],
          "71": [0, 0.69444, 0.11983, 0, 0.66667],
          "72": [0, 0.69444, 0.08094, 0, 0.70834],
          "73": [0, 0.69444, 0.13372, 0, 0.27778],
          "74": [0, 0.69444, 0.08094, 0, 0.47222],
          "75": [0, 0.69444, 0.11983, 0, 0.69445],
          "76": [0, 0.69444, 0, 0, 0.54167],
          "77": [0, 0.69444, 0.08094, 0, 0.875],
          "78": [0, 0.69444, 0.08094, 0, 0.70834],
          "79": [0, 0.69444, 0.07555, 0, 0.73611],
          "80": [0, 0.69444, 0.08293, 0, 0.63889],
          "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
          "82": [0, 0.69444, 0.08293, 0, 0.64584],
          "83": [0, 0.69444, 0.09205, 0, 0.55556],
          "84": [0, 0.69444, 0.13372, 0, 0.68056],
          "85": [0, 0.69444, 0.08094, 0, 0.6875],
          "86": [0, 0.69444, 0.1615, 0, 0.66667],
          "87": [0, 0.69444, 0.1615, 0, 0.94445],
          "88": [0, 0.69444, 0.13372, 0, 0.66667],
          "89": [0, 0.69444, 0.17261, 0, 0.66667],
          "90": [0, 0.69444, 0.11983, 0, 0.61111],
          "91": [0.25, 0.75, 0.15942, 0, 0.28889],
          "93": [0.25, 0.75, 0.08719, 0, 0.28889],
          "94": [0, 0.69444, 0.0799, 0, 0.5],
          "95": [0.35, 0.09444, 0.08616, 0, 0.5],
          "97": [0, 0.44444, 981e-5, 0, 0.48056],
          "98": [0, 0.69444, 0.03057, 0, 0.51667],
          "99": [0, 0.44444, 0.08336, 0, 0.44445],
          "100": [0, 0.69444, 0.09483, 0, 0.51667],
          "101": [0, 0.44444, 0.06778, 0, 0.44445],
          "102": [0, 0.69444, 0.21705, 0, 0.30556],
          "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
          "104": [0, 0.69444, 0.01778, 0, 0.51667],
          "105": [0, 0.67937, 0.09718, 0, 0.23889],
          "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
          "107": [0, 0.69444, 0.08336, 0, 0.48889],
          "108": [0, 0.69444, 0.09483, 0, 0.23889],
          "109": [0, 0.44444, 0.01778, 0, 0.79445],
          "110": [0, 0.44444, 0.01778, 0, 0.51667],
          "111": [0, 0.44444, 0.06613, 0, 0.5],
          "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
          "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
          "114": [0, 0.44444, 0.10836, 0, 0.34167],
          "115": [0, 0.44444, 0.0778, 0, 0.38333],
          "116": [0, 0.57143, 0.07225, 0, 0.36111],
          "117": [0, 0.44444, 0.04169, 0, 0.51667],
          "118": [0, 0.44444, 0.10836, 0, 0.46111],
          "119": [0, 0.44444, 0.10836, 0, 0.68334],
          "120": [0, 0.44444, 0.09169, 0, 0.46111],
          "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
          "122": [0, 0.44444, 0.08752, 0, 0.43472],
          "126": [0.35, 0.32659, 0.08826, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.67937, 0.06385, 0, 0.5],
          "176": [0, 0.69444, 0, 0, 0.73752],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "305": [0, 0.44444, 0.04169, 0, 0.23889],
          "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
          "710": [0, 0.69444, 0.0799, 0, 0.5],
          "711": [0, 0.63194, 0.08432, 0, 0.5],
          "713": [0, 0.60889, 0.08776, 0, 0.5],
          "714": [0, 0.69444, 0.09205, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0.09483, 0, 0.5],
          "729": [0, 0.67937, 0.07774, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.73752],
          "732": [0, 0.67659, 0.08826, 0, 0.5],
          "733": [0, 0.69444, 0.09205, 0, 0.5],
          "915": [0, 0.69444, 0.13372, 0, 0.54167],
          "916": [0, 0.69444, 0, 0, 0.83334],
          "920": [0, 0.69444, 0.07555, 0, 0.77778],
          "923": [0, 0.69444, 0, 0, 0.61111],
          "926": [0, 0.69444, 0.12816, 0, 0.66667],
          "928": [0, 0.69444, 0.08094, 0, 0.70834],
          "931": [0, 0.69444, 0.11983, 0, 0.72222],
          "933": [0, 0.69444, 0.09031, 0, 0.77778],
          "934": [0, 0.69444, 0.04603, 0, 0.72222],
          "936": [0, 0.69444, 0.09031, 0, 0.77778],
          "937": [0, 0.69444, 0.08293, 0, 0.72222],
          "8211": [0, 0.44444, 0.08616, 0, 0.5],
          "8212": [0, 0.44444, 0.08616, 0, 1],
          "8216": [0, 0.69444, 0.07816, 0, 0.27778],
          "8217": [0, 0.69444, 0.07816, 0, 0.27778],
          "8220": [0, 0.69444, 0.14205, 0, 0.5],
          "8221": [0, 0.69444, 316e-5, 0, 0.5]
        },
        "SansSerif-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "33": [0, 0.69444, 0, 0, 0.31945],
          "34": [0, 0.69444, 0, 0, 0.5],
          "35": [0.19444, 0.69444, 0, 0, 0.83334],
          "36": [0.05556, 0.75, 0, 0, 0.5],
          "37": [0.05556, 0.75, 0, 0, 0.83334],
          "38": [0, 0.69444, 0, 0, 0.75834],
          "39": [0, 0.69444, 0, 0, 0.27778],
          "40": [0.25, 0.75, 0, 0, 0.38889],
          "41": [0.25, 0.75, 0, 0, 0.38889],
          "42": [0, 0.75, 0, 0, 0.5],
          "43": [0.08333, 0.58333, 0, 0, 0.77778],
          "44": [0.125, 0.08333, 0, 0, 0.27778],
          "45": [0, 0.44444, 0, 0, 0.33333],
          "46": [0, 0.08333, 0, 0, 0.27778],
          "47": [0.25, 0.75, 0, 0, 0.5],
          "48": [0, 0.65556, 0, 0, 0.5],
          "49": [0, 0.65556, 0, 0, 0.5],
          "50": [0, 0.65556, 0, 0, 0.5],
          "51": [0, 0.65556, 0, 0, 0.5],
          "52": [0, 0.65556, 0, 0, 0.5],
          "53": [0, 0.65556, 0, 0, 0.5],
          "54": [0, 0.65556, 0, 0, 0.5],
          "55": [0, 0.65556, 0, 0, 0.5],
          "56": [0, 0.65556, 0, 0, 0.5],
          "57": [0, 0.65556, 0, 0, 0.5],
          "58": [0, 0.44444, 0, 0, 0.27778],
          "59": [0.125, 0.44444, 0, 0, 0.27778],
          "61": [-0.13, 0.37, 0, 0, 0.77778],
          "63": [0, 0.69444, 0, 0, 0.47222],
          "64": [0, 0.69444, 0, 0, 0.66667],
          "65": [0, 0.69444, 0, 0, 0.66667],
          "66": [0, 0.69444, 0, 0, 0.66667],
          "67": [0, 0.69444, 0, 0, 0.63889],
          "68": [0, 0.69444, 0, 0, 0.72223],
          "69": [0, 0.69444, 0, 0, 0.59722],
          "70": [0, 0.69444, 0, 0, 0.56945],
          "71": [0, 0.69444, 0, 0, 0.66667],
          "72": [0, 0.69444, 0, 0, 0.70834],
          "73": [0, 0.69444, 0, 0, 0.27778],
          "74": [0, 0.69444, 0, 0, 0.47222],
          "75": [0, 0.69444, 0, 0, 0.69445],
          "76": [0, 0.69444, 0, 0, 0.54167],
          "77": [0, 0.69444, 0, 0, 0.875],
          "78": [0, 0.69444, 0, 0, 0.70834],
          "79": [0, 0.69444, 0, 0, 0.73611],
          "80": [0, 0.69444, 0, 0, 0.63889],
          "81": [0.125, 0.69444, 0, 0, 0.73611],
          "82": [0, 0.69444, 0, 0, 0.64584],
          "83": [0, 0.69444, 0, 0, 0.55556],
          "84": [0, 0.69444, 0, 0, 0.68056],
          "85": [0, 0.69444, 0, 0, 0.6875],
          "86": [0, 0.69444, 0.01389, 0, 0.66667],
          "87": [0, 0.69444, 0.01389, 0, 0.94445],
          "88": [0, 0.69444, 0, 0, 0.66667],
          "89": [0, 0.69444, 0.025, 0, 0.66667],
          "90": [0, 0.69444, 0, 0, 0.61111],
          "91": [0.25, 0.75, 0, 0, 0.28889],
          "93": [0.25, 0.75, 0, 0, 0.28889],
          "94": [0, 0.69444, 0, 0, 0.5],
          "95": [0.35, 0.09444, 0.02778, 0, 0.5],
          "97": [0, 0.44444, 0, 0, 0.48056],
          "98": [0, 0.69444, 0, 0, 0.51667],
          "99": [0, 0.44444, 0, 0, 0.44445],
          "100": [0, 0.69444, 0, 0, 0.51667],
          "101": [0, 0.44444, 0, 0, 0.44445],
          "102": [0, 0.69444, 0.06944, 0, 0.30556],
          "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
          "104": [0, 0.69444, 0, 0, 0.51667],
          "105": [0, 0.67937, 0, 0, 0.23889],
          "106": [0.19444, 0.67937, 0, 0, 0.26667],
          "107": [0, 0.69444, 0, 0, 0.48889],
          "108": [0, 0.69444, 0, 0, 0.23889],
          "109": [0, 0.44444, 0, 0, 0.79445],
          "110": [0, 0.44444, 0, 0, 0.51667],
          "111": [0, 0.44444, 0, 0, 0.5],
          "112": [0.19444, 0.44444, 0, 0, 0.51667],
          "113": [0.19444, 0.44444, 0, 0, 0.51667],
          "114": [0, 0.44444, 0.01389, 0, 0.34167],
          "115": [0, 0.44444, 0, 0, 0.38333],
          "116": [0, 0.57143, 0, 0, 0.36111],
          "117": [0, 0.44444, 0, 0, 0.51667],
          "118": [0, 0.44444, 0.01389, 0, 0.46111],
          "119": [0, 0.44444, 0.01389, 0, 0.68334],
          "120": [0, 0.44444, 0, 0, 0.46111],
          "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
          "122": [0, 0.44444, 0, 0, 0.43472],
          "126": [0.35, 0.32659, 0, 0, 0.5],
          "160": [0, 0, 0, 0, 0.25],
          "168": [0, 0.67937, 0, 0, 0.5],
          "176": [0, 0.69444, 0, 0, 0.66667],
          "184": [0.17014, 0, 0, 0, 0.44445],
          "305": [0, 0.44444, 0, 0, 0.23889],
          "567": [0.19444, 0.44444, 0, 0, 0.26667],
          "710": [0, 0.69444, 0, 0, 0.5],
          "711": [0, 0.63194, 0, 0, 0.5],
          "713": [0, 0.60889, 0, 0, 0.5],
          "714": [0, 0.69444, 0, 0, 0.5],
          "715": [0, 0.69444, 0, 0, 0.5],
          "728": [0, 0.69444, 0, 0, 0.5],
          "729": [0, 0.67937, 0, 0, 0.27778],
          "730": [0, 0.69444, 0, 0, 0.66667],
          "732": [0, 0.67659, 0, 0, 0.5],
          "733": [0, 0.69444, 0, 0, 0.5],
          "915": [0, 0.69444, 0, 0, 0.54167],
          "916": [0, 0.69444, 0, 0, 0.83334],
          "920": [0, 0.69444, 0, 0, 0.77778],
          "923": [0, 0.69444, 0, 0, 0.61111],
          "926": [0, 0.69444, 0, 0, 0.66667],
          "928": [0, 0.69444, 0, 0, 0.70834],
          "931": [0, 0.69444, 0, 0, 0.72222],
          "933": [0, 0.69444, 0, 0, 0.77778],
          "934": [0, 0.69444, 0, 0, 0.72222],
          "936": [0, 0.69444, 0, 0, 0.77778],
          "937": [0, 0.69444, 0, 0, 0.72222],
          "8211": [0, 0.44444, 0.02778, 0, 0.5],
          "8212": [0, 0.44444, 0.02778, 0, 1],
          "8216": [0, 0.69444, 0, 0, 0.27778],
          "8217": [0, 0.69444, 0, 0, 0.27778],
          "8220": [0, 0.69444, 0, 0, 0.5],
          "8221": [0, 0.69444, 0, 0, 0.5]
        },
        "Script-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "65": [0, 0.7, 0.22925, 0, 0.80253],
          "66": [0, 0.7, 0.04087, 0, 0.90757],
          "67": [0, 0.7, 0.1689, 0, 0.66619],
          "68": [0, 0.7, 0.09371, 0, 0.77443],
          "69": [0, 0.7, 0.18583, 0, 0.56162],
          "70": [0, 0.7, 0.13634, 0, 0.89544],
          "71": [0, 0.7, 0.17322, 0, 0.60961],
          "72": [0, 0.7, 0.29694, 0, 0.96919],
          "73": [0, 0.7, 0.19189, 0, 0.80907],
          "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
          "75": [0, 0.7, 0.31259, 0, 0.91364],
          "76": [0, 0.7, 0.19189, 0, 0.87373],
          "77": [0, 0.7, 0.15981, 0, 1.08031],
          "78": [0, 0.7, 0.3525, 0, 0.9015],
          "79": [0, 0.7, 0.08078, 0, 0.73787],
          "80": [0, 0.7, 0.08078, 0, 1.01262],
          "81": [0, 0.7, 0.03305, 0, 0.88282],
          "82": [0, 0.7, 0.06259, 0, 0.85],
          "83": [0, 0.7, 0.19189, 0, 0.86767],
          "84": [0, 0.7, 0.29087, 0, 0.74697],
          "85": [0, 0.7, 0.25815, 0, 0.79996],
          "86": [0, 0.7, 0.27523, 0, 0.62204],
          "87": [0, 0.7, 0.27523, 0, 0.80532],
          "88": [0, 0.7, 0.26006, 0, 0.94445],
          "89": [0, 0.7, 0.2939, 0, 0.70961],
          "90": [0, 0.7, 0.24037, 0, 0.8212],
          "160": [0, 0, 0, 0, 0.25]
        },
        "Size1-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.35001, 0.85, 0, 0, 0.45834],
          "41": [0.35001, 0.85, 0, 0, 0.45834],
          "47": [0.35001, 0.85, 0, 0, 0.57778],
          "91": [0.35001, 0.85, 0, 0, 0.41667],
          "92": [0.35001, 0.85, 0, 0, 0.57778],
          "93": [0.35001, 0.85, 0, 0, 0.41667],
          "123": [0.35001, 0.85, 0, 0, 0.58334],
          "125": [0.35001, 0.85, 0, 0, 0.58334],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.72222, 0, 0, 0.55556],
          "732": [0, 0.72222, 0, 0, 0.55556],
          "770": [0, 0.72222, 0, 0, 0.55556],
          "771": [0, 0.72222, 0, 0, 0.55556],
          "8214": [-99e-5, 0.601, 0, 0, 0.77778],
          "8593": [1e-5, 0.6, 0, 0, 0.66667],
          "8595": [1e-5, 0.6, 0, 0, 0.66667],
          "8657": [1e-5, 0.6, 0, 0, 0.77778],
          "8659": [1e-5, 0.6, 0, 0, 0.77778],
          "8719": [0.25001, 0.75, 0, 0, 0.94445],
          "8720": [0.25001, 0.75, 0, 0, 0.94445],
          "8721": [0.25001, 0.75, 0, 0, 1.05556],
          "8730": [0.35001, 0.85, 0, 0, 1],
          "8739": [-599e-5, 0.606, 0, 0, 0.33333],
          "8741": [-599e-5, 0.606, 0, 0, 0.55556],
          "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
          "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
          "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
          "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
          "8896": [0.25001, 0.75, 0, 0, 0.83334],
          "8897": [0.25001, 0.75, 0, 0, 0.83334],
          "8898": [0.25001, 0.75, 0, 0, 0.83334],
          "8899": [0.25001, 0.75, 0, 0, 0.83334],
          "8968": [0.35001, 0.85, 0, 0, 0.47222],
          "8969": [0.35001, 0.85, 0, 0, 0.47222],
          "8970": [0.35001, 0.85, 0, 0, 0.47222],
          "8971": [0.35001, 0.85, 0, 0, 0.47222],
          "9168": [-99e-5, 0.601, 0, 0, 0.66667],
          "10216": [0.35001, 0.85, 0, 0, 0.47222],
          "10217": [0.35001, 0.85, 0, 0, 0.47222],
          "10752": [0.25001, 0.75, 0, 0, 1.11111],
          "10753": [0.25001, 0.75, 0, 0, 1.11111],
          "10754": [0.25001, 0.75, 0, 0, 1.11111],
          "10756": [0.25001, 0.75, 0, 0, 0.83334],
          "10758": [0.25001, 0.75, 0, 0, 0.83334]
        },
        "Size2-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.65002, 1.15, 0, 0, 0.59722],
          "41": [0.65002, 1.15, 0, 0, 0.59722],
          "47": [0.65002, 1.15, 0, 0, 0.81111],
          "91": [0.65002, 1.15, 0, 0, 0.47222],
          "92": [0.65002, 1.15, 0, 0, 0.81111],
          "93": [0.65002, 1.15, 0, 0, 0.47222],
          "123": [0.65002, 1.15, 0, 0, 0.66667],
          "125": [0.65002, 1.15, 0, 0, 0.66667],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.75, 0, 0, 1],
          "732": [0, 0.75, 0, 0, 1],
          "770": [0, 0.75, 0, 0, 1],
          "771": [0, 0.75, 0, 0, 1],
          "8719": [0.55001, 1.05, 0, 0, 1.27778],
          "8720": [0.55001, 1.05, 0, 0, 1.27778],
          "8721": [0.55001, 1.05, 0, 0, 1.44445],
          "8730": [0.65002, 1.15, 0, 0, 1],
          "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
          "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
          "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
          "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
          "8896": [0.55001, 1.05, 0, 0, 1.11111],
          "8897": [0.55001, 1.05, 0, 0, 1.11111],
          "8898": [0.55001, 1.05, 0, 0, 1.11111],
          "8899": [0.55001, 1.05, 0, 0, 1.11111],
          "8968": [0.65002, 1.15, 0, 0, 0.52778],
          "8969": [0.65002, 1.15, 0, 0, 0.52778],
          "8970": [0.65002, 1.15, 0, 0, 0.52778],
          "8971": [0.65002, 1.15, 0, 0, 0.52778],
          "10216": [0.65002, 1.15, 0, 0, 0.61111],
          "10217": [0.65002, 1.15, 0, 0, 0.61111],
          "10752": [0.55001, 1.05, 0, 0, 1.51112],
          "10753": [0.55001, 1.05, 0, 0, 1.51112],
          "10754": [0.55001, 1.05, 0, 0, 1.51112],
          "10756": [0.55001, 1.05, 0, 0, 1.11111],
          "10758": [0.55001, 1.05, 0, 0, 1.11111]
        },
        "Size3-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [0.95003, 1.45, 0, 0, 0.73611],
          "41": [0.95003, 1.45, 0, 0, 0.73611],
          "47": [0.95003, 1.45, 0, 0, 1.04445],
          "91": [0.95003, 1.45, 0, 0, 0.52778],
          "92": [0.95003, 1.45, 0, 0, 1.04445],
          "93": [0.95003, 1.45, 0, 0, 0.52778],
          "123": [0.95003, 1.45, 0, 0, 0.75],
          "125": [0.95003, 1.45, 0, 0, 0.75],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.75, 0, 0, 1.44445],
          "732": [0, 0.75, 0, 0, 1.44445],
          "770": [0, 0.75, 0, 0, 1.44445],
          "771": [0, 0.75, 0, 0, 1.44445],
          "8730": [0.95003, 1.45, 0, 0, 1],
          "8968": [0.95003, 1.45, 0, 0, 0.58334],
          "8969": [0.95003, 1.45, 0, 0, 0.58334],
          "8970": [0.95003, 1.45, 0, 0, 0.58334],
          "8971": [0.95003, 1.45, 0, 0, 0.58334],
          "10216": [0.95003, 1.45, 0, 0, 0.75],
          "10217": [0.95003, 1.45, 0, 0, 0.75]
        },
        "Size4-Regular": {
          "32": [0, 0, 0, 0, 0.25],
          "40": [1.25003, 1.75, 0, 0, 0.79167],
          "41": [1.25003, 1.75, 0, 0, 0.79167],
          "47": [1.25003, 1.75, 0, 0, 1.27778],
          "91": [1.25003, 1.75, 0, 0, 0.58334],
          "92": [1.25003, 1.75, 0, 0, 1.27778],
          "93": [1.25003, 1.75, 0, 0, 0.58334],
          "123": [1.25003, 1.75, 0, 0, 0.80556],
          "125": [1.25003, 1.75, 0, 0, 0.80556],
          "160": [0, 0, 0, 0, 0.25],
          "710": [0, 0.825, 0, 0, 1.8889],
          "732": [0, 0.825, 0, 0, 1.8889],
          "770": [0, 0.825, 0, 0, 1.8889],
          "771": [0, 0.825, 0, 0, 1.8889],
          "8730": [1.25003, 1.75, 0, 0, 1],
          "8968": [1.25003, 1.75, 0, 0, 0.63889],
          "8969": [1.25003, 1.75, 0, 0, 0.63889],
          "8970": [1.25003, 1.75, 0, 0, 0.63889],
          "8971": [1.25003, 1.75, 0, 0, 0.63889],
          "9115": [0.64502, 1.155, 0, 0, 0.875],
          "9116": [1e-5, 0.6, 0, 0, 0.875],
          "9117": [0.64502, 1.155, 0, 0, 0.875],
          "9118": [0.64502, 1.155, 0, 0, 0.875],
          "9119": [1e-5, 0.6, 0, 0, 0.875],
          "9120": [0.64502, 1.155, 0, 0, 0.875],
          "9121": [0.64502, 1.155, 0, 0, 0.66667],
          "9122": [-99e-5, 0.601, 0, 0, 0.66667],
          "9123": [0.64502, 1.155, 0, 0, 0.66667],
          "9124": [0.64502, 1.155, 0, 0, 0.66667],
          "9125": [-99e-5, 0.601, 0, 0, 0.66667],
          "9126": [0.64502, 1.155, 0, 0, 0.66667],
          "9127": [1e-5, 0.9, 0, 0, 0.88889],
          "9128": [0.65002, 1.15, 0, 0, 0.88889],
          "9129": [0.90001, 0, 0, 0, 0.88889],
          "9130": [0, 0.3, 0, 0, 0.88889],
          "9131": [1e-5, 0.9, 0, 0, 0.88889],
          "9132": [0.65002, 1.15, 0, 0, 0.88889],
          "9133": [0.90001, 0, 0, 0, 0.88889],
          "9143": [0.88502, 0.915, 0, 0, 1.05556],
          "10216": [1.25003, 1.75, 0, 0, 0.80556],
          "10217": [1.25003, 1.75, 0, 0, 0.80556],
          "57344": [-499e-5, 0.605, 0, 0, 1.05556],
          "57345": [-499e-5, 0.605, 0, 0, 1.05556],
          "57680": [0, 0.12, 0, 0, 0.45],
          "57681": [0, 0.12, 0, 0, 0.45],
          "57682": [0, 0.12, 0, 0, 0.45],
          "57683": [0, 0.12, 0, 0, 0.45]
        },
        "Typewriter-Regular": {
          "32": [0, 0, 0, 0, 0.525],
          "33": [0, 0.61111, 0, 0, 0.525],
          "34": [0, 0.61111, 0, 0, 0.525],
          "35": [0, 0.61111, 0, 0, 0.525],
          "36": [0.08333, 0.69444, 0, 0, 0.525],
          "37": [0.08333, 0.69444, 0, 0, 0.525],
          "38": [0, 0.61111, 0, 0, 0.525],
          "39": [0, 0.61111, 0, 0, 0.525],
          "40": [0.08333, 0.69444, 0, 0, 0.525],
          "41": [0.08333, 0.69444, 0, 0, 0.525],
          "42": [0, 0.52083, 0, 0, 0.525],
          "43": [-0.08056, 0.53055, 0, 0, 0.525],
          "44": [0.13889, 0.125, 0, 0, 0.525],
          "45": [-0.08056, 0.53055, 0, 0, 0.525],
          "46": [0, 0.125, 0, 0, 0.525],
          "47": [0.08333, 0.69444, 0, 0, 0.525],
          "48": [0, 0.61111, 0, 0, 0.525],
          "49": [0, 0.61111, 0, 0, 0.525],
          "50": [0, 0.61111, 0, 0, 0.525],
          "51": [0, 0.61111, 0, 0, 0.525],
          "52": [0, 0.61111, 0, 0, 0.525],
          "53": [0, 0.61111, 0, 0, 0.525],
          "54": [0, 0.61111, 0, 0, 0.525],
          "55": [0, 0.61111, 0, 0, 0.525],
          "56": [0, 0.61111, 0, 0, 0.525],
          "57": [0, 0.61111, 0, 0, 0.525],
          "58": [0, 0.43056, 0, 0, 0.525],
          "59": [0.13889, 0.43056, 0, 0, 0.525],
          "60": [-0.05556, 0.55556, 0, 0, 0.525],
          "61": [-0.19549, 0.41562, 0, 0, 0.525],
          "62": [-0.05556, 0.55556, 0, 0, 0.525],
          "63": [0, 0.61111, 0, 0, 0.525],
          "64": [0, 0.61111, 0, 0, 0.525],
          "65": [0, 0.61111, 0, 0, 0.525],
          "66": [0, 0.61111, 0, 0, 0.525],
          "67": [0, 0.61111, 0, 0, 0.525],
          "68": [0, 0.61111, 0, 0, 0.525],
          "69": [0, 0.61111, 0, 0, 0.525],
          "70": [0, 0.61111, 0, 0, 0.525],
          "71": [0, 0.61111, 0, 0, 0.525],
          "72": [0, 0.61111, 0, 0, 0.525],
          "73": [0, 0.61111, 0, 0, 0.525],
          "74": [0, 0.61111, 0, 0, 0.525],
          "75": [0, 0.61111, 0, 0, 0.525],
          "76": [0, 0.61111, 0, 0, 0.525],
          "77": [0, 0.61111, 0, 0, 0.525],
          "78": [0, 0.61111, 0, 0, 0.525],
          "79": [0, 0.61111, 0, 0, 0.525],
          "80": [0, 0.61111, 0, 0, 0.525],
          "81": [0.13889, 0.61111, 0, 0, 0.525],
          "82": [0, 0.61111, 0, 0, 0.525],
          "83": [0, 0.61111, 0, 0, 0.525],
          "84": [0, 0.61111, 0, 0, 0.525],
          "85": [0, 0.61111, 0, 0, 0.525],
          "86": [0, 0.61111, 0, 0, 0.525],
          "87": [0, 0.61111, 0, 0, 0.525],
          "88": [0, 0.61111, 0, 0, 0.525],
          "89": [0, 0.61111, 0, 0, 0.525],
          "90": [0, 0.61111, 0, 0, 0.525],
          "91": [0.08333, 0.69444, 0, 0, 0.525],
          "92": [0.08333, 0.69444, 0, 0, 0.525],
          "93": [0.08333, 0.69444, 0, 0, 0.525],
          "94": [0, 0.61111, 0, 0, 0.525],
          "95": [0.09514, 0, 0, 0, 0.525],
          "96": [0, 0.61111, 0, 0, 0.525],
          "97": [0, 0.43056, 0, 0, 0.525],
          "98": [0, 0.61111, 0, 0, 0.525],
          "99": [0, 0.43056, 0, 0, 0.525],
          "100": [0, 0.61111, 0, 0, 0.525],
          "101": [0, 0.43056, 0, 0, 0.525],
          "102": [0, 0.61111, 0, 0, 0.525],
          "103": [0.22222, 0.43056, 0, 0, 0.525],
          "104": [0, 0.61111, 0, 0, 0.525],
          "105": [0, 0.61111, 0, 0, 0.525],
          "106": [0.22222, 0.61111, 0, 0, 0.525],
          "107": [0, 0.61111, 0, 0, 0.525],
          "108": [0, 0.61111, 0, 0, 0.525],
          "109": [0, 0.43056, 0, 0, 0.525],
          "110": [0, 0.43056, 0, 0, 0.525],
          "111": [0, 0.43056, 0, 0, 0.525],
          "112": [0.22222, 0.43056, 0, 0, 0.525],
          "113": [0.22222, 0.43056, 0, 0, 0.525],
          "114": [0, 0.43056, 0, 0, 0.525],
          "115": [0, 0.43056, 0, 0, 0.525],
          "116": [0, 0.55358, 0, 0, 0.525],
          "117": [0, 0.43056, 0, 0, 0.525],
          "118": [0, 0.43056, 0, 0, 0.525],
          "119": [0, 0.43056, 0, 0, 0.525],
          "120": [0, 0.43056, 0, 0, 0.525],
          "121": [0.22222, 0.43056, 0, 0, 0.525],
          "122": [0, 0.43056, 0, 0, 0.525],
          "123": [0.08333, 0.69444, 0, 0, 0.525],
          "124": [0.08333, 0.69444, 0, 0, 0.525],
          "125": [0.08333, 0.69444, 0, 0, 0.525],
          "126": [0, 0.61111, 0, 0, 0.525],
          "127": [0, 0.61111, 0, 0, 0.525],
          "160": [0, 0, 0, 0, 0.525],
          "176": [0, 0.61111, 0, 0, 0.525],
          "184": [0.19445, 0, 0, 0, 0.525],
          "305": [0, 0.43056, 0, 0, 0.525],
          "567": [0.22222, 0.43056, 0, 0, 0.525],
          "711": [0, 0.56597, 0, 0, 0.525],
          "713": [0, 0.56555, 0, 0, 0.525],
          "714": [0, 0.61111, 0, 0, 0.525],
          "715": [0, 0.61111, 0, 0, 0.525],
          "728": [0, 0.61111, 0, 0, 0.525],
          "730": [0, 0.61111, 0, 0, 0.525],
          "770": [0, 0.61111, 0, 0, 0.525],
          "771": [0, 0.61111, 0, 0, 0.525],
          "776": [0, 0.61111, 0, 0, 0.525],
          "915": [0, 0.61111, 0, 0, 0.525],
          "916": [0, 0.61111, 0, 0, 0.525],
          "920": [0, 0.61111, 0, 0, 0.525],
          "923": [0, 0.61111, 0, 0, 0.525],
          "926": [0, 0.61111, 0, 0, 0.525],
          "928": [0, 0.61111, 0, 0, 0.525],
          "931": [0, 0.61111, 0, 0, 0.525],
          "933": [0, 0.61111, 0, 0, 0.525],
          "934": [0, 0.61111, 0, 0, 0.525],
          "936": [0, 0.61111, 0, 0, 0.525],
          "937": [0, 0.61111, 0, 0, 0.525],
          "8216": [0, 0.61111, 0, 0, 0.525],
          "8217": [0, 0.61111, 0, 0, 0.525],
          "8242": [0, 0.61111, 0, 0, 0.525],
          "9251": [0.11111, 0.21944, 0, 0, 0.525]
        }
      };
      sigmasAndXis = {
        slant: [0.25, 0.25, 0.25],
        // sigma1
        space: [0, 0, 0],
        // sigma2
        stretch: [0, 0, 0],
        // sigma3
        shrink: [0, 0, 0],
        // sigma4
        xHeight: [0.431, 0.431, 0.431],
        // sigma5
        quad: [1, 1.171, 1.472],
        // sigma6
        extraSpace: [0, 0, 0],
        // sigma7
        num1: [0.677, 0.732, 0.925],
        // sigma8
        num2: [0.394, 0.384, 0.387],
        // sigma9
        num3: [0.444, 0.471, 0.504],
        // sigma10
        denom1: [0.686, 0.752, 1.025],
        // sigma11
        denom2: [0.345, 0.344, 0.532],
        // sigma12
        sup1: [0.413, 0.503, 0.504],
        // sigma13
        sup2: [0.363, 0.431, 0.404],
        // sigma14
        sup3: [0.289, 0.286, 0.294],
        // sigma15
        sub1: [0.15, 0.143, 0.2],
        // sigma16
        sub2: [0.247, 0.286, 0.4],
        // sigma17
        supDrop: [0.386, 0.353, 0.494],
        // sigma18
        subDrop: [0.05, 0.071, 0.1],
        // sigma19
        delim1: [2.39, 1.7, 1.98],
        // sigma20
        delim2: [1.01, 1.157, 1.42],
        // sigma21
        axisHeight: [0.25, 0.25, 0.25],
        // sigma22
        // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
        // they correspond to the font parameters of the extension fonts (family 3).
        // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
        // match cmex7, we'd use cmex7.tfm values for script and scriptscript
        // values.
        defaultRuleThickness: [0.04, 0.049, 0.049],
        // xi8; cmex7: 0.049
        bigOpSpacing1: [0.111, 0.111, 0.111],
        // xi9
        bigOpSpacing2: [0.166, 0.166, 0.166],
        // xi10
        bigOpSpacing3: [0.2, 0.2, 0.2],
        // xi11
        bigOpSpacing4: [0.6, 0.611, 0.611],
        // xi12; cmex7: 0.611
        bigOpSpacing5: [0.1, 0.143, 0.143],
        // xi13; cmex7: 0.143
        // The \sqrt rule width is taken from the height of the surd character.
        // Since we use the same font at all sizes, this thickness doesn't scale.
        sqrtRuleThickness: [0.04, 0.04, 0.04],
        // This value determines how large a pt is, for metrics which are defined
        // in terms of pts.
        // This value is also used in katex.scss; if you change it make sure the
        // values match.
        ptPerEm: [10, 10, 10],
        // The space between adjacent `|` columns in an array definition. From
        // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
        doubleRuleSep: [0.2, 0.2, 0.2],
        // The width of separator lines in {array} environments. From
        // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
        arrayRuleWidth: [0.04, 0.04, 0.04],
        // Two values from LaTeX source2e:
        fboxsep: [0.3, 0.3, 0.3],
        //        3 pt / ptPerEm
        fboxrule: [0.04, 0.04, 0.04]
        // 0.4 pt / ptPerEm
      };
      extraCharacterMap = {
        // Latin-1
        "\xC5": "A",
        "\xD0": "D",
        "\xDE": "o",
        "\xE5": "a",
        "\xF0": "d",
        "\xFE": "o",
        // Cyrillic
        "\u0410": "A",
        "\u0411": "B",
        "\u0412": "B",
        "\u0413": "F",
        "\u0414": "A",
        "\u0415": "E",
        "\u0416": "K",
        "\u0417": "3",
        "\u0418": "N",
        "\u0419": "N",
        "\u041A": "K",
        "\u041B": "N",
        "\u041C": "M",
        "\u041D": "H",
        "\u041E": "O",
        "\u041F": "N",
        "\u0420": "P",
        "\u0421": "C",
        "\u0422": "T",
        "\u0423": "y",
        "\u0424": "O",
        "\u0425": "X",
        "\u0426": "U",
        "\u0427": "h",
        "\u0428": "W",
        "\u0429": "W",
        "\u042A": "B",
        "\u042B": "X",
        "\u042C": "B",
        "\u042D": "3",
        "\u042E": "X",
        "\u042F": "R",
        "\u0430": "a",
        "\u0431": "b",
        "\u0432": "a",
        "\u0433": "r",
        "\u0434": "y",
        "\u0435": "e",
        "\u0436": "m",
        "\u0437": "e",
        "\u0438": "n",
        "\u0439": "n",
        "\u043A": "n",
        "\u043B": "n",
        "\u043C": "m",
        "\u043D": "n",
        "\u043E": "o",
        "\u043F": "n",
        "\u0440": "p",
        "\u0441": "c",
        "\u0442": "o",
        "\u0443": "y",
        "\u0444": "b",
        "\u0445": "x",
        "\u0446": "n",
        "\u0447": "n",
        "\u0448": "w",
        "\u0449": "w",
        "\u044A": "a",
        "\u044B": "m",
        "\u044C": "a",
        "\u044D": "e",
        "\u044E": "m",
        "\u044F": "r"
      };
      fontMetricsBySizeIndex = {};
      sizeStyleMap = [
        // Each element contains [textsize, scriptsize, scriptscriptsize].
        // The size mappings are taken from TeX with \normalsize=10pt.
        [1, 1, 1],
        // size1: [5, 5, 5]              \tiny
        [2, 1, 1],
        // size2: [6, 5, 5]
        [3, 1, 1],
        // size3: [7, 5, 5]              \scriptsize
        [4, 2, 1],
        // size4: [8, 6, 5]              \footnotesize
        [5, 2, 1],
        // size5: [9, 6, 5]              \small
        [6, 3, 1],
        // size6: [10, 7, 5]             \normalsize
        [7, 4, 2],
        // size7: [12, 8, 6]             \large
        [8, 6, 3],
        // size8: [14.4, 10, 7]          \Large
        [9, 7, 6],
        // size9: [17.28, 12, 10]        \LARGE
        [10, 8, 7],
        // size10: [20.74, 14.4, 12]     \huge
        [11, 10, 9]
        // size11: [24.88, 20.74, 17.28] \HUGE
      ];
      sizeMultipliers = [
        // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
        // you change size indexes, change that function.
        0.5,
        0.6,
        0.7,
        0.8,
        0.9,
        1,
        1.2,
        1.44,
        1.728,
        2.074,
        2.488
      ];
      sizeAtStyle = function sizeAtStyle2(size, style) {
        return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
      };
      Options = class _Options {
        // A font family applies to a group of fonts (i.e. SansSerif), while a font
        // represents a specific font (i.e. SansSerif Bold).
        // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
        /**
         * The base size index.
         */
        constructor(data) {
          this.style = void 0;
          this.color = void 0;
          this.size = void 0;
          this.textSize = void 0;
          this.phantom = void 0;
          this.font = void 0;
          this.fontFamily = void 0;
          this.fontWeight = void 0;
          this.fontShape = void 0;
          this.sizeMultiplier = void 0;
          this.maxSize = void 0;
          this.minRuleThickness = void 0;
          this._fontMetrics = void 0;
          this.style = data.style;
          this.color = data.color;
          this.size = data.size || _Options.BASESIZE;
          this.textSize = data.textSize || this.size;
          this.phantom = !!data.phantom;
          this.font = data.font || "";
          this.fontFamily = data.fontFamily || "";
          this.fontWeight = data.fontWeight || "";
          this.fontShape = data.fontShape || "";
          this.sizeMultiplier = sizeMultipliers[this.size - 1];
          this.maxSize = data.maxSize;
          this.minRuleThickness = data.minRuleThickness;
          this._fontMetrics = void 0;
        }
        /**
         * Returns a new options object with the same properties as "this".  Properties
         * from "extension" will be copied to the new options object.
         */
        extend(extension) {
          var data = {
            style: this.style,
            size: this.size,
            textSize: this.textSize,
            color: this.color,
            phantom: this.phantom,
            font: this.font,
            fontFamily: this.fontFamily,
            fontWeight: this.fontWeight,
            fontShape: this.fontShape,
            maxSize: this.maxSize,
            minRuleThickness: this.minRuleThickness
          };
          for (var key in extension) {
            if (extension.hasOwnProperty(key)) {
              data[key] = extension[key];
            }
          }
          return new _Options(data);
        }
        /**
         * Return an options object with the given style. If `this.style === style`,
         * returns `this`.
         */
        havingStyle(style) {
          if (this.style === style) {
            return this;
          } else {
            return this.extend({
              style,
              size: sizeAtStyle(this.textSize, style)
            });
          }
        }
        /**
         * Return an options object with a cramped version of the current style. If
         * the current style is cramped, returns `this`.
         */
        havingCrampedStyle() {
          return this.havingStyle(this.style.cramp());
        }
        /**
         * Return an options object with the given size and in at least `\textstyle`.
         * Returns `this` if appropriate.
         */
        havingSize(size) {
          if (this.size === size && this.textSize === size) {
            return this;
          } else {
            return this.extend({
              style: this.style.text(),
              size,
              textSize: size,
              sizeMultiplier: sizeMultipliers[size - 1]
            });
          }
        }
        /**
         * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
         * changes to at least `\textstyle`.
         */
        havingBaseStyle(style) {
          style = style || this.style.text();
          var wantSize = sizeAtStyle(_Options.BASESIZE, style);
          if (this.size === wantSize && this.textSize === _Options.BASESIZE && this.style === style) {
            return this;
          } else {
            return this.extend({
              style,
              size: wantSize
            });
          }
        }
        /**
         * Remove the effect of sizing changes such as \Huge.
         * Keep the effect of the current style, such as \scriptstyle.
         */
        havingBaseSizing() {
          var size;
          switch (this.style.id) {
            case 4:
            case 5:
              size = 3;
              break;
            case 6:
            case 7:
              size = 1;
              break;
            default:
              size = 6;
          }
          return this.extend({
            style: this.style.text(),
            size
          });
        }
        /**
         * Create a new options object with the given color.
         */
        withColor(color) {
          return this.extend({
            color
          });
        }
        /**
         * Create a new options object with "phantom" set to true.
         */
        withPhantom() {
          return this.extend({
            phantom: true
          });
        }
        /**
         * Creates a new options object with the given math font or old text font.
         * @type {[type]}
         */
        withFont(font) {
          return this.extend({
            font
          });
        }
        /**
         * Create a new options objects with the given fontFamily.
         */
        withTextFontFamily(fontFamily) {
          return this.extend({
            fontFamily,
            font: ""
          });
        }
        /**
         * Creates a new options object with the given font weight
         */
        withTextFontWeight(fontWeight) {
          return this.extend({
            fontWeight,
            font: ""
          });
        }
        /**
         * Creates a new options object with the given font weight
         */
        withTextFontShape(fontShape) {
          return this.extend({
            fontShape,
            font: ""
          });
        }
        /**
         * Return the CSS sizing classes required to switch from enclosing options
         * `oldOptions` to `this`. Returns an array of classes.
         */
        sizingClasses(oldOptions) {
          if (oldOptions.size !== this.size) {
            return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
          } else {
            return [];
          }
        }
        /**
         * Return the CSS sizing classes required to switch to the base size. Like
         * `this.havingSize(BASESIZE).sizingClasses(this)`.
         */
        baseSizingClasses() {
          if (this.size !== _Options.BASESIZE) {
            return ["sizing", "reset-size" + this.size, "size" + _Options.BASESIZE];
          } else {
            return [];
          }
        }
        /**
         * Return the font metrics for this size.
         */
        fontMetrics() {
          if (!this._fontMetrics) {
            this._fontMetrics = getGlobalMetrics(this.size);
          }
          return this._fontMetrics;
        }
        /**
         * Gets the CSS color of the current options object
         */
        getColor() {
          if (this.phantom) {
            return "transparent";
          } else {
            return this.color;
          }
        }
      };
      Options.BASESIZE = 6;
      ptPerUnit = {
        // https://en.wikibooks.org/wiki/LaTeX/Lengths and
        // https://tex.stackexchange.com/a/8263
        "pt": 1,
        // TeX point
        "mm": 7227 / 2540,
        // millimeter
        "cm": 7227 / 254,
        // centimeter
        "in": 72.27,
        // inch
        "bp": 803 / 800,
        // big (PostScript) points
        "pc": 12,
        // pica
        "dd": 1238 / 1157,
        // didot
        "cc": 14856 / 1157,
        // cicero (12 didot)
        "nd": 685 / 642,
        // new didot
        "nc": 1370 / 107,
        // new cicero (12 new didot)
        "sp": 1 / 65536,
        // scaled point (TeX's internal smallest unit)
        // https://tex.stackexchange.com/a/41371
        "px": 803 / 800
        // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
      };
      relativeUnit = {
        "ex": true,
        "em": true,
        "mu": true
      };
      validUnit = function validUnit2(unit) {
        if (typeof unit !== "string") {
          unit = unit.unit;
        }
        return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
      };
      calculateSize = function calculateSize2(sizeValue, options2) {
        var scale;
        if (sizeValue.unit in ptPerUnit) {
          scale = ptPerUnit[sizeValue.unit] / options2.fontMetrics().ptPerEm / options2.sizeMultiplier;
        } else if (sizeValue.unit === "mu") {
          scale = options2.fontMetrics().cssEmPerMu;
        } else {
          var unitOptions;
          if (options2.style.isTight()) {
            unitOptions = options2.havingStyle(options2.style.text());
          } else {
            unitOptions = options2;
          }
          if (sizeValue.unit === "ex") {
            scale = unitOptions.fontMetrics().xHeight;
          } else if (sizeValue.unit === "em") {
            scale = unitOptions.fontMetrics().quad;
          } else {
            throw new ParseError("Invalid unit: '" + sizeValue.unit + "'");
          }
          if (unitOptions !== options2) {
            scale *= unitOptions.sizeMultiplier / options2.sizeMultiplier;
          }
        }
        return Math.min(sizeValue.number * scale, options2.maxSize);
      };
      makeEm = function makeEm2(n) {
        return +n.toFixed(4) + "em";
      };
      createClass = function createClass2(classes) {
        return classes.filter((cls) => cls).join(" ");
      };
      initNode = function initNode2(classes, options2, style) {
        this.classes = classes || [];
        this.attributes = {};
        this.height = 0;
        this.depth = 0;
        this.maxFontSize = 0;
        this.style = style || {};
        if (options2) {
          if (options2.style.isTight()) {
            this.classes.push("mtight");
          }
          var color = options2.getColor();
          if (color) {
            this.style.color = color;
          }
        }
      };
      toNode = function toNode2(tagName) {
        var node = document.createElement(tagName);
        node.className = createClass(this.classes);
        for (var style in this.style) {
          if (this.style.hasOwnProperty(style)) {
            node.style[style] = this.style[style];
          }
        }
        for (var attr in this.attributes) {
          if (this.attributes.hasOwnProperty(attr)) {
            node.setAttribute(attr, this.attributes[attr]);
          }
        }
        for (var i = 0; i < this.children.length; i++) {
          node.appendChild(this.children[i].toNode());
        }
        return node;
      };
      invalidAttributeNameRegex = /[\s"'>/=\x00-\x1f]/;
      toMarkup = function toMarkup2(tagName) {
        var markup = "<" + tagName;
        if (this.classes.length) {
          markup += ' class="' + utils.escape(createClass(this.classes)) + '"';
        }
        var styles2 = "";
        for (var style in this.style) {
          if (this.style.hasOwnProperty(style)) {
            styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
          }
        }
        if (styles2) {
          markup += ' style="' + utils.escape(styles2) + '"';
        }
        for (var attr in this.attributes) {
          if (this.attributes.hasOwnProperty(attr)) {
            if (invalidAttributeNameRegex.test(attr)) {
              throw new ParseError("Invalid attribute name '" + attr + "'");
            }
            markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
          }
        }
        markup += ">";
        for (var i = 0; i < this.children.length; i++) {
          markup += this.children[i].toMarkup();
        }
        markup += "</" + tagName + ">";
        return markup;
      };
      Span = class {
        constructor(classes, children, options2, style) {
          this.children = void 0;
          this.attributes = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.width = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          initNode.call(this, classes, options2, style);
          this.children = children || [];
        }
        /**
         * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
         * all browsers support attributes the same, and having too many custom
         * attributes is probably bad.
         */
        setAttribute(attribute, value) {
          this.attributes[attribute] = value;
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        toNode() {
          return toNode.call(this, "span");
        }
        toMarkup() {
          return toMarkup.call(this, "span");
        }
      };
      Anchor = class {
        constructor(href, classes, children, options2) {
          this.children = void 0;
          this.attributes = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          initNode.call(this, classes, options2);
          this.children = children || [];
          this.setAttribute("href", href);
        }
        setAttribute(attribute, value) {
          this.attributes[attribute] = value;
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        toNode() {
          return toNode.call(this, "a");
        }
        toMarkup() {
          return toMarkup.call(this, "a");
        }
      };
      Img = class {
        constructor(src, alt, style) {
          this.src = void 0;
          this.alt = void 0;
          this.classes = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.maxFontSize = void 0;
          this.style = void 0;
          this.alt = alt;
          this.src = src;
          this.classes = ["mord"];
          this.style = style;
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        toNode() {
          var node = document.createElement("img");
          node.src = this.src;
          node.alt = this.alt;
          node.className = "mord";
          for (var style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              node.style[style] = this.style[style];
            }
          }
          return node;
        }
        toMarkup() {
          var markup = '<img src="' + utils.escape(this.src) + '"' + (' alt="' + utils.escape(this.alt) + '"');
          var styles2 = "";
          for (var style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
            }
          }
          if (styles2) {
            markup += ' style="' + utils.escape(styles2) + '"';
          }
          markup += "'/>";
          return markup;
        }
      };
      iCombinations = {
        "\xEE": "\u0131\u0302",
        "\xEF": "\u0131\u0308",
        "\xED": "\u0131\u0301",
        // 'ī': '\u0131\u0304', // enable when we add Extended Latin
        "\xEC": "\u0131\u0300"
      };
      SymbolNode = class {
        constructor(text2, height, depth, italic, skew, width, classes, style) {
          this.text = void 0;
          this.height = void 0;
          this.depth = void 0;
          this.italic = void 0;
          this.skew = void 0;
          this.width = void 0;
          this.maxFontSize = void 0;
          this.classes = void 0;
          this.style = void 0;
          this.text = text2;
          this.height = height || 0;
          this.depth = depth || 0;
          this.italic = italic || 0;
          this.skew = skew || 0;
          this.width = width || 0;
          this.classes = classes || [];
          this.style = style || {};
          this.maxFontSize = 0;
          var script = scriptFromCodepoint(this.text.charCodeAt(0));
          if (script) {
            this.classes.push(script + "_fallback");
          }
          if (/[îïíì]/.test(this.text)) {
            this.text = iCombinations[this.text];
          }
        }
        hasClass(className) {
          return utils.contains(this.classes, className);
        }
        /**
         * Creates a text node or span from a symbol node. Note that a span is only
         * created if it is needed.
         */
        toNode() {
          var node = document.createTextNode(this.text);
          var span = null;
          if (this.italic > 0) {
            span = document.createElement("span");
            span.style.marginRight = makeEm(this.italic);
          }
          if (this.classes.length > 0) {
            span = span || document.createElement("span");
            span.className = createClass(this.classes);
          }
          for (var style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              span = span || document.createElement("span");
              span.style[style] = this.style[style];
            }
          }
          if (span) {
            span.appendChild(node);
            return span;
          } else {
            return node;
          }
        }
        /**
         * Creates markup for a symbol node.
         */
        toMarkup() {
          var needsSpan = false;
          var markup = "<span";
          if (this.classes.length) {
            needsSpan = true;
            markup += ' class="';
            markup += utils.escape(createClass(this.classes));
            markup += '"';
          }
          var styles2 = "";
          if (this.italic > 0) {
            styles2 += "margin-right:" + this.italic + "em;";
          }
          for (var style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
            }
          }
          if (styles2) {
            needsSpan = true;
            markup += ' style="' + utils.escape(styles2) + '"';
          }
          var escaped = utils.escape(this.text);
          if (needsSpan) {
            markup += ">";
            markup += escaped;
            markup += "</span>";
            return markup;
          } else {
            return escaped;
          }
        }
      };
      SvgNode = class {
        constructor(children, attributes) {
          this.children = void 0;
          this.attributes = void 0;
          this.children = children || [];
          this.attributes = attributes || {};
        }
        toNode() {
          var svgNS = "http://www.w3.org/2000/svg";
          var node = document.createElementNS(svgNS, "svg");
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node.setAttribute(attr, this.attributes[attr]);
            }
          }
          for (var i = 0; i < this.children.length; i++) {
            node.appendChild(this.children[i].toNode());
          }
          return node;
        }
        toMarkup() {
          var markup = '<svg xmlns="http://www.w3.org/2000/svg"';
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
            }
          }
          markup += ">";
          for (var i = 0; i < this.children.length; i++) {
            markup += this.children[i].toMarkup();
          }
          markup += "</svg>";
          return markup;
        }
      };
      PathNode = class {
        constructor(pathName, alternate) {
          this.pathName = void 0;
          this.alternate = void 0;
          this.pathName = pathName;
          this.alternate = alternate;
        }
        toNode() {
          var svgNS = "http://www.w3.org/2000/svg";
          var node = document.createElementNS(svgNS, "path");
          if (this.alternate) {
            node.setAttribute("d", this.alternate);
          } else {
            node.setAttribute("d", path[this.pathName]);
          }
          return node;
        }
        toMarkup() {
          if (this.alternate) {
            return '<path d="' + utils.escape(this.alternate) + '"/>';
          } else {
            return '<path d="' + utils.escape(path[this.pathName]) + '"/>';
          }
        }
      };
      LineNode = class {
        constructor(attributes) {
          this.attributes = void 0;
          this.attributes = attributes || {};
        }
        toNode() {
          var svgNS = "http://www.w3.org/2000/svg";
          var node = document.createElementNS(svgNS, "line");
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node.setAttribute(attr, this.attributes[attr]);
            }
          }
          return node;
        }
        toMarkup() {
          var markup = "<line";
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
            }
          }
          markup += "/>";
          return markup;
        }
      };
      ATOMS = {
        "bin": 1,
        "close": 1,
        "inner": 1,
        "open": 1,
        "punct": 1,
        "rel": 1
      };
      NON_ATOMS = {
        "accent-token": 1,
        "mathord": 1,
        "op-token": 1,
        "spacing": 1,
        "textord": 1
      };
      symbols = {
        "math": {},
        "text": {}
      };
      math = "math";
      text = "text";
      main = "main";
      ams = "ams";
      accent = "accent-token";
      bin = "bin";
      close = "close";
      inner = "inner";
      mathord = "mathord";
      op = "op-token";
      open = "open";
      punct = "punct";
      rel = "rel";
      spacing = "spacing";
      textord = "textord";
      defineSymbol(math, main, rel, "\u2261", "\\equiv", true);
      defineSymbol(math, main, rel, "\u227A", "\\prec", true);
      defineSymbol(math, main, rel, "\u227B", "\\succ", true);
      defineSymbol(math, main, rel, "\u223C", "\\sim", true);
      defineSymbol(math, main, rel, "\u22A5", "\\perp");
      defineSymbol(math, main, rel, "\u2AAF", "\\preceq", true);
      defineSymbol(math, main, rel, "\u2AB0", "\\succeq", true);
      defineSymbol(math, main, rel, "\u2243", "\\simeq", true);
      defineSymbol(math, main, rel, "\u2223", "\\mid", true);
      defineSymbol(math, main, rel, "\u226A", "\\ll", true);
      defineSymbol(math, main, rel, "\u226B", "\\gg", true);
      defineSymbol(math, main, rel, "\u224D", "\\asymp", true);
      defineSymbol(math, main, rel, "\u2225", "\\parallel");
      defineSymbol(math, main, rel, "\u22C8", "\\bowtie", true);
      defineSymbol(math, main, rel, "\u2323", "\\smile", true);
      defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq", true);
      defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq", true);
      defineSymbol(math, main, rel, "\u2250", "\\doteq", true);
      defineSymbol(math, main, rel, "\u2322", "\\frown", true);
      defineSymbol(math, main, rel, "\u220B", "\\ni", true);
      defineSymbol(math, main, rel, "\u221D", "\\propto", true);
      defineSymbol(math, main, rel, "\u22A2", "\\vdash", true);
      defineSymbol(math, main, rel, "\u22A3", "\\dashv", true);
      defineSymbol(math, main, rel, "\u220B", "\\owns");
      defineSymbol(math, main, punct, ".", "\\ldotp");
      defineSymbol(math, main, punct, "\u22C5", "\\cdotp");
      defineSymbol(math, main, textord, "#", "\\#");
      defineSymbol(text, main, textord, "#", "\\#");
      defineSymbol(math, main, textord, "&", "\\&");
      defineSymbol(text, main, textord, "&", "\\&");
      defineSymbol(math, main, textord, "\u2135", "\\aleph", true);
      defineSymbol(math, main, textord, "\u2200", "\\forall", true);
      defineSymbol(math, main, textord, "\u210F", "\\hbar", true);
      defineSymbol(math, main, textord, "\u2203", "\\exists", true);
      defineSymbol(math, main, textord, "\u2207", "\\nabla", true);
      defineSymbol(math, main, textord, "\u266D", "\\flat", true);
      defineSymbol(math, main, textord, "\u2113", "\\ell", true);
      defineSymbol(math, main, textord, "\u266E", "\\natural", true);
      defineSymbol(math, main, textord, "\u2663", "\\clubsuit", true);
      defineSymbol(math, main, textord, "\u2118", "\\wp", true);
      defineSymbol(math, main, textord, "\u266F", "\\sharp", true);
      defineSymbol(math, main, textord, "\u2662", "\\diamondsuit", true);
      defineSymbol(math, main, textord, "\u211C", "\\Re", true);
      defineSymbol(math, main, textord, "\u2661", "\\heartsuit", true);
      defineSymbol(math, main, textord, "\u2111", "\\Im", true);
      defineSymbol(math, main, textord, "\u2660", "\\spadesuit", true);
      defineSymbol(math, main, textord, "\xA7", "\\S", true);
      defineSymbol(text, main, textord, "\xA7", "\\S");
      defineSymbol(math, main, textord, "\xB6", "\\P", true);
      defineSymbol(text, main, textord, "\xB6", "\\P");
      defineSymbol(math, main, textord, "\u2020", "\\dag");
      defineSymbol(text, main, textord, "\u2020", "\\dag");
      defineSymbol(text, main, textord, "\u2020", "\\textdagger");
      defineSymbol(math, main, textord, "\u2021", "\\ddag");
      defineSymbol(text, main, textord, "\u2021", "\\ddag");
      defineSymbol(text, main, textord, "\u2021", "\\textdaggerdbl");
      defineSymbol(math, main, close, "\u23B1", "\\rmoustache", true);
      defineSymbol(math, main, open, "\u23B0", "\\lmoustache", true);
      defineSymbol(math, main, close, "\u27EF", "\\rgroup", true);
      defineSymbol(math, main, open, "\u27EE", "\\lgroup", true);
      defineSymbol(math, main, bin, "\u2213", "\\mp", true);
      defineSymbol(math, main, bin, "\u2296", "\\ominus", true);
      defineSymbol(math, main, bin, "\u228E", "\\uplus", true);
      defineSymbol(math, main, bin, "\u2293", "\\sqcap", true);
      defineSymbol(math, main, bin, "\u2217", "\\ast");
      defineSymbol(math, main, bin, "\u2294", "\\sqcup", true);
      defineSymbol(math, main, bin, "\u25EF", "\\bigcirc", true);
      defineSymbol(math, main, bin, "\u2219", "\\bullet", true);
      defineSymbol(math, main, bin, "\u2021", "\\ddagger");
      defineSymbol(math, main, bin, "\u2240", "\\wr", true);
      defineSymbol(math, main, bin, "\u2A3F", "\\amalg");
      defineSymbol(math, main, bin, "&", "\\And");
      defineSymbol(math, main, rel, "\u27F5", "\\longleftarrow", true);
      defineSymbol(math, main, rel, "\u21D0", "\\Leftarrow", true);
      defineSymbol(math, main, rel, "\u27F8", "\\Longleftarrow", true);
      defineSymbol(math, main, rel, "\u27F6", "\\longrightarrow", true);
      defineSymbol(math, main, rel, "\u21D2", "\\Rightarrow", true);
      defineSymbol(math, main, rel, "\u27F9", "\\Longrightarrow", true);
      defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow", true);
      defineSymbol(math, main, rel, "\u27F7", "\\longleftrightarrow", true);
      defineSymbol(math, main, rel, "\u21D4", "\\Leftrightarrow", true);
      defineSymbol(math, main, rel, "\u27FA", "\\Longleftrightarrow", true);
      defineSymbol(math, main, rel, "\u21A6", "\\mapsto", true);
      defineSymbol(math, main, rel, "\u27FC", "\\longmapsto", true);
      defineSymbol(math, main, rel, "\u2197", "\\nearrow", true);
      defineSymbol(math, main, rel, "\u21A9", "\\hookleftarrow", true);
      defineSymbol(math, main, rel, "\u21AA", "\\hookrightarrow", true);
      defineSymbol(math, main, rel, "\u2198", "\\searrow", true);
      defineSymbol(math, main, rel, "\u21BC", "\\leftharpoonup", true);
      defineSymbol(math, main, rel, "\u21C0", "\\rightharpoonup", true);
      defineSymbol(math, main, rel, "\u2199", "\\swarrow", true);
      defineSymbol(math, main, rel, "\u21BD", "\\leftharpoondown", true);
      defineSymbol(math, main, rel, "\u21C1", "\\rightharpoondown", true);
      defineSymbol(math, main, rel, "\u2196", "\\nwarrow", true);
      defineSymbol(math, main, rel, "\u21CC", "\\rightleftharpoons", true);
      defineSymbol(math, ams, rel, "\u226E", "\\nless", true);
      defineSymbol(math, ams, rel, "\uE010", "\\@nleqslant");
      defineSymbol(math, ams, rel, "\uE011", "\\@nleqq");
      defineSymbol(math, ams, rel, "\u2A87", "\\lneq", true);
      defineSymbol(math, ams, rel, "\u2268", "\\lneqq", true);
      defineSymbol(math, ams, rel, "\uE00C", "\\@lvertneqq");
      defineSymbol(math, ams, rel, "\u22E6", "\\lnsim", true);
      defineSymbol(math, ams, rel, "\u2A89", "\\lnapprox", true);
      defineSymbol(math, ams, rel, "\u2280", "\\nprec", true);
      defineSymbol(math, ams, rel, "\u22E0", "\\npreceq", true);
      defineSymbol(math, ams, rel, "\u22E8", "\\precnsim", true);
      defineSymbol(math, ams, rel, "\u2AB9", "\\precnapprox", true);
      defineSymbol(math, ams, rel, "\u2241", "\\nsim", true);
      defineSymbol(math, ams, rel, "\uE006", "\\@nshortmid");
      defineSymbol(math, ams, rel, "\u2224", "\\nmid", true);
      defineSymbol(math, ams, rel, "\u22AC", "\\nvdash", true);
      defineSymbol(math, ams, rel, "\u22AD", "\\nvDash", true);
      defineSymbol(math, ams, rel, "\u22EA", "\\ntriangleleft");
      defineSymbol(math, ams, rel, "\u22EC", "\\ntrianglelefteq", true);
      defineSymbol(math, ams, rel, "\u228A", "\\subsetneq", true);
      defineSymbol(math, ams, rel, "\uE01A", "\\@varsubsetneq");
      defineSymbol(math, ams, rel, "\u2ACB", "\\subsetneqq", true);
      defineSymbol(math, ams, rel, "\uE017", "\\@varsubsetneqq");
      defineSymbol(math, ams, rel, "\u226F", "\\ngtr", true);
      defineSymbol(math, ams, rel, "\uE00F", "\\@ngeqslant");
      defineSymbol(math, ams, rel, "\uE00E", "\\@ngeqq");
      defineSymbol(math, ams, rel, "\u2A88", "\\gneq", true);
      defineSymbol(math, ams, rel, "\u2269", "\\gneqq", true);
      defineSymbol(math, ams, rel, "\uE00D", "\\@gvertneqq");
      defineSymbol(math, ams, rel, "\u22E7", "\\gnsim", true);
      defineSymbol(math, ams, rel, "\u2A8A", "\\gnapprox", true);
      defineSymbol(math, ams, rel, "\u2281", "\\nsucc", true);
      defineSymbol(math, ams, rel, "\u22E1", "\\nsucceq", true);
      defineSymbol(math, ams, rel, "\u22E9", "\\succnsim", true);
      defineSymbol(math, ams, rel, "\u2ABA", "\\succnapprox", true);
      defineSymbol(math, ams, rel, "\u2246", "\\ncong", true);
      defineSymbol(math, ams, rel, "\uE007", "\\@nshortparallel");
      defineSymbol(math, ams, rel, "\u2226", "\\nparallel", true);
      defineSymbol(math, ams, rel, "\u22AF", "\\nVDash", true);
      defineSymbol(math, ams, rel, "\u22EB", "\\ntriangleright");
      defineSymbol(math, ams, rel, "\u22ED", "\\ntrianglerighteq", true);
      defineSymbol(math, ams, rel, "\uE018", "\\@nsupseteqq");
      defineSymbol(math, ams, rel, "\u228B", "\\supsetneq", true);
      defineSymbol(math, ams, rel, "\uE01B", "\\@varsupsetneq");
      defineSymbol(math, ams, rel, "\u2ACC", "\\supsetneqq", true);
      defineSymbol(math, ams, rel, "\uE019", "\\@varsupsetneqq");
      defineSymbol(math, ams, rel, "\u22AE", "\\nVdash", true);
      defineSymbol(math, ams, rel, "\u2AB5", "\\precneqq", true);
      defineSymbol(math, ams, rel, "\u2AB6", "\\succneqq", true);
      defineSymbol(math, ams, rel, "\uE016", "\\@nsubseteqq");
      defineSymbol(math, ams, bin, "\u22B4", "\\unlhd");
      defineSymbol(math, ams, bin, "\u22B5", "\\unrhd");
      defineSymbol(math, ams, rel, "\u219A", "\\nleftarrow", true);
      defineSymbol(math, ams, rel, "\u219B", "\\nrightarrow", true);
      defineSymbol(math, ams, rel, "\u21CD", "\\nLeftarrow", true);
      defineSymbol(math, ams, rel, "\u21CF", "\\nRightarrow", true);
      defineSymbol(math, ams, rel, "\u21AE", "\\nleftrightarrow", true);
      defineSymbol(math, ams, rel, "\u21CE", "\\nLeftrightarrow", true);
      defineSymbol(math, ams, rel, "\u25B3", "\\vartriangle");
      defineSymbol(math, ams, textord, "\u210F", "\\hslash");
      defineSymbol(math, ams, textord, "\u25BD", "\\triangledown");
      defineSymbol(math, ams, textord, "\u25CA", "\\lozenge");
      defineSymbol(math, ams, textord, "\u24C8", "\\circledS");
      defineSymbol(math, ams, textord, "\xAE", "\\circledR");
      defineSymbol(text, ams, textord, "\xAE", "\\circledR");
      defineSymbol(math, ams, textord, "\u2221", "\\measuredangle", true);
      defineSymbol(math, ams, textord, "\u2204", "\\nexists");
      defineSymbol(math, ams, textord, "\u2127", "\\mho");
      defineSymbol(math, ams, textord, "\u2132", "\\Finv", true);
      defineSymbol(math, ams, textord, "\u2141", "\\Game", true);
      defineSymbol(math, ams, textord, "\u2035", "\\backprime");
      defineSymbol(math, ams, textord, "\u25B2", "\\blacktriangle");
      defineSymbol(math, ams, textord, "\u25BC", "\\blacktriangledown");
      defineSymbol(math, ams, textord, "\u25A0", "\\blacksquare");
      defineSymbol(math, ams, textord, "\u29EB", "\\blacklozenge");
      defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
      defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle", true);
      defineSymbol(math, ams, textord, "\u2201", "\\complement", true);
      defineSymbol(math, ams, textord, "\xF0", "\\eth", true);
      defineSymbol(text, main, textord, "\xF0", "\xF0");
      defineSymbol(math, ams, textord, "\u2571", "\\diagup");
      defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
      defineSymbol(math, ams, textord, "\u25A1", "\\square");
      defineSymbol(math, ams, textord, "\u25A1", "\\Box");
      defineSymbol(math, ams, textord, "\u25CA", "\\Diamond");
      defineSymbol(math, ams, textord, "\xA5", "\\yen", true);
      defineSymbol(text, ams, textord, "\xA5", "\\yen", true);
      defineSymbol(math, ams, textord, "\u2713", "\\checkmark", true);
      defineSymbol(text, ams, textord, "\u2713", "\\checkmark");
      defineSymbol(math, ams, textord, "\u2136", "\\beth", true);
      defineSymbol(math, ams, textord, "\u2138", "\\daleth", true);
      defineSymbol(math, ams, textord, "\u2137", "\\gimel", true);
      defineSymbol(math, ams, textord, "\u03DD", "\\digamma", true);
      defineSymbol(math, ams, textord, "\u03F0", "\\varkappa");
      defineSymbol(math, ams, open, "\u250C", "\\@ulcorner", true);
      defineSymbol(math, ams, close, "\u2510", "\\@urcorner", true);
      defineSymbol(math, ams, open, "\u2514", "\\@llcorner", true);
      defineSymbol(math, ams, close, "\u2518", "\\@lrcorner", true);
      defineSymbol(math, ams, rel, "\u2266", "\\leqq", true);
      defineSymbol(math, ams, rel, "\u2A7D", "\\leqslant", true);
      defineSymbol(math, ams, rel, "\u2A95", "\\eqslantless", true);
      defineSymbol(math, ams, rel, "\u2272", "\\lesssim", true);
      defineSymbol(math, ams, rel, "\u2A85", "\\lessapprox", true);
      defineSymbol(math, ams, rel, "\u224A", "\\approxeq", true);
      defineSymbol(math, ams, bin, "\u22D6", "\\lessdot");
      defineSymbol(math, ams, rel, "\u22D8", "\\lll", true);
      defineSymbol(math, ams, rel, "\u2276", "\\lessgtr", true);
      defineSymbol(math, ams, rel, "\u22DA", "\\lesseqgtr", true);
      defineSymbol(math, ams, rel, "\u2A8B", "\\lesseqqgtr", true);
      defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
      defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq", true);
      defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq", true);
      defineSymbol(math, ams, rel, "\u223D", "\\backsim", true);
      defineSymbol(math, ams, rel, "\u22CD", "\\backsimeq", true);
      defineSymbol(math, ams, rel, "\u2AC5", "\\subseteqq", true);
      defineSymbol(math, ams, rel, "\u22D0", "\\Subset", true);
      defineSymbol(math, ams, rel, "\u228F", "\\sqsubset", true);
      defineSymbol(math, ams, rel, "\u227C", "\\preccurlyeq", true);
      defineSymbol(math, ams, rel, "\u22DE", "\\curlyeqprec", true);
      defineSymbol(math, ams, rel, "\u227E", "\\precsim", true);
      defineSymbol(math, ams, rel, "\u2AB7", "\\precapprox", true);
      defineSymbol(math, ams, rel, "\u22B2", "\\vartriangleleft");
      defineSymbol(math, ams, rel, "\u22B4", "\\trianglelefteq");
      defineSymbol(math, ams, rel, "\u22A8", "\\vDash", true);
      defineSymbol(math, ams, rel, "\u22AA", "\\Vvdash", true);
      defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
      defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
      defineSymbol(math, ams, rel, "\u224F", "\\bumpeq", true);
      defineSymbol(math, ams, rel, "\u224E", "\\Bumpeq", true);
      defineSymbol(math, ams, rel, "\u2267", "\\geqq", true);
      defineSymbol(math, ams, rel, "\u2A7E", "\\geqslant", true);
      defineSymbol(math, ams, rel, "\u2A96", "\\eqslantgtr", true);
      defineSymbol(math, ams, rel, "\u2273", "\\gtrsim", true);
      defineSymbol(math, ams, rel, "\u2A86", "\\gtrapprox", true);
      defineSymbol(math, ams, bin, "\u22D7", "\\gtrdot");
      defineSymbol(math, ams, rel, "\u22D9", "\\ggg", true);
      defineSymbol(math, ams, rel, "\u2277", "\\gtrless", true);
      defineSymbol(math, ams, rel, "\u22DB", "\\gtreqless", true);
      defineSymbol(math, ams, rel, "\u2A8C", "\\gtreqqless", true);
      defineSymbol(math, ams, rel, "\u2256", "\\eqcirc", true);
      defineSymbol(math, ams, rel, "\u2257", "\\circeq", true);
      defineSymbol(math, ams, rel, "\u225C", "\\triangleq", true);
      defineSymbol(math, ams, rel, "\u223C", "\\thicksim");
      defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
      defineSymbol(math, ams, rel, "\u2AC6", "\\supseteqq", true);
      defineSymbol(math, ams, rel, "\u22D1", "\\Supset", true);
      defineSymbol(math, ams, rel, "\u2290", "\\sqsupset", true);
      defineSymbol(math, ams, rel, "\u227D", "\\succcurlyeq", true);
      defineSymbol(math, ams, rel, "\u22DF", "\\curlyeqsucc", true);
      defineSymbol(math, ams, rel, "\u227F", "\\succsim", true);
      defineSymbol(math, ams, rel, "\u2AB8", "\\succapprox", true);
      defineSymbol(math, ams, rel, "\u22B3", "\\vartriangleright");
      defineSymbol(math, ams, rel, "\u22B5", "\\trianglerighteq");
      defineSymbol(math, ams, rel, "\u22A9", "\\Vdash", true);
      defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
      defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
      defineSymbol(math, ams, rel, "\u226C", "\\between", true);
      defineSymbol(math, ams, rel, "\u22D4", "\\pitchfork", true);
      defineSymbol(math, ams, rel, "\u221D", "\\varpropto");
      defineSymbol(math, ams, rel, "\u25C0", "\\blacktriangleleft");
      defineSymbol(math, ams, rel, "\u2234", "\\therefore", true);
      defineSymbol(math, ams, rel, "\u220D", "\\backepsilon");
      defineSymbol(math, ams, rel, "\u25B6", "\\blacktriangleright");
      defineSymbol(math, ams, rel, "\u2235", "\\because", true);
      defineSymbol(math, ams, rel, "\u22D8", "\\llless");
      defineSymbol(math, ams, rel, "\u22D9", "\\gggtr");
      defineSymbol(math, ams, bin, "\u22B2", "\\lhd");
      defineSymbol(math, ams, bin, "\u22B3", "\\rhd");
      defineSymbol(math, ams, rel, "\u2242", "\\eqsim", true);
      defineSymbol(math, main, rel, "\u22C8", "\\Join");
      defineSymbol(math, ams, rel, "\u2251", "\\Doteq", true);
      defineSymbol(math, ams, bin, "\u2214", "\\dotplus", true);
      defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
      defineSymbol(math, ams, bin, "\u22D2", "\\Cap", true);
      defineSymbol(math, ams, bin, "\u22D3", "\\Cup", true);
      defineSymbol(math, ams, bin, "\u2A5E", "\\doublebarwedge", true);
      defineSymbol(math, ams, bin, "\u229F", "\\boxminus", true);
      defineSymbol(math, ams, bin, "\u229E", "\\boxplus", true);
      defineSymbol(math, ams, bin, "\u22C7", "\\divideontimes", true);
      defineSymbol(math, ams, bin, "\u22C9", "\\ltimes", true);
      defineSymbol(math, ams, bin, "\u22CA", "\\rtimes", true);
      defineSymbol(math, ams, bin, "\u22CB", "\\leftthreetimes", true);
      defineSymbol(math, ams, bin, "\u22CC", "\\rightthreetimes", true);
      defineSymbol(math, ams, bin, "\u22CF", "\\curlywedge", true);
      defineSymbol(math, ams, bin, "\u22CE", "\\curlyvee", true);
      defineSymbol(math, ams, bin, "\u229D", "\\circleddash", true);
      defineSymbol(math, ams, bin, "\u229B", "\\circledast", true);
      defineSymbol(math, ams, bin, "\u22C5", "\\centerdot");
      defineSymbol(math, ams, bin, "\u22BA", "\\intercal", true);
      defineSymbol(math, ams, bin, "\u22D2", "\\doublecap");
      defineSymbol(math, ams, bin, "\u22D3", "\\doublecup");
      defineSymbol(math, ams, bin, "\u22A0", "\\boxtimes", true);
      defineSymbol(math, ams, rel, "\u21E2", "\\dashrightarrow", true);
      defineSymbol(math, ams, rel, "\u21E0", "\\dashleftarrow", true);
      defineSymbol(math, ams, rel, "\u21C7", "\\leftleftarrows", true);
      defineSymbol(math, ams, rel, "\u21C6", "\\leftrightarrows", true);
      defineSymbol(math, ams, rel, "\u21DA", "\\Lleftarrow", true);
      defineSymbol(math, ams, rel, "\u219E", "\\twoheadleftarrow", true);
      defineSymbol(math, ams, rel, "\u21A2", "\\leftarrowtail", true);
      defineSymbol(math, ams, rel, "\u21AB", "\\looparrowleft", true);
      defineSymbol(math, ams, rel, "\u21CB", "\\leftrightharpoons", true);
      defineSymbol(math, ams, rel, "\u21B6", "\\curvearrowleft", true);
      defineSymbol(math, ams, rel, "\u21BA", "\\circlearrowleft", true);
      defineSymbol(math, ams, rel, "\u21B0", "\\Lsh", true);
      defineSymbol(math, ams, rel, "\u21C8", "\\upuparrows", true);
      defineSymbol(math, ams, rel, "\u21BF", "\\upharpoonleft", true);
      defineSymbol(math, ams, rel, "\u21C3", "\\downharpoonleft", true);
      defineSymbol(math, main, rel, "\u22B6", "\\origof", true);
      defineSymbol(math, main, rel, "\u22B7", "\\imageof", true);
      defineSymbol(math, ams, rel, "\u22B8", "\\multimap", true);
      defineSymbol(math, ams, rel, "\u21AD", "\\leftrightsquigarrow", true);
      defineSymbol(math, ams, rel, "\u21C9", "\\rightrightarrows", true);
      defineSymbol(math, ams, rel, "\u21C4", "\\rightleftarrows", true);
      defineSymbol(math, ams, rel, "\u21A0", "\\twoheadrightarrow", true);
      defineSymbol(math, ams, rel, "\u21A3", "\\rightarrowtail", true);
      defineSymbol(math, ams, rel, "\u21AC", "\\looparrowright", true);
      defineSymbol(math, ams, rel, "\u21B7", "\\curvearrowright", true);
      defineSymbol(math, ams, rel, "\u21BB", "\\circlearrowright", true);
      defineSymbol(math, ams, rel, "\u21B1", "\\Rsh", true);
      defineSymbol(math, ams, rel, "\u21CA", "\\downdownarrows", true);
      defineSymbol(math, ams, rel, "\u21BE", "\\upharpoonright", true);
      defineSymbol(math, ams, rel, "\u21C2", "\\downharpoonright", true);
      defineSymbol(math, ams, rel, "\u21DD", "\\rightsquigarrow", true);
      defineSymbol(math, ams, rel, "\u21DD", "\\leadsto");
      defineSymbol(math, ams, rel, "\u21DB", "\\Rrightarrow", true);
      defineSymbol(math, ams, rel, "\u21BE", "\\restriction");
      defineSymbol(math, main, textord, "\u2018", "`");
      defineSymbol(math, main, textord, "$", "\\$");
      defineSymbol(text, main, textord, "$", "\\$");
      defineSymbol(text, main, textord, "$", "\\textdollar");
      defineSymbol(math, main, textord, "%", "\\%");
      defineSymbol(text, main, textord, "%", "\\%");
      defineSymbol(math, main, textord, "_", "\\_");
      defineSymbol(text, main, textord, "_", "\\_");
      defineSymbol(text, main, textord, "_", "\\textunderscore");
      defineSymbol(math, main, textord, "\u2220", "\\angle", true);
      defineSymbol(math, main, textord, "\u221E", "\\infty", true);
      defineSymbol(math, main, textord, "\u2032", "\\prime");
      defineSymbol(math, main, textord, "\u25B3", "\\triangle");
      defineSymbol(math, main, textord, "\u0393", "\\Gamma", true);
      defineSymbol(math, main, textord, "\u0394", "\\Delta", true);
      defineSymbol(math, main, textord, "\u0398", "\\Theta", true);
      defineSymbol(math, main, textord, "\u039B", "\\Lambda", true);
      defineSymbol(math, main, textord, "\u039E", "\\Xi", true);
      defineSymbol(math, main, textord, "\u03A0", "\\Pi", true);
      defineSymbol(math, main, textord, "\u03A3", "\\Sigma", true);
      defineSymbol(math, main, textord, "\u03A5", "\\Upsilon", true);
      defineSymbol(math, main, textord, "\u03A6", "\\Phi", true);
      defineSymbol(math, main, textord, "\u03A8", "\\Psi", true);
      defineSymbol(math, main, textord, "\u03A9", "\\Omega", true);
      defineSymbol(math, main, textord, "A", "\u0391");
      defineSymbol(math, main, textord, "B", "\u0392");
      defineSymbol(math, main, textord, "E", "\u0395");
      defineSymbol(math, main, textord, "Z", "\u0396");
      defineSymbol(math, main, textord, "H", "\u0397");
      defineSymbol(math, main, textord, "I", "\u0399");
      defineSymbol(math, main, textord, "K", "\u039A");
      defineSymbol(math, main, textord, "M", "\u039C");
      defineSymbol(math, main, textord, "N", "\u039D");
      defineSymbol(math, main, textord, "O", "\u039F");
      defineSymbol(math, main, textord, "P", "\u03A1");
      defineSymbol(math, main, textord, "T", "\u03A4");
      defineSymbol(math, main, textord, "X", "\u03A7");
      defineSymbol(math, main, textord, "\xAC", "\\neg", true);
      defineSymbol(math, main, textord, "\xAC", "\\lnot");
      defineSymbol(math, main, textord, "\u22A4", "\\top");
      defineSymbol(math, main, textord, "\u22A5", "\\bot");
      defineSymbol(math, main, textord, "\u2205", "\\emptyset");
      defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
      defineSymbol(math, main, mathord, "\u03B1", "\\alpha", true);
      defineSymbol(math, main, mathord, "\u03B2", "\\beta", true);
      defineSymbol(math, main, mathord, "\u03B3", "\\gamma", true);
      defineSymbol(math, main, mathord, "\u03B4", "\\delta", true);
      defineSymbol(math, main, mathord, "\u03F5", "\\epsilon", true);
      defineSymbol(math, main, mathord, "\u03B6", "\\zeta", true);
      defineSymbol(math, main, mathord, "\u03B7", "\\eta", true);
      defineSymbol(math, main, mathord, "\u03B8", "\\theta", true);
      defineSymbol(math, main, mathord, "\u03B9", "\\iota", true);
      defineSymbol(math, main, mathord, "\u03BA", "\\kappa", true);
      defineSymbol(math, main, mathord, "\u03BB", "\\lambda", true);
      defineSymbol(math, main, mathord, "\u03BC", "\\mu", true);
      defineSymbol(math, main, mathord, "\u03BD", "\\nu", true);
      defineSymbol(math, main, mathord, "\u03BE", "\\xi", true);
      defineSymbol(math, main, mathord, "\u03BF", "\\omicron", true);
      defineSymbol(math, main, mathord, "\u03C0", "\\pi", true);
      defineSymbol(math, main, mathord, "\u03C1", "\\rho", true);
      defineSymbol(math, main, mathord, "\u03C3", "\\sigma", true);
      defineSymbol(math, main, mathord, "\u03C4", "\\tau", true);
      defineSymbol(math, main, mathord, "\u03C5", "\\upsilon", true);
      defineSymbol(math, main, mathord, "\u03D5", "\\phi", true);
      defineSymbol(math, main, mathord, "\u03C7", "\\chi", true);
      defineSymbol(math, main, mathord, "\u03C8", "\\psi", true);
      defineSymbol(math, main, mathord, "\u03C9", "\\omega", true);
      defineSymbol(math, main, mathord, "\u03B5", "\\varepsilon", true);
      defineSymbol(math, main, mathord, "\u03D1", "\\vartheta", true);
      defineSymbol(math, main, mathord, "\u03D6", "\\varpi", true);
      defineSymbol(math, main, mathord, "\u03F1", "\\varrho", true);
      defineSymbol(math, main, mathord, "\u03C2", "\\varsigma", true);
      defineSymbol(math, main, mathord, "\u03C6", "\\varphi", true);
      defineSymbol(math, main, bin, "\u2217", "*", true);
      defineSymbol(math, main, bin, "+", "+");
      defineSymbol(math, main, bin, "\u2212", "-", true);
      defineSymbol(math, main, bin, "\u22C5", "\\cdot", true);
      defineSymbol(math, main, bin, "\u2218", "\\circ", true);
      defineSymbol(math, main, bin, "\xF7", "\\div", true);
      defineSymbol(math, main, bin, "\xB1", "\\pm", true);
      defineSymbol(math, main, bin, "\xD7", "\\times", true);
      defineSymbol(math, main, bin, "\u2229", "\\cap", true);
      defineSymbol(math, main, bin, "\u222A", "\\cup", true);
      defineSymbol(math, main, bin, "\u2216", "\\setminus", true);
      defineSymbol(math, main, bin, "\u2227", "\\land");
      defineSymbol(math, main, bin, "\u2228", "\\lor");
      defineSymbol(math, main, bin, "\u2227", "\\wedge", true);
      defineSymbol(math, main, bin, "\u2228", "\\vee", true);
      defineSymbol(math, main, textord, "\u221A", "\\surd");
      defineSymbol(math, main, open, "\u27E8", "\\langle", true);
      defineSymbol(math, main, open, "\u2223", "\\lvert");
      defineSymbol(math, main, open, "\u2225", "\\lVert");
      defineSymbol(math, main, close, "?", "?");
      defineSymbol(math, main, close, "!", "!");
      defineSymbol(math, main, close, "\u27E9", "\\rangle", true);
      defineSymbol(math, main, close, "\u2223", "\\rvert");
      defineSymbol(math, main, close, "\u2225", "\\rVert");
      defineSymbol(math, main, rel, "=", "=");
      defineSymbol(math, main, rel, ":", ":");
      defineSymbol(math, main, rel, "\u2248", "\\approx", true);
      defineSymbol(math, main, rel, "\u2245", "\\cong", true);
      defineSymbol(math, main, rel, "\u2265", "\\ge");
      defineSymbol(math, main, rel, "\u2265", "\\geq", true);
      defineSymbol(math, main, rel, "\u2190", "\\gets");
      defineSymbol(math, main, rel, ">", "\\gt", true);
      defineSymbol(math, main, rel, "\u2208", "\\in", true);
      defineSymbol(math, main, rel, "\uE020", "\\@not");
      defineSymbol(math, main, rel, "\u2282", "\\subset", true);
      defineSymbol(math, main, rel, "\u2283", "\\supset", true);
      defineSymbol(math, main, rel, "\u2286", "\\subseteq", true);
      defineSymbol(math, main, rel, "\u2287", "\\supseteq", true);
      defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq", true);
      defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq", true);
      defineSymbol(math, main, rel, "\u22A8", "\\models");
      defineSymbol(math, main, rel, "\u2190", "\\leftarrow", true);
      defineSymbol(math, main, rel, "\u2264", "\\le");
      defineSymbol(math, main, rel, "\u2264", "\\leq", true);
      defineSymbol(math, main, rel, "<", "\\lt", true);
      defineSymbol(math, main, rel, "\u2192", "\\rightarrow", true);
      defineSymbol(math, main, rel, "\u2192", "\\to");
      defineSymbol(math, ams, rel, "\u2271", "\\ngeq", true);
      defineSymbol(math, ams, rel, "\u2270", "\\nleq", true);
      defineSymbol(math, main, spacing, "\xA0", "\\ ");
      defineSymbol(math, main, spacing, "\xA0", "\\space");
      defineSymbol(math, main, spacing, "\xA0", "\\nobreakspace");
      defineSymbol(text, main, spacing, "\xA0", "\\ ");
      defineSymbol(text, main, spacing, "\xA0", " ");
      defineSymbol(text, main, spacing, "\xA0", "\\space");
      defineSymbol(text, main, spacing, "\xA0", "\\nobreakspace");
      defineSymbol(math, main, spacing, null, "\\nobreak");
      defineSymbol(math, main, spacing, null, "\\allowbreak");
      defineSymbol(math, main, punct, ",", ",");
      defineSymbol(math, main, punct, ";", ";");
      defineSymbol(math, ams, bin, "\u22BC", "\\barwedge", true);
      defineSymbol(math, ams, bin, "\u22BB", "\\veebar", true);
      defineSymbol(math, main, bin, "\u2299", "\\odot", true);
      defineSymbol(math, main, bin, "\u2295", "\\oplus", true);
      defineSymbol(math, main, bin, "\u2297", "\\otimes", true);
      defineSymbol(math, main, textord, "\u2202", "\\partial", true);
      defineSymbol(math, main, bin, "\u2298", "\\oslash", true);
      defineSymbol(math, ams, bin, "\u229A", "\\circledcirc", true);
      defineSymbol(math, ams, bin, "\u22A1", "\\boxdot", true);
      defineSymbol(math, main, bin, "\u25B3", "\\bigtriangleup");
      defineSymbol(math, main, bin, "\u25BD", "\\bigtriangledown");
      defineSymbol(math, main, bin, "\u2020", "\\dagger");
      defineSymbol(math, main, bin, "\u22C4", "\\diamond");
      defineSymbol(math, main, bin, "\u22C6", "\\star");
      defineSymbol(math, main, bin, "\u25C3", "\\triangleleft");
      defineSymbol(math, main, bin, "\u25B9", "\\triangleright");
      defineSymbol(math, main, open, "{", "\\{");
      defineSymbol(text, main, textord, "{", "\\{");
      defineSymbol(text, main, textord, "{", "\\textbraceleft");
      defineSymbol(math, main, close, "}", "\\}");
      defineSymbol(text, main, textord, "}", "\\}");
      defineSymbol(text, main, textord, "}", "\\textbraceright");
      defineSymbol(math, main, open, "{", "\\lbrace");
      defineSymbol(math, main, close, "}", "\\rbrace");
      defineSymbol(math, main, open, "[", "\\lbrack", true);
      defineSymbol(text, main, textord, "[", "\\lbrack", true);
      defineSymbol(math, main, close, "]", "\\rbrack", true);
      defineSymbol(text, main, textord, "]", "\\rbrack", true);
      defineSymbol(math, main, open, "(", "\\lparen", true);
      defineSymbol(math, main, close, ")", "\\rparen", true);
      defineSymbol(text, main, textord, "<", "\\textless", true);
      defineSymbol(text, main, textord, ">", "\\textgreater", true);
      defineSymbol(math, main, open, "\u230A", "\\lfloor", true);
      defineSymbol(math, main, close, "\u230B", "\\rfloor", true);
      defineSymbol(math, main, open, "\u2308", "\\lceil", true);
      defineSymbol(math, main, close, "\u2309", "\\rceil", true);
      defineSymbol(math, main, textord, "\\", "\\backslash");
      defineSymbol(math, main, textord, "\u2223", "|");
      defineSymbol(math, main, textord, "\u2223", "\\vert");
      defineSymbol(text, main, textord, "|", "\\textbar", true);
      defineSymbol(math, main, textord, "\u2225", "\\|");
      defineSymbol(math, main, textord, "\u2225", "\\Vert");
      defineSymbol(text, main, textord, "\u2225", "\\textbardbl");
      defineSymbol(text, main, textord, "~", "\\textasciitilde");
      defineSymbol(text, main, textord, "\\", "\\textbackslash");
      defineSymbol(text, main, textord, "^", "\\textasciicircum");
      defineSymbol(math, main, rel, "\u2191", "\\uparrow", true);
      defineSymbol(math, main, rel, "\u21D1", "\\Uparrow", true);
      defineSymbol(math, main, rel, "\u2193", "\\downarrow", true);
      defineSymbol(math, main, rel, "\u21D3", "\\Downarrow", true);
      defineSymbol(math, main, rel, "\u2195", "\\updownarrow", true);
      defineSymbol(math, main, rel, "\u21D5", "\\Updownarrow", true);
      defineSymbol(math, main, op, "\u2210", "\\coprod");
      defineSymbol(math, main, op, "\u22C1", "\\bigvee");
      defineSymbol(math, main, op, "\u22C0", "\\bigwedge");
      defineSymbol(math, main, op, "\u2A04", "\\biguplus");
      defineSymbol(math, main, op, "\u22C2", "\\bigcap");
      defineSymbol(math, main, op, "\u22C3", "\\bigcup");
      defineSymbol(math, main, op, "\u222B", "\\int");
      defineSymbol(math, main, op, "\u222B", "\\intop");
      defineSymbol(math, main, op, "\u222C", "\\iint");
      defineSymbol(math, main, op, "\u222D", "\\iiint");
      defineSymbol(math, main, op, "\u220F", "\\prod");
      defineSymbol(math, main, op, "\u2211", "\\sum");
      defineSymbol(math, main, op, "\u2A02", "\\bigotimes");
      defineSymbol(math, main, op, "\u2A01", "\\bigoplus");
      defineSymbol(math, main, op, "\u2A00", "\\bigodot");
      defineSymbol(math, main, op, "\u222E", "\\oint");
      defineSymbol(math, main, op, "\u222F", "\\oiint");
      defineSymbol(math, main, op, "\u2230", "\\oiiint");
      defineSymbol(math, main, op, "\u2A06", "\\bigsqcup");
      defineSymbol(math, main, op, "\u222B", "\\smallint");
      defineSymbol(text, main, inner, "\u2026", "\\textellipsis");
      defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
      defineSymbol(text, main, inner, "\u2026", "\\ldots", true);
      defineSymbol(math, main, inner, "\u2026", "\\ldots", true);
      defineSymbol(math, main, inner, "\u22EF", "\\@cdots", true);
      defineSymbol(math, main, inner, "\u22F1", "\\ddots", true);
      defineSymbol(math, main, textord, "\u22EE", "\\varvdots");
      defineSymbol(text, main, textord, "\u22EE", "\\varvdots");
      defineSymbol(math, main, accent, "\u02CA", "\\acute");
      defineSymbol(math, main, accent, "\u02CB", "\\grave");
      defineSymbol(math, main, accent, "\xA8", "\\ddot");
      defineSymbol(math, main, accent, "~", "\\tilde");
      defineSymbol(math, main, accent, "\u02C9", "\\bar");
      defineSymbol(math, main, accent, "\u02D8", "\\breve");
      defineSymbol(math, main, accent, "\u02C7", "\\check");
      defineSymbol(math, main, accent, "^", "\\hat");
      defineSymbol(math, main, accent, "\u20D7", "\\vec");
      defineSymbol(math, main, accent, "\u02D9", "\\dot");
      defineSymbol(math, main, accent, "\u02DA", "\\mathring");
      defineSymbol(math, main, mathord, "\uE131", "\\@imath");
      defineSymbol(math, main, mathord, "\uE237", "\\@jmath");
      defineSymbol(math, main, textord, "\u0131", "\u0131");
      defineSymbol(math, main, textord, "\u0237", "\u0237");
      defineSymbol(text, main, textord, "\u0131", "\\i", true);
      defineSymbol(text, main, textord, "\u0237", "\\j", true);
      defineSymbol(text, main, textord, "\xDF", "\\ss", true);
      defineSymbol(text, main, textord, "\xE6", "\\ae", true);
      defineSymbol(text, main, textord, "\u0153", "\\oe", true);
      defineSymbol(text, main, textord, "\xF8", "\\o", true);
      defineSymbol(text, main, textord, "\xC6", "\\AE", true);
      defineSymbol(text, main, textord, "\u0152", "\\OE", true);
      defineSymbol(text, main, textord, "\xD8", "\\O", true);
      defineSymbol(text, main, accent, "\u02CA", "\\'");
      defineSymbol(text, main, accent, "\u02CB", "\\`");
      defineSymbol(text, main, accent, "\u02C6", "\\^");
      defineSymbol(text, main, accent, "\u02DC", "\\~");
      defineSymbol(text, main, accent, "\u02C9", "\\=");
      defineSymbol(text, main, accent, "\u02D8", "\\u");
      defineSymbol(text, main, accent, "\u02D9", "\\.");
      defineSymbol(text, main, accent, "\xB8", "\\c");
      defineSymbol(text, main, accent, "\u02DA", "\\r");
      defineSymbol(text, main, accent, "\u02C7", "\\v");
      defineSymbol(text, main, accent, "\xA8", '\\"');
      defineSymbol(text, main, accent, "\u02DD", "\\H");
      defineSymbol(text, main, accent, "\u25EF", "\\textcircled");
      ligatures = {
        "--": true,
        "---": true,
        "``": true,
        "''": true
      };
      defineSymbol(text, main, textord, "\u2013", "--", true);
      defineSymbol(text, main, textord, "\u2013", "\\textendash");
      defineSymbol(text, main, textord, "\u2014", "---", true);
      defineSymbol(text, main, textord, "\u2014", "\\textemdash");
      defineSymbol(text, main, textord, "\u2018", "`", true);
      defineSymbol(text, main, textord, "\u2018", "\\textquoteleft");
      defineSymbol(text, main, textord, "\u2019", "'", true);
      defineSymbol(text, main, textord, "\u2019", "\\textquoteright");
      defineSymbol(text, main, textord, "\u201C", "``", true);
      defineSymbol(text, main, textord, "\u201C", "\\textquotedblleft");
      defineSymbol(text, main, textord, "\u201D", "''", true);
      defineSymbol(text, main, textord, "\u201D", "\\textquotedblright");
      defineSymbol(math, main, textord, "\xB0", "\\degree", true);
      defineSymbol(text, main, textord, "\xB0", "\\degree");
      defineSymbol(text, main, textord, "\xB0", "\\textdegree", true);
      defineSymbol(math, main, textord, "\xA3", "\\pounds");
      defineSymbol(math, main, textord, "\xA3", "\\mathsterling", true);
      defineSymbol(text, main, textord, "\xA3", "\\pounds");
      defineSymbol(text, main, textord, "\xA3", "\\textsterling", true);
      defineSymbol(math, ams, textord, "\u2720", "\\maltese");
      defineSymbol(text, ams, textord, "\u2720", "\\maltese");
      mathTextSymbols = '0123456789/@."';
      for (i = 0; i < mathTextSymbols.length; i++) {
        ch = mathTextSymbols.charAt(i);
        defineSymbol(math, main, textord, ch, ch);
      }
      textSymbols = '0123456789!@*()-=+";:?/.,';
      for (_i = 0; _i < textSymbols.length; _i++) {
        _ch = textSymbols.charAt(_i);
        defineSymbol(text, main, textord, _ch, _ch);
      }
      letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
      for (_i2 = 0; _i2 < letters.length; _i2++) {
        _ch2 = letters.charAt(_i2);
        defineSymbol(math, main, mathord, _ch2, _ch2);
        defineSymbol(text, main, textord, _ch2, _ch2);
      }
      defineSymbol(math, ams, textord, "C", "\u2102");
      defineSymbol(text, ams, textord, "C", "\u2102");
      defineSymbol(math, ams, textord, "H", "\u210D");
      defineSymbol(text, ams, textord, "H", "\u210D");
      defineSymbol(math, ams, textord, "N", "\u2115");
      defineSymbol(text, ams, textord, "N", "\u2115");
      defineSymbol(math, ams, textord, "P", "\u2119");
      defineSymbol(text, ams, textord, "P", "\u2119");
      defineSymbol(math, ams, textord, "Q", "\u211A");
      defineSymbol(text, ams, textord, "Q", "\u211A");
      defineSymbol(math, ams, textord, "R", "\u211D");
      defineSymbol(text, ams, textord, "R", "\u211D");
      defineSymbol(math, ams, textord, "Z", "\u2124");
      defineSymbol(text, ams, textord, "Z", "\u2124");
      defineSymbol(math, main, mathord, "h", "\u210E");
      defineSymbol(text, main, mathord, "h", "\u210E");
      wideChar = "";
      for (_i3 = 0; _i3 < letters.length; _i3++) {
        _ch3 = letters.charAt(_i3);
        wideChar = String.fromCharCode(55349, 56320 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56372 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56424 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56580 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56684 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56736 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56788 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56840 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text, main, textord, _ch3, wideChar);
        wideChar = String.fromCharCode(55349, 56944 + _i3);
        defineSymbol(math, main, mathord, _ch3, wideChar);
        defineSymbol(text, main, textord, _ch3, wideChar);
        if (_i3 < 26) {
          wideChar = String.fromCharCode(55349, 56632 + _i3);
          defineSymbol(math, main, mathord, _ch3, wideChar);
          defineSymbol(text, main, textord, _ch3, wideChar);
          wideChar = String.fromCharCode(55349, 56476 + _i3);
          defineSymbol(math, main, mathord, _ch3, wideChar);
          defineSymbol(text, main, textord, _ch3, wideChar);
        }
      }
      wideChar = String.fromCharCode(55349, 56668);
      defineSymbol(math, main, mathord, "k", wideChar);
      defineSymbol(text, main, textord, "k", wideChar);
      for (_i4 = 0; _i4 < 10; _i4++) {
        _ch4 = _i4.toString();
        wideChar = String.fromCharCode(55349, 57294 + _i4);
        defineSymbol(math, main, mathord, _ch4, wideChar);
        defineSymbol(text, main, textord, _ch4, wideChar);
        wideChar = String.fromCharCode(55349, 57314 + _i4);
        defineSymbol(math, main, mathord, _ch4, wideChar);
        defineSymbol(text, main, textord, _ch4, wideChar);
        wideChar = String.fromCharCode(55349, 57324 + _i4);
        defineSymbol(math, main, mathord, _ch4, wideChar);
        defineSymbol(text, main, textord, _ch4, wideChar);
        wideChar = String.fromCharCode(55349, 57334 + _i4);
        defineSymbol(math, main, mathord, _ch4, wideChar);
        defineSymbol(text, main, textord, _ch4, wideChar);
      }
      extraLatin = "\xD0\xDE\xFE";
      for (_i5 = 0; _i5 < extraLatin.length; _i5++) {
        _ch5 = extraLatin.charAt(_i5);
        defineSymbol(math, main, mathord, _ch5, _ch5);
        defineSymbol(text, main, textord, _ch5, _ch5);
      }
      wideLatinLetterData = [
        ["mathbf", "textbf", "Main-Bold"],
        // A-Z bold upright
        ["mathbf", "textbf", "Main-Bold"],
        // a-z bold upright
        ["mathnormal", "textit", "Math-Italic"],
        // A-Z italic
        ["mathnormal", "textit", "Math-Italic"],
        // a-z italic
        ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
        // A-Z bold italic
        ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
        // a-z bold italic
        // Map fancy A-Z letters to script, not calligraphic.
        // This aligns with unicode-math and math fonts (except Cambria Math).
        ["mathscr", "textscr", "Script-Regular"],
        // A-Z script
        ["", "", ""],
        // a-z script.  No font
        ["", "", ""],
        // A-Z bold script. No font
        ["", "", ""],
        // a-z bold script. No font
        ["mathfrak", "textfrak", "Fraktur-Regular"],
        // A-Z Fraktur
        ["mathfrak", "textfrak", "Fraktur-Regular"],
        // a-z Fraktur
        ["mathbb", "textbb", "AMS-Regular"],
        // A-Z double-struck
        ["mathbb", "textbb", "AMS-Regular"],
        // k double-struck
        // Note that we are using a bold font, but font metrics for regular Fraktur.
        ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
        // A-Z bold Fraktur
        ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
        // a-z bold Fraktur
        ["mathsf", "textsf", "SansSerif-Regular"],
        // A-Z sans-serif
        ["mathsf", "textsf", "SansSerif-Regular"],
        // a-z sans-serif
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        // A-Z bold sans-serif
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        // a-z bold sans-serif
        ["mathitsf", "textitsf", "SansSerif-Italic"],
        // A-Z italic sans-serif
        ["mathitsf", "textitsf", "SansSerif-Italic"],
        // a-z italic sans-serif
        ["", "", ""],
        // A-Z bold italic sans. No font
        ["", "", ""],
        // a-z bold italic sans. No font
        ["mathtt", "texttt", "Typewriter-Regular"],
        // A-Z monospace
        ["mathtt", "texttt", "Typewriter-Regular"]
        // a-z monospace
      ];
      wideNumeralData = [
        ["mathbf", "textbf", "Main-Bold"],
        // 0-9 bold
        ["", "", ""],
        // 0-9 double-struck. No KaTeX font.
        ["mathsf", "textsf", "SansSerif-Regular"],
        // 0-9 sans-serif
        ["mathboldsf", "textboldsf", "SansSerif-Bold"],
        // 0-9 bold sans-serif
        ["mathtt", "texttt", "Typewriter-Regular"]
        // 0-9 monospace
      ];
      wideCharacterFont = function wideCharacterFont2(wideChar2, mode) {
        var H = wideChar2.charCodeAt(0);
        var L = wideChar2.charCodeAt(1);
        var codePoint = (H - 55296) * 1024 + (L - 56320) + 65536;
        var j = mode === "math" ? 0 : 1;
        if (119808 <= codePoint && codePoint < 120484) {
          var i = Math.floor((codePoint - 119808) / 26);
          return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];
        } else if (120782 <= codePoint && codePoint <= 120831) {
          var _i = Math.floor((codePoint - 120782) / 10);
          return [wideNumeralData[_i][2], wideNumeralData[_i][j]];
        } else if (codePoint === 120485 || codePoint === 120486) {
          return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];
        } else if (120486 < codePoint && codePoint < 120782) {
          return ["", ""];
        } else {
          throw new ParseError("Unsupported character: " + wideChar2);
        }
      };
      lookupSymbol = function lookupSymbol2(value, fontName, mode) {
        if (symbols[mode][value] && symbols[mode][value].replace) {
          value = symbols[mode][value].replace;
        }
        return {
          value,
          metrics: getCharacterMetrics(value, fontName, mode)
        };
      };
      makeSymbol = function makeSymbol2(value, fontName, mode, options2, classes) {
        var lookup = lookupSymbol(value, fontName, mode);
        var metrics = lookup.metrics;
        value = lookup.value;
        var symbolNode;
        if (metrics) {
          var italic = metrics.italic;
          if (mode === "text" || options2 && options2.font === "mathit") {
            italic = 0;
          }
          symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
        } else {
          typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
          symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
        }
        if (options2) {
          symbolNode.maxFontSize = options2.sizeMultiplier;
          if (options2.style.isTight()) {
            symbolNode.classes.push("mtight");
          }
          var color = options2.getColor();
          if (color) {
            symbolNode.style.color = color;
          }
        }
        return symbolNode;
      };
      mathsym = function mathsym2(value, mode, options2, classes) {
        if (classes === void 0) {
          classes = [];
        }
        if (options2.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
          return makeSymbol(value, "Main-Bold", mode, options2, classes.concat(["mathbf"]));
        } else if (value === "\\" || symbols[mode][value].font === "main") {
          return makeSymbol(value, "Main-Regular", mode, options2, classes);
        } else {
          return makeSymbol(value, "AMS-Regular", mode, options2, classes.concat(["amsrm"]));
        }
      };
      boldsymbol = function boldsymbol2(value, mode, options2, classes, type) {
        if (type !== "textord" && lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
          return {
            fontName: "Math-BoldItalic",
            fontClass: "boldsymbol"
          };
        } else {
          return {
            fontName: "Main-Bold",
            fontClass: "mathbf"
          };
        }
      };
      makeOrd = function makeOrd2(group, options2, type) {
        var mode = group.mode;
        var text2 = group.text;
        var classes = ["mord"];
        var isFont = mode === "math" || mode === "text" && options2.font;
        var fontOrFamily = isFont ? options2.font : options2.fontFamily;
        var wideFontName = "";
        var wideFontClass = "";
        if (text2.charCodeAt(0) === 55349) {
          [wideFontName, wideFontClass] = wideCharacterFont(text2, mode);
        }
        if (wideFontName.length > 0) {
          return makeSymbol(text2, wideFontName, mode, options2, classes.concat(wideFontClass));
        } else if (fontOrFamily) {
          var fontName;
          var fontClasses;
          if (fontOrFamily === "boldsymbol") {
            var fontData = boldsymbol(text2, mode, options2, classes, type);
            fontName = fontData.fontName;
            fontClasses = [fontData.fontClass];
          } else if (isFont) {
            fontName = fontMap[fontOrFamily].fontName;
            fontClasses = [fontOrFamily];
          } else {
            fontName = retrieveTextFontName(fontOrFamily, options2.fontWeight, options2.fontShape);
            fontClasses = [fontOrFamily, options2.fontWeight, options2.fontShape];
          }
          if (lookupSymbol(text2, fontName, mode).metrics) {
            return makeSymbol(text2, fontName, mode, options2, classes.concat(fontClasses));
          } else if (ligatures.hasOwnProperty(text2) && fontName.slice(0, 10) === "Typewriter") {
            var parts = [];
            for (var i = 0; i < text2.length; i++) {
              parts.push(makeSymbol(text2[i], fontName, mode, options2, classes.concat(fontClasses)));
            }
            return makeFragment(parts);
          }
        }
        if (type === "mathord") {
          return makeSymbol(text2, "Math-Italic", mode, options2, classes.concat(["mathnormal"]));
        } else if (type === "textord") {
          var font = symbols[mode][text2] && symbols[mode][text2].font;
          if (font === "ams") {
            var _fontName = retrieveTextFontName("amsrm", options2.fontWeight, options2.fontShape);
            return makeSymbol(text2, _fontName, mode, options2, classes.concat("amsrm", options2.fontWeight, options2.fontShape));
          } else if (font === "main" || !font) {
            var _fontName2 = retrieveTextFontName("textrm", options2.fontWeight, options2.fontShape);
            return makeSymbol(text2, _fontName2, mode, options2, classes.concat(options2.fontWeight, options2.fontShape));
          } else {
            var _fontName3 = retrieveTextFontName(font, options2.fontWeight, options2.fontShape);
            return makeSymbol(text2, _fontName3, mode, options2, classes.concat(_fontName3, options2.fontWeight, options2.fontShape));
          }
        } else {
          throw new Error("unexpected type: " + type + " in makeOrd");
        }
      };
      canCombine = (prev, next) => {
        if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
          return false;
        }
        if (prev.classes.length === 1) {
          var cls = prev.classes[0];
          if (cls === "mbin" || cls === "mord") {
            return false;
          }
        }
        for (var style in prev.style) {
          if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
            return false;
          }
        }
        for (var _style in next.style) {
          if (next.style.hasOwnProperty(_style) && prev.style[_style] !== next.style[_style]) {
            return false;
          }
        }
        return true;
      };
      tryCombineChars = (chars) => {
        for (var i = 0; i < chars.length - 1; i++) {
          var prev = chars[i];
          var next = chars[i + 1];
          if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {
            prev.text += next.text;
            prev.height = Math.max(prev.height, next.height);
            prev.depth = Math.max(prev.depth, next.depth);
            prev.italic = next.italic;
            chars.splice(i + 1, 1);
            i--;
          }
        }
        return chars;
      };
      sizeElementFromChildren = function sizeElementFromChildren2(elem) {
        var height = 0;
        var depth = 0;
        var maxFontSize = 0;
        for (var i = 0; i < elem.children.length; i++) {
          var child = elem.children[i];
          if (child.height > height) {
            height = child.height;
          }
          if (child.depth > depth) {
            depth = child.depth;
          }
          if (child.maxFontSize > maxFontSize) {
            maxFontSize = child.maxFontSize;
          }
        }
        elem.height = height;
        elem.depth = depth;
        elem.maxFontSize = maxFontSize;
      };
      makeSpan$2 = function makeSpan(classes, children, options2, style) {
        var span = new Span(classes, children, options2, style);
        sizeElementFromChildren(span);
        return span;
      };
      makeSvgSpan = (classes, children, options2, style) => new Span(classes, children, options2, style);
      makeLineSpan = function makeLineSpan2(className, options2, thickness) {
        var line = makeSpan$2([className], [], options2);
        line.height = Math.max(thickness || options2.fontMetrics().defaultRuleThickness, options2.minRuleThickness);
        line.style.borderBottomWidth = makeEm(line.height);
        line.maxFontSize = 1;
        return line;
      };
      makeAnchor = function makeAnchor2(href, classes, children, options2) {
        var anchor = new Anchor(href, classes, children, options2);
        sizeElementFromChildren(anchor);
        return anchor;
      };
      makeFragment = function makeFragment2(children) {
        var fragment = new DocumentFragment(children);
        sizeElementFromChildren(fragment);
        return fragment;
      };
      wrapFragment = function wrapFragment2(group, options2) {
        if (group instanceof DocumentFragment) {
          return makeSpan$2([], [group], options2);
        }
        return group;
      };
      getVListChildrenAndDepth = function getVListChildrenAndDepth2(params) {
        if (params.positionType === "individualShift") {
          var oldChildren = params.children;
          var children = [oldChildren[0]];
          var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
          var currPos = _depth;
          for (var i = 1; i < oldChildren.length; i++) {
            var diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
            var size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
            currPos = currPos + diff;
            children.push({
              type: "kern",
              size
            });
            children.push(oldChildren[i]);
          }
          return {
            children,
            depth: _depth
          };
        }
        var depth;
        if (params.positionType === "top") {
          var bottom = params.positionData;
          for (var _i = 0; _i < params.children.length; _i++) {
            var child = params.children[_i];
            bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
          }
          depth = bottom;
        } else if (params.positionType === "bottom") {
          depth = -params.positionData;
        } else {
          var firstChild = params.children[0];
          if (firstChild.type !== "elem") {
            throw new Error('First child must have type "elem".');
          }
          if (params.positionType === "shift") {
            depth = -firstChild.elem.depth - params.positionData;
          } else if (params.positionType === "firstBaseline") {
            depth = -firstChild.elem.depth;
          } else {
            throw new Error("Invalid positionType " + params.positionType + ".");
          }
        }
        return {
          children: params.children,
          depth
        };
      };
      makeVList = function makeVList2(params, options2) {
        var {
          children,
          depth
        } = getVListChildrenAndDepth(params);
        var pstrutSize = 0;
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          if (child.type === "elem") {
            var elem = child.elem;
            pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
          }
        }
        pstrutSize += 2;
        var pstrut = makeSpan$2(["pstrut"], []);
        pstrut.style.height = makeEm(pstrutSize);
        var realChildren = [];
        var minPos = depth;
        var maxPos = depth;
        var currPos = depth;
        for (var _i2 = 0; _i2 < children.length; _i2++) {
          var _child = children[_i2];
          if (_child.type === "kern") {
            currPos += _child.size;
          } else {
            var _elem = _child.elem;
            var classes = _child.wrapperClasses || [];
            var style = _child.wrapperStyle || {};
            var childWrap = makeSpan$2(classes, [pstrut, _elem], void 0, style);
            childWrap.style.top = makeEm(-pstrutSize - currPos - _elem.depth);
            if (_child.marginLeft) {
              childWrap.style.marginLeft = _child.marginLeft;
            }
            if (_child.marginRight) {
              childWrap.style.marginRight = _child.marginRight;
            }
            realChildren.push(childWrap);
            currPos += _elem.height + _elem.depth;
          }
          minPos = Math.min(minPos, currPos);
          maxPos = Math.max(maxPos, currPos);
        }
        var vlist = makeSpan$2(["vlist"], realChildren);
        vlist.style.height = makeEm(maxPos);
        var rows;
        if (minPos < 0) {
          var emptySpan = makeSpan$2([], []);
          var depthStrut = makeSpan$2(["vlist"], [emptySpan]);
          depthStrut.style.height = makeEm(-minPos);
          var topStrut = makeSpan$2(["vlist-s"], [new SymbolNode("\u200B")]);
          rows = [makeSpan$2(["vlist-r"], [vlist, topStrut]), makeSpan$2(["vlist-r"], [depthStrut])];
        } else {
          rows = [makeSpan$2(["vlist-r"], [vlist])];
        }
        var vtable = makeSpan$2(["vlist-t"], rows);
        if (rows.length === 2) {
          vtable.classes.push("vlist-t2");
        }
        vtable.height = maxPos;
        vtable.depth = -minPos;
        return vtable;
      };
      makeGlue = (measurement, options2) => {
        var rule = makeSpan$2(["mspace"], [], options2);
        var size = calculateSize(measurement, options2);
        rule.style.marginRight = makeEm(size);
        return rule;
      };
      retrieveTextFontName = function retrieveTextFontName2(fontFamily, fontWeight, fontShape) {
        var baseFontName = "";
        switch (fontFamily) {
          case "amsrm":
            baseFontName = "AMS";
            break;
          case "textrm":
            baseFontName = "Main";
            break;
          case "textsf":
            baseFontName = "SansSerif";
            break;
          case "texttt":
            baseFontName = "Typewriter";
            break;
          default:
            baseFontName = fontFamily;
        }
        var fontStylesName;
        if (fontWeight === "textbf" && fontShape === "textit") {
          fontStylesName = "BoldItalic";
        } else if (fontWeight === "textbf") {
          fontStylesName = "Bold";
        } else if (fontWeight === "textit") {
          fontStylesName = "Italic";
        } else {
          fontStylesName = "Regular";
        }
        return baseFontName + "-" + fontStylesName;
      };
      fontMap = {
        // styles
        "mathbf": {
          variant: "bold",
          fontName: "Main-Bold"
        },
        "mathrm": {
          variant: "normal",
          fontName: "Main-Regular"
        },
        "textit": {
          variant: "italic",
          fontName: "Main-Italic"
        },
        "mathit": {
          variant: "italic",
          fontName: "Main-Italic"
        },
        "mathnormal": {
          variant: "italic",
          fontName: "Math-Italic"
        },
        "mathsfit": {
          variant: "sans-serif-italic",
          fontName: "SansSerif-Italic"
        },
        // "boldsymbol" is missing because they require the use of multiple fonts:
        // Math-BoldItalic and Main-Bold.  This is handled by a special case in
        // makeOrd which ends up calling boldsymbol.
        // families
        "mathbb": {
          variant: "double-struck",
          fontName: "AMS-Regular"
        },
        "mathcal": {
          variant: "script",
          fontName: "Caligraphic-Regular"
        },
        "mathfrak": {
          variant: "fraktur",
          fontName: "Fraktur-Regular"
        },
        "mathscr": {
          variant: "script",
          fontName: "Script-Regular"
        },
        "mathsf": {
          variant: "sans-serif",
          fontName: "SansSerif-Regular"
        },
        "mathtt": {
          variant: "monospace",
          fontName: "Typewriter-Regular"
        }
      };
      svgData = {
        //   path, width, height
        vec: ["vec", 0.471, 0.714],
        // values from the font glyph
        oiintSize1: ["oiintSize1", 0.957, 0.499],
        // oval to overlay the integrand
        oiintSize2: ["oiintSize2", 1.472, 0.659],
        oiiintSize1: ["oiiintSize1", 1.304, 0.499],
        oiiintSize2: ["oiiintSize2", 1.98, 0.659]
      };
      staticSvg = function staticSvg2(value, options2) {
        var [pathName, width, height] = svgData[value];
        var path2 = new PathNode(pathName);
        var svgNode = new SvgNode([path2], {
          "width": makeEm(width),
          "height": makeEm(height),
          // Override CSS rule `.katex svg { width: 100% }`
          "style": "width:" + makeEm(width),
          "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
          "preserveAspectRatio": "xMinYMin"
        });
        var span = makeSvgSpan(["overlay"], [svgNode], options2);
        span.height = height;
        span.style.height = makeEm(height);
        span.style.width = makeEm(width);
        return span;
      };
      buildCommon = {
        fontMap,
        makeSymbol,
        mathsym,
        makeSpan: makeSpan$2,
        makeSvgSpan,
        makeLineSpan,
        makeAnchor,
        makeFragment,
        wrapFragment,
        makeVList,
        makeOrd,
        makeGlue,
        staticSvg,
        svgData,
        tryCombineChars
      };
      thinspace = {
        number: 3,
        unit: "mu"
      };
      mediumspace = {
        number: 4,
        unit: "mu"
      };
      thickspace = {
        number: 5,
        unit: "mu"
      };
      spacings = {
        mord: {
          mop: thinspace,
          mbin: mediumspace,
          mrel: thickspace,
          minner: thinspace
        },
        mop: {
          mord: thinspace,
          mop: thinspace,
          mrel: thickspace,
          minner: thinspace
        },
        mbin: {
          mord: mediumspace,
          mop: mediumspace,
          mopen: mediumspace,
          minner: mediumspace
        },
        mrel: {
          mord: thickspace,
          mop: thickspace,
          mopen: thickspace,
          minner: thickspace
        },
        mopen: {},
        mclose: {
          mop: thinspace,
          mbin: mediumspace,
          mrel: thickspace,
          minner: thinspace
        },
        mpunct: {
          mord: thinspace,
          mop: thinspace,
          mrel: thickspace,
          mopen: thinspace,
          mclose: thinspace,
          mpunct: thinspace,
          minner: thinspace
        },
        minner: {
          mord: thinspace,
          mop: thinspace,
          mbin: mediumspace,
          mrel: thickspace,
          mopen: thinspace,
          mpunct: thinspace,
          minner: thinspace
        }
      };
      tightSpacings = {
        mord: {
          mop: thinspace
        },
        mop: {
          mord: thinspace,
          mop: thinspace
        },
        mbin: {},
        mrel: {},
        mopen: {},
        mclose: {
          mop: thinspace
        },
        mpunct: {},
        minner: {
          mop: thinspace
        }
      };
      _functions = {};
      _htmlGroupBuilders = {};
      _mathmlGroupBuilders = {};
      normalizeArgument = function normalizeArgument2(arg) {
        return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
      };
      ordargument = function ordargument2(arg) {
        return arg.type === "ordgroup" ? arg.body : [arg];
      };
      makeSpan$1 = buildCommon.makeSpan;
      binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
      binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
      styleMap$1 = {
        "display": Style$1.DISPLAY,
        "text": Style$1.TEXT,
        "script": Style$1.SCRIPT,
        "scriptscript": Style$1.SCRIPTSCRIPT
      };
      DomEnum = {
        mord: "mord",
        mop: "mop",
        mbin: "mbin",
        mrel: "mrel",
        mopen: "mopen",
        mclose: "mclose",
        mpunct: "mpunct",
        minner: "minner"
      };
      buildExpression$1 = function buildExpression(expression, options2, isRealGroup, surrounding) {
        if (surrounding === void 0) {
          surrounding = [null, null];
        }
        var groups = [];
        for (var i = 0; i < expression.length; i++) {
          var output = buildGroup$1(expression[i], options2);
          if (output instanceof DocumentFragment) {
            var children = output.children;
            groups.push(...children);
          } else {
            groups.push(output);
          }
        }
        buildCommon.tryCombineChars(groups);
        if (!isRealGroup) {
          return groups;
        }
        var glueOptions = options2;
        if (expression.length === 1) {
          var node = expression[0];
          if (node.type === "sizing") {
            glueOptions = options2.havingSize(node.size);
          } else if (node.type === "styling") {
            glueOptions = options2.havingStyle(styleMap$1[node.style]);
          }
        }
        var dummyPrev = makeSpan$1([surrounding[0] || "leftmost"], [], options2);
        var dummyNext = makeSpan$1([surrounding[1] || "rightmost"], [], options2);
        var isRoot = isRealGroup === "root";
        traverseNonSpaceNodes(groups, (node2, prev) => {
          var prevType = prev.classes[0];
          var type = node2.classes[0];
          if (prevType === "mbin" && utils.contains(binRightCanceller, type)) {
            prev.classes[0] = "mord";
          } else if (type === "mbin" && utils.contains(binLeftCanceller, prevType)) {
            node2.classes[0] = "mord";
          }
        }, {
          node: dummyPrev
        }, dummyNext, isRoot);
        traverseNonSpaceNodes(groups, (node2, prev) => {
          var prevType = getTypeOfDomTree(prev);
          var type = getTypeOfDomTree(node2);
          var space = prevType && type ? node2.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
          if (space) {
            return buildCommon.makeGlue(space, glueOptions);
          }
        }, {
          node: dummyPrev
        }, dummyNext, isRoot);
        return groups;
      };
      traverseNonSpaceNodes = function traverseNonSpaceNodes2(nodes, callback, prev, next, isRoot) {
        if (next) {
          nodes.push(next);
        }
        var i = 0;
        for (; i < nodes.length; i++) {
          var node = nodes[i];
          var partialGroup = checkPartialGroup(node);
          if (partialGroup) {
            traverseNonSpaceNodes2(partialGroup.children, callback, prev, null, isRoot);
            continue;
          }
          var nonspace = !node.hasClass("mspace");
          if (nonspace) {
            var result = callback(node, prev.node);
            if (result) {
              if (prev.insertAfter) {
                prev.insertAfter(result);
              } else {
                nodes.unshift(result);
                i++;
              }
            }
          }
          if (nonspace) {
            prev.node = node;
          } else if (isRoot && node.hasClass("newline")) {
            prev.node = makeSpan$1(["leftmost"]);
          }
          prev.insertAfter = /* @__PURE__ */ ((index) => (n) => {
            nodes.splice(index + 1, 0, n);
            i++;
          })(i);
        }
        if (next) {
          nodes.pop();
        }
      };
      checkPartialGroup = function checkPartialGroup2(node) {
        if (node instanceof DocumentFragment || node instanceof Anchor || node instanceof Span && node.hasClass("enclosing")) {
          return node;
        }
        return null;
      };
      getOutermostNode = function getOutermostNode2(node, side) {
        var partialGroup = checkPartialGroup(node);
        if (partialGroup) {
          var children = partialGroup.children;
          if (children.length) {
            if (side === "right") {
              return getOutermostNode2(children[children.length - 1], "right");
            } else if (side === "left") {
              return getOutermostNode2(children[0], "left");
            }
          }
        }
        return node;
      };
      getTypeOfDomTree = function getTypeOfDomTree2(node, side) {
        if (!node) {
          return null;
        }
        if (side) {
          node = getOutermostNode(node, side);
        }
        return DomEnum[node.classes[0]] || null;
      };
      makeNullDelimiter = function makeNullDelimiter2(options2, classes) {
        var moreClasses = ["nulldelimiter"].concat(options2.baseSizingClasses());
        return makeSpan$1(classes.concat(moreClasses));
      };
      buildGroup$1 = function buildGroup(group, options2, baseOptions) {
        if (!group) {
          return makeSpan$1();
        }
        if (_htmlGroupBuilders[group.type]) {
          var groupNode = _htmlGroupBuilders[group.type](group, options2);
          if (baseOptions && options2.size !== baseOptions.size) {
            groupNode = makeSpan$1(options2.sizingClasses(baseOptions), [groupNode], options2);
            var multiplier = options2.sizeMultiplier / baseOptions.sizeMultiplier;
            groupNode.height *= multiplier;
            groupNode.depth *= multiplier;
          }
          return groupNode;
        } else {
          throw new ParseError("Got group of unknown type: '" + group.type + "'");
        }
      };
      MathNode = class {
        constructor(type, children, classes) {
          this.type = void 0;
          this.attributes = void 0;
          this.children = void 0;
          this.classes = void 0;
          this.type = type;
          this.attributes = {};
          this.children = children || [];
          this.classes = classes || [];
        }
        /**
         * Sets an attribute on a MathML node. MathML depends on attributes to convey a
         * semantic content, so this is used heavily.
         */
        setAttribute(name, value) {
          this.attributes[name] = value;
        }
        /**
         * Gets an attribute on a MathML node.
         */
        getAttribute(name) {
          return this.attributes[name];
        }
        /**
         * Converts the math node into a MathML-namespaced DOM element.
         */
        toNode() {
          var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              node.setAttribute(attr, this.attributes[attr]);
            }
          }
          if (this.classes.length > 0) {
            node.className = createClass(this.classes);
          }
          for (var i = 0; i < this.children.length; i++) {
            if (this.children[i] instanceof TextNode && this.children[i + 1] instanceof TextNode) {
              var text2 = this.children[i].toText() + this.children[++i].toText();
              while (this.children[i + 1] instanceof TextNode) {
                text2 += this.children[++i].toText();
              }
              node.appendChild(new TextNode(text2).toNode());
            } else {
              node.appendChild(this.children[i].toNode());
            }
          }
          return node;
        }
        /**
         * Converts the math node into an HTML markup string.
         */
        toMarkup() {
          var markup = "<" + this.type;
          for (var attr in this.attributes) {
            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
              markup += " " + attr + '="';
              markup += utils.escape(this.attributes[attr]);
              markup += '"';
            }
          }
          if (this.classes.length > 0) {
            markup += ' class ="' + utils.escape(createClass(this.classes)) + '"';
          }
          markup += ">";
          for (var i = 0; i < this.children.length; i++) {
            markup += this.children[i].toMarkup();
          }
          markup += "</" + this.type + ">";
          return markup;
        }
        /**
         * Converts the math node into a string, similar to innerText, but escaped.
         */
        toText() {
          return this.children.map((child) => child.toText()).join("");
        }
      };
      TextNode = class {
        constructor(text2) {
          this.text = void 0;
          this.text = text2;
        }
        /**
         * Converts the text node into a DOM text node.
         */
        toNode() {
          return document.createTextNode(this.text);
        }
        /**
         * Converts the text node into escaped HTML markup
         * (representing the text itself).
         */
        toMarkup() {
          return utils.escape(this.toText());
        }
        /**
         * Converts the text node into a string
         * (representing the text itself).
         */
        toText() {
          return this.text;
        }
      };
      SpaceNode = class {
        /**
         * Create a Space node with width given in CSS ems.
         */
        constructor(width) {
          this.width = void 0;
          this.character = void 0;
          this.width = width;
          if (width >= 0.05555 && width <= 0.05556) {
            this.character = "\u200A";
          } else if (width >= 0.1666 && width <= 0.1667) {
            this.character = "\u2009";
          } else if (width >= 0.2222 && width <= 0.2223) {
            this.character = "\u2005";
          } else if (width >= 0.2777 && width <= 0.2778) {
            this.character = "\u2005\u200A";
          } else if (width >= -0.05556 && width <= -0.05555) {
            this.character = "\u200A\u2063";
          } else if (width >= -0.1667 && width <= -0.1666) {
            this.character = "\u2009\u2063";
          } else if (width >= -0.2223 && width <= -0.2222) {
            this.character = "\u205F\u2063";
          } else if (width >= -0.2778 && width <= -0.2777) {
            this.character = "\u2005\u2063";
          } else {
            this.character = null;
          }
        }
        /**
         * Converts the math node into a MathML-namespaced DOM element.
         */
        toNode() {
          if (this.character) {
            return document.createTextNode(this.character);
          } else {
            var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
            node.setAttribute("width", makeEm(this.width));
            return node;
          }
        }
        /**
         * Converts the math node into an HTML markup string.
         */
        toMarkup() {
          if (this.character) {
            return "<mtext>" + this.character + "</mtext>";
          } else {
            return '<mspace width="' + makeEm(this.width) + '"/>';
          }
        }
        /**
         * Converts the math node into a string, similar to innerText.
         */
        toText() {
          if (this.character) {
            return this.character;
          } else {
            return " ";
          }
        }
      };
      mathMLTree = {
        MathNode,
        TextNode,
        SpaceNode,
        newDocumentFragment
      };
      makeText = function makeText2(text2, mode, options2) {
        if (symbols[mode][text2] && symbols[mode][text2].replace && text2.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text2) && options2 && (options2.fontFamily && options2.fontFamily.slice(4, 6) === "tt" || options2.font && options2.font.slice(4, 6) === "tt"))) {
          text2 = symbols[mode][text2].replace;
        }
        return new mathMLTree.TextNode(text2);
      };
      makeRow = function makeRow2(body) {
        if (body.length === 1) {
          return body[0];
        } else {
          return new mathMLTree.MathNode("mrow", body);
        }
      };
      getVariant = function getVariant2(group, options2) {
        if (options2.fontFamily === "texttt") {
          return "monospace";
        } else if (options2.fontFamily === "textsf") {
          if (options2.fontShape === "textit" && options2.fontWeight === "textbf") {
            return "sans-serif-bold-italic";
          } else if (options2.fontShape === "textit") {
            return "sans-serif-italic";
          } else if (options2.fontWeight === "textbf") {
            return "bold-sans-serif";
          } else {
            return "sans-serif";
          }
        } else if (options2.fontShape === "textit" && options2.fontWeight === "textbf") {
          return "bold-italic";
        } else if (options2.fontShape === "textit") {
          return "italic";
        } else if (options2.fontWeight === "textbf") {
          return "bold";
        }
        var font = options2.font;
        if (!font || font === "mathnormal") {
          return null;
        }
        var mode = group.mode;
        if (font === "mathit") {
          return "italic";
        } else if (font === "boldsymbol") {
          return group.type === "textord" ? "bold" : "bold-italic";
        } else if (font === "mathbf") {
          return "bold";
        } else if (font === "mathbb") {
          return "double-struck";
        } else if (font === "mathsfit") {
          return "sans-serif-italic";
        } else if (font === "mathfrak") {
          return "fraktur";
        } else if (font === "mathscr" || font === "mathcal") {
          return "script";
        } else if (font === "mathsf") {
          return "sans-serif";
        } else if (font === "mathtt") {
          return "monospace";
        }
        var text2 = group.text;
        if (utils.contains(["\\imath", "\\jmath"], text2)) {
          return null;
        }
        if (symbols[mode][text2] && symbols[mode][text2].replace) {
          text2 = symbols[mode][text2].replace;
        }
        var fontName = buildCommon.fontMap[font].fontName;
        if (getCharacterMetrics(text2, fontName, mode)) {
          return buildCommon.fontMap[font].variant;
        }
        return null;
      };
      buildExpression2 = function buildExpression3(expression, options2, isOrdgroup) {
        if (expression.length === 1) {
          var group = buildGroup2(expression[0], options2);
          if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
            group.setAttribute("lspace", "0em");
            group.setAttribute("rspace", "0em");
          }
          return [group];
        }
        var groups = [];
        var lastGroup;
        for (var i = 0; i < expression.length; i++) {
          var _group = buildGroup2(expression[i], options2);
          if (_group instanceof MathNode && lastGroup instanceof MathNode) {
            if (_group.type === "mtext" && lastGroup.type === "mtext" && _group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
              lastGroup.children.push(..._group.children);
              continue;
            } else if (_group.type === "mn" && lastGroup.type === "mn") {
              lastGroup.children.push(..._group.children);
              continue;
            } else if (isNumberPunctuation(_group) && lastGroup.type === "mn") {
              lastGroup.children.push(..._group.children);
              continue;
            } else if (_group.type === "mn" && isNumberPunctuation(lastGroup)) {
              _group.children = [...lastGroup.children, ..._group.children];
              groups.pop();
            } else if ((_group.type === "msup" || _group.type === "msub") && _group.children.length >= 1 && (lastGroup.type === "mn" || isNumberPunctuation(lastGroup))) {
              var base = _group.children[0];
              if (base instanceof MathNode && base.type === "mn") {
                base.children = [...lastGroup.children, ...base.children];
                groups.pop();
              }
            } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
              var lastChild = lastGroup.children[0];
              if (lastChild instanceof TextNode && lastChild.text === "\u0338" && (_group.type === "mo" || _group.type === "mi" || _group.type === "mn")) {
                var child = _group.children[0];
                if (child instanceof TextNode && child.text.length > 0) {
                  child.text = child.text.slice(0, 1) + "\u0338" + child.text.slice(1);
                  groups.pop();
                }
              }
            }
          }
          groups.push(_group);
          lastGroup = _group;
        }
        return groups;
      };
      buildExpressionRow = function buildExpressionRow2(expression, options2, isOrdgroup) {
        return makeRow(buildExpression2(expression, options2, isOrdgroup));
      };
      buildGroup2 = function buildGroup3(group, options2) {
        if (!group) {
          return new mathMLTree.MathNode("mrow");
        }
        if (_mathmlGroupBuilders[group.type]) {
          var result = _mathmlGroupBuilders[group.type](group, options2);
          return result;
        } else {
          throw new ParseError("Got group of unknown type: '" + group.type + "'");
        }
      };
      optionsFromSettings = function optionsFromSettings2(settings) {
        return new Options({
          style: settings.displayMode ? Style$1.DISPLAY : Style$1.TEXT,
          maxSize: settings.maxSize,
          minRuleThickness: settings.minRuleThickness
        });
      };
      displayWrap = function displayWrap2(node, settings) {
        if (settings.displayMode) {
          var classes = ["katex-display"];
          if (settings.leqno) {
            classes.push("leqno");
          }
          if (settings.fleqn) {
            classes.push("fleqn");
          }
          node = buildCommon.makeSpan(classes, [node]);
        }
        return node;
      };
      buildTree = function buildTree2(tree, expression, settings) {
        var options2 = optionsFromSettings(settings);
        var katexNode;
        if (settings.output === "mathml") {
          return buildMathML(tree, expression, options2, settings.displayMode, true);
        } else if (settings.output === "html") {
          var htmlNode = buildHTML(tree, options2);
          katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
        } else {
          var mathMLNode = buildMathML(tree, expression, options2, settings.displayMode, false);
          var _htmlNode = buildHTML(tree, options2);
          katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, _htmlNode]);
        }
        return displayWrap(katexNode, settings);
      };
      buildHTMLTree = function buildHTMLTree2(tree, expression, settings) {
        var options2 = optionsFromSettings(settings);
        var htmlNode = buildHTML(tree, options2);
        var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
        return displayWrap(katexNode, settings);
      };
      stretchyCodePoint = {
        widehat: "^",
        widecheck: "\u02C7",
        widetilde: "~",
        utilde: "~",
        overleftarrow: "\u2190",
        underleftarrow: "\u2190",
        xleftarrow: "\u2190",
        overrightarrow: "\u2192",
        underrightarrow: "\u2192",
        xrightarrow: "\u2192",
        underbrace: "\u23DF",
        overbrace: "\u23DE",
        overgroup: "\u23E0",
        undergroup: "\u23E1",
        overleftrightarrow: "\u2194",
        underleftrightarrow: "\u2194",
        xleftrightarrow: "\u2194",
        Overrightarrow: "\u21D2",
        xRightarrow: "\u21D2",
        overleftharpoon: "\u21BC",
        xleftharpoonup: "\u21BC",
        overrightharpoon: "\u21C0",
        xrightharpoonup: "\u21C0",
        xLeftarrow: "\u21D0",
        xLeftrightarrow: "\u21D4",
        xhookleftarrow: "\u21A9",
        xhookrightarrow: "\u21AA",
        xmapsto: "\u21A6",
        xrightharpoondown: "\u21C1",
        xleftharpoondown: "\u21BD",
        xrightleftharpoons: "\u21CC",
        xleftrightharpoons: "\u21CB",
        xtwoheadleftarrow: "\u219E",
        xtwoheadrightarrow: "\u21A0",
        xlongequal: "=",
        xtofrom: "\u21C4",
        xrightleftarrows: "\u21C4",
        xrightequilibrium: "\u21CC",
        // Not a perfect match.
        xleftequilibrium: "\u21CB",
        // None better available.
        "\\cdrightarrow": "\u2192",
        "\\cdleftarrow": "\u2190",
        "\\cdlongequal": "="
      };
      mathMLnode = function mathMLnode2(label) {
        var node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, "")])]);
        node.setAttribute("stretchy", "true");
        return node;
      };
      katexImagesData = {
        //   path(s), minWidth, height, align
        overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
        overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
        underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
        underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
        xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
        "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
        // CD minwwidth2.5pc
        xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
        "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
        Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
        xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
        xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
        overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
        xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
        xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
        overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
        xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
        xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
        xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
        "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
        xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
        xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
        overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
        overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
        underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
        underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
        xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
        xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
        xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
        xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
        xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
        xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
        overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
        underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
        overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
        undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
        xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
        xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
        // The next three arrows are from the mhchem package.
        // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
        // document as \xrightarrow or \xrightleftharpoons. Those have
        // min-length = 1.75em, so we set min-length on these next three to match.
        xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
        xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
        xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
      };
      groupLength = function groupLength2(arg) {
        if (arg.type === "ordgroup") {
          return arg.body.length;
        } else {
          return 1;
        }
      };
      svgSpan = function svgSpan2(group, options2) {
        function buildSvgSpan_() {
          var viewBoxWidth = 4e5;
          var label = group.label.slice(1);
          if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
            var grp = group;
            var numChars = groupLength(grp.base);
            var viewBoxHeight;
            var pathName;
            var _height;
            if (numChars > 5) {
              if (label === "widehat" || label === "widecheck") {
                viewBoxHeight = 420;
                viewBoxWidth = 2364;
                _height = 0.42;
                pathName = label + "4";
              } else {
                viewBoxHeight = 312;
                viewBoxWidth = 2340;
                _height = 0.34;
                pathName = "tilde4";
              }
            } else {
              var imgIndex = [1, 1, 2, 2, 3, 3][numChars];
              if (label === "widehat" || label === "widecheck") {
                viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
                viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
                _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
                pathName = label + imgIndex;
              } else {
                viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
                viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
                _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
                pathName = "tilde" + imgIndex;
              }
            }
            var path2 = new PathNode(pathName);
            var svgNode = new SvgNode([path2], {
              "width": "100%",
              "height": makeEm(_height),
              "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
              "preserveAspectRatio": "none"
            });
            return {
              span: buildCommon.makeSvgSpan([], [svgNode], options2),
              minWidth: 0,
              height: _height
            };
          } else {
            var spans = [];
            var data = katexImagesData[label];
            var [paths, _minWidth, _viewBoxHeight] = data;
            var _height2 = _viewBoxHeight / 1e3;
            var numSvgChildren = paths.length;
            var widthClasses;
            var aligns;
            if (numSvgChildren === 1) {
              var align1 = data[3];
              widthClasses = ["hide-tail"];
              aligns = [align1];
            } else if (numSvgChildren === 2) {
              widthClasses = ["halfarrow-left", "halfarrow-right"];
              aligns = ["xMinYMin", "xMaxYMin"];
            } else if (numSvgChildren === 3) {
              widthClasses = ["brace-left", "brace-center", "brace-right"];
              aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
            } else {
              throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
            }
            for (var i = 0; i < numSvgChildren; i++) {
              var _path = new PathNode(paths[i]);
              var _svgNode = new SvgNode([_path], {
                "width": "400em",
                "height": makeEm(_height2),
                "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
                "preserveAspectRatio": aligns[i] + " slice"
              });
              var _span = buildCommon.makeSvgSpan([widthClasses[i]], [_svgNode], options2);
              if (numSvgChildren === 1) {
                return {
                  span: _span,
                  minWidth: _minWidth,
                  height: _height2
                };
              } else {
                _span.style.height = makeEm(_height2);
                spans.push(_span);
              }
            }
            return {
              span: buildCommon.makeSpan(["stretchy"], spans, options2),
              minWidth: _minWidth,
              height: _height2
            };
          }
        }
        var {
          span,
          minWidth,
          height
        } = buildSvgSpan_();
        span.height = height;
        span.style.height = makeEm(height);
        if (minWidth > 0) {
          span.style.minWidth = makeEm(minWidth);
        }
        return span;
      };
      encloseSpan = function encloseSpan2(inner2, label, topPad, bottomPad, options2) {
        var img;
        var totalHeight = inner2.height + inner2.depth + topPad + bottomPad;
        if (/fbox|color|angl/.test(label)) {
          img = buildCommon.makeSpan(["stretchy", label], [], options2);
          if (label === "fbox") {
            var color = options2.color && options2.getColor();
            if (color) {
              img.style.borderColor = color;
            }
          }
        } else {
          var lines = [];
          if (/^[bx]cancel$/.test(label)) {
            lines.push(new LineNode({
              "x1": "0",
              "y1": "0",
              "x2": "100%",
              "y2": "100%",
              "stroke-width": "0.046em"
            }));
          }
          if (/^x?cancel$/.test(label)) {
            lines.push(new LineNode({
              "x1": "0",
              "y1": "100%",
              "x2": "100%",
              "y2": "0",
              "stroke-width": "0.046em"
            }));
          }
          var svgNode = new SvgNode(lines, {
            "width": "100%",
            "height": makeEm(totalHeight)
          });
          img = buildCommon.makeSvgSpan([], [svgNode], options2);
        }
        img.height = totalHeight;
        img.style.height = makeEm(totalHeight);
        return img;
      };
      stretchy = {
        encloseSpan,
        mathMLnode,
        svgSpan
      };
      htmlBuilder$a = (grp, options2) => {
        var base;
        var group;
        var supSubGroup;
        if (grp && grp.type === "supsub") {
          group = assertNodeType(grp.base, "accent");
          base = group.base;
          grp.base = base;
          supSubGroup = assertSpan(buildGroup$1(grp, options2));
          grp.base = group;
        } else {
          group = assertNodeType(grp, "accent");
          base = group.base;
        }
        var body = buildGroup$1(base, options2.havingCrampedStyle());
        var mustShift = group.isShifty && utils.isCharacterBox(base);
        var skew = 0;
        if (mustShift) {
          var baseChar = utils.getBaseElem(base);
          var baseGroup = buildGroup$1(baseChar, options2.havingCrampedStyle());
          skew = assertSymbolDomNode(baseGroup).skew;
        }
        var accentBelow = group.label === "\\c";
        var clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options2.fontMetrics().xHeight);
        var accentBody;
        if (!group.isStretchy) {
          var accent2;
          var width;
          if (group.label === "\\vec") {
            accent2 = buildCommon.staticSvg("vec", options2);
            width = buildCommon.svgData.vec[1];
          } else {
            accent2 = buildCommon.makeOrd({
              mode: group.mode,
              text: group.label
            }, options2, "textord");
            accent2 = assertSymbolDomNode(accent2);
            accent2.italic = 0;
            width = accent2.width;
            if (accentBelow) {
              clearance += accent2.depth;
            }
          }
          accentBody = buildCommon.makeSpan(["accent-body"], [accent2]);
          var accentFull = group.label === "\\textcircled";
          if (accentFull) {
            accentBody.classes.push("accent-full");
            clearance = body.height;
          }
          var left = skew;
          if (!accentFull) {
            left -= width / 2;
          }
          accentBody.style.left = makeEm(left);
          if (group.label === "\\textcircled") {
            accentBody.style.top = ".2em";
          }
          accentBody = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body
            }, {
              type: "kern",
              size: -clearance
            }, {
              type: "elem",
              elem: accentBody
            }]
          }, options2);
        } else {
          accentBody = stretchy.svgSpan(group, options2);
          accentBody = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body
            }, {
              type: "elem",
              elem: accentBody,
              wrapperClasses: ["svg-align"],
              wrapperStyle: skew > 0 ? {
                width: "calc(100% - " + makeEm(2 * skew) + ")",
                marginLeft: makeEm(2 * skew)
              } : void 0
            }]
          }, options2);
        }
        var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options2);
        if (supSubGroup) {
          supSubGroup.children[0] = accentWrap;
          supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
          supSubGroup.classes[0] = "mord";
          return supSubGroup;
        } else {
          return accentWrap;
        }
      };
      mathmlBuilder$9 = (group, options2) => {
        var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
        var node = new mathMLTree.MathNode("mover", [buildGroup2(group.base, options2), accentNode]);
        node.setAttribute("accent", "true");
        return node;
      };
      NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((accent2) => "\\" + accent2).join("|"));
      defineFunction({
        type: "accent",
        names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
        props: {
          numArgs: 1
        },
        handler: (context, args) => {
          var base = normalizeArgument(args[0]);
          var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
          var isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
          return {
            type: "accent",
            mode: context.parser.mode,
            label: context.funcName,
            isStretchy,
            isShifty,
            base
          };
        },
        htmlBuilder: htmlBuilder$a,
        mathmlBuilder: mathmlBuilder$9
      });
      defineFunction({
        type: "accent",
        names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
        props: {
          numArgs: 1,
          allowedInText: true,
          allowedInMath: true,
          // unless in strict mode
          argTypes: ["primitive"]
        },
        handler: (context, args) => {
          var base = args[0];
          var mode = context.parser.mode;
          if (mode === "math") {
            context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
            mode = "text";
          }
          return {
            type: "accent",
            mode,
            label: context.funcName,
            isStretchy: false,
            isShifty: true,
            base
          };
        },
        htmlBuilder: htmlBuilder$a,
        mathmlBuilder: mathmlBuilder$9
      });
      defineFunction({
        type: "accentUnder",
        names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
        props: {
          numArgs: 1
        },
        handler: (_ref, args) => {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var base = args[0];
          return {
            type: "accentUnder",
            mode: parser2.mode,
            label: funcName,
            base
          };
        },
        htmlBuilder: (group, options2) => {
          var innerGroup = buildGroup$1(group.base, options2);
          var accentBody = stretchy.svgSpan(group, options2);
          var kern = group.label === "\\utilde" ? 0.12 : 0;
          var vlist = buildCommon.makeVList({
            positionType: "top",
            positionData: innerGroup.height,
            children: [{
              type: "elem",
              elem: accentBody,
              wrapperClasses: ["svg-align"]
            }, {
              type: "kern",
              size: kern
            }, {
              type: "elem",
              elem: innerGroup
            }]
          }, options2);
          return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options2);
        },
        mathmlBuilder: (group, options2) => {
          var accentNode = stretchy.mathMLnode(group.label);
          var node = new mathMLTree.MathNode("munder", [buildGroup2(group.base, options2), accentNode]);
          node.setAttribute("accentunder", "true");
          return node;
        }
      });
      paddedNode = (group) => {
        var node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
        node.setAttribute("width", "+0.6em");
        node.setAttribute("lspace", "0.3em");
        return node;
      };
      defineFunction({
        type: "xArrow",
        names: [
          "\\xleftarrow",
          "\\xrightarrow",
          "\\xLeftarrow",
          "\\xRightarrow",
          "\\xleftrightarrow",
          "\\xLeftrightarrow",
          "\\xhookleftarrow",
          "\\xhookrightarrow",
          "\\xmapsto",
          "\\xrightharpoondown",
          "\\xrightharpoonup",
          "\\xleftharpoondown",
          "\\xleftharpoonup",
          "\\xrightleftharpoons",
          "\\xleftrightharpoons",
          "\\xlongequal",
          "\\xtwoheadrightarrow",
          "\\xtwoheadleftarrow",
          "\\xtofrom",
          // The next 3 functions are here to support the mhchem extension.
          // Direct use of these functions is discouraged and may break someday.
          "\\xrightleftarrows",
          "\\xrightequilibrium",
          "\\xleftequilibrium",
          // The next 3 functions are here only to support the {CD} environment.
          "\\\\cdrightarrow",
          "\\\\cdleftarrow",
          "\\\\cdlongequal"
        ],
        props: {
          numArgs: 1,
          numOptionalArgs: 1
        },
        handler(_ref, args, optArgs) {
          var {
            parser: parser2,
            funcName
          } = _ref;
          return {
            type: "xArrow",
            mode: parser2.mode,
            label: funcName,
            body: args[0],
            below: optArgs[0]
          };
        },
        // Flow is unable to correctly infer the type of `group`, even though it's
        // unambiguously determined from the passed-in `type` above.
        htmlBuilder(group, options2) {
          var style = options2.style;
          var newOptions = options2.havingStyle(style.sup());
          var upperGroup = buildCommon.wrapFragment(buildGroup$1(group.body, newOptions, options2), options2);
          var arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
          upperGroup.classes.push(arrowPrefix + "-arrow-pad");
          var lowerGroup;
          if (group.below) {
            newOptions = options2.havingStyle(style.sub());
            lowerGroup = buildCommon.wrapFragment(buildGroup$1(group.below, newOptions, options2), options2);
            lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
          }
          var arrowBody = stretchy.svgSpan(group, options2);
          var arrowShift = -options2.fontMetrics().axisHeight + 0.5 * arrowBody.height;
          var upperShift = -options2.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
          if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
            upperShift -= upperGroup.depth;
          }
          var vlist;
          if (lowerGroup) {
            var lowerShift = -options2.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
            vlist = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: upperGroup,
                shift: upperShift
              }, {
                type: "elem",
                elem: arrowBody,
                shift: arrowShift
              }, {
                type: "elem",
                elem: lowerGroup,
                shift: lowerShift
              }]
            }, options2);
          } else {
            vlist = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: upperGroup,
                shift: upperShift
              }, {
                type: "elem",
                elem: arrowBody,
                shift: arrowShift
              }]
            }, options2);
          }
          vlist.children[0].children[0].children[1].classes.push("svg-align");
          return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options2);
        },
        mathmlBuilder(group, options2) {
          var arrowNode = stretchy.mathMLnode(group.label);
          arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
          var node;
          if (group.body) {
            var upperNode = paddedNode(buildGroup2(group.body, options2));
            if (group.below) {
              var lowerNode = paddedNode(buildGroup2(group.below, options2));
              node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
            } else {
              node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
            }
          } else if (group.below) {
            var _lowerNode = paddedNode(buildGroup2(group.below, options2));
            node = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
          } else {
            node = paddedNode();
            node = new mathMLTree.MathNode("mover", [arrowNode, node]);
          }
          return node;
        }
      });
      makeSpan2 = buildCommon.makeSpan;
      defineFunction({
        type: "mclass",
        names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler(_ref, args) {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var body = args[0];
          return {
            type: "mclass",
            mode: parser2.mode,
            mclass: "m" + funcName.slice(5),
            // TODO(kevinb): don't prefix with 'm'
            body: ordargument(body),
            isCharacterBox: utils.isCharacterBox(body)
          };
        },
        htmlBuilder: htmlBuilder$9,
        mathmlBuilder: mathmlBuilder$8
      });
      binrelClass = (arg) => {
        var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
        if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
          return "m" + atom.family;
        } else {
          return "mord";
        }
      };
      defineFunction({
        type: "mclass",
        names: ["\\@binrel"],
        props: {
          numArgs: 2
        },
        handler(_ref2, args) {
          var {
            parser: parser2
          } = _ref2;
          return {
            type: "mclass",
            mode: parser2.mode,
            mclass: binrelClass(args[0]),
            body: ordargument(args[1]),
            isCharacterBox: utils.isCharacterBox(args[1])
          };
        }
      });
      defineFunction({
        type: "mclass",
        names: ["\\stackrel", "\\overset", "\\underset"],
        props: {
          numArgs: 2
        },
        handler(_ref3, args) {
          var {
            parser: parser2,
            funcName
          } = _ref3;
          var baseArg = args[1];
          var shiftedArg = args[0];
          var mclass;
          if (funcName !== "\\stackrel") {
            mclass = binrelClass(baseArg);
          } else {
            mclass = "mrel";
          }
          var baseOp = {
            type: "op",
            mode: baseArg.mode,
            limits: true,
            alwaysHandleSupSub: true,
            parentIsSupSub: false,
            symbol: false,
            suppressBaseShift: funcName !== "\\stackrel",
            body: ordargument(baseArg)
          };
          var supsub = {
            type: "supsub",
            mode: shiftedArg.mode,
            base: baseOp,
            sup: funcName === "\\underset" ? null : shiftedArg,
            sub: funcName === "\\underset" ? shiftedArg : null
          };
          return {
            type: "mclass",
            mode: parser2.mode,
            mclass,
            body: [supsub],
            isCharacterBox: utils.isCharacterBox(supsub)
          };
        },
        htmlBuilder: htmlBuilder$9,
        mathmlBuilder: mathmlBuilder$8
      });
      defineFunction({
        type: "pmb",
        names: ["\\pmb"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler(_ref, args) {
          var {
            parser: parser2
          } = _ref;
          return {
            type: "pmb",
            mode: parser2.mode,
            mclass: binrelClass(args[0]),
            body: ordargument(args[0])
          };
        },
        htmlBuilder(group, options2) {
          var elements = buildExpression$1(group.body, options2, true);
          var node = buildCommon.makeSpan([group.mclass], elements, options2);
          node.style.textShadow = "0.02em 0.01em 0.04px";
          return node;
        },
        mathmlBuilder(group, style) {
          var inner2 = buildExpression2(group.body, style);
          var node = new mathMLTree.MathNode("mstyle", inner2);
          node.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
          return node;
        }
      });
      cdArrowFunctionName = {
        ">": "\\\\cdrightarrow",
        "<": "\\\\cdleftarrow",
        "=": "\\\\cdlongequal",
        "A": "\\uparrow",
        "V": "\\downarrow",
        "|": "\\Vert",
        ".": "no arrow"
      };
      newCell = () => {
        return {
          type: "styling",
          body: [],
          mode: "math",
          style: "display"
        };
      };
      isStartOfArrow = (node) => {
        return node.type === "textord" && node.text === "@";
      };
      isLabelEnd = (node, endChar) => {
        return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
      };
      defineFunction({
        type: "cdlabel",
        names: ["\\\\cdleft", "\\\\cdright"],
        props: {
          numArgs: 1
        },
        handler(_ref, args) {
          var {
            parser: parser2,
            funcName
          } = _ref;
          return {
            type: "cdlabel",
            mode: parser2.mode,
            side: funcName.slice(4),
            label: args[0]
          };
        },
        htmlBuilder(group, options2) {
          var newOptions = options2.havingStyle(options2.style.sup());
          var label = buildCommon.wrapFragment(buildGroup$1(group.label, newOptions, options2), options2);
          label.classes.push("cd-label-" + group.side);
          label.style.bottom = makeEm(0.8 - label.depth);
          label.height = 0;
          label.depth = 0;
          return label;
        },
        mathmlBuilder(group, options2) {
          var label = new mathMLTree.MathNode("mrow", [buildGroup2(group.label, options2)]);
          label = new mathMLTree.MathNode("mpadded", [label]);
          label.setAttribute("width", "0");
          if (group.side === "left") {
            label.setAttribute("lspace", "-1width");
          }
          label.setAttribute("voffset", "0.7em");
          label = new mathMLTree.MathNode("mstyle", [label]);
          label.setAttribute("displaystyle", "false");
          label.setAttribute("scriptlevel", "1");
          return label;
        }
      });
      defineFunction({
        type: "cdlabelparent",
        names: ["\\\\cdparent"],
        props: {
          numArgs: 1
        },
        handler(_ref2, args) {
          var {
            parser: parser2
          } = _ref2;
          return {
            type: "cdlabelparent",
            mode: parser2.mode,
            fragment: args[0]
          };
        },
        htmlBuilder(group, options2) {
          var parent = buildCommon.wrapFragment(buildGroup$1(group.fragment, options2), options2);
          parent.classes.push("cd-vert-arrow");
          return parent;
        },
        mathmlBuilder(group, options2) {
          return new mathMLTree.MathNode("mrow", [buildGroup2(group.fragment, options2)]);
        }
      });
      defineFunction({
        type: "textord",
        names: ["\\@char"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler(_ref, args) {
          var {
            parser: parser2
          } = _ref;
          var arg = assertNodeType(args[0], "ordgroup");
          var group = arg.body;
          var number = "";
          for (var i = 0; i < group.length; i++) {
            var node = assertNodeType(group[i], "textord");
            number += node.text;
          }
          var code = parseInt(number);
          var text2;
          if (isNaN(code)) {
            throw new ParseError("\\@char has non-numeric argument " + number);
          } else if (code < 0 || code >= 1114111) {
            throw new ParseError("\\@char with invalid code point " + number);
          } else if (code <= 65535) {
            text2 = String.fromCharCode(code);
          } else {
            code -= 65536;
            text2 = String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
          }
          return {
            type: "textord",
            mode: parser2.mode,
            text: text2
          };
        }
      });
      htmlBuilder$8 = (group, options2) => {
        var elements = buildExpression$1(group.body, options2.withColor(group.color), false);
        return buildCommon.makeFragment(elements);
      };
      mathmlBuilder$7 = (group, options2) => {
        var inner2 = buildExpression2(group.body, options2.withColor(group.color));
        var node = new mathMLTree.MathNode("mstyle", inner2);
        node.setAttribute("mathcolor", group.color);
        return node;
      };
      defineFunction({
        type: "color",
        names: ["\\textcolor"],
        props: {
          numArgs: 2,
          allowedInText: true,
          argTypes: ["color", "original"]
        },
        handler(_ref, args) {
          var {
            parser: parser2
          } = _ref;
          var color = assertNodeType(args[0], "color-token").color;
          var body = args[1];
          return {
            type: "color",
            mode: parser2.mode,
            color,
            body: ordargument(body)
          };
        },
        htmlBuilder: htmlBuilder$8,
        mathmlBuilder: mathmlBuilder$7
      });
      defineFunction({
        type: "color",
        names: ["\\color"],
        props: {
          numArgs: 1,
          allowedInText: true,
          argTypes: ["color"]
        },
        handler(_ref2, args) {
          var {
            parser: parser2,
            breakOnTokenText
          } = _ref2;
          var color = assertNodeType(args[0], "color-token").color;
          parser2.gullet.macros.set("\\current@color", color);
          var body = parser2.parseExpression(true, breakOnTokenText);
          return {
            type: "color",
            mode: parser2.mode,
            color,
            body
          };
        },
        htmlBuilder: htmlBuilder$8,
        mathmlBuilder: mathmlBuilder$7
      });
      defineFunction({
        type: "cr",
        names: ["\\\\"],
        props: {
          numArgs: 0,
          numOptionalArgs: 0,
          allowedInText: true
        },
        handler(_ref, args, optArgs) {
          var {
            parser: parser2
          } = _ref;
          var size = parser2.gullet.future().text === "[" ? parser2.parseSizeGroup(true) : null;
          var newLine = !parser2.settings.displayMode || !parser2.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
          return {
            type: "cr",
            mode: parser2.mode,
            newLine,
            size: size && assertNodeType(size, "size").value
          };
        },
        // The following builders are called only at the top level,
        // not within tabular/array environments.
        htmlBuilder(group, options2) {
          var span = buildCommon.makeSpan(["mspace"], [], options2);
          if (group.newLine) {
            span.classes.push("newline");
            if (group.size) {
              span.style.marginTop = makeEm(calculateSize(group.size, options2));
            }
          }
          return span;
        },
        mathmlBuilder(group, options2) {
          var node = new mathMLTree.MathNode("mspace");
          if (group.newLine) {
            node.setAttribute("linebreak", "newline");
            if (group.size) {
              node.setAttribute("height", makeEm(calculateSize(group.size, options2)));
            }
          }
          return node;
        }
      });
      globalMap = {
        "\\global": "\\global",
        "\\long": "\\\\globallong",
        "\\\\globallong": "\\\\globallong",
        "\\def": "\\gdef",
        "\\gdef": "\\gdef",
        "\\edef": "\\xdef",
        "\\xdef": "\\xdef",
        "\\let": "\\\\globallet",
        "\\futurelet": "\\\\globalfuture"
      };
      checkControlSequence = (tok) => {
        var name = tok.text;
        if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
          throw new ParseError("Expected a control sequence", tok);
        }
        return name;
      };
      getRHS = (parser2) => {
        var tok = parser2.gullet.popToken();
        if (tok.text === "=") {
          tok = parser2.gullet.popToken();
          if (tok.text === " ") {
            tok = parser2.gullet.popToken();
          }
        }
        return tok;
      };
      letCommand = (parser2, name, tok, global2) => {
        var macro = parser2.gullet.macros.get(tok.text);
        if (macro == null) {
          tok.noexpand = true;
          macro = {
            tokens: [tok],
            numArgs: 0,
            // reproduce the same behavior in expansion
            unexpandable: !parser2.gullet.isExpandable(tok.text)
          };
        }
        parser2.gullet.macros.set(name, macro, global2);
      };
      defineFunction({
        type: "internal",
        names: [
          "\\global",
          "\\long",
          "\\\\globallong"
          // can’t be entered directly
        ],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler(_ref) {
          var {
            parser: parser2,
            funcName
          } = _ref;
          parser2.consumeSpaces();
          var token = parser2.fetch();
          if (globalMap[token.text]) {
            if (funcName === "\\global" || funcName === "\\\\globallong") {
              token.text = globalMap[token.text];
            }
            return assertNodeType(parser2.parseFunction(), "internal");
          }
          throw new ParseError("Invalid token after macro prefix", token);
        }
      });
      defineFunction({
        type: "internal",
        names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler(_ref2) {
          var {
            parser: parser2,
            funcName
          } = _ref2;
          var tok = parser2.gullet.popToken();
          var name = tok.text;
          if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
            throw new ParseError("Expected a control sequence", tok);
          }
          var numArgs = 0;
          var insert;
          var delimiters2 = [[]];
          while (parser2.gullet.future().text !== "{") {
            tok = parser2.gullet.popToken();
            if (tok.text === "#") {
              if (parser2.gullet.future().text === "{") {
                insert = parser2.gullet.future();
                delimiters2[numArgs].push("{");
                break;
              }
              tok = parser2.gullet.popToken();
              if (!/^[1-9]$/.test(tok.text)) {
                throw new ParseError('Invalid argument number "' + tok.text + '"');
              }
              if (parseInt(tok.text) !== numArgs + 1) {
                throw new ParseError('Argument number "' + tok.text + '" out of order');
              }
              numArgs++;
              delimiters2.push([]);
            } else if (tok.text === "EOF") {
              throw new ParseError("Expected a macro definition");
            } else {
              delimiters2[numArgs].push(tok.text);
            }
          }
          var {
            tokens
          } = parser2.gullet.consumeArg();
          if (insert) {
            tokens.unshift(insert);
          }
          if (funcName === "\\edef" || funcName === "\\xdef") {
            tokens = parser2.gullet.expandTokens(tokens);
            tokens.reverse();
          }
          parser2.gullet.macros.set(name, {
            tokens,
            numArgs,
            delimiters: delimiters2
          }, funcName === globalMap[funcName]);
          return {
            type: "internal",
            mode: parser2.mode
          };
        }
      });
      defineFunction({
        type: "internal",
        names: [
          "\\let",
          "\\\\globallet"
          // can’t be entered directly
        ],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler(_ref3) {
          var {
            parser: parser2,
            funcName
          } = _ref3;
          var name = checkControlSequence(parser2.gullet.popToken());
          parser2.gullet.consumeSpaces();
          var tok = getRHS(parser2);
          letCommand(parser2, name, tok, funcName === "\\\\globallet");
          return {
            type: "internal",
            mode: parser2.mode
          };
        }
      });
      defineFunction({
        type: "internal",
        names: [
          "\\futurelet",
          "\\\\globalfuture"
          // can’t be entered directly
        ],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler(_ref4) {
          var {
            parser: parser2,
            funcName
          } = _ref4;
          var name = checkControlSequence(parser2.gullet.popToken());
          var middle = parser2.gullet.popToken();
          var tok = parser2.gullet.popToken();
          letCommand(parser2, name, tok, funcName === "\\\\globalfuture");
          parser2.gullet.pushToken(tok);
          parser2.gullet.pushToken(middle);
          return {
            type: "internal",
            mode: parser2.mode
          };
        }
      });
      getMetrics = function getMetrics2(symbol, font, mode) {
        var replace = symbols.math[symbol] && symbols.math[symbol].replace;
        var metrics = getCharacterMetrics(replace || symbol, font, mode);
        if (!metrics) {
          throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
        }
        return metrics;
      };
      styleWrap = function styleWrap2(delim, toStyle, options2, classes) {
        var newOptions = options2.havingBaseStyle(toStyle);
        var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options2)), [delim], options2);
        var delimSizeMultiplier = newOptions.sizeMultiplier / options2.sizeMultiplier;
        span.height *= delimSizeMultiplier;
        span.depth *= delimSizeMultiplier;
        span.maxFontSize = newOptions.sizeMultiplier;
        return span;
      };
      centerSpan = function centerSpan2(span, options2, style) {
        var newOptions = options2.havingBaseStyle(style);
        var shift = (1 - options2.sizeMultiplier / newOptions.sizeMultiplier) * options2.fontMetrics().axisHeight;
        span.classes.push("delimcenter");
        span.style.top = makeEm(shift);
        span.height -= shift;
        span.depth += shift;
      };
      makeSmallDelim = function makeSmallDelim2(delim, style, center, options2, mode, classes) {
        var text2 = buildCommon.makeSymbol(delim, "Main-Regular", mode, options2);
        var span = styleWrap(text2, style, options2, classes);
        if (center) {
          centerSpan(span, options2, style);
        }
        return span;
      };
      mathrmSize = function mathrmSize2(value, size, mode, options2) {
        return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options2);
      };
      makeLargeDelim = function makeLargeDelim2(delim, size, center, options2, mode, classes) {
        var inner2 = mathrmSize(delim, size, mode, options2);
        var span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner2], options2), Style$1.TEXT, options2, classes);
        if (center) {
          centerSpan(span, options2, Style$1.TEXT);
        }
        return span;
      };
      makeGlyphSpan = function makeGlyphSpan2(symbol, font, mode) {
        var sizeClass;
        if (font === "Size1-Regular") {
          sizeClass = "delim-size1";
        } else {
          sizeClass = "delim-size4";
        }
        var corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
        return {
          type: "elem",
          elem: corner
        };
      };
      makeInner = function makeInner2(ch, height, options2) {
        var width = fontMetricsData["Size4-Regular"][ch.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][ch.charCodeAt(0)][4] : fontMetricsData["Size1-Regular"][ch.charCodeAt(0)][4];
        var path2 = new PathNode("inner", innerPath(ch, Math.round(1e3 * height)));
        var svgNode = new SvgNode([path2], {
          "width": makeEm(width),
          "height": makeEm(height),
          // Override CSS rule `.katex svg { width: 100% }`
          "style": "width:" + makeEm(width),
          "viewBox": "0 0 " + 1e3 * width + " " + Math.round(1e3 * height),
          "preserveAspectRatio": "xMinYMin"
        });
        var span = buildCommon.makeSvgSpan([], [svgNode], options2);
        span.height = height;
        span.style.height = makeEm(height);
        span.style.width = makeEm(width);
        return {
          type: "elem",
          elem: span
        };
      };
      lapInEms = 8e-3;
      lap = {
        type: "kern",
        size: -1 * lapInEms
      };
      verts = ["|", "\\lvert", "\\rvert", "\\vert"];
      doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
      makeStackedDelim = function makeStackedDelim2(delim, heightTotal, center, options2, mode, classes) {
        var top;
        var middle;
        var repeat;
        var bottom;
        var svgLabel = "";
        var viewBoxWidth = 0;
        top = repeat = bottom = delim;
        middle = null;
        var font = "Size1-Regular";
        if (delim === "\\uparrow") {
          repeat = bottom = "\u23D0";
        } else if (delim === "\\Uparrow") {
          repeat = bottom = "\u2016";
        } else if (delim === "\\downarrow") {
          top = repeat = "\u23D0";
        } else if (delim === "\\Downarrow") {
          top = repeat = "\u2016";
        } else if (delim === "\\updownarrow") {
          top = "\\uparrow";
          repeat = "\u23D0";
          bottom = "\\downarrow";
        } else if (delim === "\\Updownarrow") {
          top = "\\Uparrow";
          repeat = "\u2016";
          bottom = "\\Downarrow";
        } else if (utils.contains(verts, delim)) {
          repeat = "\u2223";
          svgLabel = "vert";
          viewBoxWidth = 333;
        } else if (utils.contains(doubleVerts, delim)) {
          repeat = "\u2225";
          svgLabel = "doublevert";
          viewBoxWidth = 556;
        } else if (delim === "[" || delim === "\\lbrack") {
          top = "\u23A1";
          repeat = "\u23A2";
          bottom = "\u23A3";
          font = "Size4-Regular";
          svgLabel = "lbrack";
          viewBoxWidth = 667;
        } else if (delim === "]" || delim === "\\rbrack") {
          top = "\u23A4";
          repeat = "\u23A5";
          bottom = "\u23A6";
          font = "Size4-Regular";
          svgLabel = "rbrack";
          viewBoxWidth = 667;
        } else if (delim === "\\lfloor" || delim === "\u230A") {
          repeat = top = "\u23A2";
          bottom = "\u23A3";
          font = "Size4-Regular";
          svgLabel = "lfloor";
          viewBoxWidth = 667;
        } else if (delim === "\\lceil" || delim === "\u2308") {
          top = "\u23A1";
          repeat = bottom = "\u23A2";
          font = "Size4-Regular";
          svgLabel = "lceil";
          viewBoxWidth = 667;
        } else if (delim === "\\rfloor" || delim === "\u230B") {
          repeat = top = "\u23A5";
          bottom = "\u23A6";
          font = "Size4-Regular";
          svgLabel = "rfloor";
          viewBoxWidth = 667;
        } else if (delim === "\\rceil" || delim === "\u2309") {
          top = "\u23A4";
          repeat = bottom = "\u23A5";
          font = "Size4-Regular";
          svgLabel = "rceil";
          viewBoxWidth = 667;
        } else if (delim === "(" || delim === "\\lparen") {
          top = "\u239B";
          repeat = "\u239C";
          bottom = "\u239D";
          font = "Size4-Regular";
          svgLabel = "lparen";
          viewBoxWidth = 875;
        } else if (delim === ")" || delim === "\\rparen") {
          top = "\u239E";
          repeat = "\u239F";
          bottom = "\u23A0";
          font = "Size4-Regular";
          svgLabel = "rparen";
          viewBoxWidth = 875;
        } else if (delim === "\\{" || delim === "\\lbrace") {
          top = "\u23A7";
          middle = "\u23A8";
          bottom = "\u23A9";
          repeat = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\}" || delim === "\\rbrace") {
          top = "\u23AB";
          middle = "\u23AC";
          bottom = "\u23AD";
          repeat = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\lgroup" || delim === "\u27EE") {
          top = "\u23A7";
          bottom = "\u23A9";
          repeat = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\rgroup" || delim === "\u27EF") {
          top = "\u23AB";
          bottom = "\u23AD";
          repeat = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\lmoustache" || delim === "\u23B0") {
          top = "\u23A7";
          bottom = "\u23AD";
          repeat = "\u23AA";
          font = "Size4-Regular";
        } else if (delim === "\\rmoustache" || delim === "\u23B1") {
          top = "\u23AB";
          bottom = "\u23A9";
          repeat = "\u23AA";
          font = "Size4-Regular";
        }
        var topMetrics = getMetrics(top, font, mode);
        var topHeightTotal = topMetrics.height + topMetrics.depth;
        var repeatMetrics = getMetrics(repeat, font, mode);
        var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
        var bottomMetrics = getMetrics(bottom, font, mode);
        var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
        var middleHeightTotal = 0;
        var middleFactor = 1;
        if (middle !== null) {
          var middleMetrics = getMetrics(middle, font, mode);
          middleHeightTotal = middleMetrics.height + middleMetrics.depth;
          middleFactor = 2;
        }
        var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
        var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
        var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
        var axisHeight = options2.fontMetrics().axisHeight;
        if (center) {
          axisHeight *= options2.sizeMultiplier;
        }
        var depth = realHeightTotal / 2 - axisHeight;
        var stack = [];
        if (svgLabel.length > 0) {
          var midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
          var viewBoxHeight = Math.round(realHeightTotal * 1e3);
          var pathStr = tallDelim(svgLabel, Math.round(midHeight * 1e3));
          var path2 = new PathNode(svgLabel, pathStr);
          var width = (viewBoxWidth / 1e3).toFixed(3) + "em";
          var height = (viewBoxHeight / 1e3).toFixed(3) + "em";
          var svg = new SvgNode([path2], {
            "width": width,
            "height": height,
            "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight
          });
          var wrapper = buildCommon.makeSvgSpan([], [svg], options2);
          wrapper.height = viewBoxHeight / 1e3;
          wrapper.style.width = width;
          wrapper.style.height = height;
          stack.push({
            type: "elem",
            elem: wrapper
          });
        } else {
          stack.push(makeGlyphSpan(bottom, font, mode));
          stack.push(lap);
          if (middle === null) {
            var innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
            stack.push(makeInner(repeat, innerHeight, options2));
          } else {
            var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
            stack.push(makeInner(repeat, _innerHeight, options2));
            stack.push(lap);
            stack.push(makeGlyphSpan(middle, font, mode));
            stack.push(lap);
            stack.push(makeInner(repeat, _innerHeight, options2));
          }
          stack.push(lap);
          stack.push(makeGlyphSpan(top, font, mode));
        }
        var newOptions = options2.havingBaseStyle(Style$1.TEXT);
        var inner2 = buildCommon.makeVList({
          positionType: "bottom",
          positionData: depth,
          children: stack
        }, newOptions);
        return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner2], newOptions), Style$1.TEXT, options2, classes);
      };
      vbPad = 80;
      emPad = 0.08;
      sqrtSvg = function sqrtSvg2(sqrtName, height, viewBoxHeight, extraVinculum, options2) {
        var path2 = sqrtPath(sqrtName, extraVinculum, viewBoxHeight);
        var pathNode = new PathNode(sqrtName, path2);
        var svg = new SvgNode([pathNode], {
          // Note: 1000:1 ratio of viewBox to document em width.
          "width": "400em",
          "height": makeEm(height),
          "viewBox": "0 0 400000 " + viewBoxHeight,
          "preserveAspectRatio": "xMinYMin slice"
        });
        return buildCommon.makeSvgSpan(["hide-tail"], [svg], options2);
      };
      makeSqrtImage = function makeSqrtImage2(height, options2) {
        var newOptions = options2.havingBaseSizing();
        var delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
        var sizeMultiplier = newOptions.sizeMultiplier;
        var extraVinculum = Math.max(0, options2.minRuleThickness - options2.fontMetrics().sqrtRuleThickness);
        var span;
        var spanHeight = 0;
        var texHeight = 0;
        var viewBoxHeight = 0;
        var advanceWidth;
        if (delim.type === "small") {
          viewBoxHeight = 1e3 + 1e3 * extraVinculum + vbPad;
          if (height < 1) {
            sizeMultiplier = 1;
          } else if (height < 1.4) {
            sizeMultiplier = 0.7;
          }
          spanHeight = (1 + extraVinculum + emPad) / sizeMultiplier;
          texHeight = (1 + extraVinculum) / sizeMultiplier;
          span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraVinculum, options2);
          span.style.minWidth = "0.853em";
          advanceWidth = 0.833 / sizeMultiplier;
        } else if (delim.type === "large") {
          viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
          texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / sizeMultiplier;
          spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + emPad) / sizeMultiplier;
          span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options2);
          span.style.minWidth = "1.02em";
          advanceWidth = 1 / sizeMultiplier;
        } else {
          spanHeight = height + extraVinculum + emPad;
          texHeight = height + extraVinculum;
          viewBoxHeight = Math.floor(1e3 * height + extraVinculum) + vbPad;
          span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraVinculum, options2);
          span.style.minWidth = "0.742em";
          advanceWidth = 1.056;
        }
        span.height = texHeight;
        span.style.height = makeEm(spanHeight);
        return {
          span,
          advanceWidth,
          // Calculate the actual line width.
          // This actually should depend on the chosen font -- e.g. \boldmath
          // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
          // have thicker rules.
          ruleWidth: (options2.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier
        };
      };
      stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"];
      stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1"];
      stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
      sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
      makeSizedDelim = function makeSizedDelim2(delim, size, options2, mode, classes) {
        if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
          delim = "\\langle";
        } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
          delim = "\\rangle";
        }
        if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
          return makeLargeDelim(delim, size, false, options2, mode, classes);
        } else if (utils.contains(stackAlwaysDelimiters, delim)) {
          return makeStackedDelim(delim, sizeToMaxHeight[size], false, options2, mode, classes);
        } else {
          throw new ParseError("Illegal delimiter: '" + delim + "'");
        }
      };
      stackNeverDelimiterSequence = [{
        type: "small",
        style: Style$1.SCRIPTSCRIPT
      }, {
        type: "small",
        style: Style$1.SCRIPT
      }, {
        type: "small",
        style: Style$1.TEXT
      }, {
        type: "large",
        size: 1
      }, {
        type: "large",
        size: 2
      }, {
        type: "large",
        size: 3
      }, {
        type: "large",
        size: 4
      }];
      stackAlwaysDelimiterSequence = [{
        type: "small",
        style: Style$1.SCRIPTSCRIPT
      }, {
        type: "small",
        style: Style$1.SCRIPT
      }, {
        type: "small",
        style: Style$1.TEXT
      }, {
        type: "stack"
      }];
      stackLargeDelimiterSequence = [{
        type: "small",
        style: Style$1.SCRIPTSCRIPT
      }, {
        type: "small",
        style: Style$1.SCRIPT
      }, {
        type: "small",
        style: Style$1.TEXT
      }, {
        type: "large",
        size: 1
      }, {
        type: "large",
        size: 2
      }, {
        type: "large",
        size: 3
      }, {
        type: "large",
        size: 4
      }, {
        type: "stack"
      }];
      delimTypeToFont = function delimTypeToFont2(type) {
        if (type.type === "small") {
          return "Main-Regular";
        } else if (type.type === "large") {
          return "Size" + type.size + "-Regular";
        } else if (type.type === "stack") {
          return "Size4-Regular";
        } else {
          throw new Error("Add support for delim type '" + type.type + "' here.");
        }
      };
      traverseSequence = function traverseSequence2(delim, height, sequence, options2) {
        var start = Math.min(2, 3 - options2.style.size);
        for (var i = start; i < sequence.length; i++) {
          if (sequence[i].type === "stack") {
            break;
          }
          var metrics = getMetrics(delim, delimTypeToFont(sequence[i]), "math");
          var heightDepth = metrics.height + metrics.depth;
          if (sequence[i].type === "small") {
            var newOptions = options2.havingBaseStyle(sequence[i].style);
            heightDepth *= newOptions.sizeMultiplier;
          }
          if (heightDepth > height) {
            return sequence[i];
          }
        }
        return sequence[sequence.length - 1];
      };
      makeCustomSizedDelim = function makeCustomSizedDelim2(delim, height, center, options2, mode, classes) {
        if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
          delim = "\\langle";
        } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
          delim = "\\rangle";
        }
        var sequence;
        if (utils.contains(stackNeverDelimiters, delim)) {
          sequence = stackNeverDelimiterSequence;
        } else if (utils.contains(stackLargeDelimiters, delim)) {
          sequence = stackLargeDelimiterSequence;
        } else {
          sequence = stackAlwaysDelimiterSequence;
        }
        var delimType = traverseSequence(delim, height, sequence, options2);
        if (delimType.type === "small") {
          return makeSmallDelim(delim, delimType.style, center, options2, mode, classes);
        } else if (delimType.type === "large") {
          return makeLargeDelim(delim, delimType.size, center, options2, mode, classes);
        } else {
          return makeStackedDelim(delim, height, center, options2, mode, classes);
        }
      };
      makeLeftRightDelim = function makeLeftRightDelim2(delim, height, depth, options2, mode, classes) {
        var axisHeight = options2.fontMetrics().axisHeight * options2.sizeMultiplier;
        var delimiterFactor = 901;
        var delimiterExtend = 5 / options2.fontMetrics().ptPerEm;
        var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
        var totalHeight = Math.max(
          // In real TeX, calculations are done using integral values which are
          // 65536 per pt, or 655360 per em. So, the division here truncates in
          // TeX but doesn't here, producing different results. If we wanted to
          // exactly match TeX's calculation, we could do
          //   Math.floor(655360 * maxDistFromAxis / 500) *
          //    delimiterFactor / 655360
          // (To see the difference, compare
          //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
          // in TeX and KaTeX)
          maxDistFromAxis / 500 * delimiterFactor,
          2 * maxDistFromAxis - delimiterExtend
        );
        return makeCustomSizedDelim(delim, totalHeight, true, options2, mode, classes);
      };
      delimiter = {
        sqrtImage: makeSqrtImage,
        sizedDelim: makeSizedDelim,
        sizeToMaxHeight,
        customSizedDelim: makeCustomSizedDelim,
        leftRightDelim: makeLeftRightDelim
      };
      delimiterSizes = {
        "\\bigl": {
          mclass: "mopen",
          size: 1
        },
        "\\Bigl": {
          mclass: "mopen",
          size: 2
        },
        "\\biggl": {
          mclass: "mopen",
          size: 3
        },
        "\\Biggl": {
          mclass: "mopen",
          size: 4
        },
        "\\bigr": {
          mclass: "mclose",
          size: 1
        },
        "\\Bigr": {
          mclass: "mclose",
          size: 2
        },
        "\\biggr": {
          mclass: "mclose",
          size: 3
        },
        "\\Biggr": {
          mclass: "mclose",
          size: 4
        },
        "\\bigm": {
          mclass: "mrel",
          size: 1
        },
        "\\Bigm": {
          mclass: "mrel",
          size: 2
        },
        "\\biggm": {
          mclass: "mrel",
          size: 3
        },
        "\\Biggm": {
          mclass: "mrel",
          size: 4
        },
        "\\big": {
          mclass: "mord",
          size: 1
        },
        "\\Big": {
          mclass: "mord",
          size: 2
        },
        "\\bigg": {
          mclass: "mord",
          size: 3
        },
        "\\Bigg": {
          mclass: "mord",
          size: 4
        }
      };
      delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27E8", "\\rangle", "\u27E9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
      defineFunction({
        type: "delimsizing",
        names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
        props: {
          numArgs: 1,
          argTypes: ["primitive"]
        },
        handler: (context, args) => {
          var delim = checkDelimiter(args[0], context);
          return {
            type: "delimsizing",
            mode: context.parser.mode,
            size: delimiterSizes[context.funcName].size,
            mclass: delimiterSizes[context.funcName].mclass,
            delim: delim.text
          };
        },
        htmlBuilder: (group, options2) => {
          if (group.delim === ".") {
            return buildCommon.makeSpan([group.mclass]);
          }
          return delimiter.sizedDelim(group.delim, group.size, options2, group.mode, [group.mclass]);
        },
        mathmlBuilder: (group) => {
          var children = [];
          if (group.delim !== ".") {
            children.push(makeText(group.delim, group.mode));
          }
          var node = new mathMLTree.MathNode("mo", children);
          if (group.mclass === "mopen" || group.mclass === "mclose") {
            node.setAttribute("fence", "true");
          } else {
            node.setAttribute("fence", "false");
          }
          node.setAttribute("stretchy", "true");
          var size = makeEm(delimiter.sizeToMaxHeight[group.size]);
          node.setAttribute("minsize", size);
          node.setAttribute("maxsize", size);
          return node;
        }
      });
      defineFunction({
        type: "leftright-right",
        names: ["\\right"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: (context, args) => {
          var color = context.parser.gullet.macros.get("\\current@color");
          if (color && typeof color !== "string") {
            throw new ParseError("\\current@color set to non-string in \\right");
          }
          return {
            type: "leftright-right",
            mode: context.parser.mode,
            delim: checkDelimiter(args[0], context).text,
            color
            // undefined if not set via \color
          };
        }
      });
      defineFunction({
        type: "leftright",
        names: ["\\left"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: (context, args) => {
          var delim = checkDelimiter(args[0], context);
          var parser2 = context.parser;
          ++parser2.leftrightDepth;
          var body = parser2.parseExpression(false);
          --parser2.leftrightDepth;
          parser2.expect("\\right", false);
          var right = assertNodeType(parser2.parseFunction(), "leftright-right");
          return {
            type: "leftright",
            mode: parser2.mode,
            body,
            left: delim.text,
            right: right.delim,
            rightColor: right.color
          };
        },
        htmlBuilder: (group, options2) => {
          assertParsed(group);
          var inner2 = buildExpression$1(group.body, options2, true, ["mopen", "mclose"]);
          var innerHeight = 0;
          var innerDepth = 0;
          var hadMiddle = false;
          for (var i = 0; i < inner2.length; i++) {
            if (inner2[i].isMiddle) {
              hadMiddle = true;
            } else {
              innerHeight = Math.max(inner2[i].height, innerHeight);
              innerDepth = Math.max(inner2[i].depth, innerDepth);
            }
          }
          innerHeight *= options2.sizeMultiplier;
          innerDepth *= options2.sizeMultiplier;
          var leftDelim;
          if (group.left === ".") {
            leftDelim = makeNullDelimiter(options2, ["mopen"]);
          } else {
            leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options2, group.mode, ["mopen"]);
          }
          inner2.unshift(leftDelim);
          if (hadMiddle) {
            for (var _i = 1; _i < inner2.length; _i++) {
              var middleDelim = inner2[_i];
              var isMiddle = middleDelim.isMiddle;
              if (isMiddle) {
                inner2[_i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
              }
            }
          }
          var rightDelim;
          if (group.right === ".") {
            rightDelim = makeNullDelimiter(options2, ["mclose"]);
          } else {
            var colorOptions = group.rightColor ? options2.withColor(group.rightColor) : options2;
            rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
          }
          inner2.push(rightDelim);
          return buildCommon.makeSpan(["minner"], inner2, options2);
        },
        mathmlBuilder: (group, options2) => {
          assertParsed(group);
          var inner2 = buildExpression2(group.body, options2);
          if (group.left !== ".") {
            var leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
            leftNode.setAttribute("fence", "true");
            inner2.unshift(leftNode);
          }
          if (group.right !== ".") {
            var rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
            rightNode.setAttribute("fence", "true");
            if (group.rightColor) {
              rightNode.setAttribute("mathcolor", group.rightColor);
            }
            inner2.push(rightNode);
          }
          return makeRow(inner2);
        }
      });
      defineFunction({
        type: "middle",
        names: ["\\middle"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: (context, args) => {
          var delim = checkDelimiter(args[0], context);
          if (!context.parser.leftrightDepth) {
            throw new ParseError("\\middle without preceding \\left", delim);
          }
          return {
            type: "middle",
            mode: context.parser.mode,
            delim: delim.text
          };
        },
        htmlBuilder: (group, options2) => {
          var middleDelim;
          if (group.delim === ".") {
            middleDelim = makeNullDelimiter(options2, []);
          } else {
            middleDelim = delimiter.sizedDelim(group.delim, 1, options2, group.mode, []);
            var isMiddle = {
              delim: group.delim,
              options: options2
            };
            middleDelim.isMiddle = isMiddle;
          }
          return middleDelim;
        },
        mathmlBuilder: (group, options2) => {
          var textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
          var middleNode = new mathMLTree.MathNode("mo", [textNode]);
          middleNode.setAttribute("fence", "true");
          middleNode.setAttribute("lspace", "0.05em");
          middleNode.setAttribute("rspace", "0.05em");
          return middleNode;
        }
      });
      htmlBuilder$7 = (group, options2) => {
        var inner2 = buildCommon.wrapFragment(buildGroup$1(group.body, options2), options2);
        var label = group.label.slice(1);
        var scale = options2.sizeMultiplier;
        var img;
        var imgShift = 0;
        var isSingleChar = utils.isCharacterBox(group.body);
        if (label === "sout") {
          img = buildCommon.makeSpan(["stretchy", "sout"]);
          img.height = options2.fontMetrics().defaultRuleThickness / scale;
          imgShift = -0.5 * options2.fontMetrics().xHeight;
        } else if (label === "phase") {
          var lineWeight = calculateSize({
            number: 0.6,
            unit: "pt"
          }, options2);
          var clearance = calculateSize({
            number: 0.35,
            unit: "ex"
          }, options2);
          var newOptions = options2.havingBaseSizing();
          scale = scale / newOptions.sizeMultiplier;
          var angleHeight = inner2.height + inner2.depth + lineWeight + clearance;
          inner2.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight);
          var viewBoxHeight = Math.floor(1e3 * angleHeight * scale);
          var path2 = phasePath(viewBoxHeight);
          var svgNode = new SvgNode([new PathNode("phase", path2)], {
            "width": "400em",
            "height": makeEm(viewBoxHeight / 1e3),
            "viewBox": "0 0 400000 " + viewBoxHeight,
            "preserveAspectRatio": "xMinYMin slice"
          });
          img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode], options2);
          img.style.height = makeEm(angleHeight);
          imgShift = inner2.depth + lineWeight + clearance;
        } else {
          if (/cancel/.test(label)) {
            if (!isSingleChar) {
              inner2.classes.push("cancel-pad");
            }
          } else if (label === "angl") {
            inner2.classes.push("anglpad");
          } else {
            inner2.classes.push("boxpad");
          }
          var topPad = 0;
          var bottomPad = 0;
          var ruleThickness = 0;
          if (/box/.test(label)) {
            ruleThickness = Math.max(
              options2.fontMetrics().fboxrule,
              // default
              options2.minRuleThickness
              // User override.
            );
            topPad = options2.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
            bottomPad = topPad;
          } else if (label === "angl") {
            ruleThickness = Math.max(options2.fontMetrics().defaultRuleThickness, options2.minRuleThickness);
            topPad = 4 * ruleThickness;
            bottomPad = Math.max(0, 0.25 - inner2.depth);
          } else {
            topPad = isSingleChar ? 0.2 : 0;
            bottomPad = topPad;
          }
          img = stretchy.encloseSpan(inner2, label, topPad, bottomPad, options2);
          if (/fbox|boxed|fcolorbox/.test(label)) {
            img.style.borderStyle = "solid";
            img.style.borderWidth = makeEm(ruleThickness);
          } else if (label === "angl" && ruleThickness !== 0.049) {
            img.style.borderTopWidth = makeEm(ruleThickness);
            img.style.borderRightWidth = makeEm(ruleThickness);
          }
          imgShift = inner2.depth + bottomPad;
          if (group.backgroundColor) {
            img.style.backgroundColor = group.backgroundColor;
            if (group.borderColor) {
              img.style.borderColor = group.borderColor;
            }
          }
        }
        var vlist;
        if (group.backgroundColor) {
          vlist = buildCommon.makeVList({
            positionType: "individualShift",
            children: [
              // Put the color background behind inner;
              {
                type: "elem",
                elem: img,
                shift: imgShift
              },
              {
                type: "elem",
                elem: inner2,
                shift: 0
              }
            ]
          }, options2);
        } else {
          var classes = /cancel|phase/.test(label) ? ["svg-align"] : [];
          vlist = buildCommon.makeVList({
            positionType: "individualShift",
            children: [
              // Write the \cancel stroke on top of inner.
              {
                type: "elem",
                elem: inner2,
                shift: 0
              },
              {
                type: "elem",
                elem: img,
                shift: imgShift,
                wrapperClasses: classes
              }
            ]
          }, options2);
        }
        if (/cancel/.test(label)) {
          vlist.height = inner2.height;
          vlist.depth = inner2.depth;
        }
        if (/cancel/.test(label) && !isSingleChar) {
          return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options2);
        } else {
          return buildCommon.makeSpan(["mord"], [vlist], options2);
        }
      };
      mathmlBuilder$6 = (group, options2) => {
        var fboxsep = 0;
        var node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildGroup2(group.body, options2)]);
        switch (group.label) {
          case "\\cancel":
            node.setAttribute("notation", "updiagonalstrike");
            break;
          case "\\bcancel":
            node.setAttribute("notation", "downdiagonalstrike");
            break;
          case "\\phase":
            node.setAttribute("notation", "phasorangle");
            break;
          case "\\sout":
            node.setAttribute("notation", "horizontalstrike");
            break;
          case "\\fbox":
            node.setAttribute("notation", "box");
            break;
          case "\\angl":
            node.setAttribute("notation", "actuarial");
            break;
          case "\\fcolorbox":
          case "\\colorbox":
            fboxsep = options2.fontMetrics().fboxsep * options2.fontMetrics().ptPerEm;
            node.setAttribute("width", "+" + 2 * fboxsep + "pt");
            node.setAttribute("height", "+" + 2 * fboxsep + "pt");
            node.setAttribute("lspace", fboxsep + "pt");
            node.setAttribute("voffset", fboxsep + "pt");
            if (group.label === "\\fcolorbox") {
              var thk = Math.max(
                options2.fontMetrics().fboxrule,
                // default
                options2.minRuleThickness
                // user override
              );
              node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
            }
            break;
          case "\\xcancel":
            node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
            break;
        }
        if (group.backgroundColor) {
          node.setAttribute("mathbackground", group.backgroundColor);
        }
        return node;
      };
      defineFunction({
        type: "enclose",
        names: ["\\colorbox"],
        props: {
          numArgs: 2,
          allowedInText: true,
          argTypes: ["color", "text"]
        },
        handler(_ref, args, optArgs) {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var color = assertNodeType(args[0], "color-token").color;
          var body = args[1];
          return {
            type: "enclose",
            mode: parser2.mode,
            label: funcName,
            backgroundColor: color,
            body
          };
        },
        htmlBuilder: htmlBuilder$7,
        mathmlBuilder: mathmlBuilder$6
      });
      defineFunction({
        type: "enclose",
        names: ["\\fcolorbox"],
        props: {
          numArgs: 3,
          allowedInText: true,
          argTypes: ["color", "color", "text"]
        },
        handler(_ref2, args, optArgs) {
          var {
            parser: parser2,
            funcName
          } = _ref2;
          var borderColor = assertNodeType(args[0], "color-token").color;
          var backgroundColor = assertNodeType(args[1], "color-token").color;
          var body = args[2];
          return {
            type: "enclose",
            mode: parser2.mode,
            label: funcName,
            backgroundColor,
            borderColor,
            body
          };
        },
        htmlBuilder: htmlBuilder$7,
        mathmlBuilder: mathmlBuilder$6
      });
      defineFunction({
        type: "enclose",
        names: ["\\fbox"],
        props: {
          numArgs: 1,
          argTypes: ["hbox"],
          allowedInText: true
        },
        handler(_ref3, args) {
          var {
            parser: parser2
          } = _ref3;
          return {
            type: "enclose",
            mode: parser2.mode,
            label: "\\fbox",
            body: args[0]
          };
        }
      });
      defineFunction({
        type: "enclose",
        names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
        props: {
          numArgs: 1
        },
        handler(_ref4, args) {
          var {
            parser: parser2,
            funcName
          } = _ref4;
          var body = args[0];
          return {
            type: "enclose",
            mode: parser2.mode,
            label: funcName,
            body
          };
        },
        htmlBuilder: htmlBuilder$7,
        mathmlBuilder: mathmlBuilder$6
      });
      defineFunction({
        type: "enclose",
        names: ["\\angl"],
        props: {
          numArgs: 1,
          argTypes: ["hbox"],
          allowedInText: false
        },
        handler(_ref5, args) {
          var {
            parser: parser2
          } = _ref5;
          return {
            type: "enclose",
            mode: parser2.mode,
            label: "\\angl",
            body: args[0]
          };
        }
      });
      _environments = {};
      _macros = {};
      validateAmsEnvironmentContext = (context) => {
        var settings = context.parser.settings;
        if (!settings.displayMode) {
          throw new ParseError("{" + context.envName + "} can be used only in display mode.");
        }
      };
      htmlBuilder$6 = function htmlBuilder(group, options2) {
        var r;
        var c;
        var nr = group.body.length;
        var hLinesBeforeRow = group.hLinesBeforeRow;
        var nc = 0;
        var body = new Array(nr);
        var hlines = [];
        var ruleThickness = Math.max(
          // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
          options2.fontMetrics().arrayRuleWidth,
          options2.minRuleThickness
          // User override.
        );
        var pt = 1 / options2.fontMetrics().ptPerEm;
        var arraycolsep = 5 * pt;
        if (group.colSeparationType && group.colSeparationType === "small") {
          var localMultiplier = options2.havingStyle(Style$1.SCRIPT).sizeMultiplier;
          arraycolsep = 0.2778 * (localMultiplier / options2.sizeMultiplier);
        }
        var baselineskip = group.colSeparationType === "CD" ? calculateSize({
          number: 3,
          unit: "ex"
        }, options2) : 12 * pt;
        var jot = 3 * pt;
        var arrayskip = group.arraystretch * baselineskip;
        var arstrutHeight = 0.7 * arrayskip;
        var arstrutDepth = 0.3 * arrayskip;
        var totalHeight = 0;
        function setHLinePos(hlinesInGap) {
          for (var i = 0; i < hlinesInGap.length; ++i) {
            if (i > 0) {
              totalHeight += 0.25;
            }
            hlines.push({
              pos: totalHeight,
              isDashed: hlinesInGap[i]
            });
          }
        }
        setHLinePos(hLinesBeforeRow[0]);
        for (r = 0; r < group.body.length; ++r) {
          var inrow = group.body[r];
          var height = arstrutHeight;
          var depth = arstrutDepth;
          if (nc < inrow.length) {
            nc = inrow.length;
          }
          var outrow = new Array(inrow.length);
          for (c = 0; c < inrow.length; ++c) {
            var elt = buildGroup$1(inrow[c], options2);
            if (depth < elt.depth) {
              depth = elt.depth;
            }
            if (height < elt.height) {
              height = elt.height;
            }
            outrow[c] = elt;
          }
          var rowGap = group.rowGaps[r];
          var gap = 0;
          if (rowGap) {
            gap = calculateSize(rowGap, options2);
            if (gap > 0) {
              gap += arstrutDepth;
              if (depth < gap) {
                depth = gap;
              }
              gap = 0;
            }
          }
          if (group.addJot) {
            depth += jot;
          }
          outrow.height = height;
          outrow.depth = depth;
          totalHeight += height;
          outrow.pos = totalHeight;
          totalHeight += depth + gap;
          body[r] = outrow;
          setHLinePos(hLinesBeforeRow[r + 1]);
        }
        var offset = totalHeight / 2 + options2.fontMetrics().axisHeight;
        var colDescriptions = group.cols || [];
        var cols = [];
        var colSep;
        var colDescrNum;
        var tagSpans = [];
        if (group.tags && group.tags.some((tag3) => tag3)) {
          for (r = 0; r < nr; ++r) {
            var rw = body[r];
            var shift = rw.pos - offset;
            var tag2 = group.tags[r];
            var tagSpan = void 0;
            if (tag2 === true) {
              tagSpan = buildCommon.makeSpan(["eqn-num"], [], options2);
            } else if (tag2 === false) {
              tagSpan = buildCommon.makeSpan([], [], options2);
            } else {
              tagSpan = buildCommon.makeSpan([], buildExpression$1(tag2, options2, true), options2);
            }
            tagSpan.depth = rw.depth;
            tagSpan.height = rw.height;
            tagSpans.push({
              type: "elem",
              elem: tagSpan,
              shift
            });
          }
        }
        for (
          c = 0, colDescrNum = 0;
          // Continue while either there are more columns or more column
          // descriptions, so trailing separators don't get lost.
          c < nc || colDescrNum < colDescriptions.length;
          ++c, ++colDescrNum
        ) {
          var colDescr = colDescriptions[colDescrNum] || {};
          var firstSeparator = true;
          while (colDescr.type === "separator") {
            if (!firstSeparator) {
              colSep = buildCommon.makeSpan(["arraycolsep"], []);
              colSep.style.width = makeEm(options2.fontMetrics().doubleRuleSep);
              cols.push(colSep);
            }
            if (colDescr.separator === "|" || colDescr.separator === ":") {
              var lineType = colDescr.separator === "|" ? "solid" : "dashed";
              var separator = buildCommon.makeSpan(["vertical-separator"], [], options2);
              separator.style.height = makeEm(totalHeight);
              separator.style.borderRightWidth = makeEm(ruleThickness);
              separator.style.borderRightStyle = lineType;
              separator.style.margin = "0 " + makeEm(-ruleThickness / 2);
              var _shift = totalHeight - offset;
              if (_shift) {
                separator.style.verticalAlign = makeEm(-_shift);
              }
              cols.push(separator);
            } else {
              throw new ParseError("Invalid separator type: " + colDescr.separator);
            }
            colDescrNum++;
            colDescr = colDescriptions[colDescrNum] || {};
            firstSeparator = false;
          }
          if (c >= nc) {
            continue;
          }
          var sepwidth = void 0;
          if (c > 0 || group.hskipBeforeAndAfter) {
            sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
            if (sepwidth !== 0) {
              colSep = buildCommon.makeSpan(["arraycolsep"], []);
              colSep.style.width = makeEm(sepwidth);
              cols.push(colSep);
            }
          }
          var col = [];
          for (r = 0; r < nr; ++r) {
            var row = body[r];
            var elem = row[c];
            if (!elem) {
              continue;
            }
            var _shift2 = row.pos - offset;
            elem.depth = row.depth;
            elem.height = row.height;
            col.push({
              type: "elem",
              elem,
              shift: _shift2
            });
          }
          col = buildCommon.makeVList({
            positionType: "individualShift",
            children: col
          }, options2);
          col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
          cols.push(col);
          if (c < nc - 1 || group.hskipBeforeAndAfter) {
            sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
            if (sepwidth !== 0) {
              colSep = buildCommon.makeSpan(["arraycolsep"], []);
              colSep.style.width = makeEm(sepwidth);
              cols.push(colSep);
            }
          }
        }
        body = buildCommon.makeSpan(["mtable"], cols);
        if (hlines.length > 0) {
          var line = buildCommon.makeLineSpan("hline", options2, ruleThickness);
          var dashes = buildCommon.makeLineSpan("hdashline", options2, ruleThickness);
          var vListElems = [{
            type: "elem",
            elem: body,
            shift: 0
          }];
          while (hlines.length > 0) {
            var hline = hlines.pop();
            var lineShift = hline.pos - offset;
            if (hline.isDashed) {
              vListElems.push({
                type: "elem",
                elem: dashes,
                shift: lineShift
              });
            } else {
              vListElems.push({
                type: "elem",
                elem: line,
                shift: lineShift
              });
            }
          }
          body = buildCommon.makeVList({
            positionType: "individualShift",
            children: vListElems
          }, options2);
        }
        if (tagSpans.length === 0) {
          return buildCommon.makeSpan(["mord"], [body], options2);
        } else {
          var eqnNumCol = buildCommon.makeVList({
            positionType: "individualShift",
            children: tagSpans
          }, options2);
          eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options2);
          return buildCommon.makeFragment([body, eqnNumCol]);
        }
      };
      alignMap = {
        c: "center ",
        l: "left ",
        r: "right "
      };
      mathmlBuilder$5 = function mathmlBuilder(group, options2) {
        var tbl = [];
        var glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
        var tag2 = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
        for (var i = 0; i < group.body.length; i++) {
          var rw = group.body[i];
          var row = [];
          for (var j = 0; j < rw.length; j++) {
            row.push(new mathMLTree.MathNode("mtd", [buildGroup2(rw[j], options2)]));
          }
          if (group.tags && group.tags[i]) {
            row.unshift(glue);
            row.push(glue);
            if (group.leqno) {
              row.unshift(tag2);
            } else {
              row.push(tag2);
            }
          }
          tbl.push(new mathMLTree.MathNode("mtr", row));
        }
        var table = new mathMLTree.MathNode("mtable", tbl);
        var gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
        table.setAttribute("rowspacing", makeEm(gap));
        var menclose = "";
        var align = "";
        if (group.cols && group.cols.length > 0) {
          var cols = group.cols;
          var columnLines = "";
          var prevTypeWasAlign = false;
          var iStart = 0;
          var iEnd = cols.length;
          if (cols[0].type === "separator") {
            menclose += "top ";
            iStart = 1;
          }
          if (cols[cols.length - 1].type === "separator") {
            menclose += "bottom ";
            iEnd -= 1;
          }
          for (var _i = iStart; _i < iEnd; _i++) {
            if (cols[_i].type === "align") {
              align += alignMap[cols[_i].align];
              if (prevTypeWasAlign) {
                columnLines += "none ";
              }
              prevTypeWasAlign = true;
            } else if (cols[_i].type === "separator") {
              if (prevTypeWasAlign) {
                columnLines += cols[_i].separator === "|" ? "solid " : "dashed ";
                prevTypeWasAlign = false;
              }
            }
          }
          table.setAttribute("columnalign", align.trim());
          if (/[sd]/.test(columnLines)) {
            table.setAttribute("columnlines", columnLines.trim());
          }
        }
        if (group.colSeparationType === "align") {
          var _cols = group.cols || [];
          var spacing2 = "";
          for (var _i2 = 1; _i2 < _cols.length; _i2++) {
            spacing2 += _i2 % 2 ? "0em " : "1em ";
          }
          table.setAttribute("columnspacing", spacing2.trim());
        } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
          table.setAttribute("columnspacing", "0em");
        } else if (group.colSeparationType === "small") {
          table.setAttribute("columnspacing", "0.2778em");
        } else if (group.colSeparationType === "CD") {
          table.setAttribute("columnspacing", "0.5em");
        } else {
          table.setAttribute("columnspacing", "1em");
        }
        var rowLines = "";
        var hlines = group.hLinesBeforeRow;
        menclose += hlines[0].length > 0 ? "left " : "";
        menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
        for (var _i3 = 1; _i3 < hlines.length - 1; _i3++) {
          rowLines += hlines[_i3].length === 0 ? "none " : hlines[_i3][0] ? "dashed " : "solid ";
        }
        if (/[sd]/.test(rowLines)) {
          table.setAttribute("rowlines", rowLines.trim());
        }
        if (menclose !== "") {
          table = new mathMLTree.MathNode("menclose", [table]);
          table.setAttribute("notation", menclose.trim());
        }
        if (group.arraystretch && group.arraystretch < 1) {
          table = new mathMLTree.MathNode("mstyle", [table]);
          table.setAttribute("scriptlevel", "1");
        }
        return table;
      };
      alignedHandler = function alignedHandler2(context, args) {
        if (context.envName.indexOf("ed") === -1) {
          validateAmsEnvironmentContext(context);
        }
        var cols = [];
        var separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
        var isSplit = context.envName === "split";
        var res = parseArray(context.parser, {
          cols,
          addJot: true,
          autoTag: isSplit ? void 0 : getAutoTag(context.envName),
          emptySingleRow: true,
          colSeparationType: separationType,
          maxNumCols: isSplit ? 2 : void 0,
          leqno: context.parser.settings.leqno
        }, "display");
        var numMaths;
        var numCols = 0;
        var emptyGroup = {
          type: "ordgroup",
          mode: context.mode,
          body: []
        };
        if (args[0] && args[0].type === "ordgroup") {
          var arg0 = "";
          for (var i = 0; i < args[0].body.length; i++) {
            var textord2 = assertNodeType(args[0].body[i], "textord");
            arg0 += textord2.text;
          }
          numMaths = Number(arg0);
          numCols = numMaths * 2;
        }
        var isAligned = !numCols;
        res.body.forEach(function(row) {
          for (var _i4 = 1; _i4 < row.length; _i4 += 2) {
            var styling = assertNodeType(row[_i4], "styling");
            var ordgroup = assertNodeType(styling.body[0], "ordgroup");
            ordgroup.body.unshift(emptyGroup);
          }
          if (!isAligned) {
            var curMaths = row.length / 2;
            if (numMaths < curMaths) {
              throw new ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
            }
          } else if (numCols < row.length) {
            numCols = row.length;
          }
        });
        for (var _i5 = 0; _i5 < numCols; ++_i5) {
          var align = "r";
          var pregap = 0;
          if (_i5 % 2 === 1) {
            align = "l";
          } else if (_i5 > 0 && isAligned) {
            pregap = 1;
          }
          cols[_i5] = {
            type: "align",
            align,
            pregap,
            postgap: 0
          };
        }
        res.colSeparationType = isAligned ? "align" : "alignat";
        return res;
      };
      defineEnvironment({
        type: "array",
        names: ["array", "darray"],
        props: {
          numArgs: 1
        },
        handler(context, args) {
          var symNode = checkSymbolNodeType(args[0]);
          var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
          var cols = colalign.map(function(nde) {
            var node = assertSymbolNodeType(nde);
            var ca = node.text;
            if ("lcr".indexOf(ca) !== -1) {
              return {
                type: "align",
                align: ca
              };
            } else if (ca === "|") {
              return {
                type: "separator",
                separator: "|"
              };
            } else if (ca === ":") {
              return {
                type: "separator",
                separator: ":"
              };
            }
            throw new ParseError("Unknown column alignment: " + ca, nde);
          });
          var res = {
            cols,
            hskipBeforeAndAfter: true,
            // \@preamble in lttab.dtx
            maxNumCols: cols.length
          };
          return parseArray(context.parser, res, dCellStyle(context.envName));
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
        props: {
          numArgs: 0
        },
        handler(context) {
          var delimiters2 = {
            "matrix": null,
            "pmatrix": ["(", ")"],
            "bmatrix": ["[", "]"],
            "Bmatrix": ["\\{", "\\}"],
            "vmatrix": ["|", "|"],
            "Vmatrix": ["\\Vert", "\\Vert"]
          }[context.envName.replace("*", "")];
          var colAlign = "c";
          var payload = {
            hskipBeforeAndAfter: false,
            cols: [{
              type: "align",
              align: colAlign
            }]
          };
          if (context.envName.charAt(context.envName.length - 1) === "*") {
            var parser2 = context.parser;
            parser2.consumeSpaces();
            if (parser2.fetch().text === "[") {
              parser2.consume();
              parser2.consumeSpaces();
              colAlign = parser2.fetch().text;
              if ("lcr".indexOf(colAlign) === -1) {
                throw new ParseError("Expected l or c or r", parser2.nextToken);
              }
              parser2.consume();
              parser2.consumeSpaces();
              parser2.expect("]");
              parser2.consume();
              payload.cols = [{
                type: "align",
                align: colAlign
              }];
            }
          }
          var res = parseArray(context.parser, payload, dCellStyle(context.envName));
          var numCols = Math.max(0, ...res.body.map((row) => row.length));
          res.cols = new Array(numCols).fill({
            type: "align",
            align: colAlign
          });
          return delimiters2 ? {
            type: "leftright",
            mode: context.mode,
            body: [res],
            left: delimiters2[0],
            right: delimiters2[1],
            rightColor: void 0
            // \right uninfluenced by \color in array
          } : res;
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["smallmatrix"],
        props: {
          numArgs: 0
        },
        handler(context) {
          var payload = {
            arraystretch: 0.5
          };
          var res = parseArray(context.parser, payload, "script");
          res.colSeparationType = "small";
          return res;
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["subarray"],
        props: {
          numArgs: 1
        },
        handler(context, args) {
          var symNode = checkSymbolNodeType(args[0]);
          var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
          var cols = colalign.map(function(nde) {
            var node = assertSymbolNodeType(nde);
            var ca = node.text;
            if ("lc".indexOf(ca) !== -1) {
              return {
                type: "align",
                align: ca
              };
            }
            throw new ParseError("Unknown column alignment: " + ca, nde);
          });
          if (cols.length > 1) {
            throw new ParseError("{subarray} can contain only one column");
          }
          var res = {
            cols,
            hskipBeforeAndAfter: false,
            arraystretch: 0.5
          };
          res = parseArray(context.parser, res, "script");
          if (res.body.length > 0 && res.body[0].length > 1) {
            throw new ParseError("{subarray} can contain only one column");
          }
          return res;
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["cases", "dcases", "rcases", "drcases"],
        props: {
          numArgs: 0
        },
        handler(context) {
          var payload = {
            arraystretch: 1.2,
            cols: [{
              type: "align",
              align: "l",
              pregap: 0,
              // TODO(kevinb) get the current style.
              // For now we use the metrics for TEXT style which is what we were
              // doing before.  Before attempting to get the current style we
              // should look at TeX's behavior especially for \over and matrices.
              postgap: 1
              /* 1em quad */
            }, {
              type: "align",
              align: "l",
              pregap: 0,
              postgap: 0
            }]
          };
          var res = parseArray(context.parser, payload, dCellStyle(context.envName));
          return {
            type: "leftright",
            mode: context.mode,
            body: [res],
            left: context.envName.indexOf("r") > -1 ? "." : "\\{",
            right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
            rightColor: void 0
          };
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["align", "align*", "aligned", "split"],
        props: {
          numArgs: 0
        },
        handler: alignedHandler,
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["gathered", "gather", "gather*"],
        props: {
          numArgs: 0
        },
        handler(context) {
          if (utils.contains(["gather", "gather*"], context.envName)) {
            validateAmsEnvironmentContext(context);
          }
          var res = {
            cols: [{
              type: "align",
              align: "c"
            }],
            addJot: true,
            colSeparationType: "gather",
            autoTag: getAutoTag(context.envName),
            emptySingleRow: true,
            leqno: context.parser.settings.leqno
          };
          return parseArray(context.parser, res, "display");
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["alignat", "alignat*", "alignedat"],
        props: {
          numArgs: 1
        },
        handler: alignedHandler,
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["equation", "equation*"],
        props: {
          numArgs: 0
        },
        handler(context) {
          validateAmsEnvironmentContext(context);
          var res = {
            autoTag: getAutoTag(context.envName),
            emptySingleRow: true,
            singleRow: true,
            maxNumCols: 1,
            leqno: context.parser.settings.leqno
          };
          return parseArray(context.parser, res, "display");
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineEnvironment({
        type: "array",
        names: ["CD"],
        props: {
          numArgs: 0
        },
        handler(context) {
          validateAmsEnvironmentContext(context);
          return parseCD(context.parser);
        },
        htmlBuilder: htmlBuilder$6,
        mathmlBuilder: mathmlBuilder$5
      });
      defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
      defineMacro("\\notag", "\\nonumber");
      defineFunction({
        type: "text",
        // Doesn't matter what this is.
        names: ["\\hline", "\\hdashline"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: true
        },
        handler(context, args) {
          throw new ParseError(context.funcName + " valid only within array environment");
        }
      });
      environments = _environments;
      defineFunction({
        type: "environment",
        names: ["\\begin", "\\end"],
        props: {
          numArgs: 1,
          argTypes: ["text"]
        },
        handler(_ref, args) {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var nameGroup = args[0];
          if (nameGroup.type !== "ordgroup") {
            throw new ParseError("Invalid environment name", nameGroup);
          }
          var envName = "";
          for (var i = 0; i < nameGroup.body.length; ++i) {
            envName += assertNodeType(nameGroup.body[i], "textord").text;
          }
          if (funcName === "\\begin") {
            if (!environments.hasOwnProperty(envName)) {
              throw new ParseError("No such environment: " + envName, nameGroup);
            }
            var env = environments[envName];
            var {
              args: _args,
              optArgs
            } = parser2.parseArguments("\\begin{" + envName + "}", env);
            var context = {
              mode: parser2.mode,
              envName,
              parser: parser2
            };
            var result = env.handler(context, _args, optArgs);
            parser2.expect("\\end", false);
            var endNameToken = parser2.nextToken;
            var end = assertNodeType(parser2.parseFunction(), "environment");
            if (end.name !== envName) {
              throw new ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
            }
            return result;
          }
          return {
            type: "environment",
            mode: parser2.mode,
            name: envName,
            nameGroup
          };
        }
      });
      htmlBuilder$5 = (group, options2) => {
        var font = group.font;
        var newOptions = options2.withFont(font);
        return buildGroup$1(group.body, newOptions);
      };
      mathmlBuilder$4 = (group, options2) => {
        var font = group.font;
        var newOptions = options2.withFont(font);
        return buildGroup2(group.body, newOptions);
      };
      fontAliases = {
        "\\Bbb": "\\mathbb",
        "\\bold": "\\mathbf",
        "\\frak": "\\mathfrak",
        "\\bm": "\\boldsymbol"
      };
      defineFunction({
        type: "font",
        names: [
          // styles, except \boldsymbol defined below
          "\\mathrm",
          "\\mathit",
          "\\mathbf",
          "\\mathnormal",
          "\\mathsfit",
          // families
          "\\mathbb",
          "\\mathcal",
          "\\mathfrak",
          "\\mathscr",
          "\\mathsf",
          "\\mathtt",
          // aliases, except \bm defined below
          "\\Bbb",
          "\\bold",
          "\\frak"
        ],
        props: {
          numArgs: 1,
          allowedInArgument: true
        },
        handler: (_ref, args) => {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var body = normalizeArgument(args[0]);
          var func = funcName;
          if (func in fontAliases) {
            func = fontAliases[func];
          }
          return {
            type: "font",
            mode: parser2.mode,
            font: func.slice(1),
            body
          };
        },
        htmlBuilder: htmlBuilder$5,
        mathmlBuilder: mathmlBuilder$4
      });
      defineFunction({
        type: "mclass",
        names: ["\\boldsymbol", "\\bm"],
        props: {
          numArgs: 1
        },
        handler: (_ref2, args) => {
          var {
            parser: parser2
          } = _ref2;
          var body = args[0];
          var isCharacterBox3 = utils.isCharacterBox(body);
          return {
            type: "mclass",
            mode: parser2.mode,
            mclass: binrelClass(body),
            body: [{
              type: "font",
              mode: parser2.mode,
              font: "boldsymbol",
              body
            }],
            isCharacterBox: isCharacterBox3
          };
        }
      });
      defineFunction({
        type: "font",
        names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: (_ref3, args) => {
          var {
            parser: parser2,
            funcName,
            breakOnTokenText
          } = _ref3;
          var {
            mode
          } = parser2;
          var body = parser2.parseExpression(true, breakOnTokenText);
          var style = "math" + funcName.slice(1);
          return {
            type: "font",
            mode,
            font: style,
            body: {
              type: "ordgroup",
              mode: parser2.mode,
              body
            }
          };
        },
        htmlBuilder: htmlBuilder$5,
        mathmlBuilder: mathmlBuilder$4
      });
      adjustStyle = (size, originalStyle) => {
        var style = originalStyle;
        if (size === "display") {
          style = style.id >= Style$1.SCRIPT.id ? style.text() : Style$1.DISPLAY;
        } else if (size === "text" && style.size === Style$1.DISPLAY.size) {
          style = Style$1.TEXT;
        } else if (size === "script") {
          style = Style$1.SCRIPT;
        } else if (size === "scriptscript") {
          style = Style$1.SCRIPTSCRIPT;
        }
        return style;
      };
      htmlBuilder$4 = (group, options2) => {
        var style = adjustStyle(group.size, options2.style);
        var nstyle = style.fracNum();
        var dstyle = style.fracDen();
        var newOptions;
        newOptions = options2.havingStyle(nstyle);
        var numerm = buildGroup$1(group.numer, newOptions, options2);
        if (group.continued) {
          var hStrut = 8.5 / options2.fontMetrics().ptPerEm;
          var dStrut = 3.5 / options2.fontMetrics().ptPerEm;
          numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
          numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
        }
        newOptions = options2.havingStyle(dstyle);
        var denomm = buildGroup$1(group.denom, newOptions, options2);
        var rule;
        var ruleWidth;
        var ruleSpacing;
        if (group.hasBarLine) {
          if (group.barSize) {
            ruleWidth = calculateSize(group.barSize, options2);
            rule = buildCommon.makeLineSpan("frac-line", options2, ruleWidth);
          } else {
            rule = buildCommon.makeLineSpan("frac-line", options2);
          }
          ruleWidth = rule.height;
          ruleSpacing = rule.height;
        } else {
          rule = null;
          ruleWidth = 0;
          ruleSpacing = options2.fontMetrics().defaultRuleThickness;
        }
        var numShift;
        var clearance;
        var denomShift;
        if (style.size === Style$1.DISPLAY.size || group.size === "display") {
          numShift = options2.fontMetrics().num1;
          if (ruleWidth > 0) {
            clearance = 3 * ruleSpacing;
          } else {
            clearance = 7 * ruleSpacing;
          }
          denomShift = options2.fontMetrics().denom1;
        } else {
          if (ruleWidth > 0) {
            numShift = options2.fontMetrics().num2;
            clearance = ruleSpacing;
          } else {
            numShift = options2.fontMetrics().num3;
            clearance = 3 * ruleSpacing;
          }
          denomShift = options2.fontMetrics().denom2;
        }
        var frac;
        if (!rule) {
          var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
          if (candidateClearance < clearance) {
            numShift += 0.5 * (clearance - candidateClearance);
            denomShift += 0.5 * (clearance - candidateClearance);
          }
          frac = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: denomm,
              shift: denomShift
            }, {
              type: "elem",
              elem: numerm,
              shift: -numShift
            }]
          }, options2);
        } else {
          var axisHeight = options2.fontMetrics().axisHeight;
          if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
            numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
          }
          if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
            denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
          }
          var midShift = -(axisHeight - 0.5 * ruleWidth);
          frac = buildCommon.makeVList({
            positionType: "individualShift",
            children: [{
              type: "elem",
              elem: denomm,
              shift: denomShift
            }, {
              type: "elem",
              elem: rule,
              shift: midShift
            }, {
              type: "elem",
              elem: numerm,
              shift: -numShift
            }]
          }, options2);
        }
        newOptions = options2.havingStyle(style);
        frac.height *= newOptions.sizeMultiplier / options2.sizeMultiplier;
        frac.depth *= newOptions.sizeMultiplier / options2.sizeMultiplier;
        var delimSize;
        if (style.size === Style$1.DISPLAY.size) {
          delimSize = options2.fontMetrics().delim1;
        } else if (style.size === Style$1.SCRIPTSCRIPT.size) {
          delimSize = options2.havingStyle(Style$1.SCRIPT).fontMetrics().delim2;
        } else {
          delimSize = options2.fontMetrics().delim2;
        }
        var leftDelim;
        var rightDelim;
        if (group.leftDelim == null) {
          leftDelim = makeNullDelimiter(options2, ["mopen"]);
        } else {
          leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options2.havingStyle(style), group.mode, ["mopen"]);
        }
        if (group.continued) {
          rightDelim = buildCommon.makeSpan([]);
        } else if (group.rightDelim == null) {
          rightDelim = makeNullDelimiter(options2, ["mclose"]);
        } else {
          rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options2.havingStyle(style), group.mode, ["mclose"]);
        }
        return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options2)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options2);
      };
      mathmlBuilder$3 = (group, options2) => {
        var node = new mathMLTree.MathNode("mfrac", [buildGroup2(group.numer, options2), buildGroup2(group.denom, options2)]);
        if (!group.hasBarLine) {
          node.setAttribute("linethickness", "0px");
        } else if (group.barSize) {
          var ruleWidth = calculateSize(group.barSize, options2);
          node.setAttribute("linethickness", makeEm(ruleWidth));
        }
        var style = adjustStyle(group.size, options2.style);
        if (style.size !== options2.style.size) {
          node = new mathMLTree.MathNode("mstyle", [node]);
          var isDisplay = style.size === Style$1.DISPLAY.size ? "true" : "false";
          node.setAttribute("displaystyle", isDisplay);
          node.setAttribute("scriptlevel", "0");
        }
        if (group.leftDelim != null || group.rightDelim != null) {
          var withDelims = [];
          if (group.leftDelim != null) {
            var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
            leftOp.setAttribute("fence", "true");
            withDelims.push(leftOp);
          }
          withDelims.push(node);
          if (group.rightDelim != null) {
            var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
            rightOp.setAttribute("fence", "true");
            withDelims.push(rightOp);
          }
          return makeRow(withDelims);
        }
        return node;
      };
      defineFunction({
        type: "genfrac",
        names: [
          "\\dfrac",
          "\\frac",
          "\\tfrac",
          "\\dbinom",
          "\\binom",
          "\\tbinom",
          "\\\\atopfrac",
          // can’t be entered directly
          "\\\\bracefrac",
          "\\\\brackfrac"
          // ditto
        ],
        props: {
          numArgs: 2,
          allowedInArgument: true
        },
        handler: (_ref, args) => {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var numer = args[0];
          var denom = args[1];
          var hasBarLine;
          var leftDelim = null;
          var rightDelim = null;
          var size = "auto";
          switch (funcName) {
            case "\\dfrac":
            case "\\frac":
            case "\\tfrac":
              hasBarLine = true;
              break;
            case "\\\\atopfrac":
              hasBarLine = false;
              break;
            case "\\dbinom":
            case "\\binom":
            case "\\tbinom":
              hasBarLine = false;
              leftDelim = "(";
              rightDelim = ")";
              break;
            case "\\\\bracefrac":
              hasBarLine = false;
              leftDelim = "\\{";
              rightDelim = "\\}";
              break;
            case "\\\\brackfrac":
              hasBarLine = false;
              leftDelim = "[";
              rightDelim = "]";
              break;
            default:
              throw new Error("Unrecognized genfrac command");
          }
          switch (funcName) {
            case "\\dfrac":
            case "\\dbinom":
              size = "display";
              break;
            case "\\tfrac":
            case "\\tbinom":
              size = "text";
              break;
          }
          return {
            type: "genfrac",
            mode: parser2.mode,
            continued: false,
            numer,
            denom,
            hasBarLine,
            leftDelim,
            rightDelim,
            size,
            barSize: null
          };
        },
        htmlBuilder: htmlBuilder$4,
        mathmlBuilder: mathmlBuilder$3
      });
      defineFunction({
        type: "genfrac",
        names: ["\\cfrac"],
        props: {
          numArgs: 2
        },
        handler: (_ref2, args) => {
          var {
            parser: parser2,
            funcName
          } = _ref2;
          var numer = args[0];
          var denom = args[1];
          return {
            type: "genfrac",
            mode: parser2.mode,
            continued: true,
            numer,
            denom,
            hasBarLine: true,
            leftDelim: null,
            rightDelim: null,
            size: "display",
            barSize: null
          };
        }
      });
      defineFunction({
        type: "infix",
        names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
        props: {
          numArgs: 0,
          infix: true
        },
        handler(_ref3) {
          var {
            parser: parser2,
            funcName,
            token
          } = _ref3;
          var replaceWith;
          switch (funcName) {
            case "\\over":
              replaceWith = "\\frac";
              break;
            case "\\choose":
              replaceWith = "\\binom";
              break;
            case "\\atop":
              replaceWith = "\\\\atopfrac";
              break;
            case "\\brace":
              replaceWith = "\\\\bracefrac";
              break;
            case "\\brack":
              replaceWith = "\\\\brackfrac";
              break;
            default:
              throw new Error("Unrecognized infix genfrac command");
          }
          return {
            type: "infix",
            mode: parser2.mode,
            replaceWith,
            token
          };
        }
      });
      stylArray = ["display", "text", "script", "scriptscript"];
      delimFromValue = function delimFromValue2(delimString) {
        var delim = null;
        if (delimString.length > 0) {
          delim = delimString;
          delim = delim === "." ? null : delim;
        }
        return delim;
      };
      defineFunction({
        type: "genfrac",
        names: ["\\genfrac"],
        props: {
          numArgs: 6,
          allowedInArgument: true,
          argTypes: ["math", "math", "size", "text", "math", "math"]
        },
        handler(_ref4, args) {
          var {
            parser: parser2
          } = _ref4;
          var numer = args[4];
          var denom = args[5];
          var leftNode = normalizeArgument(args[0]);
          var leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
          var rightNode = normalizeArgument(args[1]);
          var rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
          var barNode = assertNodeType(args[2], "size");
          var hasBarLine;
          var barSize = null;
          if (barNode.isBlank) {
            hasBarLine = true;
          } else {
            barSize = barNode.value;
            hasBarLine = barSize.number > 0;
          }
          var size = "auto";
          var styl = args[3];
          if (styl.type === "ordgroup") {
            if (styl.body.length > 0) {
              var textOrd = assertNodeType(styl.body[0], "textord");
              size = stylArray[Number(textOrd.text)];
            }
          } else {
            styl = assertNodeType(styl, "textord");
            size = stylArray[Number(styl.text)];
          }
          return {
            type: "genfrac",
            mode: parser2.mode,
            numer,
            denom,
            continued: false,
            hasBarLine,
            barSize,
            leftDelim,
            rightDelim,
            size
          };
        },
        htmlBuilder: htmlBuilder$4,
        mathmlBuilder: mathmlBuilder$3
      });
      defineFunction({
        type: "infix",
        names: ["\\above"],
        props: {
          numArgs: 1,
          argTypes: ["size"],
          infix: true
        },
        handler(_ref5, args) {
          var {
            parser: parser2,
            funcName,
            token
          } = _ref5;
          return {
            type: "infix",
            mode: parser2.mode,
            replaceWith: "\\\\abovefrac",
            size: assertNodeType(args[0], "size").value,
            token
          };
        }
      });
      defineFunction({
        type: "genfrac",
        names: ["\\\\abovefrac"],
        props: {
          numArgs: 3,
          argTypes: ["math", "size", "math"]
        },
        handler: (_ref6, args) => {
          var {
            parser: parser2,
            funcName
          } = _ref6;
          var numer = args[0];
          var barSize = assert(assertNodeType(args[1], "infix").size);
          var denom = args[2];
          var hasBarLine = barSize.number > 0;
          return {
            type: "genfrac",
            mode: parser2.mode,
            numer,
            denom,
            continued: false,
            hasBarLine,
            barSize,
            leftDelim: null,
            rightDelim: null,
            size: "auto"
          };
        },
        htmlBuilder: htmlBuilder$4,
        mathmlBuilder: mathmlBuilder$3
      });
      htmlBuilder$3 = (grp, options2) => {
        var style = options2.style;
        var supSubGroup;
        var group;
        if (grp.type === "supsub") {
          supSubGroup = grp.sup ? buildGroup$1(grp.sup, options2.havingStyle(style.sup()), options2) : buildGroup$1(grp.sub, options2.havingStyle(style.sub()), options2);
          group = assertNodeType(grp.base, "horizBrace");
        } else {
          group = assertNodeType(grp, "horizBrace");
        }
        var body = buildGroup$1(group.base, options2.havingBaseStyle(Style$1.DISPLAY));
        var braceBody = stretchy.svgSpan(group, options2);
        var vlist;
        if (group.isOver) {
          vlist = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: body
            }, {
              type: "kern",
              size: 0.1
            }, {
              type: "elem",
              elem: braceBody
            }]
          }, options2);
          vlist.children[0].children[0].children[1].classes.push("svg-align");
        } else {
          vlist = buildCommon.makeVList({
            positionType: "bottom",
            positionData: body.depth + 0.1 + braceBody.height,
            children: [{
              type: "elem",
              elem: braceBody
            }, {
              type: "kern",
              size: 0.1
            }, {
              type: "elem",
              elem: body
            }]
          }, options2);
          vlist.children[0].children[0].children[0].classes.push("svg-align");
        }
        if (supSubGroup) {
          var vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options2);
          if (group.isOver) {
            vlist = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: vSpan
              }, {
                type: "kern",
                size: 0.2
              }, {
                type: "elem",
                elem: supSubGroup
              }]
            }, options2);
          } else {
            vlist = buildCommon.makeVList({
              positionType: "bottom",
              positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
              children: [{
                type: "elem",
                elem: supSubGroup
              }, {
                type: "kern",
                size: 0.2
              }, {
                type: "elem",
                elem: vSpan
              }]
            }, options2);
          }
        }
        return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options2);
      };
      mathmlBuilder$2 = (group, options2) => {
        var accentNode = stretchy.mathMLnode(group.label);
        return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildGroup2(group.base, options2), accentNode]);
      };
      defineFunction({
        type: "horizBrace",
        names: ["\\overbrace", "\\underbrace"],
        props: {
          numArgs: 1
        },
        handler(_ref, args) {
          var {
            parser: parser2,
            funcName
          } = _ref;
          return {
            type: "horizBrace",
            mode: parser2.mode,
            label: funcName,
            isOver: /^\\over/.test(funcName),
            base: args[0]
          };
        },
        htmlBuilder: htmlBuilder$3,
        mathmlBuilder: mathmlBuilder$2
      });
      defineFunction({
        type: "href",
        names: ["\\href"],
        props: {
          numArgs: 2,
          argTypes: ["url", "original"],
          allowedInText: true
        },
        handler: (_ref, args) => {
          var {
            parser: parser2
          } = _ref;
          var body = args[1];
          var href = assertNodeType(args[0], "url").url;
          if (!parser2.settings.isTrusted({
            command: "\\href",
            url: href
          })) {
            return parser2.formatUnsupportedCmd("\\href");
          }
          return {
            type: "href",
            mode: parser2.mode,
            href,
            body: ordargument(body)
          };
        },
        htmlBuilder: (group, options2) => {
          var elements = buildExpression$1(group.body, options2, false);
          return buildCommon.makeAnchor(group.href, [], elements, options2);
        },
        mathmlBuilder: (group, options2) => {
          var math2 = buildExpressionRow(group.body, options2);
          if (!(math2 instanceof MathNode)) {
            math2 = new MathNode("mrow", [math2]);
          }
          math2.setAttribute("href", group.href);
          return math2;
        }
      });
      defineFunction({
        type: "href",
        names: ["\\url"],
        props: {
          numArgs: 1,
          argTypes: ["url"],
          allowedInText: true
        },
        handler: (_ref2, args) => {
          var {
            parser: parser2
          } = _ref2;
          var href = assertNodeType(args[0], "url").url;
          if (!parser2.settings.isTrusted({
            command: "\\url",
            url: href
          })) {
            return parser2.formatUnsupportedCmd("\\url");
          }
          var chars = [];
          for (var i = 0; i < href.length; i++) {
            var c = href[i];
            if (c === "~") {
              c = "\\textasciitilde";
            }
            chars.push({
              type: "textord",
              mode: "text",
              text: c
            });
          }
          var body = {
            type: "text",
            mode: parser2.mode,
            font: "\\texttt",
            body: chars
          };
          return {
            type: "href",
            mode: parser2.mode,
            href,
            body: ordargument(body)
          };
        }
      });
      defineFunction({
        type: "hbox",
        names: ["\\hbox"],
        props: {
          numArgs: 1,
          argTypes: ["text"],
          allowedInText: true,
          primitive: true
        },
        handler(_ref, args) {
          var {
            parser: parser2
          } = _ref;
          return {
            type: "hbox",
            mode: parser2.mode,
            body: ordargument(args[0])
          };
        },
        htmlBuilder(group, options2) {
          var elements = buildExpression$1(group.body, options2, false);
          return buildCommon.makeFragment(elements);
        },
        mathmlBuilder(group, options2) {
          return new mathMLTree.MathNode("mrow", buildExpression2(group.body, options2));
        }
      });
      defineFunction({
        type: "html",
        names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
        props: {
          numArgs: 2,
          argTypes: ["raw", "original"],
          allowedInText: true
        },
        handler: (_ref, args) => {
          var {
            parser: parser2,
            funcName,
            token
          } = _ref;
          var value = assertNodeType(args[0], "raw").string;
          var body = args[1];
          if (parser2.settings.strict) {
            parser2.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
          }
          var trustContext;
          var attributes = {};
          switch (funcName) {
            case "\\htmlClass":
              attributes.class = value;
              trustContext = {
                command: "\\htmlClass",
                class: value
              };
              break;
            case "\\htmlId":
              attributes.id = value;
              trustContext = {
                command: "\\htmlId",
                id: value
              };
              break;
            case "\\htmlStyle":
              attributes.style = value;
              trustContext = {
                command: "\\htmlStyle",
                style: value
              };
              break;
            case "\\htmlData": {
              var data = value.split(",");
              for (var i = 0; i < data.length; i++) {
                var keyVal = data[i].split("=");
                if (keyVal.length !== 2) {
                  throw new ParseError("Error parsing key-value for \\htmlData");
                }
                attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
              }
              trustContext = {
                command: "\\htmlData",
                attributes
              };
              break;
            }
            default:
              throw new Error("Unrecognized html command");
          }
          if (!parser2.settings.isTrusted(trustContext)) {
            return parser2.formatUnsupportedCmd(funcName);
          }
          return {
            type: "html",
            mode: parser2.mode,
            attributes,
            body: ordargument(body)
          };
        },
        htmlBuilder: (group, options2) => {
          var elements = buildExpression$1(group.body, options2, false);
          var classes = ["enclosing"];
          if (group.attributes.class) {
            classes.push(...group.attributes.class.trim().split(/\s+/));
          }
          var span = buildCommon.makeSpan(classes, elements, options2);
          for (var attr in group.attributes) {
            if (attr !== "class" && group.attributes.hasOwnProperty(attr)) {
              span.setAttribute(attr, group.attributes[attr]);
            }
          }
          return span;
        },
        mathmlBuilder: (group, options2) => {
          return buildExpressionRow(group.body, options2);
        }
      });
      defineFunction({
        type: "htmlmathml",
        names: ["\\html@mathml"],
        props: {
          numArgs: 2,
          allowedInText: true
        },
        handler: (_ref, args) => {
          var {
            parser: parser2
          } = _ref;
          return {
            type: "htmlmathml",
            mode: parser2.mode,
            html: ordargument(args[0]),
            mathml: ordargument(args[1])
          };
        },
        htmlBuilder: (group, options2) => {
          var elements = buildExpression$1(group.html, options2, false);
          return buildCommon.makeFragment(elements);
        },
        mathmlBuilder: (group, options2) => {
          return buildExpressionRow(group.mathml, options2);
        }
      });
      sizeData = function sizeData2(str) {
        if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
          return {
            number: +str,
            unit: "bp"
          };
        } else {
          var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
          if (!match) {
            throw new ParseError("Invalid size: '" + str + "' in \\includegraphics");
          }
          var data = {
            number: +(match[1] + match[2]),
            // sign + magnitude, cast to number
            unit: match[3]
          };
          if (!validUnit(data)) {
            throw new ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
          }
          return data;
        }
      };
      defineFunction({
        type: "includegraphics",
        names: ["\\includegraphics"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1,
          argTypes: ["raw", "url"],
          allowedInText: false
        },
        handler: (_ref, args, optArgs) => {
          var {
            parser: parser2
          } = _ref;
          var width = {
            number: 0,
            unit: "em"
          };
          var height = {
            number: 0.9,
            unit: "em"
          };
          var totalheight = {
            number: 0,
            unit: "em"
          };
          var alt = "";
          if (optArgs[0]) {
            var attributeStr = assertNodeType(optArgs[0], "raw").string;
            var attributes = attributeStr.split(",");
            for (var i = 0; i < attributes.length; i++) {
              var keyVal = attributes[i].split("=");
              if (keyVal.length === 2) {
                var str = keyVal[1].trim();
                switch (keyVal[0].trim()) {
                  case "alt":
                    alt = str;
                    break;
                  case "width":
                    width = sizeData(str);
                    break;
                  case "height":
                    height = sizeData(str);
                    break;
                  case "totalheight":
                    totalheight = sizeData(str);
                    break;
                  default:
                    throw new ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
                }
              }
            }
          }
          var src = assertNodeType(args[0], "url").url;
          if (alt === "") {
            alt = src;
            alt = alt.replace(/^.*[\\/]/, "");
            alt = alt.substring(0, alt.lastIndexOf("."));
          }
          if (!parser2.settings.isTrusted({
            command: "\\includegraphics",
            url: src
          })) {
            return parser2.formatUnsupportedCmd("\\includegraphics");
          }
          return {
            type: "includegraphics",
            mode: parser2.mode,
            alt,
            width,
            height,
            totalheight,
            src
          };
        },
        htmlBuilder: (group, options2) => {
          var height = calculateSize(group.height, options2);
          var depth = 0;
          if (group.totalheight.number > 0) {
            depth = calculateSize(group.totalheight, options2) - height;
          }
          var width = 0;
          if (group.width.number > 0) {
            width = calculateSize(group.width, options2);
          }
          var style = {
            height: makeEm(height + depth)
          };
          if (width > 0) {
            style.width = makeEm(width);
          }
          if (depth > 0) {
            style.verticalAlign = makeEm(-depth);
          }
          var node = new Img(group.src, group.alt, style);
          node.height = height;
          node.depth = depth;
          return node;
        },
        mathmlBuilder: (group, options2) => {
          var node = new mathMLTree.MathNode("mglyph", []);
          node.setAttribute("alt", group.alt);
          var height = calculateSize(group.height, options2);
          var depth = 0;
          if (group.totalheight.number > 0) {
            depth = calculateSize(group.totalheight, options2) - height;
            node.setAttribute("valign", makeEm(-depth));
          }
          node.setAttribute("height", makeEm(height + depth));
          if (group.width.number > 0) {
            var width = calculateSize(group.width, options2);
            node.setAttribute("width", makeEm(width));
          }
          node.setAttribute("src", group.src);
          return node;
        }
      });
      defineFunction({
        type: "kern",
        names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
        props: {
          numArgs: 1,
          argTypes: ["size"],
          primitive: true,
          allowedInText: true
        },
        handler(_ref, args) {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var size = assertNodeType(args[0], "size");
          if (parser2.settings.strict) {
            var mathFunction = funcName[1] === "m";
            var muUnit = size.value.unit === "mu";
            if (mathFunction) {
              if (!muUnit) {
                parser2.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
              }
              if (parser2.mode !== "math") {
                parser2.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
              }
            } else {
              if (muUnit) {
                parser2.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
              }
            }
          }
          return {
            type: "kern",
            mode: parser2.mode,
            dimension: size.value
          };
        },
        htmlBuilder(group, options2) {
          return buildCommon.makeGlue(group.dimension, options2);
        },
        mathmlBuilder(group, options2) {
          var dimension = calculateSize(group.dimension, options2);
          return new mathMLTree.SpaceNode(dimension);
        }
      });
      defineFunction({
        type: "lap",
        names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: (_ref, args) => {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var body = args[0];
          return {
            type: "lap",
            mode: parser2.mode,
            alignment: funcName.slice(5),
            body
          };
        },
        htmlBuilder: (group, options2) => {
          var inner2;
          if (group.alignment === "clap") {
            inner2 = buildCommon.makeSpan([], [buildGroup$1(group.body, options2)]);
            inner2 = buildCommon.makeSpan(["inner"], [inner2], options2);
          } else {
            inner2 = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options2)]);
          }
          var fix = buildCommon.makeSpan(["fix"], []);
          var node = buildCommon.makeSpan([group.alignment], [inner2, fix], options2);
          var strut = buildCommon.makeSpan(["strut"]);
          strut.style.height = makeEm(node.height + node.depth);
          if (node.depth) {
            strut.style.verticalAlign = makeEm(-node.depth);
          }
          node.children.unshift(strut);
          node = buildCommon.makeSpan(["thinbox"], [node], options2);
          return buildCommon.makeSpan(["mord", "vbox"], [node], options2);
        },
        mathmlBuilder: (group, options2) => {
          var node = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options2)]);
          if (group.alignment !== "rlap") {
            var offset = group.alignment === "llap" ? "-1" : "-0.5";
            node.setAttribute("lspace", offset + "width");
          }
          node.setAttribute("width", "0px");
          return node;
        }
      });
      defineFunction({
        type: "styling",
        names: ["\\(", "$"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: false
        },
        handler(_ref, args) {
          var {
            funcName,
            parser: parser2
          } = _ref;
          var outerMode = parser2.mode;
          parser2.switchMode("math");
          var close2 = funcName === "\\(" ? "\\)" : "$";
          var body = parser2.parseExpression(false, close2);
          parser2.expect(close2);
          parser2.switchMode(outerMode);
          return {
            type: "styling",
            mode: parser2.mode,
            style: "text",
            body
          };
        }
      });
      defineFunction({
        type: "text",
        // Doesn't matter what this is.
        names: ["\\)", "\\]"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInMath: false
        },
        handler(context, args) {
          throw new ParseError("Mismatched " + context.funcName);
        }
      });
      chooseMathStyle = (group, options2) => {
        switch (options2.style.size) {
          case Style$1.DISPLAY.size:
            return group.display;
          case Style$1.TEXT.size:
            return group.text;
          case Style$1.SCRIPT.size:
            return group.script;
          case Style$1.SCRIPTSCRIPT.size:
            return group.scriptscript;
          default:
            return group.text;
        }
      };
      defineFunction({
        type: "mathchoice",
        names: ["\\mathchoice"],
        props: {
          numArgs: 4,
          primitive: true
        },
        handler: (_ref, args) => {
          var {
            parser: parser2
          } = _ref;
          return {
            type: "mathchoice",
            mode: parser2.mode,
            display: ordargument(args[0]),
            text: ordargument(args[1]),
            script: ordargument(args[2]),
            scriptscript: ordargument(args[3])
          };
        },
        htmlBuilder: (group, options2) => {
          var body = chooseMathStyle(group, options2);
          var elements = buildExpression$1(body, options2, false);
          return buildCommon.makeFragment(elements);
        },
        mathmlBuilder: (group, options2) => {
          var body = chooseMathStyle(group, options2);
          return buildExpressionRow(body, options2);
        }
      });
      assembleSupSub = (base, supGroup, subGroup, options2, style, slant, baseShift) => {
        base = buildCommon.makeSpan([], [base]);
        var subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
        var sub2;
        var sup2;
        if (supGroup) {
          var elem = buildGroup$1(supGroup, options2.havingStyle(style.sup()), options2);
          sup2 = {
            elem,
            kern: Math.max(options2.fontMetrics().bigOpSpacing1, options2.fontMetrics().bigOpSpacing3 - elem.depth)
          };
        }
        if (subGroup) {
          var _elem = buildGroup$1(subGroup, options2.havingStyle(style.sub()), options2);
          sub2 = {
            elem: _elem,
            kern: Math.max(options2.fontMetrics().bigOpSpacing2, options2.fontMetrics().bigOpSpacing4 - _elem.height)
          };
        }
        var finalGroup;
        if (sup2 && sub2) {
          var bottom = options2.fontMetrics().bigOpSpacing5 + sub2.elem.height + sub2.elem.depth + sub2.kern + base.depth + baseShift;
          finalGroup = buildCommon.makeVList({
            positionType: "bottom",
            positionData: bottom,
            children: [{
              type: "kern",
              size: options2.fontMetrics().bigOpSpacing5
            }, {
              type: "elem",
              elem: sub2.elem,
              marginLeft: makeEm(-slant)
            }, {
              type: "kern",
              size: sub2.kern
            }, {
              type: "elem",
              elem: base
            }, {
              type: "kern",
              size: sup2.kern
            }, {
              type: "elem",
              elem: sup2.elem,
              marginLeft: makeEm(slant)
            }, {
              type: "kern",
              size: options2.fontMetrics().bigOpSpacing5
            }]
          }, options2);
        } else if (sub2) {
          var top = base.height - baseShift;
          finalGroup = buildCommon.makeVList({
            positionType: "top",
            positionData: top,
            children: [{
              type: "kern",
              size: options2.fontMetrics().bigOpSpacing5
            }, {
              type: "elem",
              elem: sub2.elem,
              marginLeft: makeEm(-slant)
            }, {
              type: "kern",
              size: sub2.kern
            }, {
              type: "elem",
              elem: base
            }]
          }, options2);
        } else if (sup2) {
          var _bottom = base.depth + baseShift;
          finalGroup = buildCommon.makeVList({
            positionType: "bottom",
            positionData: _bottom,
            children: [{
              type: "elem",
              elem: base
            }, {
              type: "kern",
              size: sup2.kern
            }, {
              type: "elem",
              elem: sup2.elem,
              marginLeft: makeEm(slant)
            }, {
              type: "kern",
              size: options2.fontMetrics().bigOpSpacing5
            }]
          }, options2);
        } else {
          return base;
        }
        var parts = [finalGroup];
        if (sub2 && slant !== 0 && !subIsSingleCharacter) {
          var spacer = buildCommon.makeSpan(["mspace"], [], options2);
          spacer.style.marginRight = makeEm(slant);
          parts.unshift(spacer);
        }
        return buildCommon.makeSpan(["mop", "op-limits"], parts, options2);
      };
      noSuccessor = ["\\smallint"];
      htmlBuilder$2 = (grp, options2) => {
        var supGroup;
        var subGroup;
        var hasLimits = false;
        var group;
        if (grp.type === "supsub") {
          supGroup = grp.sup;
          subGroup = grp.sub;
          group = assertNodeType(grp.base, "op");
          hasLimits = true;
        } else {
          group = assertNodeType(grp, "op");
        }
        var style = options2.style;
        var large = false;
        if (style.size === Style$1.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
          large = true;
        }
        var base;
        if (group.symbol) {
          var fontName = large ? "Size2-Regular" : "Size1-Regular";
          var stash = "";
          if (group.name === "\\oiint" || group.name === "\\oiiint") {
            stash = group.name.slice(1);
            group.name = stash === "oiint" ? "\\iint" : "\\iiint";
          }
          base = buildCommon.makeSymbol(group.name, fontName, "math", options2, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
          if (stash.length > 0) {
            var italic = base.italic;
            var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options2);
            base = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: base,
                shift: 0
              }, {
                type: "elem",
                elem: oval,
                shift: large ? 0.08 : 0
              }]
            }, options2);
            group.name = "\\" + stash;
            base.classes.unshift("mop");
            base.italic = italic;
          }
        } else if (group.body) {
          var inner2 = buildExpression$1(group.body, options2, true);
          if (inner2.length === 1 && inner2[0] instanceof SymbolNode) {
            base = inner2[0];
            base.classes[0] = "mop";
          } else {
            base = buildCommon.makeSpan(["mop"], inner2, options2);
          }
        } else {
          var output = [];
          for (var i = 1; i < group.name.length; i++) {
            output.push(buildCommon.mathsym(group.name[i], group.mode, options2));
          }
          base = buildCommon.makeSpan(["mop"], output, options2);
        }
        var baseShift = 0;
        var slant = 0;
        if ((base instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
          baseShift = (base.height - base.depth) / 2 - options2.fontMetrics().axisHeight;
          slant = base.italic;
        }
        if (hasLimits) {
          return assembleSupSub(base, supGroup, subGroup, options2, style, slant, baseShift);
        } else {
          if (baseShift) {
            base.style.position = "relative";
            base.style.top = makeEm(baseShift);
          }
          return base;
        }
      };
      mathmlBuilder$1 = (group, options2) => {
        var node;
        if (group.symbol) {
          node = new MathNode("mo", [makeText(group.name, group.mode)]);
          if (utils.contains(noSuccessor, group.name)) {
            node.setAttribute("largeop", "false");
          }
        } else if (group.body) {
          node = new MathNode("mo", buildExpression2(group.body, options2));
        } else {
          node = new MathNode("mi", [new TextNode(group.name.slice(1))]);
          var operator = new MathNode("mo", [makeText("\u2061", "text")]);
          if (group.parentIsSupSub) {
            node = new MathNode("mrow", [node, operator]);
          } else {
            node = newDocumentFragment([node, operator]);
          }
        }
        return node;
      };
      singleCharBigOps = {
        "\u220F": "\\prod",
        "\u2210": "\\coprod",
        "\u2211": "\\sum",
        "\u22C0": "\\bigwedge",
        "\u22C1": "\\bigvee",
        "\u22C2": "\\bigcap",
        "\u22C3": "\\bigcup",
        "\u2A00": "\\bigodot",
        "\u2A01": "\\bigoplus",
        "\u2A02": "\\bigotimes",
        "\u2A04": "\\biguplus",
        "\u2A06": "\\bigsqcup"
      };
      defineFunction({
        type: "op",
        names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22C0", "\u22C1", "\u22C2", "\u22C3", "\u2A00", "\u2A01", "\u2A02", "\u2A04", "\u2A06"],
        props: {
          numArgs: 0
        },
        handler: (_ref, args) => {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var fName = funcName;
          if (fName.length === 1) {
            fName = singleCharBigOps[fName];
          }
          return {
            type: "op",
            mode: parser2.mode,
            limits: true,
            parentIsSupSub: false,
            symbol: true,
            name: fName
          };
        },
        htmlBuilder: htmlBuilder$2,
        mathmlBuilder: mathmlBuilder$1
      });
      defineFunction({
        type: "op",
        names: ["\\mathop"],
        props: {
          numArgs: 1,
          primitive: true
        },
        handler: (_ref2, args) => {
          var {
            parser: parser2
          } = _ref2;
          var body = args[0];
          return {
            type: "op",
            mode: parser2.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: false,
            body: ordargument(body)
          };
        },
        htmlBuilder: htmlBuilder$2,
        mathmlBuilder: mathmlBuilder$1
      });
      singleCharIntegrals = {
        "\u222B": "\\int",
        "\u222C": "\\iint",
        "\u222D": "\\iiint",
        "\u222E": "\\oint",
        "\u222F": "\\oiint",
        "\u2230": "\\oiiint"
      };
      defineFunction({
        type: "op",
        names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
        props: {
          numArgs: 0
        },
        handler(_ref3) {
          var {
            parser: parser2,
            funcName
          } = _ref3;
          return {
            type: "op",
            mode: parser2.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: false,
            name: funcName
          };
        },
        htmlBuilder: htmlBuilder$2,
        mathmlBuilder: mathmlBuilder$1
      });
      defineFunction({
        type: "op",
        names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
        props: {
          numArgs: 0
        },
        handler(_ref4) {
          var {
            parser: parser2,
            funcName
          } = _ref4;
          return {
            type: "op",
            mode: parser2.mode,
            limits: true,
            parentIsSupSub: false,
            symbol: false,
            name: funcName
          };
        },
        htmlBuilder: htmlBuilder$2,
        mathmlBuilder: mathmlBuilder$1
      });
      defineFunction({
        type: "op",
        names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222B", "\u222C", "\u222D", "\u222E", "\u222F", "\u2230"],
        props: {
          numArgs: 0
        },
        handler(_ref5) {
          var {
            parser: parser2,
            funcName
          } = _ref5;
          var fName = funcName;
          if (fName.length === 1) {
            fName = singleCharIntegrals[fName];
          }
          return {
            type: "op",
            mode: parser2.mode,
            limits: false,
            parentIsSupSub: false,
            symbol: true,
            name: fName
          };
        },
        htmlBuilder: htmlBuilder$2,
        mathmlBuilder: mathmlBuilder$1
      });
      htmlBuilder$1 = (grp, options2) => {
        var supGroup;
        var subGroup;
        var hasLimits = false;
        var group;
        if (grp.type === "supsub") {
          supGroup = grp.sup;
          subGroup = grp.sub;
          group = assertNodeType(grp.base, "operatorname");
          hasLimits = true;
        } else {
          group = assertNodeType(grp, "operatorname");
        }
        var base;
        if (group.body.length > 0) {
          var body = group.body.map((child2) => {
            var childText = child2.text;
            if (typeof childText === "string") {
              return {
                type: "textord",
                mode: child2.mode,
                text: childText
              };
            } else {
              return child2;
            }
          });
          var expression = buildExpression$1(body, options2.withFont("mathrm"), true);
          for (var i = 0; i < expression.length; i++) {
            var child = expression[i];
            if (child instanceof SymbolNode) {
              child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
            }
          }
          base = buildCommon.makeSpan(["mop"], expression, options2);
        } else {
          base = buildCommon.makeSpan(["mop"], [], options2);
        }
        if (hasLimits) {
          return assembleSupSub(base, supGroup, subGroup, options2, options2.style, 0, 0);
        } else {
          return base;
        }
      };
      mathmlBuilder2 = (group, options2) => {
        var expression = buildExpression2(group.body, options2.withFont("mathrm"));
        var isAllString = true;
        for (var i = 0; i < expression.length; i++) {
          var node = expression[i];
          if (node instanceof mathMLTree.SpaceNode) ;
          else if (node instanceof mathMLTree.MathNode) {
            switch (node.type) {
              case "mi":
              case "mn":
              case "ms":
              case "mspace":
              case "mtext":
                break;
              // Do nothing yet.
              case "mo": {
                var child = node.children[0];
                if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
                  child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                } else {
                  isAllString = false;
                }
                break;
              }
              default:
                isAllString = false;
            }
          } else {
            isAllString = false;
          }
        }
        if (isAllString) {
          var word = expression.map((node2) => node2.toText()).join("");
          expression = [new mathMLTree.TextNode(word)];
        }
        var identifier = new mathMLTree.MathNode("mi", expression);
        identifier.setAttribute("mathvariant", "normal");
        var operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
        if (group.parentIsSupSub) {
          return new mathMLTree.MathNode("mrow", [identifier, operator]);
        } else {
          return mathMLTree.newDocumentFragment([identifier, operator]);
        }
      };
      defineFunction({
        type: "operatorname",
        names: ["\\operatorname@", "\\operatornamewithlimits"],
        props: {
          numArgs: 1
        },
        handler: (_ref, args) => {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var body = args[0];
          return {
            type: "operatorname",
            mode: parser2.mode,
            body: ordargument(body),
            alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
            limits: false,
            parentIsSupSub: false
          };
        },
        htmlBuilder: htmlBuilder$1,
        mathmlBuilder: mathmlBuilder2
      });
      defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
      defineFunctionBuilders({
        type: "ordgroup",
        htmlBuilder(group, options2) {
          if (group.semisimple) {
            return buildCommon.makeFragment(buildExpression$1(group.body, options2, false));
          }
          return buildCommon.makeSpan(["mord"], buildExpression$1(group.body, options2, true), options2);
        },
        mathmlBuilder(group, options2) {
          return buildExpressionRow(group.body, options2, true);
        }
      });
      defineFunction({
        type: "overline",
        names: ["\\overline"],
        props: {
          numArgs: 1
        },
        handler(_ref, args) {
          var {
            parser: parser2
          } = _ref;
          var body = args[0];
          return {
            type: "overline",
            mode: parser2.mode,
            body
          };
        },
        htmlBuilder(group, options2) {
          var innerGroup = buildGroup$1(group.body, options2.havingCrampedStyle());
          var line = buildCommon.makeLineSpan("overline-line", options2);
          var defaultRuleThickness = options2.fontMetrics().defaultRuleThickness;
          var vlist = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: innerGroup
            }, {
              type: "kern",
              size: 3 * defaultRuleThickness
            }, {
              type: "elem",
              elem: line
            }, {
              type: "kern",
              size: defaultRuleThickness
            }]
          }, options2);
          return buildCommon.makeSpan(["mord", "overline"], [vlist], options2);
        },
        mathmlBuilder(group, options2) {
          var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
          operator.setAttribute("stretchy", "true");
          var node = new mathMLTree.MathNode("mover", [buildGroup2(group.body, options2), operator]);
          node.setAttribute("accent", "true");
          return node;
        }
      });
      defineFunction({
        type: "phantom",
        names: ["\\phantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: (_ref, args) => {
          var {
            parser: parser2
          } = _ref;
          var body = args[0];
          return {
            type: "phantom",
            mode: parser2.mode,
            body: ordargument(body)
          };
        },
        htmlBuilder: (group, options2) => {
          var elements = buildExpression$1(group.body, options2.withPhantom(), false);
          return buildCommon.makeFragment(elements);
        },
        mathmlBuilder: (group, options2) => {
          var inner2 = buildExpression2(group.body, options2);
          return new mathMLTree.MathNode("mphantom", inner2);
        }
      });
      defineFunction({
        type: "hphantom",
        names: ["\\hphantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: (_ref2, args) => {
          var {
            parser: parser2
          } = _ref2;
          var body = args[0];
          return {
            type: "hphantom",
            mode: parser2.mode,
            body
          };
        },
        htmlBuilder: (group, options2) => {
          var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options2.withPhantom())]);
          node.height = 0;
          node.depth = 0;
          if (node.children) {
            for (var i = 0; i < node.children.length; i++) {
              node.children[i].height = 0;
              node.children[i].depth = 0;
            }
          }
          node = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: node
            }]
          }, options2);
          return buildCommon.makeSpan(["mord"], [node], options2);
        },
        mathmlBuilder: (group, options2) => {
          var inner2 = buildExpression2(ordargument(group.body), options2);
          var phantom = new mathMLTree.MathNode("mphantom", inner2);
          var node = new mathMLTree.MathNode("mpadded", [phantom]);
          node.setAttribute("height", "0px");
          node.setAttribute("depth", "0px");
          return node;
        }
      });
      defineFunction({
        type: "vphantom",
        names: ["\\vphantom"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler: (_ref3, args) => {
          var {
            parser: parser2
          } = _ref3;
          var body = args[0];
          return {
            type: "vphantom",
            mode: parser2.mode,
            body
          };
        },
        htmlBuilder: (group, options2) => {
          var inner2 = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options2.withPhantom())]);
          var fix = buildCommon.makeSpan(["fix"], []);
          return buildCommon.makeSpan(["mord", "rlap"], [inner2, fix], options2);
        },
        mathmlBuilder: (group, options2) => {
          var inner2 = buildExpression2(ordargument(group.body), options2);
          var phantom = new mathMLTree.MathNode("mphantom", inner2);
          var node = new mathMLTree.MathNode("mpadded", [phantom]);
          node.setAttribute("width", "0px");
          return node;
        }
      });
      defineFunction({
        type: "raisebox",
        names: ["\\raisebox"],
        props: {
          numArgs: 2,
          argTypes: ["size", "hbox"],
          allowedInText: true
        },
        handler(_ref, args) {
          var {
            parser: parser2
          } = _ref;
          var amount = assertNodeType(args[0], "size").value;
          var body = args[1];
          return {
            type: "raisebox",
            mode: parser2.mode,
            dy: amount,
            body
          };
        },
        htmlBuilder(group, options2) {
          var body = buildGroup$1(group.body, options2);
          var dy = calculateSize(group.dy, options2);
          return buildCommon.makeVList({
            positionType: "shift",
            positionData: -dy,
            children: [{
              type: "elem",
              elem: body
            }]
          }, options2);
        },
        mathmlBuilder(group, options2) {
          var node = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options2)]);
          var dy = group.dy.number + group.dy.unit;
          node.setAttribute("voffset", dy);
          return node;
        }
      });
      defineFunction({
        type: "internal",
        names: ["\\relax"],
        props: {
          numArgs: 0,
          allowedInText: true,
          allowedInArgument: true
        },
        handler(_ref) {
          var {
            parser: parser2
          } = _ref;
          return {
            type: "internal",
            mode: parser2.mode
          };
        }
      });
      defineFunction({
        type: "rule",
        names: ["\\rule"],
        props: {
          numArgs: 2,
          numOptionalArgs: 1,
          allowedInText: true,
          allowedInMath: true,
          argTypes: ["size", "size", "size"]
        },
        handler(_ref, args, optArgs) {
          var {
            parser: parser2
          } = _ref;
          var shift = optArgs[0];
          var width = assertNodeType(args[0], "size");
          var height = assertNodeType(args[1], "size");
          return {
            type: "rule",
            mode: parser2.mode,
            shift: shift && assertNodeType(shift, "size").value,
            width: width.value,
            height: height.value
          };
        },
        htmlBuilder(group, options2) {
          var rule = buildCommon.makeSpan(["mord", "rule"], [], options2);
          var width = calculateSize(group.width, options2);
          var height = calculateSize(group.height, options2);
          var shift = group.shift ? calculateSize(group.shift, options2) : 0;
          rule.style.borderRightWidth = makeEm(width);
          rule.style.borderTopWidth = makeEm(height);
          rule.style.bottom = makeEm(shift);
          rule.width = width;
          rule.height = height + shift;
          rule.depth = -shift;
          rule.maxFontSize = height * 1.125 * options2.sizeMultiplier;
          return rule;
        },
        mathmlBuilder(group, options2) {
          var width = calculateSize(group.width, options2);
          var height = calculateSize(group.height, options2);
          var shift = group.shift ? calculateSize(group.shift, options2) : 0;
          var color = options2.color && options2.getColor() || "black";
          var rule = new mathMLTree.MathNode("mspace");
          rule.setAttribute("mathbackground", color);
          rule.setAttribute("width", makeEm(width));
          rule.setAttribute("height", makeEm(height));
          var wrapper = new mathMLTree.MathNode("mpadded", [rule]);
          if (shift >= 0) {
            wrapper.setAttribute("height", makeEm(shift));
          } else {
            wrapper.setAttribute("height", makeEm(shift));
            wrapper.setAttribute("depth", makeEm(-shift));
          }
          wrapper.setAttribute("voffset", makeEm(shift));
          return wrapper;
        }
      });
      sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
      htmlBuilder2 = (group, options2) => {
        var newOptions = options2.havingSize(group.size);
        return sizingGroup(group.body, newOptions, options2);
      };
      defineFunction({
        type: "sizing",
        names: sizeFuncs,
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler: (_ref, args) => {
          var {
            breakOnTokenText,
            funcName,
            parser: parser2
          } = _ref;
          var body = parser2.parseExpression(false, breakOnTokenText);
          return {
            type: "sizing",
            mode: parser2.mode,
            // Figure out what size to use based on the list of functions above
            size: sizeFuncs.indexOf(funcName) + 1,
            body
          };
        },
        htmlBuilder: htmlBuilder2,
        mathmlBuilder: (group, options2) => {
          var newOptions = options2.havingSize(group.size);
          var inner2 = buildExpression2(group.body, newOptions);
          var node = new mathMLTree.MathNode("mstyle", inner2);
          node.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
          return node;
        }
      });
      defineFunction({
        type: "smash",
        names: ["\\smash"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1,
          allowedInText: true
        },
        handler: (_ref, args, optArgs) => {
          var {
            parser: parser2
          } = _ref;
          var smashHeight = false;
          var smashDepth = false;
          var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
          if (tbArg) {
            var letter = "";
            for (var i = 0; i < tbArg.body.length; ++i) {
              var node = tbArg.body[i];
              letter = node.text;
              if (letter === "t") {
                smashHeight = true;
              } else if (letter === "b") {
                smashDepth = true;
              } else {
                smashHeight = false;
                smashDepth = false;
                break;
              }
            }
          } else {
            smashHeight = true;
            smashDepth = true;
          }
          var body = args[0];
          return {
            type: "smash",
            mode: parser2.mode,
            body,
            smashHeight,
            smashDepth
          };
        },
        htmlBuilder: (group, options2) => {
          var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options2)]);
          if (!group.smashHeight && !group.smashDepth) {
            return node;
          }
          if (group.smashHeight) {
            node.height = 0;
            if (node.children) {
              for (var i = 0; i < node.children.length; i++) {
                node.children[i].height = 0;
              }
            }
          }
          if (group.smashDepth) {
            node.depth = 0;
            if (node.children) {
              for (var _i = 0; _i < node.children.length; _i++) {
                node.children[_i].depth = 0;
              }
            }
          }
          var smashedNode = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: node
            }]
          }, options2);
          return buildCommon.makeSpan(["mord"], [smashedNode], options2);
        },
        mathmlBuilder: (group, options2) => {
          var node = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options2)]);
          if (group.smashHeight) {
            node.setAttribute("height", "0px");
          }
          if (group.smashDepth) {
            node.setAttribute("depth", "0px");
          }
          return node;
        }
      });
      defineFunction({
        type: "sqrt",
        names: ["\\sqrt"],
        props: {
          numArgs: 1,
          numOptionalArgs: 1
        },
        handler(_ref, args, optArgs) {
          var {
            parser: parser2
          } = _ref;
          var index = optArgs[0];
          var body = args[0];
          return {
            type: "sqrt",
            mode: parser2.mode,
            body,
            index
          };
        },
        htmlBuilder(group, options2) {
          var inner2 = buildGroup$1(group.body, options2.havingCrampedStyle());
          if (inner2.height === 0) {
            inner2.height = options2.fontMetrics().xHeight;
          }
          inner2 = buildCommon.wrapFragment(inner2, options2);
          var metrics = options2.fontMetrics();
          var theta = metrics.defaultRuleThickness;
          var phi = theta;
          if (options2.style.id < Style$1.TEXT.id) {
            phi = options2.fontMetrics().xHeight;
          }
          var lineClearance = theta + phi / 4;
          var minDelimiterHeight = inner2.height + inner2.depth + lineClearance + theta;
          var {
            span: img,
            ruleWidth,
            advanceWidth
          } = delimiter.sqrtImage(minDelimiterHeight, options2);
          var delimDepth = img.height - ruleWidth;
          if (delimDepth > inner2.height + inner2.depth + lineClearance) {
            lineClearance = (lineClearance + delimDepth - inner2.height - inner2.depth) / 2;
          }
          var imgShift = img.height - inner2.height - lineClearance - ruleWidth;
          inner2.style.paddingLeft = makeEm(advanceWidth);
          var body = buildCommon.makeVList({
            positionType: "firstBaseline",
            children: [{
              type: "elem",
              elem: inner2,
              wrapperClasses: ["svg-align"]
            }, {
              type: "kern",
              size: -(inner2.height + imgShift)
            }, {
              type: "elem",
              elem: img
            }, {
              type: "kern",
              size: ruleWidth
            }]
          }, options2);
          if (!group.index) {
            return buildCommon.makeSpan(["mord", "sqrt"], [body], options2);
          } else {
            var newOptions = options2.havingStyle(Style$1.SCRIPTSCRIPT);
            var rootm = buildGroup$1(group.index, newOptions, options2);
            var toShift = 0.6 * (body.height - body.depth);
            var rootVList = buildCommon.makeVList({
              positionType: "shift",
              positionData: -toShift,
              children: [{
                type: "elem",
                elem: rootm
              }]
            }, options2);
            var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
            return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options2);
          }
        },
        mathmlBuilder(group, options2) {
          var {
            body,
            index
          } = group;
          return index ? new mathMLTree.MathNode("mroot", [buildGroup2(body, options2), buildGroup2(index, options2)]) : new mathMLTree.MathNode("msqrt", [buildGroup2(body, options2)]);
        }
      });
      styleMap = {
        "display": Style$1.DISPLAY,
        "text": Style$1.TEXT,
        "script": Style$1.SCRIPT,
        "scriptscript": Style$1.SCRIPTSCRIPT
      };
      defineFunction({
        type: "styling",
        names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
        props: {
          numArgs: 0,
          allowedInText: true,
          primitive: true
        },
        handler(_ref, args) {
          var {
            breakOnTokenText,
            funcName,
            parser: parser2
          } = _ref;
          var body = parser2.parseExpression(true, breakOnTokenText);
          var style = funcName.slice(1, funcName.length - 5);
          return {
            type: "styling",
            mode: parser2.mode,
            // Figure out what style to use by pulling out the style from
            // the function name
            style,
            body
          };
        },
        htmlBuilder(group, options2) {
          var newStyle = styleMap[group.style];
          var newOptions = options2.havingStyle(newStyle).withFont("");
          return sizingGroup(group.body, newOptions, options2);
        },
        mathmlBuilder(group, options2) {
          var newStyle = styleMap[group.style];
          var newOptions = options2.havingStyle(newStyle);
          var inner2 = buildExpression2(group.body, newOptions);
          var node = new mathMLTree.MathNode("mstyle", inner2);
          var styleAttributes = {
            "display": ["0", "true"],
            "text": ["0", "false"],
            "script": ["1", "false"],
            "scriptscript": ["2", "false"]
          };
          var attr = styleAttributes[group.style];
          node.setAttribute("scriptlevel", attr[0]);
          node.setAttribute("displaystyle", attr[1]);
          return node;
        }
      });
      htmlBuilderDelegate = function htmlBuilderDelegate2(group, options2) {
        var base = group.base;
        if (!base) {
          return null;
        } else if (base.type === "op") {
          var delegate = base.limits && (options2.style.size === Style$1.DISPLAY.size || base.alwaysHandleSupSub);
          return delegate ? htmlBuilder$2 : null;
        } else if (base.type === "operatorname") {
          var _delegate = base.alwaysHandleSupSub && (options2.style.size === Style$1.DISPLAY.size || base.limits);
          return _delegate ? htmlBuilder$1 : null;
        } else if (base.type === "accent") {
          return utils.isCharacterBox(base.base) ? htmlBuilder$a : null;
        } else if (base.type === "horizBrace") {
          var isSup = !group.sub;
          return isSup === base.isOver ? htmlBuilder$3 : null;
        } else {
          return null;
        }
      };
      defineFunctionBuilders({
        type: "supsub",
        htmlBuilder(group, options2) {
          var builderDelegate = htmlBuilderDelegate(group, options2);
          if (builderDelegate) {
            return builderDelegate(group, options2);
          }
          var {
            base: valueBase,
            sup: valueSup,
            sub: valueSub
          } = group;
          var base = buildGroup$1(valueBase, options2);
          var supm;
          var subm;
          var metrics = options2.fontMetrics();
          var supShift = 0;
          var subShift = 0;
          var isCharacterBox3 = valueBase && utils.isCharacterBox(valueBase);
          if (valueSup) {
            var newOptions = options2.havingStyle(options2.style.sup());
            supm = buildGroup$1(valueSup, newOptions, options2);
            if (!isCharacterBox3) {
              supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options2.sizeMultiplier;
            }
          }
          if (valueSub) {
            var _newOptions = options2.havingStyle(options2.style.sub());
            subm = buildGroup$1(valueSub, _newOptions, options2);
            if (!isCharacterBox3) {
              subShift = base.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options2.sizeMultiplier;
            }
          }
          var minSupShift;
          if (options2.style === Style$1.DISPLAY) {
            minSupShift = metrics.sup1;
          } else if (options2.style.cramped) {
            minSupShift = metrics.sup3;
          } else {
            minSupShift = metrics.sup2;
          }
          var multiplier = options2.sizeMultiplier;
          var marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
          var marginLeft = null;
          if (subm) {
            var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
            if (base instanceof SymbolNode || isOiint) {
              marginLeft = makeEm(-base.italic);
            }
          }
          var supsub;
          if (supm && subm) {
            supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
            subShift = Math.max(subShift, metrics.sub2);
            var ruleWidth = metrics.defaultRuleThickness;
            var maxWidth = 4 * ruleWidth;
            if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
              subShift = maxWidth - (supShift - supm.depth) + subm.height;
              var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
              if (psi > 0) {
                supShift += psi;
                subShift -= psi;
              }
            }
            var vlistElem = [{
              type: "elem",
              elem: subm,
              shift: subShift,
              marginRight,
              marginLeft
            }, {
              type: "elem",
              elem: supm,
              shift: -supShift,
              marginRight
            }];
            supsub = buildCommon.makeVList({
              positionType: "individualShift",
              children: vlistElem
            }, options2);
          } else if (subm) {
            subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
            var _vlistElem = [{
              type: "elem",
              elem: subm,
              marginLeft,
              marginRight
            }];
            supsub = buildCommon.makeVList({
              positionType: "shift",
              positionData: subShift,
              children: _vlistElem
            }, options2);
          } else if (supm) {
            supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
            supsub = buildCommon.makeVList({
              positionType: "shift",
              positionData: -supShift,
              children: [{
                type: "elem",
                elem: supm,
                marginRight
              }]
            }, options2);
          } else {
            throw new Error("supsub must have either sup or sub.");
          }
          var mclass = getTypeOfDomTree(base, "right") || "mord";
          return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options2);
        },
        mathmlBuilder(group, options2) {
          var isBrace = false;
          var isOver;
          var isSup;
          if (group.base && group.base.type === "horizBrace") {
            isSup = !!group.sup;
            if (isSup === group.base.isOver) {
              isBrace = true;
              isOver = group.base.isOver;
            }
          }
          if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
            group.base.parentIsSupSub = true;
          }
          var children = [buildGroup2(group.base, options2)];
          if (group.sub) {
            children.push(buildGroup2(group.sub, options2));
          }
          if (group.sup) {
            children.push(buildGroup2(group.sup, options2));
          }
          var nodeType;
          if (isBrace) {
            nodeType = isOver ? "mover" : "munder";
          } else if (!group.sub) {
            var base = group.base;
            if (base && base.type === "op" && base.limits && (options2.style === Style$1.DISPLAY || base.alwaysHandleSupSub)) {
              nodeType = "mover";
            } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options2.style === Style$1.DISPLAY)) {
              nodeType = "mover";
            } else {
              nodeType = "msup";
            }
          } else if (!group.sup) {
            var _base = group.base;
            if (_base && _base.type === "op" && _base.limits && (options2.style === Style$1.DISPLAY || _base.alwaysHandleSupSub)) {
              nodeType = "munder";
            } else if (_base && _base.type === "operatorname" && _base.alwaysHandleSupSub && (_base.limits || options2.style === Style$1.DISPLAY)) {
              nodeType = "munder";
            } else {
              nodeType = "msub";
            }
          } else {
            var _base2 = group.base;
            if (_base2 && _base2.type === "op" && _base2.limits && options2.style === Style$1.DISPLAY) {
              nodeType = "munderover";
            } else if (_base2 && _base2.type === "operatorname" && _base2.alwaysHandleSupSub && (options2.style === Style$1.DISPLAY || _base2.limits)) {
              nodeType = "munderover";
            } else {
              nodeType = "msubsup";
            }
          }
          return new mathMLTree.MathNode(nodeType, children);
        }
      });
      defineFunctionBuilders({
        type: "atom",
        htmlBuilder(group, options2) {
          return buildCommon.mathsym(group.text, group.mode, options2, ["m" + group.family]);
        },
        mathmlBuilder(group, options2) {
          var node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
          if (group.family === "bin") {
            var variant = getVariant(group, options2);
            if (variant === "bold-italic") {
              node.setAttribute("mathvariant", variant);
            }
          } else if (group.family === "punct") {
            node.setAttribute("separator", "true");
          } else if (group.family === "open" || group.family === "close") {
            node.setAttribute("stretchy", "false");
          }
          return node;
        }
      });
      defaultVariant = {
        "mi": "italic",
        "mn": "normal",
        "mtext": "normal"
      };
      defineFunctionBuilders({
        type: "mathord",
        htmlBuilder(group, options2) {
          return buildCommon.makeOrd(group, options2, "mathord");
        },
        mathmlBuilder(group, options2) {
          var node = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options2)]);
          var variant = getVariant(group, options2) || "italic";
          if (variant !== defaultVariant[node.type]) {
            node.setAttribute("mathvariant", variant);
          }
          return node;
        }
      });
      defineFunctionBuilders({
        type: "textord",
        htmlBuilder(group, options2) {
          return buildCommon.makeOrd(group, options2, "textord");
        },
        mathmlBuilder(group, options2) {
          var text2 = makeText(group.text, group.mode, options2);
          var variant = getVariant(group, options2) || "normal";
          var node;
          if (group.mode === "text") {
            node = new mathMLTree.MathNode("mtext", [text2]);
          } else if (/[0-9]/.test(group.text)) {
            node = new mathMLTree.MathNode("mn", [text2]);
          } else if (group.text === "\\prime") {
            node = new mathMLTree.MathNode("mo", [text2]);
          } else {
            node = new mathMLTree.MathNode("mi", [text2]);
          }
          if (variant !== defaultVariant[node.type]) {
            node.setAttribute("mathvariant", variant);
          }
          return node;
        }
      });
      cssSpace = {
        "\\nobreak": "nobreak",
        "\\allowbreak": "allowbreak"
      };
      regularSpace = {
        " ": {},
        "\\ ": {},
        "~": {
          className: "nobreak"
        },
        "\\space": {},
        "\\nobreakspace": {
          className: "nobreak"
        }
      };
      defineFunctionBuilders({
        type: "spacing",
        htmlBuilder(group, options2) {
          if (regularSpace.hasOwnProperty(group.text)) {
            var className = regularSpace[group.text].className || "";
            if (group.mode === "text") {
              var ord = buildCommon.makeOrd(group, options2, "textord");
              ord.classes.push(className);
              return ord;
            } else {
              return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options2)], options2);
            }
          } else if (cssSpace.hasOwnProperty(group.text)) {
            return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options2);
          } else {
            throw new ParseError('Unknown type of space "' + group.text + '"');
          }
        },
        mathmlBuilder(group, options2) {
          var node;
          if (regularSpace.hasOwnProperty(group.text)) {
            node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\xA0")]);
          } else if (cssSpace.hasOwnProperty(group.text)) {
            return new mathMLTree.MathNode("mspace");
          } else {
            throw new ParseError('Unknown type of space "' + group.text + '"');
          }
          return node;
        }
      });
      pad = () => {
        var padNode = new mathMLTree.MathNode("mtd", []);
        padNode.setAttribute("width", "50%");
        return padNode;
      };
      defineFunctionBuilders({
        type: "tag",
        mathmlBuilder(group, options2) {
          var table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options2)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options2)])])]);
          table.setAttribute("width", "100%");
          return table;
        }
      });
      textFontFamilies = {
        "\\text": void 0,
        "\\textrm": "textrm",
        "\\textsf": "textsf",
        "\\texttt": "texttt",
        "\\textnormal": "textrm"
      };
      textFontWeights = {
        "\\textbf": "textbf",
        "\\textmd": "textmd"
      };
      textFontShapes = {
        "\\textit": "textit",
        "\\textup": "textup"
      };
      optionsWithFont = (group, options2) => {
        var font = group.font;
        if (!font) {
          return options2;
        } else if (textFontFamilies[font]) {
          return options2.withTextFontFamily(textFontFamilies[font]);
        } else if (textFontWeights[font]) {
          return options2.withTextFontWeight(textFontWeights[font]);
        } else if (font === "\\emph") {
          return options2.fontShape === "textit" ? options2.withTextFontShape("textup") : options2.withTextFontShape("textit");
        }
        return options2.withTextFontShape(textFontShapes[font]);
      };
      defineFunction({
        type: "text",
        names: [
          // Font families
          "\\text",
          "\\textrm",
          "\\textsf",
          "\\texttt",
          "\\textnormal",
          // Font weights
          "\\textbf",
          "\\textmd",
          // Font Shapes
          "\\textit",
          "\\textup",
          "\\emph"
        ],
        props: {
          numArgs: 1,
          argTypes: ["text"],
          allowedInArgument: true,
          allowedInText: true
        },
        handler(_ref, args) {
          var {
            parser: parser2,
            funcName
          } = _ref;
          var body = args[0];
          return {
            type: "text",
            mode: parser2.mode,
            body: ordargument(body),
            font: funcName
          };
        },
        htmlBuilder(group, options2) {
          var newOptions = optionsWithFont(group, options2);
          var inner2 = buildExpression$1(group.body, newOptions, true);
          return buildCommon.makeSpan(["mord", "text"], inner2, newOptions);
        },
        mathmlBuilder(group, options2) {
          var newOptions = optionsWithFont(group, options2);
          return buildExpressionRow(group.body, newOptions);
        }
      });
      defineFunction({
        type: "underline",
        names: ["\\underline"],
        props: {
          numArgs: 1,
          allowedInText: true
        },
        handler(_ref, args) {
          var {
            parser: parser2
          } = _ref;
          return {
            type: "underline",
            mode: parser2.mode,
            body: args[0]
          };
        },
        htmlBuilder(group, options2) {
          var innerGroup = buildGroup$1(group.body, options2);
          var line = buildCommon.makeLineSpan("underline-line", options2);
          var defaultRuleThickness = options2.fontMetrics().defaultRuleThickness;
          var vlist = buildCommon.makeVList({
            positionType: "top",
            positionData: innerGroup.height,
            children: [{
              type: "kern",
              size: defaultRuleThickness
            }, {
              type: "elem",
              elem: line
            }, {
              type: "kern",
              size: 3 * defaultRuleThickness
            }, {
              type: "elem",
              elem: innerGroup
            }]
          }, options2);
          return buildCommon.makeSpan(["mord", "underline"], [vlist], options2);
        },
        mathmlBuilder(group, options2) {
          var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
          operator.setAttribute("stretchy", "true");
          var node = new mathMLTree.MathNode("munder", [buildGroup2(group.body, options2), operator]);
          node.setAttribute("accentunder", "true");
          return node;
        }
      });
      defineFunction({
        type: "vcenter",
        names: ["\\vcenter"],
        props: {
          numArgs: 1,
          argTypes: ["original"],
          // In LaTeX, \vcenter can act only on a box.
          allowedInText: false
        },
        handler(_ref, args) {
          var {
            parser: parser2
          } = _ref;
          return {
            type: "vcenter",
            mode: parser2.mode,
            body: args[0]
          };
        },
        htmlBuilder(group, options2) {
          var body = buildGroup$1(group.body, options2);
          var axisHeight = options2.fontMetrics().axisHeight;
          var dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
          return buildCommon.makeVList({
            positionType: "shift",
            positionData: dy,
            children: [{
              type: "elem",
              elem: body
            }]
          }, options2);
        },
        mathmlBuilder(group, options2) {
          return new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options2)], ["vcenter"]);
        }
      });
      defineFunction({
        type: "verb",
        names: ["\\verb"],
        props: {
          numArgs: 0,
          allowedInText: true
        },
        handler(context, args, optArgs) {
          throw new ParseError("\\verb ended by end of line instead of matching delimiter");
        },
        htmlBuilder(group, options2) {
          var text2 = makeVerb(group);
          var body = [];
          var newOptions = options2.havingStyle(options2.style.text());
          for (var i = 0; i < text2.length; i++) {
            var c = text2[i];
            if (c === "~") {
              c = "\\textasciitilde";
            }
            body.push(buildCommon.makeSymbol(c, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
          }
          return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options2)), buildCommon.tryCombineChars(body), newOptions);
        },
        mathmlBuilder(group, options2) {
          var text2 = new mathMLTree.TextNode(makeVerb(group));
          var node = new mathMLTree.MathNode("mtext", [text2]);
          node.setAttribute("mathvariant", "monospace");
          return node;
        }
      });
      makeVerb = (group) => group.body.replace(/ /g, group.star ? "\u2423" : "\xA0");
      functions = _functions;
      spaceRegexString = "[ \r\n	]";
      controlWordRegexString = "\\\\[a-zA-Z@]+";
      controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
      controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
      controlSpaceRegexString = "\\\\(\n|[ \r	]+\n?)[ \r	]*";
      combiningDiacriticalMarkString = "[\u0300-\u036F]";
      combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
      tokenRegexString = "(" + spaceRegexString + "+)|" + // whitespace
      (controlSpaceRegexString + "|") + // \whitespace
      "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + // single codepoint
      (combiningDiacriticalMarkString + "*") + // ...plus accents
      "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
      (combiningDiacriticalMarkString + "*") + // ...plus accents
      "|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
      ("|" + controlWordWhitespaceRegexString) + // \macroName + spaces
      ("|" + controlSymbolRegexString + ")");
      Lexer = class {
        // Category codes. The lexer only supports comment characters (14) for now.
        // MacroExpander additionally distinguishes active (13).
        constructor(input, settings) {
          this.input = void 0;
          this.settings = void 0;
          this.tokenRegex = void 0;
          this.catcodes = void 0;
          this.input = input;
          this.settings = settings;
          this.tokenRegex = new RegExp(tokenRegexString, "g");
          this.catcodes = {
            "%": 14,
            // comment character
            "~": 13
            // active character
          };
        }
        setCatcode(char, code) {
          this.catcodes[char] = code;
        }
        /**
         * This function lexes a single token.
         */
        lex() {
          var input = this.input;
          var pos = this.tokenRegex.lastIndex;
          if (pos === input.length) {
            return new Token("EOF", new SourceLocation(this, pos, pos));
          }
          var match = this.tokenRegex.exec(input);
          if (match === null || match.index !== pos) {
            throw new ParseError("Unexpected character: '" + input[pos] + "'", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));
          }
          var text2 = match[6] || match[3] || (match[2] ? "\\ " : " ");
          if (this.catcodes[text2] === 14) {
            var nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
            if (nlIndex === -1) {
              this.tokenRegex.lastIndex = input.length;
              this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
            } else {
              this.tokenRegex.lastIndex = nlIndex + 1;
            }
            return this.lex();
          }
          return new Token(text2, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
        }
      };
      Namespace = class {
        /**
         * Both arguments are optional.  The first argument is an object of
         * built-in mappings which never change.  The second argument is an object
         * of initial (global-level) mappings, which will constantly change
         * according to any global/top-level `set`s done.
         */
        constructor(builtins, globalMacros) {
          if (builtins === void 0) {
            builtins = {};
          }
          if (globalMacros === void 0) {
            globalMacros = {};
          }
          this.current = void 0;
          this.builtins = void 0;
          this.undefStack = void 0;
          this.current = globalMacros;
          this.builtins = builtins;
          this.undefStack = [];
        }
        /**
         * Start a new nested group, affecting future local `set`s.
         */
        beginGroup() {
          this.undefStack.push({});
        }
        /**
         * End current nested group, restoring values before the group began.
         */
        endGroup() {
          if (this.undefStack.length === 0) {
            throw new ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
          }
          var undefs = this.undefStack.pop();
          for (var undef in undefs) {
            if (undefs.hasOwnProperty(undef)) {
              if (undefs[undef] == null) {
                delete this.current[undef];
              } else {
                this.current[undef] = undefs[undef];
              }
            }
          }
        }
        /**
         * Ends all currently nested groups (if any), restoring values before the
         * groups began.  Useful in case of an error in the middle of parsing.
         */
        endGroups() {
          while (this.undefStack.length > 0) {
            this.endGroup();
          }
        }
        /**
         * Detect whether `name` has a definition.  Equivalent to
         * `get(name) != null`.
         */
        has(name) {
          return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
        }
        /**
         * Get the current value of a name, or `undefined` if there is no value.
         *
         * Note: Do not use `if (namespace.get(...))` to detect whether a macro
         * is defined, as the definition may be the empty string which evaluates
         * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
         * `if (namespace.has(...))`.
         */
        get(name) {
          if (this.current.hasOwnProperty(name)) {
            return this.current[name];
          } else {
            return this.builtins[name];
          }
        }
        /**
         * Set the current value of a name, and optionally set it globally too.
         * Local set() sets the current value and (when appropriate) adds an undo
         * operation to the undo stack.  Global set() may change the undo
         * operation at every level, so takes time linear in their number.
         * A value of undefined means to delete existing definitions.
         */
        set(name, value, global2) {
          if (global2 === void 0) {
            global2 = false;
          }
          if (global2) {
            for (var i = 0; i < this.undefStack.length; i++) {
              delete this.undefStack[i][name];
            }
            if (this.undefStack.length > 0) {
              this.undefStack[this.undefStack.length - 1][name] = value;
            }
          } else {
            var top = this.undefStack[this.undefStack.length - 1];
            if (top && !top.hasOwnProperty(name)) {
              top[name] = this.current[name];
            }
          }
          if (value == null) {
            delete this.current[name];
          } else {
            this.current[name] = value;
          }
        }
      };
      macros = _macros;
      defineMacro("\\noexpand", function(context) {
        var t = context.popToken();
        if (context.isExpandable(t.text)) {
          t.noexpand = true;
          t.treatAsRelax = true;
        }
        return {
          tokens: [t],
          numArgs: 0
        };
      });
      defineMacro("\\expandafter", function(context) {
        var t = context.popToken();
        context.expandOnce(true);
        return {
          tokens: [t],
          numArgs: 0
        };
      });
      defineMacro("\\@firstoftwo", function(context) {
        var args = context.consumeArgs(2);
        return {
          tokens: args[0],
          numArgs: 0
        };
      });
      defineMacro("\\@secondoftwo", function(context) {
        var args = context.consumeArgs(2);
        return {
          tokens: args[1],
          numArgs: 0
        };
      });
      defineMacro("\\@ifnextchar", function(context) {
        var args = context.consumeArgs(3);
        context.consumeSpaces();
        var nextToken = context.future();
        if (args[0].length === 1 && args[0][0].text === nextToken.text) {
          return {
            tokens: args[1],
            numArgs: 0
          };
        } else {
          return {
            tokens: args[2],
            numArgs: 0
          };
        }
      });
      defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
      defineMacro("\\TextOrMath", function(context) {
        var args = context.consumeArgs(2);
        if (context.mode === "text") {
          return {
            tokens: args[0],
            numArgs: 0
          };
        } else {
          return {
            tokens: args[1],
            numArgs: 0
          };
        }
      });
      digitToNumber = {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9,
        "a": 10,
        "A": 10,
        "b": 11,
        "B": 11,
        "c": 12,
        "C": 12,
        "d": 13,
        "D": 13,
        "e": 14,
        "E": 14,
        "f": 15,
        "F": 15
      };
      defineMacro("\\char", function(context) {
        var token = context.popToken();
        var base;
        var number = "";
        if (token.text === "'") {
          base = 8;
          token = context.popToken();
        } else if (token.text === '"') {
          base = 16;
          token = context.popToken();
        } else if (token.text === "`") {
          token = context.popToken();
          if (token.text[0] === "\\") {
            number = token.text.charCodeAt(1);
          } else if (token.text === "EOF") {
            throw new ParseError("\\char` missing argument");
          } else {
            number = token.text.charCodeAt(0);
          }
        } else {
          base = 10;
        }
        if (base) {
          number = digitToNumber[token.text];
          if (number == null || number >= base) {
            throw new ParseError("Invalid base-" + base + " digit " + token.text);
          }
          var digit;
          while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
            number *= base;
            number += digit;
            context.popToken();
          }
        }
        return "\\@char{" + number + "}";
      });
      newcommand = (context, existsOK, nonexistsOK, skipIfExists) => {
        var arg = context.consumeArg().tokens;
        if (arg.length !== 1) {
          throw new ParseError("\\newcommand's first argument must be a macro name");
        }
        var name = arg[0].text;
        var exists = context.isDefined(name);
        if (exists && !existsOK) {
          throw new ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
        }
        if (!exists && !nonexistsOK) {
          throw new ParseError("\\renewcommand{" + name + "} when command " + name + " does not yet exist; use \\newcommand");
        }
        var numArgs = 0;
        arg = context.consumeArg().tokens;
        if (arg.length === 1 && arg[0].text === "[") {
          var argText = "";
          var token = context.expandNextToken();
          while (token.text !== "]" && token.text !== "EOF") {
            argText += token.text;
            token = context.expandNextToken();
          }
          if (!argText.match(/^\s*[0-9]+\s*$/)) {
            throw new ParseError("Invalid number of arguments: " + argText);
          }
          numArgs = parseInt(argText);
          arg = context.consumeArg().tokens;
        }
        if (!(exists && skipIfExists)) {
          context.macros.set(name, {
            tokens: arg,
            numArgs
          });
        }
        return "";
      };
      defineMacro("\\newcommand", (context) => newcommand(context, false, true, false));
      defineMacro("\\renewcommand", (context) => newcommand(context, true, false, false));
      defineMacro("\\providecommand", (context) => newcommand(context, true, true, true));
      defineMacro("\\message", (context) => {
        var arg = context.consumeArgs(1)[0];
        console.log(arg.reverse().map((token) => token.text).join(""));
        return "";
      });
      defineMacro("\\errmessage", (context) => {
        var arg = context.consumeArgs(1)[0];
        console.error(arg.reverse().map((token) => token.text).join(""));
        return "";
      });
      defineMacro("\\show", (context) => {
        var tok = context.popToken();
        var name = tok.text;
        console.log(tok, context.macros.get(name), functions[name], symbols.math[name], symbols.text[name]);
        return "";
      });
      defineMacro("\\bgroup", "{");
      defineMacro("\\egroup", "}");
      defineMacro("~", "\\nobreakspace");
      defineMacro("\\lq", "`");
      defineMacro("\\rq", "'");
      defineMacro("\\aa", "\\r a");
      defineMacro("\\AA", "\\r A");
      defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`\xA9}");
      defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
      defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`\xAE}");
      defineMacro("\u212C", "\\mathscr{B}");
      defineMacro("\u2130", "\\mathscr{E}");
      defineMacro("\u2131", "\\mathscr{F}");
      defineMacro("\u210B", "\\mathscr{H}");
      defineMacro("\u2110", "\\mathscr{I}");
      defineMacro("\u2112", "\\mathscr{L}");
      defineMacro("\u2133", "\\mathscr{M}");
      defineMacro("\u211B", "\\mathscr{R}");
      defineMacro("\u212D", "\\mathfrak{C}");
      defineMacro("\u210C", "\\mathfrak{H}");
      defineMacro("\u2128", "\\mathfrak{Z}");
      defineMacro("\\Bbbk", "\\Bbb{k}");
      defineMacro("\xB7", "\\cdotp");
      defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
      defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
      defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
      defineMacro("\\mathstrut", "\\vphantom{(}");
      defineMacro("\\underbar", "\\underline{\\text{#1}}");
      defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
      defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`\u2260}}");
      defineMacro("\\ne", "\\neq");
      defineMacro("\u2260", "\\neq");
      defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`\u2209}}");
      defineMacro("\u2209", "\\notin");
      defineMacro("\u2258", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`\u2258}}");
      defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
      defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
      defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`\u225B}}");
      defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`\u225D}}");
      defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`\u225E}}");
      defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}");
      defineMacro("\u27C2", "\\perp");
      defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
      defineMacro("\u220C", "\\notni");
      defineMacro("\u231C", "\\ulcorner");
      defineMacro("\u231D", "\\urcorner");
      defineMacro("\u231E", "\\llcorner");
      defineMacro("\u231F", "\\lrcorner");
      defineMacro("\xA9", "\\copyright");
      defineMacro("\xAE", "\\textregistered");
      defineMacro("\uFE0F", "\\textregistered");
      defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
      defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
      defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
      defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
      defineMacro("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
      defineMacro("\u22EE", "\\vdots");
      defineMacro("\\varGamma", "\\mathit{\\Gamma}");
      defineMacro("\\varDelta", "\\mathit{\\Delta}");
      defineMacro("\\varTheta", "\\mathit{\\Theta}");
      defineMacro("\\varLambda", "\\mathit{\\Lambda}");
      defineMacro("\\varXi", "\\mathit{\\Xi}");
      defineMacro("\\varPi", "\\mathit{\\Pi}");
      defineMacro("\\varSigma", "\\mathit{\\Sigma}");
      defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
      defineMacro("\\varPhi", "\\mathit{\\Phi}");
      defineMacro("\\varPsi", "\\mathit{\\Psi}");
      defineMacro("\\varOmega", "\\mathit{\\Omega}");
      defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
      defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
      defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
      defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
      defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
      defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
      defineMacro("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
      defineMacro("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
      dotsByToken = {
        ",": "\\dotsc",
        "\\not": "\\dotsb",
        // \keybin@ checks for the following:
        "+": "\\dotsb",
        "=": "\\dotsb",
        "<": "\\dotsb",
        ">": "\\dotsb",
        "-": "\\dotsb",
        "*": "\\dotsb",
        ":": "\\dotsb",
        // Symbols whose definition starts with \DOTSB:
        "\\DOTSB": "\\dotsb",
        "\\coprod": "\\dotsb",
        "\\bigvee": "\\dotsb",
        "\\bigwedge": "\\dotsb",
        "\\biguplus": "\\dotsb",
        "\\bigcap": "\\dotsb",
        "\\bigcup": "\\dotsb",
        "\\prod": "\\dotsb",
        "\\sum": "\\dotsb",
        "\\bigotimes": "\\dotsb",
        "\\bigoplus": "\\dotsb",
        "\\bigodot": "\\dotsb",
        "\\bigsqcup": "\\dotsb",
        "\\And": "\\dotsb",
        "\\longrightarrow": "\\dotsb",
        "\\Longrightarrow": "\\dotsb",
        "\\longleftarrow": "\\dotsb",
        "\\Longleftarrow": "\\dotsb",
        "\\longleftrightarrow": "\\dotsb",
        "\\Longleftrightarrow": "\\dotsb",
        "\\mapsto": "\\dotsb",
        "\\longmapsto": "\\dotsb",
        "\\hookrightarrow": "\\dotsb",
        "\\doteq": "\\dotsb",
        // Symbols whose definition starts with \mathbin:
        "\\mathbin": "\\dotsb",
        // Symbols whose definition starts with \mathrel:
        "\\mathrel": "\\dotsb",
        "\\relbar": "\\dotsb",
        "\\Relbar": "\\dotsb",
        "\\xrightarrow": "\\dotsb",
        "\\xleftarrow": "\\dotsb",
        // Symbols whose definition starts with \DOTSI:
        "\\DOTSI": "\\dotsi",
        "\\int": "\\dotsi",
        "\\oint": "\\dotsi",
        "\\iint": "\\dotsi",
        "\\iiint": "\\dotsi",
        "\\iiiint": "\\dotsi",
        "\\idotsint": "\\dotsi",
        // Symbols whose definition starts with \DOTSX:
        "\\DOTSX": "\\dotsx"
      };
      defineMacro("\\dots", function(context) {
        var thedots = "\\dotso";
        var next = context.expandAfterFuture().text;
        if (next in dotsByToken) {
          thedots = dotsByToken[next];
        } else if (next.slice(0, 4) === "\\not") {
          thedots = "\\dotsb";
        } else if (next in symbols.math) {
          if (utils.contains(["bin", "rel"], symbols.math[next].group)) {
            thedots = "\\dotsb";
          }
        }
        return thedots;
      });
      spaceAfterDots = {
        // \rightdelim@ checks for the following:
        ")": true,
        "]": true,
        "\\rbrack": true,
        "\\}": true,
        "\\rbrace": true,
        "\\rangle": true,
        "\\rceil": true,
        "\\rfloor": true,
        "\\rgroup": true,
        "\\rmoustache": true,
        "\\right": true,
        "\\bigr": true,
        "\\biggr": true,
        "\\Bigr": true,
        "\\Biggr": true,
        // \extra@ also tests for the following:
        "$": true,
        // \extrap@ checks for the following:
        ";": true,
        ".": true,
        ",": true
      };
      defineMacro("\\dotso", function(context) {
        var next = context.future().text;
        if (next in spaceAfterDots) {
          return "\\ldots\\,";
        } else {
          return "\\ldots";
        }
      });
      defineMacro("\\dotsc", function(context) {
        var next = context.future().text;
        if (next in spaceAfterDots && next !== ",") {
          return "\\ldots\\,";
        } else {
          return "\\ldots";
        }
      });
      defineMacro("\\cdots", function(context) {
        var next = context.future().text;
        if (next in spaceAfterDots) {
          return "\\@cdots\\,";
        } else {
          return "\\@cdots";
        }
      });
      defineMacro("\\dotsb", "\\cdots");
      defineMacro("\\dotsm", "\\cdots");
      defineMacro("\\dotsi", "\\!\\cdots");
      defineMacro("\\dotsx", "\\ldots\\,");
      defineMacro("\\DOTSI", "\\relax");
      defineMacro("\\DOTSB", "\\relax");
      defineMacro("\\DOTSX", "\\relax");
      defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
      defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
      defineMacro("\\thinspace", "\\,");
      defineMacro("\\>", "\\mskip{4mu}");
      defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
      defineMacro("\\medspace", "\\:");
      defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
      defineMacro("\\thickspace", "\\;");
      defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
      defineMacro("\\negthinspace", "\\!");
      defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
      defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
      defineMacro("\\enspace", "\\kern.5em ");
      defineMacro("\\enskip", "\\hskip.5em\\relax");
      defineMacro("\\quad", "\\hskip1em\\relax");
      defineMacro("\\qquad", "\\hskip2em\\relax");
      defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
      defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
      defineMacro("\\tag@literal", (context) => {
        if (context.macros.get("\\df@tag")) {
          throw new ParseError("Multiple \\tag");
        }
        return "\\gdef\\df@tag{\\text{#1}}";
      });
      defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
      defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
      defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
      defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
      defineMacro("\\newline", "\\\\\\relax");
      defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
      latexRaiseA = makeEm(fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1]);
      defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
      defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
      defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
      defineMacro("\\@hspace", "\\hskip #1\\relax");
      defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
      defineMacro("\\ordinarycolon", ":");
      defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
      defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
      defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
      defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
      defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
      defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
      defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
      defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
      defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
      defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
      defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
      defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
      defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
      defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
      defineMacro("\u2237", "\\dblcolon");
      defineMacro("\u2239", "\\eqcolon");
      defineMacro("\u2254", "\\coloneqq");
      defineMacro("\u2255", "\\eqqcolon");
      defineMacro("\u2A74", "\\Coloneqq");
      defineMacro("\\ratio", "\\vcentcolon");
      defineMacro("\\coloncolon", "\\dblcolon");
      defineMacro("\\colonequals", "\\coloneqq");
      defineMacro("\\coloncolonequals", "\\Coloneqq");
      defineMacro("\\equalscolon", "\\eqqcolon");
      defineMacro("\\equalscoloncolon", "\\Eqqcolon");
      defineMacro("\\colonminus", "\\coloneq");
      defineMacro("\\coloncolonminus", "\\Coloneq");
      defineMacro("\\minuscolon", "\\eqcolon");
      defineMacro("\\minuscoloncolon", "\\Eqcolon");
      defineMacro("\\coloncolonapprox", "\\Colonapprox");
      defineMacro("\\coloncolonsim", "\\Colonsim");
      defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
      defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
      defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
      defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
      defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
      defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
      defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
      defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
      defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
      defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
      defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
      defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
      defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
      defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
      defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
      defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
      defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
      defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
      defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
      defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{\u2224}");
      defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{\u2226}");
      defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
      defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
      defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{\u228A}");
      defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{\u2ACB}");
      defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{\u228B}");
      defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{\u2ACC}");
      defineMacro("\\imath", "\\html@mathml{\\@imath}{\u0131}");
      defineMacro("\\jmath", "\\html@mathml{\\@jmath}{\u0237}");
      defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`\u27E6}}");
      defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`\u27E7}}");
      defineMacro("\u27E6", "\\llbracket");
      defineMacro("\u27E7", "\\rrbracket");
      defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`\u2983}}");
      defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`\u2984}}");
      defineMacro("\u2983", "\\lBrace");
      defineMacro("\u2984", "\\rBrace");
      defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`\u29B5}}");
      defineMacro("\u29B5", "\\minuso");
      defineMacro("\\darr", "\\downarrow");
      defineMacro("\\dArr", "\\Downarrow");
      defineMacro("\\Darr", "\\Downarrow");
      defineMacro("\\lang", "\\langle");
      defineMacro("\\rang", "\\rangle");
      defineMacro("\\uarr", "\\uparrow");
      defineMacro("\\uArr", "\\Uparrow");
      defineMacro("\\Uarr", "\\Uparrow");
      defineMacro("\\N", "\\mathbb{N}");
      defineMacro("\\R", "\\mathbb{R}");
      defineMacro("\\Z", "\\mathbb{Z}");
      defineMacro("\\alef", "\\aleph");
      defineMacro("\\alefsym", "\\aleph");
      defineMacro("\\Alpha", "\\mathrm{A}");
      defineMacro("\\Beta", "\\mathrm{B}");
      defineMacro("\\bull", "\\bullet");
      defineMacro("\\Chi", "\\mathrm{X}");
      defineMacro("\\clubs", "\\clubsuit");
      defineMacro("\\cnums", "\\mathbb{C}");
      defineMacro("\\Complex", "\\mathbb{C}");
      defineMacro("\\Dagger", "\\ddagger");
      defineMacro("\\diamonds", "\\diamondsuit");
      defineMacro("\\empty", "\\emptyset");
      defineMacro("\\Epsilon", "\\mathrm{E}");
      defineMacro("\\Eta", "\\mathrm{H}");
      defineMacro("\\exist", "\\exists");
      defineMacro("\\harr", "\\leftrightarrow");
      defineMacro("\\hArr", "\\Leftrightarrow");
      defineMacro("\\Harr", "\\Leftrightarrow");
      defineMacro("\\hearts", "\\heartsuit");
      defineMacro("\\image", "\\Im");
      defineMacro("\\infin", "\\infty");
      defineMacro("\\Iota", "\\mathrm{I}");
      defineMacro("\\isin", "\\in");
      defineMacro("\\Kappa", "\\mathrm{K}");
      defineMacro("\\larr", "\\leftarrow");
      defineMacro("\\lArr", "\\Leftarrow");
      defineMacro("\\Larr", "\\Leftarrow");
      defineMacro("\\lrarr", "\\leftrightarrow");
      defineMacro("\\lrArr", "\\Leftrightarrow");
      defineMacro("\\Lrarr", "\\Leftrightarrow");
      defineMacro("\\Mu", "\\mathrm{M}");
      defineMacro("\\natnums", "\\mathbb{N}");
      defineMacro("\\Nu", "\\mathrm{N}");
      defineMacro("\\Omicron", "\\mathrm{O}");
      defineMacro("\\plusmn", "\\pm");
      defineMacro("\\rarr", "\\rightarrow");
      defineMacro("\\rArr", "\\Rightarrow");
      defineMacro("\\Rarr", "\\Rightarrow");
      defineMacro("\\real", "\\Re");
      defineMacro("\\reals", "\\mathbb{R}");
      defineMacro("\\Reals", "\\mathbb{R}");
      defineMacro("\\Rho", "\\mathrm{P}");
      defineMacro("\\sdot", "\\cdot");
      defineMacro("\\sect", "\\S");
      defineMacro("\\spades", "\\spadesuit");
      defineMacro("\\sub", "\\subset");
      defineMacro("\\sube", "\\subseteq");
      defineMacro("\\supe", "\\supseteq");
      defineMacro("\\Tau", "\\mathrm{T}");
      defineMacro("\\thetasym", "\\vartheta");
      defineMacro("\\weierp", "\\wp");
      defineMacro("\\Zeta", "\\mathrm{Z}");
      defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
      defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
      defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
      defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
      defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
      defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
      defineMacro("\\Bra", "\\left\\langle#1\\right|");
      defineMacro("\\Ket", "\\left|#1\\right\\rangle");
      braketHelper = (one) => (context) => {
        var left = context.consumeArg().tokens;
        var middle = context.consumeArg().tokens;
        var middleDouble = context.consumeArg().tokens;
        var right = context.consumeArg().tokens;
        var oldMiddle = context.macros.get("|");
        var oldMiddleDouble = context.macros.get("\\|");
        context.macros.beginGroup();
        var midMacro = (double) => (context2) => {
          if (one) {
            context2.macros.set("|", oldMiddle);
            if (middleDouble.length) {
              context2.macros.set("\\|", oldMiddleDouble);
            }
          }
          var doubled = double;
          if (!double && middleDouble.length) {
            var nextToken = context2.future();
            if (nextToken.text === "|") {
              context2.popToken();
              doubled = true;
            }
          }
          return {
            tokens: doubled ? middleDouble : middle,
            numArgs: 0
          };
        };
        context.macros.set("|", midMacro(false));
        if (middleDouble.length) {
          context.macros.set("\\|", midMacro(true));
        }
        var arg = context.consumeArg().tokens;
        var expanded = context.expandTokens([
          ...right,
          ...arg,
          ...left
          // reversed
        ]);
        context.macros.endGroup();
        return {
          tokens: expanded.reverse(),
          numArgs: 0
        };
      };
      defineMacro("\\bra@ket", braketHelper(false));
      defineMacro("\\bra@set", braketHelper(true));
      defineMacro("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
      defineMacro("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
      defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
      defineMacro("\\angln", "{\\angl n}");
      defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
      defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
      defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
      defineMacro("\\red", "\\textcolor{##df0030}{#1}");
      defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
      defineMacro("\\gray", "\\textcolor{gray}{#1}");
      defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
      defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
      defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
      defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
      defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
      defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
      defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
      defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
      defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
      defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
      defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
      defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
      defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
      defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
      defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
      defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
      defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
      defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
      defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
      defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
      defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
      defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
      defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
      defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
      defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
      defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
      defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
      defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
      defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
      defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
      defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
      defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
      defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
      defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
      defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
      defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
      defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
      defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
      defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
      defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
      defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
      defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
      defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
      defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
      defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
      defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
      defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
      defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
      defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
      defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
      implicitCommands = {
        "^": true,
        // Parser.js
        "_": true,
        // Parser.js
        "\\limits": true,
        // Parser.js
        "\\nolimits": true
        // Parser.js
      };
      MacroExpander = class {
        constructor(input, settings, mode) {
          this.settings = void 0;
          this.expansionCount = void 0;
          this.lexer = void 0;
          this.macros = void 0;
          this.stack = void 0;
          this.mode = void 0;
          this.settings = settings;
          this.expansionCount = 0;
          this.feed(input);
          this.macros = new Namespace(macros, settings.macros);
          this.mode = mode;
          this.stack = [];
        }
        /**
         * Feed a new input string to the same MacroExpander
         * (with existing macros etc.).
         */
        feed(input) {
          this.lexer = new Lexer(input, this.settings);
        }
        /**
         * Switches between "text" and "math" modes.
         */
        switchMode(newMode) {
          this.mode = newMode;
        }
        /**
         * Start a new group nesting within all namespaces.
         */
        beginGroup() {
          this.macros.beginGroup();
        }
        /**
         * End current group nesting within all namespaces.
         */
        endGroup() {
          this.macros.endGroup();
        }
        /**
         * Ends all currently nested groups (if any), restoring values before the
         * groups began.  Useful in case of an error in the middle of parsing.
         */
        endGroups() {
          this.macros.endGroups();
        }
        /**
         * Returns the topmost token on the stack, without expanding it.
         * Similar in behavior to TeX's `\futurelet`.
         */
        future() {
          if (this.stack.length === 0) {
            this.pushToken(this.lexer.lex());
          }
          return this.stack[this.stack.length - 1];
        }
        /**
         * Remove and return the next unexpanded token.
         */
        popToken() {
          this.future();
          return this.stack.pop();
        }
        /**
         * Add a given token to the token stack.  In particular, this get be used
         * to put back a token returned from one of the other methods.
         */
        pushToken(token) {
          this.stack.push(token);
        }
        /**
         * Append an array of tokens to the token stack.
         */
        pushTokens(tokens) {
          this.stack.push(...tokens);
        }
        /**
         * Find an macro argument without expanding tokens and append the array of
         * tokens to the token stack. Uses Token as a container for the result.
         */
        scanArgument(isOptional) {
          var start;
          var end;
          var tokens;
          if (isOptional) {
            this.consumeSpaces();
            if (this.future().text !== "[") {
              return null;
            }
            start = this.popToken();
            ({
              tokens,
              end
            } = this.consumeArg(["]"]));
          } else {
            ({
              tokens,
              start,
              end
            } = this.consumeArg());
          }
          this.pushToken(new Token("EOF", end.loc));
          this.pushTokens(tokens);
          return start.range(end, "");
        }
        /**
         * Consume all following space tokens, without expansion.
         */
        consumeSpaces() {
          for (; ; ) {
            var token = this.future();
            if (token.text === " ") {
              this.stack.pop();
            } else {
              break;
            }
          }
        }
        /**
         * Consume an argument from the token stream, and return the resulting array
         * of tokens and start/end token.
         */
        consumeArg(delims) {
          var tokens = [];
          var isDelimited = delims && delims.length > 0;
          if (!isDelimited) {
            this.consumeSpaces();
          }
          var start = this.future();
          var tok;
          var depth = 0;
          var match = 0;
          do {
            tok = this.popToken();
            tokens.push(tok);
            if (tok.text === "{") {
              ++depth;
            } else if (tok.text === "}") {
              --depth;
              if (depth === -1) {
                throw new ParseError("Extra }", tok);
              }
            } else if (tok.text === "EOF") {
              throw new ParseError("Unexpected end of input in a macro argument, expected '" + (delims && isDelimited ? delims[match] : "}") + "'", tok);
            }
            if (delims && isDelimited) {
              if ((depth === 0 || depth === 1 && delims[match] === "{") && tok.text === delims[match]) {
                ++match;
                if (match === delims.length) {
                  tokens.splice(-match, match);
                  break;
                }
              } else {
                match = 0;
              }
            }
          } while (depth !== 0 || isDelimited);
          if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
            tokens.pop();
            tokens.shift();
          }
          tokens.reverse();
          return {
            tokens,
            start,
            end: tok
          };
        }
        /**
         * Consume the specified number of (delimited) arguments from the token
         * stream and return the resulting array of arguments.
         */
        consumeArgs(numArgs, delimiters2) {
          if (delimiters2) {
            if (delimiters2.length !== numArgs + 1) {
              throw new ParseError("The length of delimiters doesn't match the number of args!");
            }
            var delims = delimiters2[0];
            for (var i = 0; i < delims.length; i++) {
              var tok = this.popToken();
              if (delims[i] !== tok.text) {
                throw new ParseError("Use of the macro doesn't match its definition", tok);
              }
            }
          }
          var args = [];
          for (var _i = 0; _i < numArgs; _i++) {
            args.push(this.consumeArg(delimiters2 && delimiters2[_i + 1]).tokens);
          }
          return args;
        }
        /**
         * Increment `expansionCount` by the specified amount.
         * Throw an error if it exceeds `maxExpand`.
         */
        countExpansion(amount) {
          this.expansionCount += amount;
          if (this.expansionCount > this.settings.maxExpand) {
            throw new ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
          }
        }
        /**
         * Expand the next token only once if possible.
         *
         * If the token is expanded, the resulting tokens will be pushed onto
         * the stack in reverse order, and the number of such tokens will be
         * returned.  This number might be zero or positive.
         *
         * If not, the return value is `false`, and the next token remains at the
         * top of the stack.
         *
         * In either case, the next token will be on the top of the stack,
         * or the stack will be empty (in case of empty expansion
         * and no other tokens).
         *
         * Used to implement `expandAfterFuture` and `expandNextToken`.
         *
         * If expandableOnly, only expandable tokens are expanded and
         * an undefined control sequence results in an error.
         */
        expandOnce(expandableOnly) {
          var topToken = this.popToken();
          var name = topToken.text;
          var expansion = !topToken.noexpand ? this._getExpansion(name) : null;
          if (expansion == null || expandableOnly && expansion.unexpandable) {
            if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
              throw new ParseError("Undefined control sequence: " + name);
            }
            this.pushToken(topToken);
            return false;
          }
          this.countExpansion(1);
          var tokens = expansion.tokens;
          var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
          if (expansion.numArgs) {
            tokens = tokens.slice();
            for (var i = tokens.length - 1; i >= 0; --i) {
              var tok = tokens[i];
              if (tok.text === "#") {
                if (i === 0) {
                  throw new ParseError("Incomplete placeholder at end of macro body", tok);
                }
                tok = tokens[--i];
                if (tok.text === "#") {
                  tokens.splice(i + 1, 1);
                } else if (/^[1-9]$/.test(tok.text)) {
                  tokens.splice(i, 2, ...args[+tok.text - 1]);
                } else {
                  throw new ParseError("Not a valid argument number", tok);
                }
              }
            }
          }
          this.pushTokens(tokens);
          return tokens.length;
        }
        /**
         * Expand the next token only once (if possible), and return the resulting
         * top token on the stack (without removing anything from the stack).
         * Similar in behavior to TeX's `\expandafter\futurelet`.
         * Equivalent to expandOnce() followed by future().
         */
        expandAfterFuture() {
          this.expandOnce();
          return this.future();
        }
        /**
         * Recursively expand first token, then return first non-expandable token.
         */
        expandNextToken() {
          for (; ; ) {
            if (this.expandOnce() === false) {
              var token = this.stack.pop();
              if (token.treatAsRelax) {
                token.text = "\\relax";
              }
              return token;
            }
          }
          throw new Error();
        }
        /**
         * Fully expand the given macro name and return the resulting list of
         * tokens, or return `undefined` if no such macro is defined.
         */
        expandMacro(name) {
          return this.macros.has(name) ? this.expandTokens([new Token(name)]) : void 0;
        }
        /**
         * Fully expand the given token stream and return the resulting list of
         * tokens.  Note that the input tokens are in reverse order, but the
         * output tokens are in forward order.
         */
        expandTokens(tokens) {
          var output = [];
          var oldStackLength = this.stack.length;
          this.pushTokens(tokens);
          while (this.stack.length > oldStackLength) {
            if (this.expandOnce(true) === false) {
              var token = this.stack.pop();
              if (token.treatAsRelax) {
                token.noexpand = false;
                token.treatAsRelax = false;
              }
              output.push(token);
            }
          }
          this.countExpansion(output.length);
          return output;
        }
        /**
         * Fully expand the given macro name and return the result as a string,
         * or return `undefined` if no such macro is defined.
         */
        expandMacroAsText(name) {
          var tokens = this.expandMacro(name);
          if (tokens) {
            return tokens.map((token) => token.text).join("");
          } else {
            return tokens;
          }
        }
        /**
         * Returns the expanded macro as a reversed array of tokens and a macro
         * argument count.  Or returns `null` if no such macro.
         */
        _getExpansion(name) {
          var definition = this.macros.get(name);
          if (definition == null) {
            return definition;
          }
          if (name.length === 1) {
            var catcode = this.lexer.catcodes[name];
            if (catcode != null && catcode !== 13) {
              return;
            }
          }
          var expansion = typeof definition === "function" ? definition(this) : definition;
          if (typeof expansion === "string") {
            var numArgs = 0;
            if (expansion.indexOf("#") !== -1) {
              var stripped = expansion.replace(/##/g, "");
              while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
                ++numArgs;
              }
            }
            var bodyLexer = new Lexer(expansion, this.settings);
            var tokens = [];
            var tok = bodyLexer.lex();
            while (tok.text !== "EOF") {
              tokens.push(tok);
              tok = bodyLexer.lex();
            }
            tokens.reverse();
            var expanded = {
              tokens,
              numArgs
            };
            return expanded;
          }
          return expansion;
        }
        /**
         * Determine whether a command is currently "defined" (has some
         * functionality), meaning that it's a macro (in the current group),
         * a function, a symbol, or one of the special commands listed in
         * `implicitCommands`.
         */
        isDefined(name) {
          return this.macros.has(name) || functions.hasOwnProperty(name) || symbols.math.hasOwnProperty(name) || symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
        }
        /**
         * Determine whether a command is expandable.
         */
        isExpandable(name) {
          var macro = this.macros.get(name);
          return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : functions.hasOwnProperty(name) && !functions[name].primitive;
        }
      };
      unicodeSubRegEx = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/;
      uSubsAndSups = Object.freeze({
        "\u208A": "+",
        "\u208B": "-",
        "\u208C": "=",
        "\u208D": "(",
        "\u208E": ")",
        "\u2080": "0",
        "\u2081": "1",
        "\u2082": "2",
        "\u2083": "3",
        "\u2084": "4",
        "\u2085": "5",
        "\u2086": "6",
        "\u2087": "7",
        "\u2088": "8",
        "\u2089": "9",
        "\u2090": "a",
        "\u2091": "e",
        "\u2095": "h",
        "\u1D62": "i",
        "\u2C7C": "j",
        "\u2096": "k",
        "\u2097": "l",
        "\u2098": "m",
        "\u2099": "n",
        "\u2092": "o",
        "\u209A": "p",
        "\u1D63": "r",
        "\u209B": "s",
        "\u209C": "t",
        "\u1D64": "u",
        "\u1D65": "v",
        "\u2093": "x",
        "\u1D66": "\u03B2",
        "\u1D67": "\u03B3",
        "\u1D68": "\u03C1",
        "\u1D69": "\u03D5",
        "\u1D6A": "\u03C7",
        "\u207A": "+",
        "\u207B": "-",
        "\u207C": "=",
        "\u207D": "(",
        "\u207E": ")",
        "\u2070": "0",
        "\xB9": "1",
        "\xB2": "2",
        "\xB3": "3",
        "\u2074": "4",
        "\u2075": "5",
        "\u2076": "6",
        "\u2077": "7",
        "\u2078": "8",
        "\u2079": "9",
        "\u1D2C": "A",
        "\u1D2E": "B",
        "\u1D30": "D",
        "\u1D31": "E",
        "\u1D33": "G",
        "\u1D34": "H",
        "\u1D35": "I",
        "\u1D36": "J",
        "\u1D37": "K",
        "\u1D38": "L",
        "\u1D39": "M",
        "\u1D3A": "N",
        "\u1D3C": "O",
        "\u1D3E": "P",
        "\u1D3F": "R",
        "\u1D40": "T",
        "\u1D41": "U",
        "\u2C7D": "V",
        "\u1D42": "W",
        "\u1D43": "a",
        "\u1D47": "b",
        "\u1D9C": "c",
        "\u1D48": "d",
        "\u1D49": "e",
        "\u1DA0": "f",
        "\u1D4D": "g",
        "\u02B0": "h",
        "\u2071": "i",
        "\u02B2": "j",
        "\u1D4F": "k",
        "\u02E1": "l",
        "\u1D50": "m",
        "\u207F": "n",
        "\u1D52": "o",
        "\u1D56": "p",
        "\u02B3": "r",
        "\u02E2": "s",
        "\u1D57": "t",
        "\u1D58": "u",
        "\u1D5B": "v",
        "\u02B7": "w",
        "\u02E3": "x",
        "\u02B8": "y",
        "\u1DBB": "z",
        "\u1D5D": "\u03B2",
        "\u1D5E": "\u03B3",
        "\u1D5F": "\u03B4",
        "\u1D60": "\u03D5",
        "\u1D61": "\u03C7",
        "\u1DBF": "\u03B8"
      });
      unicodeAccents = {
        "\u0301": {
          "text": "\\'",
          "math": "\\acute"
        },
        "\u0300": {
          "text": "\\`",
          "math": "\\grave"
        },
        "\u0308": {
          "text": '\\"',
          "math": "\\ddot"
        },
        "\u0303": {
          "text": "\\~",
          "math": "\\tilde"
        },
        "\u0304": {
          "text": "\\=",
          "math": "\\bar"
        },
        "\u0306": {
          "text": "\\u",
          "math": "\\breve"
        },
        "\u030C": {
          "text": "\\v",
          "math": "\\check"
        },
        "\u0302": {
          "text": "\\^",
          "math": "\\hat"
        },
        "\u0307": {
          "text": "\\.",
          "math": "\\dot"
        },
        "\u030A": {
          "text": "\\r",
          "math": "\\mathring"
        },
        "\u030B": {
          "text": "\\H"
        },
        "\u0327": {
          "text": "\\c"
        }
      };
      unicodeSymbols = {
        "\xE1": "a\u0301",
        "\xE0": "a\u0300",
        "\xE4": "a\u0308",
        "\u01DF": "a\u0308\u0304",
        "\xE3": "a\u0303",
        "\u0101": "a\u0304",
        "\u0103": "a\u0306",
        "\u1EAF": "a\u0306\u0301",
        "\u1EB1": "a\u0306\u0300",
        "\u1EB5": "a\u0306\u0303",
        "\u01CE": "a\u030C",
        "\xE2": "a\u0302",
        "\u1EA5": "a\u0302\u0301",
        "\u1EA7": "a\u0302\u0300",
        "\u1EAB": "a\u0302\u0303",
        "\u0227": "a\u0307",
        "\u01E1": "a\u0307\u0304",
        "\xE5": "a\u030A",
        "\u01FB": "a\u030A\u0301",
        "\u1E03": "b\u0307",
        "\u0107": "c\u0301",
        "\u1E09": "c\u0327\u0301",
        "\u010D": "c\u030C",
        "\u0109": "c\u0302",
        "\u010B": "c\u0307",
        "\xE7": "c\u0327",
        "\u010F": "d\u030C",
        "\u1E0B": "d\u0307",
        "\u1E11": "d\u0327",
        "\xE9": "e\u0301",
        "\xE8": "e\u0300",
        "\xEB": "e\u0308",
        "\u1EBD": "e\u0303",
        "\u0113": "e\u0304",
        "\u1E17": "e\u0304\u0301",
        "\u1E15": "e\u0304\u0300",
        "\u0115": "e\u0306",
        "\u1E1D": "e\u0327\u0306",
        "\u011B": "e\u030C",
        "\xEA": "e\u0302",
        "\u1EBF": "e\u0302\u0301",
        "\u1EC1": "e\u0302\u0300",
        "\u1EC5": "e\u0302\u0303",
        "\u0117": "e\u0307",
        "\u0229": "e\u0327",
        "\u1E1F": "f\u0307",
        "\u01F5": "g\u0301",
        "\u1E21": "g\u0304",
        "\u011F": "g\u0306",
        "\u01E7": "g\u030C",
        "\u011D": "g\u0302",
        "\u0121": "g\u0307",
        "\u0123": "g\u0327",
        "\u1E27": "h\u0308",
        "\u021F": "h\u030C",
        "\u0125": "h\u0302",
        "\u1E23": "h\u0307",
        "\u1E29": "h\u0327",
        "\xED": "i\u0301",
        "\xEC": "i\u0300",
        "\xEF": "i\u0308",
        "\u1E2F": "i\u0308\u0301",
        "\u0129": "i\u0303",
        "\u012B": "i\u0304",
        "\u012D": "i\u0306",
        "\u01D0": "i\u030C",
        "\xEE": "i\u0302",
        "\u01F0": "j\u030C",
        "\u0135": "j\u0302",
        "\u1E31": "k\u0301",
        "\u01E9": "k\u030C",
        "\u0137": "k\u0327",
        "\u013A": "l\u0301",
        "\u013E": "l\u030C",
        "\u013C": "l\u0327",
        "\u1E3F": "m\u0301",
        "\u1E41": "m\u0307",
        "\u0144": "n\u0301",
        "\u01F9": "n\u0300",
        "\xF1": "n\u0303",
        "\u0148": "n\u030C",
        "\u1E45": "n\u0307",
        "\u0146": "n\u0327",
        "\xF3": "o\u0301",
        "\xF2": "o\u0300",
        "\xF6": "o\u0308",
        "\u022B": "o\u0308\u0304",
        "\xF5": "o\u0303",
        "\u1E4D": "o\u0303\u0301",
        "\u1E4F": "o\u0303\u0308",
        "\u022D": "o\u0303\u0304",
        "\u014D": "o\u0304",
        "\u1E53": "o\u0304\u0301",
        "\u1E51": "o\u0304\u0300",
        "\u014F": "o\u0306",
        "\u01D2": "o\u030C",
        "\xF4": "o\u0302",
        "\u1ED1": "o\u0302\u0301",
        "\u1ED3": "o\u0302\u0300",
        "\u1ED7": "o\u0302\u0303",
        "\u022F": "o\u0307",
        "\u0231": "o\u0307\u0304",
        "\u0151": "o\u030B",
        "\u1E55": "p\u0301",
        "\u1E57": "p\u0307",
        "\u0155": "r\u0301",
        "\u0159": "r\u030C",
        "\u1E59": "r\u0307",
        "\u0157": "r\u0327",
        "\u015B": "s\u0301",
        "\u1E65": "s\u0301\u0307",
        "\u0161": "s\u030C",
        "\u1E67": "s\u030C\u0307",
        "\u015D": "s\u0302",
        "\u1E61": "s\u0307",
        "\u015F": "s\u0327",
        "\u1E97": "t\u0308",
        "\u0165": "t\u030C",
        "\u1E6B": "t\u0307",
        "\u0163": "t\u0327",
        "\xFA": "u\u0301",
        "\xF9": "u\u0300",
        "\xFC": "u\u0308",
        "\u01D8": "u\u0308\u0301",
        "\u01DC": "u\u0308\u0300",
        "\u01D6": "u\u0308\u0304",
        "\u01DA": "u\u0308\u030C",
        "\u0169": "u\u0303",
        "\u1E79": "u\u0303\u0301",
        "\u016B": "u\u0304",
        "\u1E7B": "u\u0304\u0308",
        "\u016D": "u\u0306",
        "\u01D4": "u\u030C",
        "\xFB": "u\u0302",
        "\u016F": "u\u030A",
        "\u0171": "u\u030B",
        "\u1E7D": "v\u0303",
        "\u1E83": "w\u0301",
        "\u1E81": "w\u0300",
        "\u1E85": "w\u0308",
        "\u0175": "w\u0302",
        "\u1E87": "w\u0307",
        "\u1E98": "w\u030A",
        "\u1E8D": "x\u0308",
        "\u1E8B": "x\u0307",
        "\xFD": "y\u0301",
        "\u1EF3": "y\u0300",
        "\xFF": "y\u0308",
        "\u1EF9": "y\u0303",
        "\u0233": "y\u0304",
        "\u0177": "y\u0302",
        "\u1E8F": "y\u0307",
        "\u1E99": "y\u030A",
        "\u017A": "z\u0301",
        "\u017E": "z\u030C",
        "\u1E91": "z\u0302",
        "\u017C": "z\u0307",
        "\xC1": "A\u0301",
        "\xC0": "A\u0300",
        "\xC4": "A\u0308",
        "\u01DE": "A\u0308\u0304",
        "\xC3": "A\u0303",
        "\u0100": "A\u0304",
        "\u0102": "A\u0306",
        "\u1EAE": "A\u0306\u0301",
        "\u1EB0": "A\u0306\u0300",
        "\u1EB4": "A\u0306\u0303",
        "\u01CD": "A\u030C",
        "\xC2": "A\u0302",
        "\u1EA4": "A\u0302\u0301",
        "\u1EA6": "A\u0302\u0300",
        "\u1EAA": "A\u0302\u0303",
        "\u0226": "A\u0307",
        "\u01E0": "A\u0307\u0304",
        "\xC5": "A\u030A",
        "\u01FA": "A\u030A\u0301",
        "\u1E02": "B\u0307",
        "\u0106": "C\u0301",
        "\u1E08": "C\u0327\u0301",
        "\u010C": "C\u030C",
        "\u0108": "C\u0302",
        "\u010A": "C\u0307",
        "\xC7": "C\u0327",
        "\u010E": "D\u030C",
        "\u1E0A": "D\u0307",
        "\u1E10": "D\u0327",
        "\xC9": "E\u0301",
        "\xC8": "E\u0300",
        "\xCB": "E\u0308",
        "\u1EBC": "E\u0303",
        "\u0112": "E\u0304",
        "\u1E16": "E\u0304\u0301",
        "\u1E14": "E\u0304\u0300",
        "\u0114": "E\u0306",
        "\u1E1C": "E\u0327\u0306",
        "\u011A": "E\u030C",
        "\xCA": "E\u0302",
        "\u1EBE": "E\u0302\u0301",
        "\u1EC0": "E\u0302\u0300",
        "\u1EC4": "E\u0302\u0303",
        "\u0116": "E\u0307",
        "\u0228": "E\u0327",
        "\u1E1E": "F\u0307",
        "\u01F4": "G\u0301",
        "\u1E20": "G\u0304",
        "\u011E": "G\u0306",
        "\u01E6": "G\u030C",
        "\u011C": "G\u0302",
        "\u0120": "G\u0307",
        "\u0122": "G\u0327",
        "\u1E26": "H\u0308",
        "\u021E": "H\u030C",
        "\u0124": "H\u0302",
        "\u1E22": "H\u0307",
        "\u1E28": "H\u0327",
        "\xCD": "I\u0301",
        "\xCC": "I\u0300",
        "\xCF": "I\u0308",
        "\u1E2E": "I\u0308\u0301",
        "\u0128": "I\u0303",
        "\u012A": "I\u0304",
        "\u012C": "I\u0306",
        "\u01CF": "I\u030C",
        "\xCE": "I\u0302",
        "\u0130": "I\u0307",
        "\u0134": "J\u0302",
        "\u1E30": "K\u0301",
        "\u01E8": "K\u030C",
        "\u0136": "K\u0327",
        "\u0139": "L\u0301",
        "\u013D": "L\u030C",
        "\u013B": "L\u0327",
        "\u1E3E": "M\u0301",
        "\u1E40": "M\u0307",
        "\u0143": "N\u0301",
        "\u01F8": "N\u0300",
        "\xD1": "N\u0303",
        "\u0147": "N\u030C",
        "\u1E44": "N\u0307",
        "\u0145": "N\u0327",
        "\xD3": "O\u0301",
        "\xD2": "O\u0300",
        "\xD6": "O\u0308",
        "\u022A": "O\u0308\u0304",
        "\xD5": "O\u0303",
        "\u1E4C": "O\u0303\u0301",
        "\u1E4E": "O\u0303\u0308",
        "\u022C": "O\u0303\u0304",
        "\u014C": "O\u0304",
        "\u1E52": "O\u0304\u0301",
        "\u1E50": "O\u0304\u0300",
        "\u014E": "O\u0306",
        "\u01D1": "O\u030C",
        "\xD4": "O\u0302",
        "\u1ED0": "O\u0302\u0301",
        "\u1ED2": "O\u0302\u0300",
        "\u1ED6": "O\u0302\u0303",
        "\u022E": "O\u0307",
        "\u0230": "O\u0307\u0304",
        "\u0150": "O\u030B",
        "\u1E54": "P\u0301",
        "\u1E56": "P\u0307",
        "\u0154": "R\u0301",
        "\u0158": "R\u030C",
        "\u1E58": "R\u0307",
        "\u0156": "R\u0327",
        "\u015A": "S\u0301",
        "\u1E64": "S\u0301\u0307",
        "\u0160": "S\u030C",
        "\u1E66": "S\u030C\u0307",
        "\u015C": "S\u0302",
        "\u1E60": "S\u0307",
        "\u015E": "S\u0327",
        "\u0164": "T\u030C",
        "\u1E6A": "T\u0307",
        "\u0162": "T\u0327",
        "\xDA": "U\u0301",
        "\xD9": "U\u0300",
        "\xDC": "U\u0308",
        "\u01D7": "U\u0308\u0301",
        "\u01DB": "U\u0308\u0300",
        "\u01D5": "U\u0308\u0304",
        "\u01D9": "U\u0308\u030C",
        "\u0168": "U\u0303",
        "\u1E78": "U\u0303\u0301",
        "\u016A": "U\u0304",
        "\u1E7A": "U\u0304\u0308",
        "\u016C": "U\u0306",
        "\u01D3": "U\u030C",
        "\xDB": "U\u0302",
        "\u016E": "U\u030A",
        "\u0170": "U\u030B",
        "\u1E7C": "V\u0303",
        "\u1E82": "W\u0301",
        "\u1E80": "W\u0300",
        "\u1E84": "W\u0308",
        "\u0174": "W\u0302",
        "\u1E86": "W\u0307",
        "\u1E8C": "X\u0308",
        "\u1E8A": "X\u0307",
        "\xDD": "Y\u0301",
        "\u1EF2": "Y\u0300",
        "\u0178": "Y\u0308",
        "\u1EF8": "Y\u0303",
        "\u0232": "Y\u0304",
        "\u0176": "Y\u0302",
        "\u1E8E": "Y\u0307",
        "\u0179": "Z\u0301",
        "\u017D": "Z\u030C",
        "\u1E90": "Z\u0302",
        "\u017B": "Z\u0307",
        "\u03AC": "\u03B1\u0301",
        "\u1F70": "\u03B1\u0300",
        "\u1FB1": "\u03B1\u0304",
        "\u1FB0": "\u03B1\u0306",
        "\u03AD": "\u03B5\u0301",
        "\u1F72": "\u03B5\u0300",
        "\u03AE": "\u03B7\u0301",
        "\u1F74": "\u03B7\u0300",
        "\u03AF": "\u03B9\u0301",
        "\u1F76": "\u03B9\u0300",
        "\u03CA": "\u03B9\u0308",
        "\u0390": "\u03B9\u0308\u0301",
        "\u1FD2": "\u03B9\u0308\u0300",
        "\u1FD1": "\u03B9\u0304",
        "\u1FD0": "\u03B9\u0306",
        "\u03CC": "\u03BF\u0301",
        "\u1F78": "\u03BF\u0300",
        "\u03CD": "\u03C5\u0301",
        "\u1F7A": "\u03C5\u0300",
        "\u03CB": "\u03C5\u0308",
        "\u03B0": "\u03C5\u0308\u0301",
        "\u1FE2": "\u03C5\u0308\u0300",
        "\u1FE1": "\u03C5\u0304",
        "\u1FE0": "\u03C5\u0306",
        "\u03CE": "\u03C9\u0301",
        "\u1F7C": "\u03C9\u0300",
        "\u038E": "\u03A5\u0301",
        "\u1FEA": "\u03A5\u0300",
        "\u03AB": "\u03A5\u0308",
        "\u1FE9": "\u03A5\u0304",
        "\u1FE8": "\u03A5\u0306",
        "\u038F": "\u03A9\u0301",
        "\u1FFA": "\u03A9\u0300"
      };
      Parser = class _Parser2 {
        constructor(input, settings) {
          this.mode = void 0;
          this.gullet = void 0;
          this.settings = void 0;
          this.leftrightDepth = void 0;
          this.nextToken = void 0;
          this.mode = "math";
          this.gullet = new MacroExpander(input, settings, this.mode);
          this.settings = settings;
          this.leftrightDepth = 0;
        }
        /**
         * Checks a result to make sure it has the right type, and throws an
         * appropriate error otherwise.
         */
        expect(text2, consume) {
          if (consume === void 0) {
            consume = true;
          }
          if (this.fetch().text !== text2) {
            throw new ParseError("Expected '" + text2 + "', got '" + this.fetch().text + "'", this.fetch());
          }
          if (consume) {
            this.consume();
          }
        }
        /**
         * Discards the current lookahead token, considering it consumed.
         */
        consume() {
          this.nextToken = null;
        }
        /**
         * Return the current lookahead token, or if there isn't one (at the
         * beginning, or if the previous lookahead token was consume()d),
         * fetch the next token as the new lookahead token and return it.
         */
        fetch() {
          if (this.nextToken == null) {
            this.nextToken = this.gullet.expandNextToken();
          }
          return this.nextToken;
        }
        /**
         * Switches between "text" and "math" modes.
         */
        switchMode(newMode) {
          this.mode = newMode;
          this.gullet.switchMode(newMode);
        }
        /**
         * Main parsing function, which parses an entire input.
         */
        parse() {
          if (!this.settings.globalGroup) {
            this.gullet.beginGroup();
          }
          if (this.settings.colorIsTextColor) {
            this.gullet.macros.set("\\color", "\\textcolor");
          }
          try {
            var parse = this.parseExpression(false);
            this.expect("EOF");
            if (!this.settings.globalGroup) {
              this.gullet.endGroup();
            }
            return parse;
          } finally {
            this.gullet.endGroups();
          }
        }
        /**
         * Fully parse a separate sequence of tokens as a separate job.
         * Tokens should be specified in reverse order, as in a MacroDefinition.
         */
        subparse(tokens) {
          var oldToken = this.nextToken;
          this.consume();
          this.gullet.pushToken(new Token("}"));
          this.gullet.pushTokens(tokens);
          var parse = this.parseExpression(false);
          this.expect("}");
          this.nextToken = oldToken;
          return parse;
        }
        /**
         * Parses an "expression", which is a list of atoms.
         *
         * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
         *                 happens when functions have higher precedence han infix
         *                 nodes in implicit parses.
         *
         * `breakOnTokenText`: The text of the token that the expression should end
         *                     with, or `null` if something else should end the
         *                     expression.
         */
        parseExpression(breakOnInfix, breakOnTokenText) {
          var body = [];
          while (true) {
            if (this.mode === "math") {
              this.consumeSpaces();
            }
            var lex = this.fetch();
            if (_Parser2.endOfExpression.indexOf(lex.text) !== -1) {
              break;
            }
            if (breakOnTokenText && lex.text === breakOnTokenText) {
              break;
            }
            if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
              break;
            }
            var atom = this.parseAtom(breakOnTokenText);
            if (!atom) {
              break;
            } else if (atom.type === "internal") {
              continue;
            }
            body.push(atom);
          }
          if (this.mode === "text") {
            this.formLigatures(body);
          }
          return this.handleInfixNodes(body);
        }
        /**
         * Rewrites infix operators such as \over with corresponding commands such
         * as \frac.
         *
         * There can only be one infix operator per group.  If there's more than one
         * then the expression is ambiguous.  This can be resolved by adding {}.
         */
        handleInfixNodes(body) {
          var overIndex = -1;
          var funcName;
          for (var i = 0; i < body.length; i++) {
            if (body[i].type === "infix") {
              if (overIndex !== -1) {
                throw new ParseError("only one infix operator per group", body[i].token);
              }
              overIndex = i;
              funcName = body[i].replaceWith;
            }
          }
          if (overIndex !== -1 && funcName) {
            var numerNode;
            var denomNode;
            var numerBody = body.slice(0, overIndex);
            var denomBody = body.slice(overIndex + 1);
            if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
              numerNode = numerBody[0];
            } else {
              numerNode = {
                type: "ordgroup",
                mode: this.mode,
                body: numerBody
              };
            }
            if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
              denomNode = denomBody[0];
            } else {
              denomNode = {
                type: "ordgroup",
                mode: this.mode,
                body: denomBody
              };
            }
            var node;
            if (funcName === "\\\\abovefrac") {
              node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
            } else {
              node = this.callFunction(funcName, [numerNode, denomNode], []);
            }
            return [node];
          } else {
            return body;
          }
        }
        /**
         * Handle a subscript or superscript with nice errors.
         */
        handleSupSubscript(name) {
          var symbolToken = this.fetch();
          var symbol = symbolToken.text;
          this.consume();
          this.consumeSpaces();
          var group;
          do {
            var _group;
            group = this.parseGroup(name);
          } while (((_group = group) == null ? void 0 : _group.type) === "internal");
          if (!group) {
            throw new ParseError("Expected group after '" + symbol + "'", symbolToken);
          }
          return group;
        }
        /**
         * Converts the textual input of an unsupported command into a text node
         * contained within a color node whose color is determined by errorColor
         */
        formatUnsupportedCmd(text2) {
          var textordArray = [];
          for (var i = 0; i < text2.length; i++) {
            textordArray.push({
              type: "textord",
              mode: "text",
              text: text2[i]
            });
          }
          var textNode = {
            type: "text",
            mode: this.mode,
            body: textordArray
          };
          var colorNode = {
            type: "color",
            mode: this.mode,
            color: this.settings.errorColor,
            body: [textNode]
          };
          return colorNode;
        }
        /**
         * Parses a group with optional super/subscripts.
         */
        parseAtom(breakOnTokenText) {
          var base = this.parseGroup("atom", breakOnTokenText);
          if ((base == null ? void 0 : base.type) === "internal") {
            return base;
          }
          if (this.mode === "text") {
            return base;
          }
          var superscript;
          var subscript;
          while (true) {
            this.consumeSpaces();
            var lex = this.fetch();
            if (lex.text === "\\limits" || lex.text === "\\nolimits") {
              if (base && base.type === "op") {
                var limits = lex.text === "\\limits";
                base.limits = limits;
                base.alwaysHandleSupSub = true;
              } else if (base && base.type === "operatorname") {
                if (base.alwaysHandleSupSub) {
                  base.limits = lex.text === "\\limits";
                }
              } else {
                throw new ParseError("Limit controls must follow a math operator", lex);
              }
              this.consume();
            } else if (lex.text === "^") {
              if (superscript) {
                throw new ParseError("Double superscript", lex);
              }
              superscript = this.handleSupSubscript("superscript");
            } else if (lex.text === "_") {
              if (subscript) {
                throw new ParseError("Double subscript", lex);
              }
              subscript = this.handleSupSubscript("subscript");
            } else if (lex.text === "'") {
              if (superscript) {
                throw new ParseError("Double superscript", lex);
              }
              var prime = {
                type: "textord",
                mode: this.mode,
                text: "\\prime"
              };
              var primes = [prime];
              this.consume();
              while (this.fetch().text === "'") {
                primes.push(prime);
                this.consume();
              }
              if (this.fetch().text === "^") {
                primes.push(this.handleSupSubscript("superscript"));
              }
              superscript = {
                type: "ordgroup",
                mode: this.mode,
                body: primes
              };
            } else if (uSubsAndSups[lex.text]) {
              var isSub = unicodeSubRegEx.test(lex.text);
              var subsupTokens = [];
              subsupTokens.push(new Token(uSubsAndSups[lex.text]));
              this.consume();
              while (true) {
                var token = this.fetch().text;
                if (!uSubsAndSups[token]) {
                  break;
                }
                if (unicodeSubRegEx.test(token) !== isSub) {
                  break;
                }
                subsupTokens.unshift(new Token(uSubsAndSups[token]));
                this.consume();
              }
              var body = this.subparse(subsupTokens);
              if (isSub) {
                subscript = {
                  type: "ordgroup",
                  mode: "math",
                  body
                };
              } else {
                superscript = {
                  type: "ordgroup",
                  mode: "math",
                  body
                };
              }
            } else {
              break;
            }
          }
          if (superscript || subscript) {
            return {
              type: "supsub",
              mode: this.mode,
              base,
              sup: superscript,
              sub: subscript
            };
          } else {
            return base;
          }
        }
        /**
         * Parses an entire function, including its base and all of its arguments.
         */
        parseFunction(breakOnTokenText, name) {
          var token = this.fetch();
          var func = token.text;
          var funcData = functions[func];
          if (!funcData) {
            return null;
          }
          this.consume();
          if (name && name !== "atom" && !funcData.allowedInArgument) {
            throw new ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
          } else if (this.mode === "text" && !funcData.allowedInText) {
            throw new ParseError("Can't use function '" + func + "' in text mode", token);
          } else if (this.mode === "math" && funcData.allowedInMath === false) {
            throw new ParseError("Can't use function '" + func + "' in math mode", token);
          }
          var {
            args,
            optArgs
          } = this.parseArguments(func, funcData);
          return this.callFunction(func, args, optArgs, token, breakOnTokenText);
        }
        /**
         * Call a function handler with a suitable context and arguments.
         */
        callFunction(name, args, optArgs, token, breakOnTokenText) {
          var context = {
            funcName: name,
            parser: this,
            token,
            breakOnTokenText
          };
          var func = functions[name];
          if (func && func.handler) {
            return func.handler(context, args, optArgs);
          } else {
            throw new ParseError("No function handler for " + name);
          }
        }
        /**
         * Parses the arguments of a function or environment
         */
        parseArguments(func, funcData) {
          var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
          if (totalArgs === 0) {
            return {
              args: [],
              optArgs: []
            };
          }
          var args = [];
          var optArgs = [];
          for (var i = 0; i < totalArgs; i++) {
            var argType = funcData.argTypes && funcData.argTypes[i];
            var isOptional = i < funcData.numOptionalArgs;
            if (funcData.primitive && argType == null || // \sqrt expands into primitive if optional argument doesn't exist
            funcData.type === "sqrt" && i === 1 && optArgs[0] == null) {
              argType = "primitive";
            }
            var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
            if (isOptional) {
              optArgs.push(arg);
            } else if (arg != null) {
              args.push(arg);
            } else {
              throw new ParseError("Null argument, please report this as a bug");
            }
          }
          return {
            args,
            optArgs
          };
        }
        /**
         * Parses a group when the mode is changing.
         */
        parseGroupOfType(name, type, optional) {
          switch (type) {
            case "color":
              return this.parseColorGroup(optional);
            case "size":
              return this.parseSizeGroup(optional);
            case "url":
              return this.parseUrlGroup(optional);
            case "math":
            case "text":
              return this.parseArgumentGroup(optional, type);
            case "hbox": {
              var group = this.parseArgumentGroup(optional, "text");
              return group != null ? {
                type: "styling",
                mode: group.mode,
                body: [group],
                style: "text"
                // simulate \textstyle
              } : null;
            }
            case "raw": {
              var token = this.parseStringGroup("raw", optional);
              return token != null ? {
                type: "raw",
                mode: "text",
                string: token.text
              } : null;
            }
            case "primitive": {
              if (optional) {
                throw new ParseError("A primitive argument cannot be optional");
              }
              var _group2 = this.parseGroup(name);
              if (_group2 == null) {
                throw new ParseError("Expected group as " + name, this.fetch());
              }
              return _group2;
            }
            case "original":
            case null:
            case void 0:
              return this.parseArgumentGroup(optional);
            default:
              throw new ParseError("Unknown group type as " + name, this.fetch());
          }
        }
        /**
         * Discard any space tokens, fetching the next non-space token.
         */
        consumeSpaces() {
          while (this.fetch().text === " ") {
            this.consume();
          }
        }
        /**
         * Parses a group, essentially returning the string formed by the
         * brace-enclosed tokens plus some position information.
         */
        parseStringGroup(modeName, optional) {
          var argToken = this.gullet.scanArgument(optional);
          if (argToken == null) {
            return null;
          }
          var str = "";
          var nextToken;
          while ((nextToken = this.fetch()).text !== "EOF") {
            str += nextToken.text;
            this.consume();
          }
          this.consume();
          argToken.text = str;
          return argToken;
        }
        /**
         * Parses a regex-delimited group: the largest sequence of tokens
         * whose concatenated strings match `regex`. Returns the string
         * formed by the tokens plus some position information.
         */
        parseRegexGroup(regex, modeName) {
          var firstToken = this.fetch();
          var lastToken = firstToken;
          var str = "";
          var nextToken;
          while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
            lastToken = nextToken;
            str += lastToken.text;
            this.consume();
          }
          if (str === "") {
            throw new ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
          }
          return firstToken.range(lastToken, str);
        }
        /**
         * Parses a color description.
         */
        parseColorGroup(optional) {
          var res = this.parseStringGroup("color", optional);
          if (res == null) {
            return null;
          }
          var match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
          if (!match) {
            throw new ParseError("Invalid color: '" + res.text + "'", res);
          }
          var color = match[0];
          if (/^[0-9a-f]{6}$/i.test(color)) {
            color = "#" + color;
          }
          return {
            type: "color-token",
            mode: this.mode,
            color
          };
        }
        /**
         * Parses a size specification, consisting of magnitude and unit.
         */
        parseSizeGroup(optional) {
          var res;
          var isBlank = false;
          this.gullet.consumeSpaces();
          if (!optional && this.gullet.future().text !== "{") {
            res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
          } else {
            res = this.parseStringGroup("size", optional);
          }
          if (!res) {
            return null;
          }
          if (!optional && res.text.length === 0) {
            res.text = "0pt";
            isBlank = true;
          }
          var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
          if (!match) {
            throw new ParseError("Invalid size: '" + res.text + "'", res);
          }
          var data = {
            number: +(match[1] + match[2]),
            // sign + magnitude, cast to number
            unit: match[3]
          };
          if (!validUnit(data)) {
            throw new ParseError("Invalid unit: '" + data.unit + "'", res);
          }
          return {
            type: "size",
            mode: this.mode,
            value: data,
            isBlank
          };
        }
        /**
         * Parses an URL, checking escaped letters and allowed protocols,
         * and setting the catcode of % as an active character (as in \hyperref).
         */
        parseUrlGroup(optional) {
          this.gullet.lexer.setCatcode("%", 13);
          this.gullet.lexer.setCatcode("~", 12);
          var res = this.parseStringGroup("url", optional);
          this.gullet.lexer.setCatcode("%", 14);
          this.gullet.lexer.setCatcode("~", 13);
          if (res == null) {
            return null;
          }
          var url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
          return {
            type: "url",
            mode: this.mode,
            url
          };
        }
        /**
         * Parses an argument with the mode specified.
         */
        parseArgumentGroup(optional, mode) {
          var argToken = this.gullet.scanArgument(optional);
          if (argToken == null) {
            return null;
          }
          var outerMode = this.mode;
          if (mode) {
            this.switchMode(mode);
          }
          this.gullet.beginGroup();
          var expression = this.parseExpression(false, "EOF");
          this.expect("EOF");
          this.gullet.endGroup();
          var result = {
            type: "ordgroup",
            mode: this.mode,
            loc: argToken.loc,
            body: expression
          };
          if (mode) {
            this.switchMode(outerMode);
          }
          return result;
        }
        /**
         * Parses an ordinary group, which is either a single nucleus (like "x")
         * or an expression in braces (like "{x+y}") or an implicit group, a group
         * that starts at the current position, and ends right before a higher explicit
         * group ends, or at EOF.
         */
        parseGroup(name, breakOnTokenText) {
          var firstToken = this.fetch();
          var text2 = firstToken.text;
          var result;
          if (text2 === "{" || text2 === "\\begingroup") {
            this.consume();
            var groupEnd = text2 === "{" ? "}" : "\\endgroup";
            this.gullet.beginGroup();
            var expression = this.parseExpression(false, groupEnd);
            var lastToken = this.fetch();
            this.expect(groupEnd);
            this.gullet.endGroup();
            result = {
              type: "ordgroup",
              mode: this.mode,
              loc: SourceLocation.range(firstToken, lastToken),
              body: expression,
              // A group formed by \begingroup...\endgroup is a semi-simple group
              // which doesn't affect spacing in math mode, i.e., is transparent.
              // https://tex.stackexchange.com/questions/1930/when-should-one-
              // use-begingroup-instead-of-bgroup
              semisimple: text2 === "\\begingroup" || void 0
            };
          } else {
            result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
            if (result == null && text2[0] === "\\" && !implicitCommands.hasOwnProperty(text2)) {
              if (this.settings.throwOnError) {
                throw new ParseError("Undefined control sequence: " + text2, firstToken);
              }
              result = this.formatUnsupportedCmd(text2);
              this.consume();
            }
          }
          return result;
        }
        /**
         * Form ligature-like combinations of characters for text mode.
         * This includes inputs like "--", "---", "``" and "''".
         * The result will simply replace multiple textord nodes with a single
         * character in each value by a single textord node having multiple
         * characters in its value.  The representation is still ASCII source.
         * The group will be modified in place.
         */
        formLigatures(group) {
          var n = group.length - 1;
          for (var i = 0; i < n; ++i) {
            var a = group[i];
            var v = a.text;
            if (v === "-" && group[i + 1].text === "-") {
              if (i + 1 < n && group[i + 2].text === "-") {
                group.splice(i, 3, {
                  type: "textord",
                  mode: "text",
                  loc: SourceLocation.range(a, group[i + 2]),
                  text: "---"
                });
                n -= 2;
              } else {
                group.splice(i, 2, {
                  type: "textord",
                  mode: "text",
                  loc: SourceLocation.range(a, group[i + 1]),
                  text: "--"
                });
                n -= 1;
              }
            }
            if ((v === "'" || v === "`") && group[i + 1].text === v) {
              group.splice(i, 2, {
                type: "textord",
                mode: "text",
                loc: SourceLocation.range(a, group[i + 1]),
                text: v + v
              });
              n -= 1;
            }
          }
        }
        /**
         * Parse a single symbol out of the string. Here, we handle single character
         * symbols and special functions like \verb.
         */
        parseSymbol() {
          var nucleus = this.fetch();
          var text2 = nucleus.text;
          if (/^\\verb[^a-zA-Z]/.test(text2)) {
            this.consume();
            var arg = text2.slice(5);
            var star = arg.charAt(0) === "*";
            if (star) {
              arg = arg.slice(1);
            }
            if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
              throw new ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
            }
            arg = arg.slice(1, -1);
            return {
              type: "verb",
              mode: "text",
              body: arg,
              star
            };
          }
          if (unicodeSymbols.hasOwnProperty(text2[0]) && !symbols[this.mode][text2[0]]) {
            if (this.settings.strict && this.mode === "math") {
              this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text2[0] + '" used in math mode', nucleus);
            }
            text2 = unicodeSymbols[text2[0]] + text2.slice(1);
          }
          var match = combiningDiacriticalMarksEndRegex.exec(text2);
          if (match) {
            text2 = text2.substring(0, match.index);
            if (text2 === "i") {
              text2 = "\u0131";
            } else if (text2 === "j") {
              text2 = "\u0237";
            }
          }
          var symbol;
          if (symbols[this.mode][text2]) {
            if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text2) >= 0) {
              this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text2[0] + '" used in math mode', nucleus);
            }
            var group = symbols[this.mode][text2].group;
            var loc = SourceLocation.range(nucleus);
            var s;
            if (ATOMS.hasOwnProperty(group)) {
              var family = group;
              s = {
                type: "atom",
                mode: this.mode,
                family,
                loc,
                text: text2
              };
            } else {
              s = {
                type: group,
                mode: this.mode,
                loc,
                text: text2
              };
            }
            symbol = s;
          } else if (text2.charCodeAt(0) >= 128) {
            if (this.settings.strict) {
              if (!supportedCodepoint(text2.charCodeAt(0))) {
                this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text2[0] + '"' + (" (" + text2.charCodeAt(0) + ")"), nucleus);
              } else if (this.mode === "math") {
                this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text2[0] + '" used in math mode', nucleus);
              }
            }
            symbol = {
              type: "textord",
              mode: "text",
              loc: SourceLocation.range(nucleus),
              text: text2
            };
          } else {
            return null;
          }
          this.consume();
          if (match) {
            for (var i = 0; i < match[0].length; i++) {
              var accent2 = match[0][i];
              if (!unicodeAccents[accent2]) {
                throw new ParseError("Unknown accent ' " + accent2 + "'", nucleus);
              }
              var command = unicodeAccents[accent2][this.mode] || unicodeAccents[accent2].text;
              if (!command) {
                throw new ParseError("Accent " + accent2 + " unsupported in " + this.mode + " mode", nucleus);
              }
              symbol = {
                type: "accent",
                mode: this.mode,
                loc: SourceLocation.range(nucleus),
                label: command,
                isStretchy: false,
                isShifty: true,
                // $FlowFixMe
                base: symbol
              };
            }
          }
          return symbol;
        }
      };
      Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
      parseTree = function parseTree2(toParse, settings) {
        if (!(typeof toParse === "string" || toParse instanceof String)) {
          throw new TypeError("KaTeX can only parse string typed expression");
        }
        var parser2 = new Parser(toParse, settings);
        delete parser2.gullet.macros.current["\\df@tag"];
        var tree = parser2.parse();
        delete parser2.gullet.macros.current["\\current@color"];
        delete parser2.gullet.macros.current["\\color"];
        if (parser2.gullet.macros.get("\\df@tag")) {
          if (!settings.displayMode) {
            throw new ParseError("\\tag works only in display equations");
          }
          tree = [{
            type: "tag",
            mode: "text",
            body: tree,
            tag: parser2.subparse([new Token("\\df@tag")])
          }];
        }
        return tree;
      };
      render = function render2(expression, baseNode, options2) {
        baseNode.textContent = "";
        var node = renderToDomTree(expression, options2).toNode();
        baseNode.appendChild(node);
      };
      if (typeof document !== "undefined") {
        if (document.compatMode !== "CSS1Compat") {
          typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
          render = function render3() {
            throw new ParseError("KaTeX doesn't work in quirks mode.");
          };
        }
      }
      renderToString = function renderToString2(expression, options2) {
        var markup = renderToDomTree(expression, options2).toMarkup();
        return markup;
      };
      generateParseTree = function generateParseTree2(expression, options2) {
        var settings = new Settings(options2);
        return parseTree(expression, settings);
      };
      renderError = function renderError2(error, expression, options2) {
        if (options2.throwOnError || !(error instanceof ParseError)) {
          throw error;
        }
        var node = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
        node.setAttribute("title", error.toString());
        node.setAttribute("style", "color:" + options2.errorColor);
        return node;
      };
      renderToDomTree = function renderToDomTree2(expression, options2) {
        var settings = new Settings(options2);
        try {
          var tree = parseTree(expression, settings);
          return buildTree(tree, expression, settings);
        } catch (error) {
          return renderError(error, expression, settings);
        }
      };
      renderToHTMLTree = function renderToHTMLTree2(expression, options2) {
        var settings = new Settings(options2);
        try {
          var tree = parseTree(expression, settings);
          return buildHTMLTree(tree, expression, settings);
        } catch (error) {
          return renderError(error, expression, settings);
        }
      };
      version = "0.16.22";
      __domTree = {
        Span,
        Anchor,
        SymbolNode,
        SvgNode,
        PathNode,
        LineNode
      };
      katex = {
        /**
         * Current KaTeX version
         */
        version,
        /**
         * Renders the given LaTeX into an HTML+MathML combination, and adds
         * it as a child to the specified DOM node.
         */
        render,
        /**
         * Renders the given LaTeX into an HTML+MathML combination string,
         * for sending to the client.
         */
        renderToString,
        /**
         * KaTeX error, usually during parsing.
         */
        ParseError,
        /**
         * The schema of Settings
         */
        SETTINGS_SCHEMA,
        /**
         * Parses the given LaTeX into KaTeX's internal parse tree structure,
         * without rendering to HTML or MathML.
         *
         * NOTE: This method is not currently recommended for public use.
         * The internal tree representation is unstable and is very likely
         * to change. Use at your own risk.
         */
        __parse: generateParseTree,
        /**
         * Renders the given LaTeX into an HTML+MathML internal DOM tree
         * representation, without flattening that representation to a string.
         *
         * NOTE: This method is not currently recommended for public use.
         * The internal tree representation is unstable and is very likely
         * to change. Use at your own risk.
         */
        __renderToDomTree: renderToDomTree,
        /**
         * Renders the given LaTeX into an HTML internal DOM tree representation,
         * without MathML and without flattening that representation to a string.
         *
         * NOTE: This method is not currently recommended for public use.
         * The internal tree representation is unstable and is very likely
         * to change. Use at your own risk.
         */
        __renderToHTMLTree: renderToHTMLTree,
        /**
         * extends internal font metrics object with a new object
         * each key in the new object represents a font name
        */
        __setFontMetrics: setFontMetrics,
        /**
         * adds a new symbol to builtin symbols table
         */
        __defineSymbol: defineSymbol,
        /**
         * adds a new function to builtin function list,
         * which directly produce parse tree elements
         * and have their own html/mathml builders
         */
        __defineFunction: defineFunction,
        /**
         * adds a new macro to builtin macro list
         */
        __defineMacro: defineMacro,
        /**
         * Expose the dom tree node types, which can be useful for type checking nodes.
         *
         * NOTE: These methods are not currently recommended for public use.
         * The internal tree representation is unstable and is very likely
         * to change. Use at your own risk.
         */
        __domTree
      };
    }
  });

  // node_modules/prismjs/prism.js
  var require_prism = __commonJS({
    "node_modules/prismjs/prism.js"(exports, module) {
      var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
      var Prism2 = function(_self2) {
        var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
        var uniqueId = 0;
        var plainTextGrammar = {};
        var _ = {
          /**
           * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
           * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
           * additional languages or plugins yourself.
           *
           * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
           *
           * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
           * empty Prism object into the global scope before loading the Prism script like this:
           *
           * ```js
           * window.Prism = window.Prism || {};
           * Prism.manual = true;
           * // add a new <script> to load Prism's script
           * ```
           *
           * @default false
           * @type {boolean}
           * @memberof Prism
           * @public
           */
          manual: _self2.Prism && _self2.Prism.manual,
          /**
           * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
           * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
           * own worker, you don't want it to do this.
           *
           * By setting this value to `true`, Prism will not add its own listeners to the worker.
           *
           * You obviously have to change this value before Prism executes. To do this, you can add an
           * empty Prism object into the global scope before loading the Prism script like this:
           *
           * ```js
           * window.Prism = window.Prism || {};
           * Prism.disableWorkerMessageHandler = true;
           * // Load Prism's script
           * ```
           *
           * @default false
           * @type {boolean}
           * @memberof Prism
           * @public
           */
          disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
          /**
           * A namespace for utility methods.
           *
           * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
           * change or disappear at any time.
           *
           * @namespace
           * @memberof Prism
           */
          util: {
            encode: function encode(tokens) {
              if (tokens instanceof Token2) {
                return new Token2(tokens.type, encode(tokens.content), tokens.alias);
              } else if (Array.isArray(tokens)) {
                return tokens.map(encode);
              } else {
                return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
              }
            },
            /**
             * Returns the name of the type of the given value.
             *
             * @param {any} o
             * @returns {string}
             * @example
             * type(null)      === 'Null'
             * type(undefined) === 'Undefined'
             * type(123)       === 'Number'
             * type('foo')     === 'String'
             * type(true)      === 'Boolean'
             * type([1, 2])    === 'Array'
             * type({})        === 'Object'
             * type(String)    === 'Function'
             * type(/abc+/)    === 'RegExp'
             */
            type: function(o) {
              return Object.prototype.toString.call(o).slice(8, -1);
            },
            /**
             * Returns a unique number for the given object. Later calls will still return the same number.
             *
             * @param {Object} obj
             * @returns {number}
             */
            objId: function(obj) {
              if (!obj["__id"]) {
                Object.defineProperty(obj, "__id", { value: ++uniqueId });
              }
              return obj["__id"];
            },
            /**
             * Creates a deep clone of the given object.
             *
             * The main intended use of this function is to clone language definitions.
             *
             * @param {T} o
             * @param {Record<number, any>} [visited]
             * @returns {T}
             * @template T
             */
            clone: function deepClone(o, visited) {
              visited = visited || {};
              var clone;
              var id;
              switch (_.util.type(o)) {
                case "Object":
                  id = _.util.objId(o);
                  if (visited[id]) {
                    return visited[id];
                  }
                  clone = /** @type {Record<string, any>} */
                  {};
                  visited[id] = clone;
                  for (var key in o) {
                    if (o.hasOwnProperty(key)) {
                      clone[key] = deepClone(o[key], visited);
                    }
                  }
                  return (
                    /** @type {any} */
                    clone
                  );
                case "Array":
                  id = _.util.objId(o);
                  if (visited[id]) {
                    return visited[id];
                  }
                  clone = [];
                  visited[id] = clone;
                  /** @type {Array} */
                  /** @type {any} */
                  o.forEach(function(v, i) {
                    clone[i] = deepClone(v, visited);
                  });
                  return (
                    /** @type {any} */
                    clone
                  );
                default:
                  return o;
              }
            },
            /**
             * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
             *
             * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
             *
             * @param {Element} element
             * @returns {string}
             */
            getLanguage: function(element) {
              while (element) {
                var m = lang.exec(element.className);
                if (m) {
                  return m[1].toLowerCase();
                }
                element = element.parentElement;
              }
              return "none";
            },
            /**
             * Sets the Prism `language-xxxx` class of the given element.
             *
             * @param {Element} element
             * @param {string} language
             * @returns {void}
             */
            setLanguage: function(element, language) {
              element.className = element.className.replace(RegExp(lang, "gi"), "");
              element.classList.add("language-" + language);
            },
            /**
             * Returns the script element that is currently executing.
             *
             * This does __not__ work for line script element.
             *
             * @returns {HTMLScriptElement | null}
             */
            currentScript: function() {
              if (typeof document === "undefined") {
                return null;
              }
              if ("currentScript" in document && 1 < 2) {
                return (
                  /** @type {any} */
                  document.currentScript
                );
              }
              try {
                throw new Error();
              } catch (err) {
                var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
                if (src) {
                  var scripts = document.getElementsByTagName("script");
                  for (var i in scripts) {
                    if (scripts[i].src == src) {
                      return scripts[i];
                    }
                  }
                }
                return null;
              }
            },
            /**
             * Returns whether a given class is active for `element`.
             *
             * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
             * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
             * given class is just the given class with a `no-` prefix.
             *
             * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
             * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
             * ancestors have the given class or the negated version of it, then the default activation will be returned.
             *
             * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
             * version of it, the class is considered active.
             *
             * @param {Element} element
             * @param {string} className
             * @param {boolean} [defaultActivation=false]
             * @returns {boolean}
             */
            isActive: function(element, className, defaultActivation) {
              var no = "no-" + className;
              while (element) {
                var classList = element.classList;
                if (classList.contains(className)) {
                  return true;
                }
                if (classList.contains(no)) {
                  return false;
                }
                element = element.parentElement;
              }
              return !!defaultActivation;
            }
          },
          /**
           * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
           *
           * @namespace
           * @memberof Prism
           * @public
           */
          languages: {
            /**
             * The grammar for plain, unformatted text.
             */
            plain: plainTextGrammar,
            plaintext: plainTextGrammar,
            text: plainTextGrammar,
            txt: plainTextGrammar,
            /**
             * Creates a deep copy of the language with the given id and appends the given tokens.
             *
             * If a token in `redef` also appears in the copied language, then the existing token in the copied language
             * will be overwritten at its original position.
             *
             * ## Best practices
             *
             * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
             * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
             * understand the language definition because, normally, the order of tokens matters in Prism grammars.
             *
             * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
             * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
             *
             * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
             * @param {Grammar} redef The new tokens to append.
             * @returns {Grammar} The new language created.
             * @public
             * @example
             * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
             *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
             *     // at its original position
             *     'comment': { ... },
             *     // CSS doesn't have a 'color' token, so this token will be appended
             *     'color': /\b(?:red|green|blue)\b/
             * });
             */
            extend: function(id, redef) {
              var lang2 = _.util.clone(_.languages[id]);
              for (var key in redef) {
                lang2[key] = redef[key];
              }
              return lang2;
            },
            /**
             * Inserts tokens _before_ another token in a language definition or any other grammar.
             *
             * ## Usage
             *
             * This helper method makes it easy to modify existing languages. For example, the CSS language definition
             * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
             * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
             * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
             * this:
             *
             * ```js
             * Prism.languages.markup.style = {
             *     // token
             * };
             * ```
             *
             * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
             * before existing tokens. For the CSS example above, you would use it like this:
             *
             * ```js
             * Prism.languages.insertBefore('markup', 'cdata', {
             *     'style': {
             *         // token
             *     }
             * });
             * ```
             *
             * ## Special cases
             *
             * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
             * will be ignored.
             *
             * This behavior can be used to insert tokens after `before`:
             *
             * ```js
             * Prism.languages.insertBefore('markup', 'comment', {
             *     'comment': Prism.languages.markup.comment,
             *     // tokens after 'comment'
             * });
             * ```
             *
             * ## Limitations
             *
             * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
             * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
             * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
             * deleting properties which is necessary to insert at arbitrary positions.
             *
             * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
             * Instead, it will create a new object and replace all references to the target object with the new one. This
             * can be done without temporarily deleting properties, so the iteration order is well-defined.
             *
             * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
             * you hold the target object in a variable, then the value of the variable will not change.
             *
             * ```js
             * var oldMarkup = Prism.languages.markup;
             * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
             *
             * assert(oldMarkup !== Prism.languages.markup);
             * assert(newMarkup === Prism.languages.markup);
             * ```
             *
             * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
             * object to be modified.
             * @param {string} before The key to insert before.
             * @param {Grammar} insert An object containing the key-value pairs to be inserted.
             * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
             * object to be modified.
             *
             * Defaults to `Prism.languages`.
             * @returns {Grammar} The new grammar object.
             * @public
             */
            insertBefore: function(inside, before, insert, root) {
              root = root || /** @type {any} */
              _.languages;
              var grammar = root[inside];
              var ret = {};
              for (var token in grammar) {
                if (grammar.hasOwnProperty(token)) {
                  if (token == before) {
                    for (var newToken in insert) {
                      if (insert.hasOwnProperty(newToken)) {
                        ret[newToken] = insert[newToken];
                      }
                    }
                  }
                  if (!insert.hasOwnProperty(token)) {
                    ret[token] = grammar[token];
                  }
                }
              }
              var old = root[inside];
              root[inside] = ret;
              _.languages.DFS(_.languages, function(key, value) {
                if (value === old && key != inside) {
                  this[key] = ret;
                }
              });
              return ret;
            },
            // Traverse a language definition with Depth First Search
            DFS: function DFS(o, callback, type, visited) {
              visited = visited || {};
              var objId = _.util.objId;
              for (var i in o) {
                if (o.hasOwnProperty(i)) {
                  callback.call(o, i, o[i], type || i);
                  var property = o[i];
                  var propertyType = _.util.type(property);
                  if (propertyType === "Object" && !visited[objId(property)]) {
                    visited[objId(property)] = true;
                    DFS(property, callback, null, visited);
                  } else if (propertyType === "Array" && !visited[objId(property)]) {
                    visited[objId(property)] = true;
                    DFS(property, callback, i, visited);
                  }
                }
              }
            }
          },
          plugins: {},
          /**
           * This is the most high-level function in Prism’s API.
           * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
           * each one of them.
           *
           * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
           *
           * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
           * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
           * @memberof Prism
           * @public
           */
          highlightAll: function(async, callback) {
            _.highlightAllUnder(document, async, callback);
          },
          /**
           * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
           * {@link Prism.highlightElement} on each one of them.
           *
           * The following hooks will be run:
           * 1. `before-highlightall`
           * 2. `before-all-elements-highlight`
           * 3. All hooks of {@link Prism.highlightElement} for each element.
           *
           * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
           * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
           * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
           * @memberof Prism
           * @public
           */
          highlightAllUnder: function(container, async, callback) {
            var env = {
              callback,
              container,
              selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
            };
            _.hooks.run("before-highlightall", env);
            env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
            _.hooks.run("before-all-elements-highlight", env);
            for (var i = 0, element; element = env.elements[i++]; ) {
              _.highlightElement(element, async === true, env.callback);
            }
          },
          /**
           * Highlights the code inside a single element.
           *
           * The following hooks will be run:
           * 1. `before-sanity-check`
           * 2. `before-highlight`
           * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
           * 4. `before-insert`
           * 5. `after-highlight`
           * 6. `complete`
           *
           * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
           * the element's language.
           *
           * @param {Element} element The element containing the code.
           * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
           * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
           * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
           * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
           *
           * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
           * asynchronous highlighting to work. You can build your own bundle on the
           * [Download page](https://prismjs.com/download.html).
           * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
           * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
           * @memberof Prism
           * @public
           */
          highlightElement: function(element, async, callback) {
            var language = _.util.getLanguage(element);
            var grammar = _.languages[language];
            _.util.setLanguage(element, language);
            var parent = element.parentElement;
            if (parent && parent.nodeName.toLowerCase() === "pre") {
              _.util.setLanguage(parent, language);
            }
            var code = element.textContent;
            var env = {
              element,
              language,
              grammar,
              code
            };
            function insertHighlightedCode(highlightedCode) {
              env.highlightedCode = highlightedCode;
              _.hooks.run("before-insert", env);
              env.element.innerHTML = env.highlightedCode;
              _.hooks.run("after-highlight", env);
              _.hooks.run("complete", env);
              callback && callback.call(env.element);
            }
            _.hooks.run("before-sanity-check", env);
            parent = env.element.parentElement;
            if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
              parent.setAttribute("tabindex", "0");
            }
            if (!env.code) {
              _.hooks.run("complete", env);
              callback && callback.call(env.element);
              return;
            }
            _.hooks.run("before-highlight", env);
            if (!env.grammar) {
              insertHighlightedCode(_.util.encode(env.code));
              return;
            }
            if (async && _self2.Worker) {
              var worker = new Worker(_.filename);
              worker.onmessage = function(evt) {
                insertHighlightedCode(evt.data);
              };
              worker.postMessage(JSON.stringify({
                language: env.language,
                code: env.code,
                immediateClose: true
              }));
            } else {
              insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
            }
          },
          /**
           * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
           * and the language definitions to use, and returns a string with the HTML produced.
           *
           * The following hooks will be run:
           * 1. `before-tokenize`
           * 2. `after-tokenize`
           * 3. `wrap`: On each {@link Token}.
           *
           * @param {string} text A string with the code to be highlighted.
           * @param {Grammar} grammar An object containing the tokens to use.
           *
           * Usually a language definition like `Prism.languages.markup`.
           * @param {string} language The name of the language definition passed to `grammar`.
           * @returns {string} The highlighted HTML.
           * @memberof Prism
           * @public
           * @example
           * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
           */
          highlight: function(text2, grammar, language) {
            var env = {
              code: text2,
              grammar,
              language
            };
            _.hooks.run("before-tokenize", env);
            if (!env.grammar) {
              throw new Error('The language "' + env.language + '" has no grammar.');
            }
            env.tokens = _.tokenize(env.code, env.grammar);
            _.hooks.run("after-tokenize", env);
            return Token2.stringify(_.util.encode(env.tokens), env.language);
          },
          /**
           * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
           * and the language definitions to use, and returns an array with the tokenized code.
           *
           * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
           *
           * This method could be useful in other contexts as well, as a very crude parser.
           *
           * @param {string} text A string with the code to be highlighted.
           * @param {Grammar} grammar An object containing the tokens to use.
           *
           * Usually a language definition like `Prism.languages.markup`.
           * @returns {TokenStream} An array of strings and tokens, a token stream.
           * @memberof Prism
           * @public
           * @example
           * let code = `var foo = 0;`;
           * let tokens = Prism.tokenize(code, Prism.languages.javascript);
           * tokens.forEach(token => {
           *     if (token instanceof Prism.Token && token.type === 'number') {
           *         console.log(`Found numeric literal: ${token.content}`);
           *     }
           * });
           */
          tokenize: function(text2, grammar) {
            var rest = grammar.rest;
            if (rest) {
              for (var token in rest) {
                grammar[token] = rest[token];
              }
              delete grammar.rest;
            }
            var tokenList = new LinkedList();
            addAfter(tokenList, tokenList.head, text2);
            matchGrammar(text2, tokenList, grammar, tokenList.head, 0);
            return toArray(tokenList);
          },
          /**
           * @namespace
           * @memberof Prism
           * @public
           */
          hooks: {
            all: {},
            /**
             * Adds the given callback to the list of callbacks for the given hook.
             *
             * The callback will be invoked when the hook it is registered for is run.
             * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
             *
             * One callback function can be registered to multiple hooks and the same hook multiple times.
             *
             * @param {string} name The name of the hook.
             * @param {HookCallback} callback The callback function which is given environment variables.
             * @public
             */
            add: function(name, callback) {
              var hooks = _.hooks.all;
              hooks[name] = hooks[name] || [];
              hooks[name].push(callback);
            },
            /**
             * Runs a hook invoking all registered callbacks with the given environment variables.
             *
             * Callbacks will be invoked synchronously and in the order in which they were registered.
             *
             * @param {string} name The name of the hook.
             * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
             * @public
             */
            run: function(name, env) {
              var callbacks = _.hooks.all[name];
              if (!callbacks || !callbacks.length) {
                return;
              }
              for (var i = 0, callback; callback = callbacks[i++]; ) {
                callback(env);
              }
            }
          },
          Token: Token2
        };
        _self2.Prism = _;
        function Token2(type, content, alias, matchedStr) {
          this.type = type;
          this.content = content;
          this.alias = alias;
          this.length = (matchedStr || "").length | 0;
        }
        Token2.stringify = function stringify(o, language) {
          if (typeof o == "string") {
            return o;
          }
          if (Array.isArray(o)) {
            var s = "";
            o.forEach(function(e) {
              s += stringify(e, language);
            });
            return s;
          }
          var env = {
            type: o.type,
            content: stringify(o.content, language),
            tag: "span",
            classes: ["token", o.type],
            attributes: {},
            language
          };
          var aliases = o.alias;
          if (aliases) {
            if (Array.isArray(aliases)) {
              Array.prototype.push.apply(env.classes, aliases);
            } else {
              env.classes.push(aliases);
            }
          }
          _.hooks.run("wrap", env);
          var attributes = "";
          for (var name in env.attributes) {
            attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
          }
          return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
        };
        function matchPattern(pattern, pos, text2, lookbehind) {
          pattern.lastIndex = pos;
          var match = pattern.exec(text2);
          if (match && lookbehind && match[1]) {
            var lookbehindLength = match[1].length;
            match.index += lookbehindLength;
            match[0] = match[0].slice(lookbehindLength);
          }
          return match;
        }
        function matchGrammar(text2, tokenList, grammar, startNode, startPos, rematch) {
          for (var token in grammar) {
            if (!grammar.hasOwnProperty(token) || !grammar[token]) {
              continue;
            }
            var patterns = grammar[token];
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            for (var j = 0; j < patterns.length; ++j) {
              if (rematch && rematch.cause == token + "," + j) {
                return;
              }
              var patternObj = patterns[j];
              var inside = patternObj.inside;
              var lookbehind = !!patternObj.lookbehind;
              var greedy = !!patternObj.greedy;
              var alias = patternObj.alias;
              if (greedy && !patternObj.pattern.global) {
                var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
                patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
              }
              var pattern = patternObj.pattern || patternObj;
              for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
                if (rematch && pos >= rematch.reach) {
                  break;
                }
                var str = currentNode.value;
                if (tokenList.length > text2.length) {
                  return;
                }
                if (str instanceof Token2) {
                  continue;
                }
                var removeCount = 1;
                var match;
                if (greedy) {
                  match = matchPattern(pattern, pos, text2, lookbehind);
                  if (!match || match.index >= text2.length) {
                    break;
                  }
                  var from = match.index;
                  var to = match.index + match[0].length;
                  var p = pos;
                  p += currentNode.value.length;
                  while (from >= p) {
                    currentNode = currentNode.next;
                    p += currentNode.value.length;
                  }
                  p -= currentNode.value.length;
                  pos = p;
                  if (currentNode.value instanceof Token2) {
                    continue;
                  }
                  for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next) {
                    removeCount++;
                    p += k.value.length;
                  }
                  removeCount--;
                  str = text2.slice(pos, p);
                  match.index -= pos;
                } else {
                  match = matchPattern(pattern, 0, str, lookbehind);
                  if (!match) {
                    continue;
                  }
                }
                var from = match.index;
                var matchStr = match[0];
                var before = str.slice(0, from);
                var after = str.slice(from + matchStr.length);
                var reach = pos + str.length;
                if (rematch && reach > rematch.reach) {
                  rematch.reach = reach;
                }
                var removeFrom = currentNode.prev;
                if (before) {
                  removeFrom = addAfter(tokenList, removeFrom, before);
                  pos += before.length;
                }
                removeRange(tokenList, removeFrom, removeCount);
                var wrapped = new Token2(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
                currentNode = addAfter(tokenList, removeFrom, wrapped);
                if (after) {
                  addAfter(tokenList, currentNode, after);
                }
                if (removeCount > 1) {
                  var nestedRematch = {
                    cause: token + "," + j,
                    reach
                  };
                  matchGrammar(text2, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                  if (rematch && nestedRematch.reach > rematch.reach) {
                    rematch.reach = nestedRematch.reach;
                  }
                }
              }
            }
          }
        }
        function LinkedList() {
          var head = { value: null, prev: null, next: null };
          var tail = { value: null, prev: head, next: null };
          head.next = tail;
          this.head = head;
          this.tail = tail;
          this.length = 0;
        }
        function addAfter(list2, node, value) {
          var next = node.next;
          var newNode = { value, prev: node, next };
          node.next = newNode;
          next.prev = newNode;
          list2.length++;
          return newNode;
        }
        function removeRange(list2, node, count) {
          var next = node.next;
          for (var i = 0; i < count && next !== list2.tail; i++) {
            next = next.next;
          }
          node.next = next;
          next.prev = node;
          list2.length -= i;
        }
        function toArray(list2) {
          var array = [];
          var node = list2.head.next;
          while (node !== list2.tail) {
            array.push(node.value);
            node = node.next;
          }
          return array;
        }
        if (!_self2.document) {
          if (!_self2.addEventListener) {
            return _;
          }
          if (!_.disableWorkerMessageHandler) {
            _self2.addEventListener("message", function(evt) {
              var message = JSON.parse(evt.data);
              var lang2 = message.language;
              var code = message.code;
              var immediateClose = message.immediateClose;
              _self2.postMessage(_.highlight(code, _.languages[lang2], lang2));
              if (immediateClose) {
                _self2.close();
              }
            }, false);
          }
          return _;
        }
        var script = _.util.currentScript();
        if (script) {
          _.filename = script.src;
          if (script.hasAttribute("data-manual")) {
            _.manual = true;
          }
        }
        function highlightAutomaticallyCallback() {
          if (!_.manual) {
            _.highlightAll();
          }
        }
        if (!_.manual) {
          var readyState = document.readyState;
          if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
            document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
          } else {
            if (window.requestAnimationFrame) {
              window.requestAnimationFrame(highlightAutomaticallyCallback);
            } else {
              window.setTimeout(highlightAutomaticallyCallback, 16);
            }
          }
        }
        return _;
      }(_self);
      if (typeof module !== "undefined" && module.exports) {
        module.exports = Prism2;
      }
      if (typeof global !== "undefined") {
        global.Prism = Prism2;
      }
      Prism2.languages.markup = {
        "comment": {
          pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
          greedy: true
        },
        "prolog": {
          pattern: /<\?[\s\S]+?\?>/,
          greedy: true
        },
        "doctype": {
          // https://www.w3.org/TR/xml/#NT-doctypedecl
          pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
          greedy: true,
          inside: {
            "internal-subset": {
              pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
              lookbehind: true,
              greedy: true,
              inside: null
              // see below
            },
            "string": {
              pattern: /"[^"]*"|'[^']*'/,
              greedy: true
            },
            "punctuation": /^<!|>$|[[\]]/,
            "doctype-tag": /^DOCTYPE/i,
            "name": /[^\s<>'"]+/
          }
        },
        "cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          greedy: true
        },
        "tag": {
          pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
          greedy: true,
          inside: {
            "tag": {
              pattern: /^<\/?[^\s>\/]+/,
              inside: {
                "punctuation": /^<\/?/,
                "namespace": /^[^\s>\/:]+:/
              }
            },
            "special-attr": [],
            "attr-value": {
              pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
              inside: {
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  {
                    pattern: /^(\s*)["']|["']$/,
                    lookbehind: true
                  }
                ]
              }
            },
            "punctuation": /\/?>/,
            "attr-name": {
              pattern: /[^\s>\/]+/,
              inside: {
                "namespace": /^[^\s>\/:]+:/
              }
            }
          }
        },
        "entity": [
          {
            pattern: /&[\da-z]{1,8};/i,
            alias: "named-entity"
          },
          /&#x?[\da-f]{1,8};/i
        ]
      };
      Prism2.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism2.languages.markup["entity"];
      Prism2.languages.markup["doctype"].inside["internal-subset"].inside = Prism2.languages.markup;
      Prism2.hooks.add("wrap", function(env) {
        if (env.type === "entity") {
          env.attributes["title"] = env.content.replace(/&amp;/, "&");
        }
      });
      Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
        /**
         * Adds an inlined language to markup.
         *
         * An example of an inlined language is CSS with `<style>` tags.
         *
         * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
         * case insensitive.
         * @param {string} lang The language key.
         * @example
         * addInlined('style', 'css');
         */
        value: function addInlined(tagName, lang) {
          var includedCdataInside = {};
          includedCdataInside["language-" + lang] = {
            pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
            lookbehind: true,
            inside: Prism2.languages[lang]
          };
          includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
          var inside = {
            "included-cdata": {
              pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
              inside: includedCdataInside
            }
          };
          inside["language-" + lang] = {
            pattern: /[\s\S]+/,
            inside: Prism2.languages[lang]
          };
          var def2 = {};
          def2[tagName] = {
            pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
              return tagName;
            }), "i"),
            lookbehind: true,
            greedy: true,
            inside
          };
          Prism2.languages.insertBefore("markup", "cdata", def2);
        }
      });
      Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
        /**
         * Adds an pattern to highlight languages embedded in HTML attributes.
         *
         * An example of an inlined language is CSS with `style` attributes.
         *
         * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
         * case insensitive.
         * @param {string} lang The language key.
         * @example
         * addAttribute('style', 'css');
         */
        value: function(attrName, lang) {
          Prism2.languages.markup.tag.inside["special-attr"].push({
            pattern: RegExp(
              /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
              "i"
            ),
            lookbehind: true,
            inside: {
              "attr-name": /^[^\s=]+/,
              "attr-value": {
                pattern: /=[\s\S]+/,
                inside: {
                  "value": {
                    pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                    lookbehind: true,
                    alias: [lang, "language-" + lang],
                    inside: Prism2.languages[lang]
                  },
                  "punctuation": [
                    {
                      pattern: /^=/,
                      alias: "attr-equals"
                    },
                    /"|'/
                  ]
                }
              }
            }
          });
        }
      });
      Prism2.languages.html = Prism2.languages.markup;
      Prism2.languages.mathml = Prism2.languages.markup;
      Prism2.languages.svg = Prism2.languages.markup;
      Prism2.languages.xml = Prism2.languages.extend("markup", {});
      Prism2.languages.ssml = Prism2.languages.xml;
      Prism2.languages.atom = Prism2.languages.xml;
      Prism2.languages.rss = Prism2.languages.xml;
      (function(Prism3) {
        var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
        Prism3.languages.css = {
          "comment": /\/\*[\s\S]*?\*\//,
          "atrule": {
            pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
            inside: {
              "rule": /^@[\w-]+/,
              "selector-function-argument": {
                pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                lookbehind: true,
                alias: "selector"
              },
              "keyword": {
                pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                lookbehind: true
              }
              // See rest below
            }
          },
          "url": {
            // https://drafts.csswg.org/css-values-3/#urls
            pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
            greedy: true,
            inside: {
              "function": /^url/i,
              "punctuation": /^\(|\)$/,
              "string": {
                pattern: RegExp("^" + string.source + "$"),
                alias: "url"
              }
            }
          },
          "selector": {
            pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
            lookbehind: true
          },
          "string": {
            pattern: string,
            greedy: true
          },
          "property": {
            pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
            lookbehind: true
          },
          "important": /!important\b/i,
          "function": {
            pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
            lookbehind: true
          },
          "punctuation": /[(){};:,]/
        };
        Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
        var markup = Prism3.languages.markup;
        if (markup) {
          markup.tag.addInlined("style", "css");
          markup.tag.addAttribute("style", "css");
        }
      })(Prism2);
      Prism2.languages.clike = {
        "comment": [
          {
            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
            lookbehind: true,
            greedy: true
          },
          {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: true,
            greedy: true
          }
        ],
        "string": {
          pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
          greedy: true
        },
        "class-name": {
          pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
          lookbehind: true,
          inside: {
            "punctuation": /[.\\]/
          }
        },
        "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
        "boolean": /\b(?:false|true)\b/,
        "function": /\b\w+(?=\()/,
        "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
        "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
        "punctuation": /[{}[\];(),.:]/
      };
      Prism2.languages.javascript = Prism2.languages.extend("clike", {
        "class-name": [
          Prism2.languages.clike["class-name"],
          {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
            lookbehind: true
          }
        ],
        "keyword": [
          {
            pattern: /((?:^|\})\s*)catch\b/,
            lookbehind: true
          },
          {
            pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
            lookbehind: true
          }
        ],
        // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
        "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
        "number": {
          pattern: RegExp(
            /(^|[^\w$])/.source + "(?:" + // constant
            (/NaN|Infinity/.source + "|" + // binary integer
            /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
            /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
            /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
            /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
            /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
          ),
          lookbehind: true
        },
        "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
      });
      Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
      Prism2.languages.insertBefore("javascript", "keyword", {
        "regex": {
          pattern: RegExp(
            // lookbehind
            // eslint-disable-next-line regexp/no-dupe-characters-character-class
            /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
            // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
            // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
            // with the only syntax, so we have to define 2 different regex patterns.
            /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
            /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
            /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
          ),
          lookbehind: true,
          greedy: true,
          inside: {
            "regex-source": {
              pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
              lookbehind: true,
              alias: "language-regex",
              inside: Prism2.languages.regex
            },
            "regex-delimiter": /^\/|\/$/,
            "regex-flags": /^[a-z]+$/
          }
        },
        // This must be declared before keyword because we use "function" inside the look-forward
        "function-variable": {
          pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
          alias: "function"
        },
        "parameter": [
          {
            pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
            lookbehind: true,
            inside: Prism2.languages.javascript
          },
          {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
            lookbehind: true,
            inside: Prism2.languages.javascript
          },
          {
            pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
            lookbehind: true,
            inside: Prism2.languages.javascript
          },
          {
            pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
            lookbehind: true,
            inside: Prism2.languages.javascript
          }
        ],
        "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
      });
      Prism2.languages.insertBefore("javascript", "string", {
        "hashbang": {
          pattern: /^#!.*/,
          greedy: true,
          alias: "comment"
        },
        "template-string": {
          pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
          greedy: true,
          inside: {
            "template-punctuation": {
              pattern: /^`|`$/,
              alias: "string"
            },
            "interpolation": {
              pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
              lookbehind: true,
              inside: {
                "interpolation-punctuation": {
                  pattern: /^\$\{|\}$/,
                  alias: "punctuation"
                },
                rest: Prism2.languages.javascript
              }
            },
            "string": /[\s\S]+/
          }
        },
        "string-property": {
          pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
          lookbehind: true,
          greedy: true,
          alias: "property"
        }
      });
      Prism2.languages.insertBefore("javascript", "operator", {
        "literal-property": {
          pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
          lookbehind: true,
          alias: "property"
        }
      });
      if (Prism2.languages.markup) {
        Prism2.languages.markup.tag.addInlined("script", "javascript");
        Prism2.languages.markup.tag.addAttribute(
          /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
          "javascript"
        );
      }
      Prism2.languages.js = Prism2.languages.javascript;
      (function() {
        if (typeof Prism2 === "undefined" || typeof document === "undefined") {
          return;
        }
        if (!Element.prototype.matches) {
          Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
        }
        var LOADING_MESSAGE = "Loading\u2026";
        var FAILURE_MESSAGE = function(status, message) {
          return "\u2716 Error " + status + " while fetching file: " + message;
        };
        var FAILURE_EMPTY_MESSAGE = "\u2716 Error: File does not exist or is empty";
        var EXTENSIONS = {
          "js": "javascript",
          "py": "python",
          "rb": "ruby",
          "ps1": "powershell",
          "psm1": "powershell",
          "sh": "bash",
          "bat": "batch",
          "h": "c",
          "tex": "latex"
        };
        var STATUS_ATTR = "data-src-status";
        var STATUS_LOADING = "loading";
        var STATUS_LOADED = "loaded";
        var STATUS_FAILED = "failed";
        var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
        function loadFile(src, success, error) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", src, true);
          xhr.onreadystatechange = function() {
            if (xhr.readyState == 4) {
              if (xhr.status < 400 && xhr.responseText) {
                success(xhr.responseText);
              } else {
                if (xhr.status >= 400) {
                  error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
                } else {
                  error(FAILURE_EMPTY_MESSAGE);
                }
              }
            }
          };
          xhr.send(null);
        }
        function parseRange(range) {
          var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
          if (m) {
            var start = Number(m[1]);
            var comma = m[2];
            var end = m[3];
            if (!comma) {
              return [start, start];
            }
            if (!end) {
              return [start, void 0];
            }
            return [start, Number(end)];
          }
          return void 0;
        }
        Prism2.hooks.add("before-highlightall", function(env) {
          env.selector += ", " + SELECTOR;
        });
        Prism2.hooks.add("before-sanity-check", function(env) {
          var pre = (
            /** @type {HTMLPreElement} */
            env.element
          );
          if (pre.matches(SELECTOR)) {
            env.code = "";
            pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
            var code = pre.appendChild(document.createElement("CODE"));
            code.textContent = LOADING_MESSAGE;
            var src = pre.getAttribute("data-src");
            var language = env.language;
            if (language === "none") {
              var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
              language = EXTENSIONS[extension] || extension;
            }
            Prism2.util.setLanguage(code, language);
            Prism2.util.setLanguage(pre, language);
            var autoloader = Prism2.plugins.autoloader;
            if (autoloader) {
              autoloader.loadLanguages(language);
            }
            loadFile(
              src,
              function(text2) {
                pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
                var range = parseRange(pre.getAttribute("data-range"));
                if (range) {
                  var lines = text2.split(/\r\n?|\n/g);
                  var start = range[0];
                  var end = range[1] == null ? lines.length : range[1];
                  if (start < 0) {
                    start += lines.length;
                  }
                  start = Math.max(0, Math.min(start - 1, lines.length));
                  if (end < 0) {
                    end += lines.length;
                  }
                  end = Math.max(0, Math.min(end, lines.length));
                  text2 = lines.slice(start, end).join("\n");
                  if (!pre.hasAttribute("data-start")) {
                    pre.setAttribute("data-start", String(start + 1));
                  }
                }
                code.textContent = text2;
                Prism2.highlightElement(code);
              },
              function(error) {
                pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
                code.textContent = error;
              }
            );
          }
        });
        Prism2.plugins.fileHighlight = {
          /**
           * Executes the File Highlight plugin for all matching `pre` elements under the given container.
           *
           * Note: Elements which are already loaded or currently loading will not be touched by this method.
           *
           * @param {ParentNode} [container=document]
           */
          highlight: function highlight(container) {
            var elements = (container || document).querySelectorAll(SELECTOR);
            for (var i = 0, element; element = elements[i++]; ) {
              Prism2.highlightElement(element);
            }
          }
        };
        var logged = false;
        Prism2.fileHighlight = function() {
          if (!logged) {
            console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
            logged = true;
          }
          Prism2.plugins.fileHighlight.highlight.apply(this, arguments);
        };
      })();
    }
  });

  // node_modules/prismjs/components/prism-clike.js
  var init_prism_clike = __esm({
    "node_modules/prismjs/components/prism-clike.js"() {
      Prism.languages.clike = {
        "comment": [
          {
            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
            lookbehind: true,
            greedy: true
          },
          {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: true,
            greedy: true
          }
        ],
        "string": {
          pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
          greedy: true
        },
        "class-name": {
          pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
          lookbehind: true,
          inside: {
            "punctuation": /[.\\]/
          }
        },
        "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
        "boolean": /\b(?:false|true)\b/,
        "function": /\b\w+(?=\()/,
        "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
        "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
        "punctuation": /[{}[\];(),.:]/
      };
    }
  });

  // node_modules/prismjs/components/prism-python.js
  var init_prism_python = __esm({
    "node_modules/prismjs/components/prism-python.js"() {
      Prism.languages.python = {
        "comment": {
          pattern: /(^|[^\\])#.*/,
          lookbehind: true,
          greedy: true
        },
        "string-interpolation": {
          pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
          greedy: true,
          inside: {
            "interpolation": {
              // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
              pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
              lookbehind: true,
              inside: {
                "format-spec": {
                  pattern: /(:)[^:(){}]+(?=\}$)/,
                  lookbehind: true
                },
                "conversion-option": {
                  pattern: /![sra](?=[:}]$)/,
                  alias: "punctuation"
                },
                rest: null
              }
            },
            "string": /[\s\S]+/
          }
        },
        "triple-quoted-string": {
          pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
          greedy: true,
          alias: "string"
        },
        "string": {
          pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
          greedy: true
        },
        "function": {
          pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
          lookbehind: true
        },
        "class-name": {
          pattern: /(\bclass\s+)\w+/i,
          lookbehind: true
        },
        "decorator": {
          pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
          lookbehind: true,
          alias: ["annotation", "punctuation"],
          inside: {
            "punctuation": /\./
          }
        },
        "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
        "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
        "boolean": /\b(?:False|None|True)\b/,
        "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
        "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
        "punctuation": /[{}[\];(),.:]/
      };
      Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;
      Prism.languages.py = Prism.languages.python;
    }
  });

  // node_modules/prismjs/components/prism-javascript.js
  var init_prism_javascript = __esm({
    "node_modules/prismjs/components/prism-javascript.js"() {
      Prism.languages.javascript = Prism.languages.extend("clike", {
        "class-name": [
          Prism.languages.clike["class-name"],
          {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
            lookbehind: true
          }
        ],
        "keyword": [
          {
            pattern: /((?:^|\})\s*)catch\b/,
            lookbehind: true
          },
          {
            pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
            lookbehind: true
          }
        ],
        // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
        "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
        "number": {
          pattern: RegExp(
            /(^|[^\w$])/.source + "(?:" + // constant
            (/NaN|Infinity/.source + "|" + // binary integer
            /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
            /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
            /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
            /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
            /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
          ),
          lookbehind: true
        },
        "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
      });
      Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
      Prism.languages.insertBefore("javascript", "keyword", {
        "regex": {
          pattern: RegExp(
            // lookbehind
            // eslint-disable-next-line regexp/no-dupe-characters-character-class
            /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
            // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
            // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
            // with the only syntax, so we have to define 2 different regex patterns.
            /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
            /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
            /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
          ),
          lookbehind: true,
          greedy: true,
          inside: {
            "regex-source": {
              pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
              lookbehind: true,
              alias: "language-regex",
              inside: Prism.languages.regex
            },
            "regex-delimiter": /^\/|\/$/,
            "regex-flags": /^[a-z]+$/
          }
        },
        // This must be declared before keyword because we use "function" inside the look-forward
        "function-variable": {
          pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
          alias: "function"
        },
        "parameter": [
          {
            pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
            lookbehind: true,
            inside: Prism.languages.javascript
          },
          {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
            lookbehind: true,
            inside: Prism.languages.javascript
          },
          {
            pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
            lookbehind: true,
            inside: Prism.languages.javascript
          },
          {
            pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
            lookbehind: true,
            inside: Prism.languages.javascript
          }
        ],
        "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
      });
      Prism.languages.insertBefore("javascript", "string", {
        "hashbang": {
          pattern: /^#!.*/,
          greedy: true,
          alias: "comment"
        },
        "template-string": {
          pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
          greedy: true,
          inside: {
            "template-punctuation": {
              pattern: /^`|`$/,
              alias: "string"
            },
            "interpolation": {
              pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
              lookbehind: true,
              inside: {
                "interpolation-punctuation": {
                  pattern: /^\$\{|\}$/,
                  alias: "punctuation"
                },
                rest: Prism.languages.javascript
              }
            },
            "string": /[\s\S]+/
          }
        },
        "string-property": {
          pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
          lookbehind: true,
          greedy: true,
          alias: "property"
        }
      });
      Prism.languages.insertBefore("javascript", "operator", {
        "literal-property": {
          pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
          lookbehind: true,
          alias: "property"
        }
      });
      if (Prism.languages.markup) {
        Prism.languages.markup.tag.addInlined("script", "javascript");
        Prism.languages.markup.tag.addAttribute(
          /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
          "javascript"
        );
      }
      Prism.languages.js = Prism.languages.javascript;
    }
  });

  // node_modules/prismjs/components/prism-css.js
  var init_prism_css = __esm({
    "node_modules/prismjs/components/prism-css.js"() {
      (function(Prism2) {
        var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
        Prism2.languages.css = {
          "comment": /\/\*[\s\S]*?\*\//,
          "atrule": {
            pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
            inside: {
              "rule": /^@[\w-]+/,
              "selector-function-argument": {
                pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                lookbehind: true,
                alias: "selector"
              },
              "keyword": {
                pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                lookbehind: true
              }
              // See rest below
            }
          },
          "url": {
            // https://drafts.csswg.org/css-values-3/#urls
            pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
            greedy: true,
            inside: {
              "function": /^url/i,
              "punctuation": /^\(|\)$/,
              "string": {
                pattern: RegExp("^" + string.source + "$"),
                alias: "url"
              }
            }
          },
          "selector": {
            pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
            lookbehind: true
          },
          "string": {
            pattern: string,
            greedy: true
          },
          "property": {
            pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
            lookbehind: true
          },
          "important": /!important\b/i,
          "function": {
            pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
            lookbehind: true
          },
          "punctuation": /[(){};:,]/
        };
        Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
        var markup = Prism2.languages.markup;
        if (markup) {
          markup.tag.addInlined("style", "css");
          markup.tag.addAttribute("style", "css");
        }
      })(Prism);
    }
  });

  // node_modules/prismjs/components/prism-bash.js
  var init_prism_bash = __esm({
    "node_modules/prismjs/components/prism-bash.js"() {
      (function(Prism2) {
        var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
        var commandAfterHeredoc = {
          pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
          lookbehind: true,
          alias: "punctuation",
          // this looks reasonably well in all themes
          inside: null
          // see below
        };
        var insideString = {
          "bash": commandAfterHeredoc,
          "environment": {
            pattern: RegExp("\\$" + envVars),
            alias: "constant"
          },
          "variable": [
            // [0]: Arithmetic Environment
            {
              pattern: /\$?\(\([\s\S]+?\)\)/,
              greedy: true,
              inside: {
                // If there is a $ sign at the beginning highlight $(( and )) as variable
                "variable": [
                  {
                    pattern: /(^\$\(\([\s\S]+)\)\)/,
                    lookbehind: true
                  },
                  /^\$\(\(/
                ],
                "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
                // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
                "operator": /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
                // If there is no $ sign at the beginning highlight (( and )) as punctuation
                "punctuation": /\(\(?|\)\)?|,|;/
              }
            },
            // [1]: Command Substitution
            {
              pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
              greedy: true,
              inside: {
                "variable": /^\$\(|^`|\)$|`$/
              }
            },
            // [2]: Brace expansion
            {
              pattern: /\$\{[^}]+\}/,
              greedy: true,
              inside: {
                "operator": /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
                "punctuation": /[\[\]]/,
                "environment": {
                  pattern: RegExp("(\\{)" + envVars),
                  lookbehind: true,
                  alias: "constant"
                }
              }
            },
            /\$(?:\w+|[#?*!@$])/
          ],
          // Escape sequences from echo and printf's manuals, and escaped quotes.
          "entity": /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
        };
        Prism2.languages.bash = {
          "shebang": {
            pattern: /^#!\s*\/.*/,
            alias: "important"
          },
          "comment": {
            pattern: /(^|[^"{\\$])#.*/,
            lookbehind: true
          },
          "function-name": [
            // a) function foo {
            // b) foo() {
            // c) function foo() {
            // but not “foo {”
            {
              // a) and c)
              pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
              lookbehind: true,
              alias: "function"
            },
            {
              // b)
              pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
              alias: "function"
            }
          ],
          // Highlight variable names as variables in for and select beginnings.
          "for-or-select": {
            pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
            alias: "variable",
            lookbehind: true
          },
          // Highlight variable names as variables in the left-hand part
          // of assignments (“=” and “+=”).
          "assign-left": {
            pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
            inside: {
              "environment": {
                pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
                lookbehind: true,
                alias: "constant"
              }
            },
            alias: "variable",
            lookbehind: true
          },
          // Highlight parameter names as variables
          "parameter": {
            pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
            alias: "variable",
            lookbehind: true
          },
          "string": [
            // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
            {
              pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
              lookbehind: true,
              greedy: true,
              inside: insideString
            },
            // Here-document with quotes around the tag
            // → No expansion (so no “inside”).
            {
              pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
              lookbehind: true,
              greedy: true,
              inside: {
                "bash": commandAfterHeredoc
              }
            },
            // “Normal” string
            {
              // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
              pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
              lookbehind: true,
              greedy: true,
              inside: insideString
            },
            {
              // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
              pattern: /(^|[^$\\])'[^']*'/,
              lookbehind: true,
              greedy: true
            },
            {
              // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
              pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
              greedy: true,
              inside: {
                "entity": insideString.entity
              }
            }
          ],
          "environment": {
            pattern: RegExp("\\$?" + envVars),
            alias: "constant"
          },
          "variable": insideString.variable,
          "function": {
            pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
            lookbehind: true
          },
          "keyword": {
            pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
            lookbehind: true
          },
          // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
          "builtin": {
            pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
            lookbehind: true,
            // Alias added to make those easier to distinguish from strings.
            alias: "class-name"
          },
          "boolean": {
            pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
            lookbehind: true
          },
          "file-descriptor": {
            pattern: /\B&\d\b/,
            alias: "important"
          },
          "operator": {
            // Lots of redirections here, but not just that.
            pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
            inside: {
              "file-descriptor": {
                pattern: /^\d/,
                alias: "important"
              }
            }
          },
          "punctuation": /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
          "number": {
            pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
            lookbehind: true
          }
        };
        commandAfterHeredoc.inside = Prism2.languages.bash;
        var toBeCopied = [
          "comment",
          "function-name",
          "for-or-select",
          "assign-left",
          "parameter",
          "string",
          "environment",
          "function",
          "keyword",
          "builtin",
          "boolean",
          "file-descriptor",
          "operator",
          "punctuation",
          "number"
        ];
        var inside = insideString.variable[1].inside;
        for (var i = 0; i < toBeCopied.length; i++) {
          inside[toBeCopied[i]] = Prism2.languages.bash[toBeCopied[i]];
        }
        Prism2.languages.sh = Prism2.languages.bash;
        Prism2.languages.shell = Prism2.languages.bash;
      })(Prism);
    }
  });

  // node_modules/prismjs/components/prism-json.js
  var init_prism_json = __esm({
    "node_modules/prismjs/components/prism-json.js"() {
      Prism.languages.json = {
        "property": {
          pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
          lookbehind: true,
          greedy: true
        },
        "string": {
          pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
          lookbehind: true,
          greedy: true
        },
        "comment": {
          pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
          greedy: true
        },
        "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
        "punctuation": /[{}[\],]/,
        "operator": /:/,
        "boolean": /\b(?:false|true)\b/,
        "null": {
          pattern: /\bnull\b/,
          alias: "keyword"
        }
      };
      Prism.languages.webmanifest = Prism.languages.json;
    }
  });

  // node_modules/prismjs/components/prism-yaml.js
  var init_prism_yaml = __esm({
    "node_modules/prismjs/components/prism-yaml.js"() {
      (function(Prism2) {
        var anchorOrAlias = /[*&][^\s[\]{},]+/;
        var tag2 = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
        var properties = "(?:" + tag2.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag2.source + ")?)";
        var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
          return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
        });
        var string = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
        function createValuePattern(value, flags) {
          flags = (flags || "").replace(/m/g, "") + "m";
          var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
            return properties;
          }).replace(/<<value>>/g, function() {
            return value;
          });
          return RegExp(pattern, flags);
        }
        Prism2.languages.yaml = {
          "scalar": {
            pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
              return properties;
            })),
            lookbehind: true,
            alias: "string"
          },
          "comment": /#.*/,
          "key": {
            pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
              return properties;
            }).replace(/<<key>>/g, function() {
              return "(?:" + plainKey + "|" + string + ")";
            })),
            lookbehind: true,
            greedy: true,
            alias: "atrule"
          },
          "directive": {
            pattern: /(^[ \t]*)%.+/m,
            lookbehind: true,
            alias: "important"
          },
          "datetime": {
            pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
            lookbehind: true,
            alias: "number"
          },
          "boolean": {
            pattern: createValuePattern(/false|true/.source, "i"),
            lookbehind: true,
            alias: "important"
          },
          "null": {
            pattern: createValuePattern(/null|~/.source, "i"),
            lookbehind: true,
            alias: "important"
          },
          "string": {
            pattern: createValuePattern(string),
            lookbehind: true,
            greedy: true
          },
          "number": {
            pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
            lookbehind: true
          },
          "tag": tag2,
          "important": anchorOrAlias,
          "punctuation": /---|[:[\]{}\-,|>?]|\.\.\./
        };
        Prism2.languages.yml = Prism2.languages.yaml;
      })(Prism);
    }
  });

  // node_modules/prismjs/components/prism-sql.js
  var init_prism_sql = __esm({
    "node_modules/prismjs/components/prism-sql.js"() {
      Prism.languages.sql = {
        "comment": {
          pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
          lookbehind: true
        },
        "variable": [
          {
            pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
            greedy: true
          },
          /@[\w.$]+/
        ],
        "string": {
          pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
          greedy: true,
          lookbehind: true
        },
        "identifier": {
          pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
          greedy: true,
          lookbehind: true,
          inside: {
            "punctuation": /^`|`$/
          }
        },
        "function": /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
        // Should we highlight user defined functions too?
        "keyword": /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
        "boolean": /\b(?:FALSE|NULL|TRUE)\b/i,
        "number": /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
        "operator": /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
        "punctuation": /[;[\]()`,.]/
      };
    }
  });

  // node_modules/prismjs/components/prism-java.js
  var init_prism_java = __esm({
    "node_modules/prismjs/components/prism-java.js"() {
      (function(Prism2) {
        var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
        var classNamePrefix = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
        var className = {
          pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
          lookbehind: true,
          inside: {
            "namespace": {
              pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
              inside: {
                "punctuation": /\./
              }
            },
            "punctuation": /\./
          }
        };
        Prism2.languages.java = Prism2.languages.extend("clike", {
          "string": {
            pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
            lookbehind: true,
            greedy: true
          },
          "class-name": [
            className,
            {
              // variables, parameters, and constructor references
              // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
              pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
              lookbehind: true,
              inside: className.inside
            },
            {
              // class names based on keyword
              // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
              pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix + /[A-Z]\w*\b/.source),
              lookbehind: true,
              inside: className.inside
            }
          ],
          "keyword": keywords,
          "function": [
            Prism2.languages.clike.function,
            {
              pattern: /(::\s*)[a-z_]\w*/,
              lookbehind: true
            }
          ],
          "number": /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
          "operator": {
            pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
            lookbehind: true
          },
          "constant": /\b[A-Z][A-Z_\d]+\b/
        });
        Prism2.languages.insertBefore("java", "string", {
          "triple-quoted-string": {
            // http://openjdk.java.net/jeps/355#Description
            pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
            greedy: true,
            alias: "string"
          },
          "char": {
            pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
            greedy: true
          }
        });
        Prism2.languages.insertBefore("java", "class-name", {
          "annotation": {
            pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
            lookbehind: true,
            alias: "punctuation"
          },
          "generics": {
            pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
            inside: {
              "class-name": className,
              "keyword": keywords,
              "punctuation": /[<>(),.:]/,
              "operator": /[?&|]/
            }
          },
          "import": [
            {
              pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
              lookbehind: true,
              inside: {
                "namespace": className.inside.namespace,
                "punctuation": /\./,
                "operator": /\*/,
                "class-name": /\w+/
              }
            },
            {
              pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix + /(?:\w+|\*)(?=\s*;)/.source),
              lookbehind: true,
              alias: "static",
              inside: {
                "namespace": className.inside.namespace,
                "static": /\b\w+$/,
                "punctuation": /\./,
                "operator": /\*/,
                "class-name": /\w+/
              }
            }
          ],
          "namespace": {
            pattern: RegExp(
              /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
                return keywords.source;
              })
            ),
            lookbehind: true,
            inside: {
              "punctuation": /\./
            }
          }
        });
      })(Prism);
    }
  });

  // node_modules/prismjs/components/prism-csharp.js
  var init_prism_csharp = __esm({
    "node_modules/prismjs/components/prism-csharp.js"() {
      (function(Prism2) {
        function replace(pattern, replacements) {
          return pattern.replace(/<<(\d+)>>/g, function(m, index) {
            return "(?:" + replacements[+index] + ")";
          });
        }
        function re(pattern, replacements, flags) {
          return RegExp(replace(pattern, replacements), flags || "");
        }
        function nested(pattern, depthLog2) {
          for (var i = 0; i < depthLog2; i++) {
            pattern = pattern.replace(/<<self>>/g, function() {
              return "(?:" + pattern + ")";
            });
          }
          return pattern.replace(/<<self>>/g, "[^\\s\\S]");
        }
        var keywordKinds = {
          // keywords which represent a return or variable type
          type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
          // keywords which are used to declare a type
          typeDeclaration: "class enum interface record struct",
          // contextual keywords
          // ("var" and "dynamic" are missing because they are used like types)
          contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
          // all other keywords
          other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
        };
        function keywordsToPattern(words) {
          return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
        }
        var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);
        var keywords = RegExp(keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other));
        var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other);
        var nonContextualKeywords = keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.other);
        var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2);
        var nestedRound = nested(/\((?:[^()]|<<self>>)*\)/.source, 2);
        var name = /@?\b[A-Za-z_]\w*\b/.source;
        var genericName = replace(/<<0>>(?:\s*<<1>>)?/.source, [name, generic]);
        var identifier = replace(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [nonTypeKeywords, genericName]);
        var array = /\[\s*(?:,\s*)*\]/.source;
        var typeExpressionWithoutTuple = replace(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [identifier, array]);
        var tupleElement = replace(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [generic, nestedRound, array]);
        var tuple = replace(/\(<<0>>+(?:,<<0>>+)+\)/.source, [tupleElement]);
        var typeExpression = replace(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [tuple, identifier, array]);
        var typeInside = {
          "keyword": keywords,
          "punctuation": /[<>()?,.:[\]]/
        };
        var character = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source;
        var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
        var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
        Prism2.languages.csharp = Prism2.languages.extend("clike", {
          "string": [
            {
              pattern: re(/(^|[^$\\])<<0>>/.source, [verbatimString]),
              lookbehind: true,
              greedy: true
            },
            {
              pattern: re(/(^|[^@$\\])<<0>>/.source, [regularString]),
              lookbehind: true,
              greedy: true
            }
          ],
          "class-name": [
            {
              // Using static
              // using static System.Math;
              pattern: re(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [identifier]),
              lookbehind: true,
              inside: typeInside
            },
            {
              // Using alias (type)
              // using Project = PC.MyCompany.Project;
              pattern: re(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [name, typeExpression]),
              lookbehind: true,
              inside: typeInside
            },
            {
              // Using alias (alias)
              // using Project = PC.MyCompany.Project;
              pattern: re(/(\busing\s+)<<0>>(?=\s*=)/.source, [name]),
              lookbehind: true
            },
            {
              // Type declarations
              // class Foo<A, B>
              // interface Foo<out A, B>
              pattern: re(/(\b<<0>>\s+)<<1>>/.source, [typeDeclarationKeywords, genericName]),
              lookbehind: true,
              inside: typeInside
            },
            {
              // Single catch exception declaration
              // catch(Foo)
              // (things like catch(Foo e) is covered by variable declaration)
              pattern: re(/(\bcatch\s*\(\s*)<<0>>/.source, [identifier]),
              lookbehind: true,
              inside: typeInside
            },
            {
              // Name of the type parameter of generic constraints
              // where Foo : class
              pattern: re(/(\bwhere\s+)<<0>>/.source, [name]),
              lookbehind: true
            },
            {
              // Casts and checks via as and is.
              // as Foo<A>, is Bar<B>
              // (things like if(a is Foo b) is covered by variable declaration)
              pattern: re(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [typeExpressionWithoutTuple]),
              lookbehind: true,
              inside: typeInside
            },
            {
              // Variable, field and parameter declaration
              // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
              pattern: re(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [typeExpression, nonContextualKeywords, name]),
              inside: typeInside
            }
          ],
          "keyword": keywords,
          // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
          "number": /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
          "operator": />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
          "punctuation": /\?\.?|::|[{}[\];(),.:]/
        });
        Prism2.languages.insertBefore("csharp", "number", {
          "range": {
            pattern: /\.\./,
            alias: "operator"
          }
        });
        Prism2.languages.insertBefore("csharp", "punctuation", {
          "named-parameter": {
            pattern: re(/([(,]\s*)<<0>>(?=\s*:)/.source, [name]),
            lookbehind: true,
            alias: "punctuation"
          }
        });
        Prism2.languages.insertBefore("csharp", "class-name", {
          "namespace": {
            // namespace Foo.Bar {}
            // using Foo.Bar;
            pattern: re(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [name]),
            lookbehind: true,
            inside: {
              "punctuation": /\./
            }
          },
          "type-expression": {
            // default(Foo), typeof(Foo<Bar>), sizeof(int)
            pattern: re(/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [nestedRound]),
            lookbehind: true,
            alias: "class-name",
            inside: typeInside
          },
          "return-type": {
            // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
            // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
            // int Foo => 0; int Foo { get; set } = 0;
            pattern: re(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [typeExpression, identifier]),
            inside: typeInside,
            alias: "class-name"
          },
          "constructor-invocation": {
            // new List<Foo<Bar[]>> { }
            pattern: re(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [typeExpression]),
            lookbehind: true,
            inside: typeInside,
            alias: "class-name"
          },
          /*'explicit-implementation': {
          	// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
          	pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
          	inside: classNameInside,
          	alias: 'class-name'
          },*/
          "generic-method": {
            // foo<Bar>()
            pattern: re(/<<0>>\s*<<1>>(?=\s*\()/.source, [name, generic]),
            inside: {
              "function": re(/^<<0>>/.source, [name]),
              "generic": {
                pattern: RegExp(generic),
                alias: "class-name",
                inside: typeInside
              }
            }
          },
          "type-list": {
            // The list of types inherited or of generic constraints
            // class Foo<F> : Bar, IList<FooBar>
            // where F : Bar, IList<int>
            pattern: re(
              /\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source,
              [typeDeclarationKeywords, genericName, name, typeExpression, keywords.source, nestedRound, /\bnew\s*\(\s*\)/.source]
            ),
            lookbehind: true,
            inside: {
              "record-arguments": {
                pattern: re(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [genericName, nestedRound]),
                lookbehind: true,
                greedy: true,
                inside: Prism2.languages.csharp
              },
              "keyword": keywords,
              "class-name": {
                pattern: RegExp(typeExpression),
                greedy: true,
                inside: typeInside
              },
              "punctuation": /[,()]/
            }
          },
          "preprocessor": {
            pattern: /(^[\t ]*)#.*/m,
            lookbehind: true,
            alias: "property",
            inside: {
              // highlight preprocessor directives as keywords
              "directive": {
                pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
                lookbehind: true,
                alias: "keyword"
              }
            }
          }
        });
        var regularStringOrCharacter = regularString + "|" + character;
        var regularStringCharacterOrComment = replace(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [regularStringOrCharacter]);
        var roundExpression = nested(replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
        var attrTarget = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source;
        var attr = replace(/<<0>>(?:\s*\(<<1>>*\))?/.source, [identifier, roundExpression]);
        Prism2.languages.insertBefore("csharp", "class-name", {
          "attribute": {
            // Attributes
            // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
            pattern: re(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [attrTarget, attr]),
            lookbehind: true,
            greedy: true,
            inside: {
              "target": {
                pattern: re(/^<<0>>(?=\s*:)/.source, [attrTarget]),
                alias: "keyword"
              },
              "attribute-arguments": {
                pattern: re(/\(<<0>>*\)/.source, [roundExpression]),
                inside: Prism2.languages.csharp
              },
              "class-name": {
                pattern: RegExp(identifier),
                inside: {
                  "punctuation": /\./
                }
              },
              "punctuation": /[:,]/
            }
          }
        });
        var formatString = /:[^}\r\n]+/.source;
        var mInterpolationRound = nested(replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
        var mInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [mInterpolationRound, formatString]);
        var sInterpolationRound = nested(replace(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [regularStringOrCharacter]), 2);
        var sInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [sInterpolationRound, formatString]);
        function createInterpolationInside(interpolation, interpolationRound) {
          return {
            "interpolation": {
              pattern: re(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [interpolation]),
              lookbehind: true,
              inside: {
                "format-string": {
                  pattern: re(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [interpolationRound, formatString]),
                  lookbehind: true,
                  inside: {
                    "punctuation": /^:/
                  }
                },
                "punctuation": /^\{|\}$/,
                "expression": {
                  pattern: /[\s\S]+/,
                  alias: "language-csharp",
                  inside: Prism2.languages.csharp
                }
              }
            },
            "string": /[\s\S]+/
          };
        }
        Prism2.languages.insertBefore("csharp", "string", {
          "interpolation-string": [
            {
              pattern: re(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [mInterpolation]),
              lookbehind: true,
              greedy: true,
              inside: createInterpolationInside(mInterpolation, mInterpolationRound)
            },
            {
              pattern: re(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [sInterpolation]),
              lookbehind: true,
              greedy: true,
              inside: createInterpolationInside(sInterpolation, sInterpolationRound)
            }
          ],
          "char": {
            pattern: RegExp(character),
            greedy: true
          }
        });
        Prism2.languages.dotnet = Prism2.languages.cs = Prism2.languages.csharp;
      })(Prism);
    }
  });

  // node_modules/prismjs/components/prism-go.js
  var init_prism_go = __esm({
    "node_modules/prismjs/components/prism-go.js"() {
      Prism.languages.go = Prism.languages.extend("clike", {
        "string": {
          pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
          lookbehind: true,
          greedy: true
        },
        "keyword": /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
        "boolean": /\b(?:_|false|iota|nil|true)\b/,
        "number": [
          // binary and octal integers
          /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
          // hexadecimal integers and floats
          /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
          // decimal integers and floats
          /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
        ],
        "operator": /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
        "builtin": /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
      });
      Prism.languages.insertBefore("go", "string", {
        "char": {
          pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
          greedy: true
        }
      });
      delete Prism.languages.go["class-name"];
    }
  });

  // node_modules/prismjs/components/prism-rust.js
  var init_prism_rust = __esm({
    "node_modules/prismjs/components/prism-rust.js"() {
      (function(Prism2) {
        var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
        for (var i = 0; i < 2; i++) {
          multilineComment = multilineComment.replace(/<self>/g, function() {
            return multilineComment;
          });
        }
        multilineComment = multilineComment.replace(/<self>/g, function() {
          return /[^\s\S]/.source;
        });
        Prism2.languages.rust = {
          "comment": [
            {
              pattern: RegExp(/(^|[^\\])/.source + multilineComment),
              lookbehind: true,
              greedy: true
            },
            {
              pattern: /(^|[^\\:])\/\/.*/,
              lookbehind: true,
              greedy: true
            }
          ],
          "string": {
            pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
            greedy: true
          },
          "char": {
            pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
            greedy: true
          },
          "attribute": {
            pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
            greedy: true,
            alias: "attr-name",
            inside: {
              "string": null
              // see below
            }
          },
          // Closure params should not be confused with bitwise OR |
          "closure-params": {
            pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
            lookbehind: true,
            greedy: true,
            inside: {
              "closure-punctuation": {
                pattern: /^\||\|$/,
                alias: "punctuation"
              },
              rest: null
              // see below
            }
          },
          "lifetime-annotation": {
            pattern: /'\w+/,
            alias: "symbol"
          },
          "fragment-specifier": {
            pattern: /(\$\w+:)[a-z]+/,
            lookbehind: true,
            alias: "punctuation"
          },
          "variable": /\$\w+/,
          "function-definition": {
            pattern: /(\bfn\s+)\w+/,
            lookbehind: true,
            alias: "function"
          },
          "type-definition": {
            pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
            lookbehind: true,
            alias: "class-name"
          },
          "module-declaration": [
            {
              pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
              lookbehind: true,
              alias: "namespace"
            },
            {
              pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
              lookbehind: true,
              alias: "namespace",
              inside: {
                "punctuation": /::/
              }
            }
          ],
          "keyword": [
            // https://github.com/rust-lang/reference/blob/master/src/keywords.md
            /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
            // primitives and str
            // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
            /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
          ],
          // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
          // and Rust's naming conventions recommend snake_case anyway.
          // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
          "function": /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
          "macro": {
            pattern: /\b\w+!/,
            alias: "property"
          },
          "constant": /\b[A-Z_][A-Z_\d]+\b/,
          "class-name": /\b[A-Z]\w*\b/,
          "namespace": {
            pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
            inside: {
              "punctuation": /::/
            }
          },
          // Hex, oct, bin, dec numbers with visual separators and type suffix
          "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
          "boolean": /\b(?:false|true)\b/,
          "punctuation": /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
          "operator": /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
        };
        Prism2.languages.rust["closure-params"].inside.rest = Prism2.languages.rust;
        Prism2.languages.rust["attribute"].inside["string"] = Prism2.languages.rust["string"];
      })(Prism);
    }
  });

  // node_modules/prismjs/components/prism-docker.js
  var init_prism_docker = __esm({
    "node_modules/prismjs/components/prism-docker.js"() {
      (function(Prism2) {
        var spaceAfterBackSlash = /\\[\r\n](?:\s|\\[\r\n]|#.*(?!.))*(?![\s#]|\\[\r\n])/.source;
        var space = /(?:[ \t]+(?![ \t])(?:<SP_BS>)?|<SP_BS>)/.source.replace(/<SP_BS>/g, function() {
          return spaceAfterBackSlash;
        });
        var string = /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"|'(?:[^'\\\r\n]|\\(?:\r\n|[\s\S]))*'/.source;
        var option = /--[\w-]+=(?:<STR>|(?!["'])(?:[^\s\\]|\\.)+)/.source.replace(/<STR>/g, function() {
          return string;
        });
        var stringRule = {
          pattern: RegExp(string),
          greedy: true
        };
        var commentRule = {
          pattern: /(^[ \t]*)#.*/m,
          lookbehind: true,
          greedy: true
        };
        function re(source, flags) {
          source = source.replace(/<OPT>/g, function() {
            return option;
          }).replace(/<SP>/g, function() {
            return space;
          });
          return RegExp(source, flags);
        }
        Prism2.languages.docker = {
          "instruction": {
            pattern: /(^[ \t]*)(?:ADD|ARG|CMD|COPY|ENTRYPOINT|ENV|EXPOSE|FROM|HEALTHCHECK|LABEL|MAINTAINER|ONBUILD|RUN|SHELL|STOPSIGNAL|USER|VOLUME|WORKDIR)(?=\s)(?:\\.|[^\r\n\\])*(?:\\$(?:\s|#.*$)*(?![\s#])(?:\\.|[^\r\n\\])*)*/im,
            lookbehind: true,
            greedy: true,
            inside: {
              "options": {
                pattern: re(/(^(?:ONBUILD<SP>)?\w+<SP>)<OPT>(?:<SP><OPT>)*/.source, "i"),
                lookbehind: true,
                greedy: true,
                inside: {
                  "property": {
                    pattern: /(^|\s)--[\w-]+/,
                    lookbehind: true
                  },
                  "string": [
                    stringRule,
                    {
                      pattern: /(=)(?!["'])(?:[^\s\\]|\\.)+/,
                      lookbehind: true
                    }
                  ],
                  "operator": /\\$/m,
                  "punctuation": /=/
                }
              },
              "keyword": [
                {
                  // https://docs.docker.com/engine/reference/builder/#healthcheck
                  pattern: re(/(^(?:ONBUILD<SP>)?HEALTHCHECK<SP>(?:<OPT><SP>)*)(?:CMD|NONE)\b/.source, "i"),
                  lookbehind: true,
                  greedy: true
                },
                {
                  // https://docs.docker.com/engine/reference/builder/#from
                  pattern: re(/(^(?:ONBUILD<SP>)?FROM<SP>(?:<OPT><SP>)*(?!--)[^ \t\\]+<SP>)AS/.source, "i"),
                  lookbehind: true,
                  greedy: true
                },
                {
                  // https://docs.docker.com/engine/reference/builder/#onbuild
                  pattern: re(/(^ONBUILD<SP>)\w+/.source, "i"),
                  lookbehind: true,
                  greedy: true
                },
                {
                  pattern: /^\w+/,
                  greedy: true
                }
              ],
              "comment": commentRule,
              "string": stringRule,
              "variable": /\$(?:\w+|\{[^{}"'\\]*\})/,
              "operator": /\\$/m
            }
          },
          "comment": commentRule
        };
        Prism2.languages.dockerfile = Prism2.languages.docker;
      })(Prism);
    }
  });

  // node_modules/prismjs/components/prism-typescript.js
  var init_prism_typescript = __esm({
    "node_modules/prismjs/components/prism-typescript.js"() {
      (function(Prism2) {
        Prism2.languages.typescript = Prism2.languages.extend("javascript", {
          "class-name": {
            pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
            lookbehind: true,
            greedy: true,
            inside: null
            // see below
          },
          "builtin": /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
        });
        Prism2.languages.typescript.keyword.push(
          /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
          // keywords that have to be followed by an identifier
          /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
          // This is for `import type *, {}`
          /\btype\b(?=\s*(?:[\{*]|$))/
        );
        delete Prism2.languages.typescript["parameter"];
        delete Prism2.languages.typescript["literal-property"];
        var typeInside = Prism2.languages.extend("typescript", {});
        delete typeInside["class-name"];
        Prism2.languages.typescript["class-name"].inside = typeInside;
        Prism2.languages.insertBefore("typescript", "function", {
          "decorator": {
            pattern: /@[$\w\xA0-\uFFFF]+/,
            inside: {
              "at": {
                pattern: /^@/,
                alias: "operator"
              },
              "function": /^[\s\S]+/
            }
          },
          "generic-function": {
            // e.g. foo<T extends "bar" | "baz">( ...
            pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
            greedy: true,
            inside: {
              "function": /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
              "generic": {
                pattern: /<[\s\S]+/,
                // everything after the first <
                alias: "class-name",
                inside: typeInside
              }
            }
          }
        });
        Prism2.languages.ts = Prism2.languages.typescript;
      })(Prism);
    }
  });

  // node_modules/prismjs/components/prism-c.js
  var init_prism_c = __esm({
    "node_modules/prismjs/components/prism-c.js"() {
      Prism.languages.c = Prism.languages.extend("clike", {
        "comment": {
          pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
          greedy: true
        },
        "string": {
          // https://en.cppreference.com/w/c/language/string_literal
          pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
          greedy: true
        },
        "class-name": {
          pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
          lookbehind: true
        },
        "keyword": /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
        "function": /\b[a-z_]\w*(?=\s*\()/i,
        "number": /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
        "operator": />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
      });
      Prism.languages.insertBefore("c", "string", {
        "char": {
          // https://en.cppreference.com/w/c/language/character_constant
          pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
          greedy: true
        }
      });
      Prism.languages.insertBefore("c", "string", {
        "macro": {
          // allow for multiline macro definitions
          // spaces after the # character compile fine with gcc
          pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
          lookbehind: true,
          greedy: true,
          alias: "property",
          inside: {
            "string": [
              {
                // highlight the path of the include statement as a string
                pattern: /^(#\s*include\s*)<[^>]+>/,
                lookbehind: true
              },
              Prism.languages.c["string"]
            ],
            "char": Prism.languages.c["char"],
            "comment": Prism.languages.c["comment"],
            "macro-name": [
              {
                pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
                lookbehind: true
              },
              {
                pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
                lookbehind: true,
                alias: "function"
              }
            ],
            // highlight macro directives as keywords
            "directive": {
              pattern: /^(#\s*)[a-z]+/,
              lookbehind: true,
              alias: "keyword"
            },
            "directive-hash": /^#/,
            "punctuation": /##|\\(?=[\r\n])/,
            "expression": {
              pattern: /\S[\s\S]*/,
              inside: Prism.languages.c
            }
          }
        }
      });
      Prism.languages.insertBefore("c", "function", {
        // highlight predefined macros as constants
        "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
      });
      delete Prism.languages.c["boolean"];
    }
  });

  // node_modules/prismjs/components/prism-cpp.js
  var init_prism_cpp = __esm({
    "node_modules/prismjs/components/prism-cpp.js"() {
      (function(Prism2) {
        var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
        var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
          return keyword.source;
        });
        Prism2.languages.cpp = Prism2.languages.extend("c", {
          "class-name": [
            {
              pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
                return keyword.source;
              })),
              lookbehind: true
            },
            // This is intended to capture the class name of method implementations like:
            //   void foo::bar() const {}
            // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
            // it starts with an uppercase letter. This approximation should give decent results.
            /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
            // This will capture the class name before destructors like:
            //   Foo::~Foo() {}
            /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
            // This also intends to capture the class name of method implementations but here the class has template
            // parameters, so it can't be a namespace (until C++ adds generic namespaces).
            /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
          ],
          "keyword": keyword,
          "number": {
            pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
            greedy: true
          },
          "operator": />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
          "boolean": /\b(?:false|true)\b/
        });
        Prism2.languages.insertBefore("cpp", "string", {
          "module": {
            // https://en.cppreference.com/w/cpp/language/modules
            pattern: RegExp(
              /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
              /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
              /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
                return modName;
              }) + ")"
            ),
            lookbehind: true,
            greedy: true,
            inside: {
              "string": /^[<"][\s\S]+/,
              "operator": /:/,
              "punctuation": /\./
            }
          },
          "raw-string": {
            pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
            alias: "string",
            greedy: true
          }
        });
        Prism2.languages.insertBefore("cpp", "keyword", {
          "generic-function": {
            pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
            inside: {
              "function": /^\w+/,
              "generic": {
                pattern: /<[\s\S]+/,
                alias: "class-name",
                inside: Prism2.languages.cpp
              }
            }
          }
        });
        Prism2.languages.insertBefore("cpp", "operator", {
          "double-colon": {
            pattern: /::/,
            alias: "punctuation"
          }
        });
        Prism2.languages.insertBefore("cpp", "class-name", {
          // the base clause is an optional list of parent classes
          // https://en.cppreference.com/w/cpp/language/class
          "base-clause": {
            pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
            lookbehind: true,
            greedy: true,
            inside: Prism2.languages.extend("cpp", {})
          }
        });
        Prism2.languages.insertBefore("inside", "double-colon", {
          // All untokenized words that are not namespaces should be class names
          "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
        }, Prism2.languages.cpp["base-clause"]);
      })(Prism);
    }
  });

  // app/static/script.js
  var require_script = __commonJS({
    "app/static/script.js"() {
      init_marked_esm();
      init_katex();
      var import_prismjs = __toESM(require_prism());
      init_prism_clike();
      init_prism_python();
      init_prism_javascript();
      init_prism_css();
      init_prism_bash();
      init_prism_json();
      init_prism_yaml();
      init_prism_sql();
      init_prism_java();
      init_prism_csharp();
      init_prism_go();
      init_prism_rust();
      init_prism_docker();
      init_prism_typescript();
      init_prism_c();
      init_prism_cpp();
      var chatHistory = document.getElementById("chat-history");
      var chatForm = document.getElementById("chat-form");
      var messageInput = document.getElementById("message-input");
      var sendButton = document.getElementById("send-button");
      var thinkCheckbox = document.getElementById("think-checkbox");
      var websocket;
      var clientId = `web-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
      var currentTurnId = 0;
      var MODE_ANSWER = "MODE_ANSWER";
      var MODE_SEEKING_CODE_LANGUAGE = "MODE_SEEKING_CODE_LANGUAGE";
      var MODE_INSIDE_CODE_BLOCK = "MODE_INSIDE_CODE_BLOCK";
      var MODE_KATEX_BUFFERING_INLINE = "MODE_KATEX_BUFFERING_INLINE";
      var MODE_KATEX_BUFFERING_DISPLAY = "MODE_KATEX_BUFFERING_DISPLAY";
      var MODE_MAYBE_START_DISPLAY_KATEX = "MODE_MAYBE_START_DISPLAY_KATEX";
      var MODE_SEEKING_TAG = "MODE_SEEKING_TAG";
      var MODE_INSIDE_THINK = "MODE_INSIDE_THINK";
      var MODE_MAYBE_END_THINK = "MODE_MAYBE_END_THINK";
      var NO_THINK_PREFIX = "\\no_think";
      var MODE_SEEKING_CODE_START_FENCE = "MODE_SEEKING_CODE_START_FENCE";
      var MODE_SEEKING_CODE_END_FENCE = "MODE_SEEKING_CODE_END_FENCE";
      var currentProcessingMode = MODE_ANSWER;
      var langBuffer = "";
      var currentCodeBlockLang = "";
      var currentCodeBlockElement = null;
      var currentCodeBlockPreElement = null;
      var katexBuffer = "";
      var currentKatexMarkerId = null;
      var thinkBuffer = "";
      var tagBuffer = "";
      var fenceBuffer = "";
      var currentAiTurnContainer = null;
      var currentAnswerElement = null;
      var currentThinkingArea = null;
      var currentThinkingPreElement = null;
      var currentCodeBlocksArea = null;
      var codeBlockCounterThisTurn = 0;
      var thinkingRequestedForCurrentTurn = false;
      var accumulatedAnswerText = "";
      var lastAppendedNode = null;
      var hasThinkingContentArrivedThisTurn = false;
      var firstAnswerTokenReceived = false;
      var FENCE = "```";
      var THINK_START_TAG = "<think>";
      var THINK_END_TAG = "</think>";
      var KATEX_PLACEHOLDER_PREFIX = "%%KATEX_PLACEHOLDER_";
      var KATEX_RENDERED_ATTR = "data-katex-rendered";
      function scrollToBottom(behavior = "auto") {
        const isNearBottom = chatHistory.scrollHeight - chatHistory.scrollTop - chatHistory.clientHeight < 100;
        if (isNearBottom) {
          requestAnimationFrame(() => {
            chatHistory.scrollTo({ top: chatHistory.scrollHeight, behavior });
          });
        }
      }
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
      function getCursorPosition(parentElement) {
        const selection = window.getSelection();
        if (selection.rangeCount === 0) return -1;
        const range = selection.getRangeAt(0);
        if (!parentElement.contains(range.startContainer)) {
          return -1;
        }
        const preSelectionRange = range.cloneRange();
        preSelectionRange.selectNodeContents(parentElement);
        try {
          preSelectionRange.setEnd(range.startContainer, range.startOffset);
        } catch (e) {
          console.error("Error setting preSelectionRange end:", e, "Range:", range);
          return -1;
        }
        return preSelectionRange.toString().length;
      }
      function setCursorPosition(parentElement, offset) {
        const selection = window.getSelection();
        if (!selection) return;
        const range = document.createRange();
        let charCount = 0;
        let foundStart = false;
        function findNodeAndOffset(node) {
          if (foundStart) return;
          if (node.nodeType === Node.TEXT_NODE) {
            const nextCharCount = charCount + node.length;
            if (!foundStart && offset >= charCount && offset <= nextCharCount) {
              try {
                const offsetInNode2 = offset - charCount;
                range.setStart(node, offsetInNode2);
                foundStart = true;
              } catch (e) {
                console.error("Error setting range start:", e, "Node:", node, "Offset:", offsetInNode);
              }
            }
            charCount = nextCharCount;
          } else {
            for (let i = 0; i < node.childNodes.length; i++) {
              findNodeAndOffset(node.childNodes[i]);
              if (foundStart) break;
            }
          }
        }
        findNodeAndOffset(parentElement);
        if (foundStart) {
          range.collapse(true);
          selection.removeAllRanges();
          selection.addRange(range);
        } else {
          range.selectNodeContents(parentElement);
          range.collapse(false);
          selection.removeAllRanges();
          selection.addRange(range);
          console.warn(`Could not set cursor precisely at offset ${offset}. Placed at end.`);
        }
        parentElement.focus();
      }
      function addUserMessage(text2) {
        const messageElement = document.createElement("div");
        messageElement.classList.add("message", "user-message");
        messageElement.textContent = text2;
        chatHistory.appendChild(messageElement);
        setTimeout(() => scrollToBottom("smooth"), 50);
      }
      function addSystemMessage(text2) {
        const messageElement = document.createElement("div");
        messageElement.classList.add("system-message");
        messageElement.textContent = text2;
        chatHistory.appendChild(messageElement);
        setTimeout(() => scrollToBottom("smooth"), 50);
      }
      function addErrorMessage(text2) {
        console.error("[UI ERROR] ", text2);
        const messageElement = document.createElement("div");
        messageElement.classList.add("error-message");
        messageElement.textContent = `Error: ${text2}`;
        if (currentAiTurnContainer) {
          const target = currentAnswerElement || currentCodeBlocksArea || currentAiTurnContainer;
          target.appendChild(messageElement);
        } else {
          chatHistory.appendChild(messageElement);
        }
        setTimeout(() => scrollToBottom("smooth"), 50);
      }
      function setInputDisabledState(disabled) {
        messageInput.disabled = disabled;
        sendButton.disabled = disabled;
        if (thinkCheckbox) {
          thinkCheckbox.disabled = disabled;
        }
      }
      function setupNewAiTurn() {
        currentTurnId++;
        codeBlockCounterThisTurn = 0;
        accumulatedAnswerText = "";
        lastAppendedNode = null;
        thinkBuffer = "";
        hasThinkingContentArrivedThisTurn = false;
        firstAnswerTokenReceived = false;
        currentAiTurnContainer = null;
        currentThinkingArea = null;
        currentThinkingPreElement = null;
        currentAnswerElement = null;
        currentCodeBlocksArea = null;
        console.log(`[setupNewAiTurn] Starting setup for Turn ID: ${currentTurnId}. thinkingRequestedForCurrentTurn is: ${thinkingRequestedForCurrentTurn}`);
        currentAiTurnContainer = document.createElement("div");
        currentAiTurnContainer.classList.add("ai-turn-container");
        currentAiTurnContainer.dataset.turnId = currentTurnId;
        currentThinkingArea = document.createElement("div");
        currentThinkingArea.classList.add("thinking-area");
        currentThinkingArea.dataset.turnId = currentTurnId;
        if (!thinkingRequestedForCurrentTurn) {
          console.log("[setupNewAiTurn] Setting thinking area style to display:none because thinkingRequested=false.");
          currentThinkingArea.style.display = "none";
        } else {
          console.log("[setupNewAiTurn] NOT hiding thinking area initially because thinkingRequested=true.");
        }
        const details = document.createElement("details");
        details.id = `thinking-details-${currentTurnId}`;
        const summary = document.createElement("summary");
        summary.classList.add("thinking-summary");
        const summaryTextSpan = document.createElement("span");
        summaryTextSpan.classList.add("text");
        summaryTextSpan.textContent = "Show Thinking";
        const summaryDotsSpan = document.createElement("span");
        summaryDotsSpan.classList.add("dots");
        summary.appendChild(summaryTextSpan);
        summary.appendChild(summaryDotsSpan);
        currentThinkingPreElement = document.createElement("pre");
        details.appendChild(summary);
        details.appendChild(currentThinkingPreElement);
        currentThinkingArea.appendChild(details);
        currentAiTurnContainer.appendChild(currentThinkingArea);
        details.addEventListener("toggle", (event) => {
          const textSpan = event.target.querySelector(".thinking-summary .text");
          if (!textSpan) return;
          textSpan.textContent = event.target.open ? "Hide Thinking" : "Show Thinking";
        });
        currentAnswerElement = document.createElement("div");
        currentAnswerElement.classList.add("message", "ai-message");
        if (thinkingRequestedForCurrentTurn) {
          console.log("[setupNewAiTurn] Hiding answer bubble initially because thinkingRequested=true.");
          currentAnswerElement.style.display = "none";
        } else {
          console.log("[setupNewAiTurn] Showing answer bubble immediately with loading dots because thinkingRequested=false.");
          const loadingSpan = document.createElement("span");
          loadingSpan.classList.add("loading-dots");
          currentAnswerElement.appendChild(loadingSpan);
        }
        currentAiTurnContainer.appendChild(currentAnswerElement);
        currentCodeBlocksArea = document.createElement("div");
        currentCodeBlocksArea.classList.add("code-blocks-area");
        currentAiTurnContainer.appendChild(currentCodeBlocksArea);
        chatHistory.appendChild(currentAiTurnContainer);
        console.log(`[setupNewAiTurn] Finished setup for Turn ID: ${currentTurnId}.`);
      }
      function appendRawTextToThinkingArea(text2) {
        if (text2 && text2.trim().length > 0) {
        } else if (text2 !== null) {
        }
        if (!thinkingRequestedForCurrentTurn) {
          return;
        }
        if (!currentThinkingArea || !currentThinkingPreElement || text2.length === 0) {
          return;
        }
        if (!hasThinkingContentArrivedThisTurn) {
          if (currentThinkingArea.style.display === "none") {
            currentThinkingArea.style.display = "";
          }
          hasThinkingContentArrivedThisTurn = true;
        }
        try {
          currentThinkingPreElement.appendChild(document.createTextNode(text2));
        } catch (appendError) {
          console.error("[appendRawTextToThinkingArea] Error appending text node:", appendError, "Pre Element:", currentThinkingPreElement, "Text:", text2);
          return;
        }
        const detailsElement = currentThinkingPreElement.closest("details");
        if (detailsElement && detailsElement.open) {
          const isNearBottom = currentThinkingPreElement.scrollHeight - currentThinkingPreElement.scrollTop - currentThinkingPreElement.clientHeight < 50;
          if (isNearBottom) {
            requestAnimationFrame(() => {
              currentThinkingPreElement.scrollTop = currentThinkingPreElement.scrollHeight;
            });
          }
        }
      }
      function appendCodeReference() {
        if (!currentAnswerElement) {
          console.error("Attempted to append code reference to null answer bubble!");
          return;
        }
        if (codeBlockCounterThisTurn > 0) {
          const refSpan = document.createElement("span");
          refSpan.classList.add("code-reference");
          refSpan.textContent = `[Code ${codeBlockCounterThisTurn}]`;
          currentAnswerElement.appendChild(refSpan);
          lastAppendedNode = refSpan;
        } else {
          console.warn("appendCodeReference called but codeBlockCounterThisTurn is 0.");
        }
      }
      function formatAnswerBubbleFinal() {
        if (!currentAnswerElement) {
          console.warn("[DEBUG] Skipping final formatting: currentAnswerElement is null.");
          accumulatedAnswerText = "";
          lastAppendedNode = null;
          firstAnswerTokenReceived = false;
          return;
        }
        if (currentAnswerElement.style.display === "none" && (currentAnswerElement.hasChildNodes() || accumulatedAnswerText.trim().length > 0)) {
          console.warn("[formatAnswerBubbleFinal] Answer bubble was hidden but contained content. Making visible.");
          currentAnswerElement.style.display = "";
          const loadingDots = currentAnswerElement.querySelector(".loading-dots");
          if (loadingDots) loadingDots.remove();
        }
        const hasVisualContent = currentAnswerElement.hasChildNodes() && !currentAnswerElement.querySelector(".loading-dots");
        const hasAccumulatedContent = accumulatedAnswerText.trim().length > 0;
        if (!hasVisualContent && !hasAccumulatedContent) {
          console.log("[DEBUG] Skipping final formatting: No actual content found.");
          const loadingDots = currentAnswerElement.querySelector(".loading-dots");
          if (loadingDots) loadingDots.remove();
          accumulatedAnswerText = "";
          lastAppendedNode = null;
          return;
        }
        try {
          const storedKatexNodes = {};
          let placeholderIndex = 0;
          let textForMarkdown = accumulatedAnswerText;
          const katexSpans = Array.from(currentAnswerElement.children).filter((el) => el.matches(`span[${KATEX_RENDERED_ATTR}="true"]`));
          if (katexSpans.length > 0) {
            katexSpans.forEach((el) => {
              if (!el.parentNode) return;
              const placeholder = `${KATEX_PLACEHOLDER_PREFIX}${placeholderIndex++}`;
              storedKatexNodes[placeholder] = el.cloneNode(true);
              try {
                el.parentNode.replaceChild(document.createTextNode(placeholder), el);
              } catch (replaceError) {
                console.error(`[DEBUG] Error replacing KaTeX node with placeholder ${placeholder}:`, replaceError, "Node:", el);
                try {
                  el.parentNode.removeChild(el);
                } catch (removeError) {
                  console.error("Failed to remove problematic KaTeX node:", removeError);
                }
              }
            });
            textForMarkdown = currentAnswerElement.innerHTML;
          } else {
            if (hasVisualContent && hasAccumulatedContent) {
              currentAnswerElement.innerHTML = "";
            } else if (!hasAccumulatedContent && hasVisualContent) {
              textForMarkdown = currentAnswerElement.innerHTML;
            }
          }
          if (textForMarkdown.trim().length === 0) {
          } else {
            const markdownHtml = marked.parse(textForMarkdown, {
              mangle: false,
              headerIds: false,
              gfm: true,
              breaks: true,
              sanitize: false
            });
            currentAnswerElement.innerHTML = markdownHtml;
            lastAppendedNode = null;
          }
          if (Object.keys(storedKatexNodes).length > 0) {
            const walker = document.createTreeWalker(currentAnswerElement, NodeFilter.SHOW_TEXT);
            let node;
            const textNodesContainingPlaceholders = [];
            while (node = walker.nextNode()) {
              if (node.nodeValue && node.nodeValue.includes(KATEX_PLACEHOLDER_PREFIX)) {
                textNodesContainingPlaceholders.push(node);
              }
            }
            textNodesContainingPlaceholders.forEach((textNode) => {
              let currentNodeValue = textNode.nodeValue;
              let parent = textNode.parentNode;
              if (!parent) return;
              let lastNodeInserted = textNode;
              for (const placeholder in storedKatexNodes) {
                if (currentNodeValue.includes(placeholder)) {
                  const parts = currentNodeValue.split(placeholder);
                  let firstPart = parts.shift();
                  if (firstPart) {
                    parent.insertBefore(document.createTextNode(firstPart), lastNodeInserted);
                  }
                  const katexNode = storedKatexNodes[placeholder].cloneNode(true);
                  parent.insertBefore(katexNode, lastNodeInserted);
                  currentNodeValue = parts.join(placeholder);
                }
              }
              if (currentNodeValue) {
                parent.insertBefore(document.createTextNode(currentNodeValue), lastNodeInserted);
              }
              parent.removeChild(lastNodeInserted);
            });
          } else {
          }
        } catch (error) {
          console.error("Error during final Markdown/KaTeX formatting:", error);
          addErrorMessage("Failed to perform final message formatting.");
          if (currentAnswerElement && accumulatedAnswerText.trim().length > 0) {
            console.warn("Attempting fallback to raw accumulated text due to formatting error.");
            currentAnswerElement.textContent = accumulatedAnswerText;
          }
        }
        accumulatedAnswerText = "";
      }
      function resetStreamingState() {
        currentProcessingMode = MODE_ANSWER;
        langBuffer = "";
        currentCodeBlockLang = "";
        currentCodeBlockElement = null;
        currentCodeBlockPreElement = null;
        katexBuffer = "";
        currentKatexMarkerId = null;
        thinkBuffer = "";
        tagBuffer = "";
        fenceBuffer = "";
        lastAppendedNode = null;
        thinkingRequestedForCurrentTurn = false;
      }
      function renderAndReplaceKatex(isDisplay, markerId) {
        if (!currentAnswerElement || !markerId || katexBuffer === null || katexBuffer === void 0) {
          console.error("[KaTeX Replace Marker] Error: Invalid state (element, markerId, or buffer). MarkerID:", markerId, "Buffer:", katexBuffer);
          if (markerId && currentAnswerElement) {
            try {
              const strayMarker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);
              if (strayMarker?.parentNode) strayMarker.parentNode.removeChild(strayMarker);
            } catch (e) {
              console.error("Error cleaning stray marker:", e);
            }
          }
          katexBuffer = "";
          return false;
        }
        const trimmedKatexBuffer = katexBuffer.trim();
        try {
          const stringToRender = trimmedKatexBuffer.length > 0 ? trimmedKatexBuffer : " ";
          const katexHtml = katex.renderToString(stringToRender, {
            displayMode: isDisplay,
            throwOnError: false,
            output: "html",
            strict: false
          });
          if (katexHtml.includes("katex-error") && trimmedKatexBuffer.length > 0) {
            console.warn(`[KaTeX Replace Marker] KaTeX reported a rendering error for buffer: "${trimmedKatexBuffer}". Marker ID: ${markerId}. Raw text will remain.`);
            try {
              const marker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);
              if (marker?.parentNode) marker.parentNode.removeChild(marker);
              else console.warn("Couldn't find marker to clean up after render error.");
            } catch (cleanupError) {
              console.error("Error during marker cleanup after render error:", cleanupError);
            }
            katexBuffer = "";
            return false;
          }
          const startMarker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);
          if (!startMarker) {
            console.error(`[KaTeX Replace Marker] Error: Cannot find start marker span with ID: ${markerId}. Aborting replacement. Content might be inconsistent.`);
            katexBuffer = "";
            return false;
          }
          if (!startMarker.parentNode) {
            console.error(`[KaTeX Replace Marker] Error: Start marker span with ID ${markerId} found but has no parent (already removed?). Aborting.`);
            katexBuffer = "";
            return false;
          }
          const parent = startMarker.parentNode;
          let nodesToRemove = [];
          let currentNode = startMarker.nextSibling;
          while (currentNode) {
            nodesToRemove.push(currentNode);
            if (nodesToRemove.length > 1e3) {
              console.error("[KaTeX Replace Marker] Error: Excessive node collection limit reached (1000). Aborting replacement.");
              try {
                parent.removeChild(startMarker);
              } catch (e) {
              }
              katexBuffer = "";
              return false;
            }
            currentNode = currentNode.nextSibling;
          }
          const katexSpan = document.createElement("span");
          katexSpan.setAttribute(KATEX_RENDERED_ATTR, "true");
          katexSpan.innerHTML = katexHtml;
          parent.insertBefore(katexSpan, startMarker);
          parent.removeChild(startMarker);
          nodesToRemove.forEach((node) => {
            if (node.parentNode === parent) {
              parent.removeChild(node);
            } else {
              console.warn("[KaTeX Replace Marker] Node parent changed or node removed unexpectedly during collection, skipping removal:", node);
            }
          });
          appendToAnswer(null, katexSpan);
          katexBuffer = "";
          return true;
        } catch (error) {
          console.error("[KaTeX Replace Marker] General error during marker-based replacement:", error);
          try {
            const marker = currentAnswerElement?.querySelector(`span[data-katex-start-id="${markerId}"]`);
            if (marker?.parentNode) marker.parentNode.removeChild(marker);
          } catch (cleanupError) {
            console.error("Error during marker cleanup after general error:", cleanupError);
          }
          katexBuffer = "";
          return false;
        }
      }
      function finalizeTurnOnErrorOrClose() {
        console.log("[DEBUG] finalizeTurnOnErrorOrClose called.");
        if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK && currentCodeBlockElement) {
          console.warn("Stream ended unexpectedly inside code block. Finalizing highlight.");
          try {
            finalizeCodeBlock(true);
          } catch (e) {
            console.error("Prism highlight error on close:", e);
          }
        }
        if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE || currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY || currentProcessingMode === MODE_MAYBE_START_DISPLAY_KATEX) {
          console.warn("Stream ended unexpectedly inside KaTeX block. Processing raw text.");
          if (currentKatexMarkerId) {
            renderAndReplaceKatex(currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY, currentKatexMarkerId);
            currentKatexMarkerId = null;
          }
        }
        if (currentProcessingMode === MODE_INSIDE_THINK || currentProcessingMode === MODE_MAYBE_END_THINK || currentProcessingMode === MODE_SEEKING_TAG) {
          console.warn("Stream ended unexpectedly inside/seeking Think tags. Finishing think buffer:", thinkBuffer);
          if (currentThinkingArea && currentThinkingArea.style.display !== "none" && currentThinkingPreElement) {
            appendRawTextToThinkingArea("\n--- (Stream ended unexpectedly during thinking) ---");
          }
        }
        formatAnswerBubbleFinal();
        resetStreamingState();
        setInputDisabledState(true);
      }
      function createCodeBlockStructure(language) {
        if (!currentCodeBlocksArea) {
          console.error("Code blocks area is null!");
          return;
        }
        codeBlockCounterThisTurn++;
        const currentCodeNumber = codeBlockCounterThisTurn;
        const blockId = `code-block-turn${currentTurnId}-${currentCodeNumber}`;
        const safeLanguage = (language || "").trim().toLowerCase() || "plain";
        const langAlias = {
          "python": "python",
          "py": "python",
          "javascript": "javascript",
          "js": "javascript",
          "html": "markup",
          "xml": "markup",
          "svg": "markup",
          "css": "css",
          "bash": "bash",
          "sh": "bash",
          "shell": "bash",
          "json": "json",
          "yaml": "yaml",
          "yml": "yaml",
          "markdown": "markdown",
          "md": "markdown",
          "sql": "sql",
          "java": "java",
          "c": "c",
          "cpp": "cpp",
          "c++": "cpp",
          "csharp": "csharp",
          "cs": "csharp",
          "go": "go",
          "rust": "rust",
          "php": "php",
          "ruby": "ruby",
          "rb": "ruby",
          "dockerfile": "docker",
          "docker": "docker",
          "typescript": "typescript",
          "ts": "typescript",
          "plaintext": "plain",
          "text": "plain"
        };
        const prismLang = langAlias[safeLanguage] || safeLanguage;
        const displayLang = safeLanguage;
        currentCodeBlockLang = prismLang;
        const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;
        const container = document.createElement("div");
        container.classList.add("code-block-container");
        container.id = blockId;
        container.dataset.language = safeLanguage;
        const codeHeader = document.createElement("div");
        codeHeader.classList.add("code-block-header");
        const codeButtonsDiv = document.createElement("div");
        codeButtonsDiv.classList.add("code-block-buttons");
        const runStopBtn = document.createElement("button");
        runStopBtn.classList.add("run-code-btn", "code-action-btn");
        runStopBtn.dataset.status = "idle";
        runStopBtn.innerHTML = playIconSvg;
        runStopBtn.title = "Run Code";
        const toggleCodeBtn = document.createElement("button");
        toggleCodeBtn.classList.add("toggle-code-btn", "code-action-btn");
        toggleCodeBtn.textContent = "Hide";
        toggleCodeBtn.title = "Show/Hide Code";
        const copyCodeBtn = document.createElement("button");
        copyCodeBtn.classList.add("copy-code-btn", "code-action-btn");
        copyCodeBtn.textContent = "Copy";
        copyCodeBtn.title = "Copy Code";
        codeButtonsDiv.appendChild(runStopBtn);
        codeButtonsDiv.appendChild(toggleCodeBtn);
        codeButtonsDiv.appendChild(copyCodeBtn);
        const codeTitle = document.createElement("span");
        codeTitle.classList.add("code-block-title");
        codeTitle.textContent = `Code ${currentCodeNumber} (${displayLang})`;
        codeTitle.style.flexGrow = "1";
        codeTitle.style.textAlign = "left";
        codeHeader.appendChild(codeButtonsDiv);
        codeHeader.appendChild(codeTitle);
        const preElement = document.createElement("pre");
        preElement.classList.add("manual");
        const codeElement = document.createElement("code");
        codeElement.className = `language-${prismLang}`;
        codeElement.setAttribute("contenteditable", "true");
        codeElement.setAttribute("spellcheck", "false");
        currentCodeBlockPreElement = preElement;
        currentCodeBlockElement = codeElement;
        const outputHeader = document.createElement("div");
        outputHeader.classList.add("code-output-header");
        outputHeader.style.display = "none";
        const outputButtonsDiv = document.createElement("div");
        outputButtonsDiv.classList.add("code-block-buttons");
        const placeholderSpan = document.createElement("span");
        placeholderSpan.classList.add("output-header-button-placeholder");
        outputButtonsDiv.appendChild(placeholderSpan);
        const toggleOutputBtn = document.createElement("button");
        toggleOutputBtn.classList.add("toggle-output-btn", "code-action-btn");
        toggleOutputBtn.textContent = "Hide";
        toggleOutputBtn.title = "Show/Hide Output";
        const copyOutputBtn = document.createElement("button");
        copyOutputBtn.classList.add("copy-output-btn", "code-action-btn");
        copyOutputBtn.textContent = "Copy";
        copyOutputBtn.title = "Copy Output";
        outputButtonsDiv.appendChild(toggleOutputBtn);
        outputButtonsDiv.appendChild(copyOutputBtn);
        const outputTitle = document.createElement("span");
        outputTitle.classList.add("output-header-title");
        outputTitle.textContent = `Output Code ${currentCodeNumber}`;
        const codeStatusSpan = document.createElement("span");
        codeStatusSpan.classList.add("code-status-span");
        codeStatusSpan.textContent = "Idle";
        outputHeader.appendChild(outputButtonsDiv);
        outputHeader.appendChild(outputTitle);
        outputHeader.appendChild(codeStatusSpan);
        const outputConsoleDiv = document.createElement("div");
        outputConsoleDiv.classList.add("code-output-console");
        outputConsoleDiv.style.display = "none";
        const outputPre = document.createElement("pre");
        outputConsoleDiv.appendChild(outputPre);
        preElement.appendChild(codeElement);
        container.appendChild(codeHeader);
        container.appendChild(preElement);
        container.appendChild(outputHeader);
        container.appendChild(outputConsoleDiv);
        toggleCodeBtn.addEventListener("click", () => {
          const isHidden = preElement.classList.toggle("hidden");
          toggleCodeBtn.textContent = isHidden ? "Show" : "Hide";
        });
        copyCodeBtn.addEventListener("click", async () => {
          if (!codeElement) return;
          try {
            await navigator.clipboard.writeText(codeElement.textContent || "");
            copyCodeBtn.textContent = "Copied!";
            copyCodeBtn.classList.add("copied");
            setTimeout(() => {
              copyCodeBtn.textContent = "Copy";
              copyCodeBtn.classList.remove("copied");
            }, 1500);
          } catch (err) {
            console.error("Failed to copy code: ", err);
            copyCodeBtn.textContent = "Error";
            setTimeout(() => {
              copyCodeBtn.textContent = "Copy";
            }, 1500);
          }
        });
        runStopBtn.addEventListener("click", handleRunStopCodeClick);
        const debouncedHighlight = debounce(() => {
          const savedPosition = getCursorPosition(codeElement);
          if (savedPosition === -1) {
            console.warn("Could not save cursor position or cursor not in element. Highlight may cause cursor jump.");
          }
          try {
            const currentText = codeElement.textContent;
            codeElement.innerHTML = "";
            codeElement.textContent = currentText;
            import_prismjs.default.highlightElement(codeElement);
            if (savedPosition !== -1) {
              setCursorPosition(codeElement, savedPosition);
            }
          } catch (e) {
            console.error("Error during debounced highlighting:", e);
            if (savedPosition !== -1) {
              setCursorPosition(codeElement, savedPosition);
            }
          }
        }, 500);
        codeElement.addEventListener("input", debouncedHighlight);
        codeElement.addEventListener("paste", (e) => {
          setTimeout(debouncedHighlight, 100);
        });
        toggleOutputBtn.addEventListener("click", () => {
          const isHidden = outputConsoleDiv.classList.toggle("hidden");
          toggleOutputBtn.textContent = isHidden ? "Show" : "Hide";
        });
        copyOutputBtn.addEventListener("click", async () => {
          if (!outputPre) return;
          try {
            await navigator.clipboard.writeText(outputPre.textContent || "");
            copyOutputBtn.textContent = "Copied!";
            copyOutputBtn.classList.add("copied");
            setTimeout(() => {
              copyOutputBtn.textContent = "Copy";
              copyOutputBtn.classList.remove("copied");
            }, 1500);
          } catch (err) {
            console.error("Failed to copy output: ", err);
            copyOutputBtn.textContent = "Error";
            setTimeout(() => {
              copyOutputBtn.textContent = "Copy";
            }, 1500);
          }
        });
        currentCodeBlocksArea.appendChild(container);
        lastAppendedNode = null;
      }
      async function handleRunStopCodeClick(event) {
        const button = event.currentTarget;
        const container = button.closest(".code-block-container");
        if (!container) return;
        const codeBlockId = container.id;
        const language = container.dataset.language;
        const codeElement = container.querySelector("code");
        const outputHeader = container.querySelector(".code-output-header");
        const outputConsoleDiv = container.querySelector(".code-output-console");
        const outputPre = outputConsoleDiv ? outputConsoleDiv.querySelector("pre") : null;
        const statusSpan = outputHeader ? outputHeader.querySelector(".code-status-span") : null;
        if (!language || !codeElement || !outputHeader || !outputConsoleDiv || !outputPre || !statusSpan) {
          console.error(`Missing elements for code block ${codeBlockId}`);
          addErrorMessage(`Cannot run code block ${codeBlockId}: Internal UI error.`);
          return;
        }
        const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;
        const stopIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><rect width="100" height="100" rx="15"/></svg>`;
        const stoppingIconSvg = `<svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: block;"><path d="M12 2V6M12 18V22M6 12H2M22 12H18M19.0711 4.92893L16.2426 7.75736M7.75736 16.2426L4.92893 19.0711M19.0711 19.0711L16.2426 16.2426M7.75736 7.75736L4.92893 4.92893" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
        const code = codeElement.textContent || "";
        const currentStatus = button.dataset.status;
        if (!websocket || websocket.readyState !== WebSocket.OPEN) {
          console.warn("WebSocket not open. Cannot run/stop code.");
          statusSpan.textContent = "Error: Disconnected";
          statusSpan.className = "code-status-span error";
          outputHeader.style.display = "flex";
          addErrorMessage("Cannot run/stop code: Not connected to server.");
          return;
        }
        if (currentStatus === "idle") {
          console.log(`Requesting run for block ${codeBlockId} (${language})`);
          button.dataset.status = "running";
          button.innerHTML = stopIconSvg;
          button.title = "Stop Execution";
          outputPre.innerHTML = "";
          outputHeader.style.display = "flex";
          outputConsoleDiv.style.display = "block";
          outputConsoleDiv.classList.remove("hidden");
          const toggleOutputBtn = outputHeader.querySelector(".toggle-output-btn");
          if (toggleOutputBtn) toggleOutputBtn.textContent = "Hide";
          statusSpan.textContent = "Running...";
          statusSpan.className = "code-status-span running";
          websocket.send(JSON.stringify({
            type: "run_code",
            payload: { code_block_id: codeBlockId, language, code }
          }));
        } else if (currentStatus === "running") {
          console.log(`Requesting stop for block ${codeBlockId}`);
          button.dataset.status = "stopping";
          button.innerHTML = stoppingIconSvg;
          button.title = "Stopping...";
          button.disabled = true;
          statusSpan.textContent = "Stopping...";
          statusSpan.className = "code-status-span stopping";
          websocket.send(JSON.stringify({
            type: "stop_code",
            payload: { code_block_id: codeBlockId }
          }));
        } else if (currentStatus === "stopping") {
          console.log(`Already stopping block ${codeBlockId}`);
        }
      }
      function addCodeOutput(outputPreElement, streamType, text2) {
        if (!outputPreElement || !text2) return;
        const span = document.createElement("span");
        span.classList.add(streamType === "stderr" ? "stderr-output" : "stdout-output");
        span.textContent = text2;
        outputPreElement.appendChild(span);
        outputPreElement.scrollTop = outputPreElement.scrollHeight;
      }
      function appendToCodeBlock(text2) {
        if (currentCodeBlockElement) {
          currentCodeBlockElement.appendChild(document.createTextNode(text2));
          if (currentCodeBlockPreElement && !currentCodeBlockPreElement.classList.contains("hidden")) {
            const isNearCodeBottom = currentCodeBlockPreElement.scrollHeight - currentCodeBlockPreElement.scrollTop - currentCodeBlockPreElement.clientHeight < 50;
            if (isNearCodeBottom) {
              requestAnimationFrame(() => {
                currentCodeBlockPreElement.scrollTop = currentCodeBlockPreElement.scrollHeight;
              });
            }
          }
        } else {
          console.error("Attempted to append to null code block element!");
        }
      }
      function appendToAnswer(text2 = null, node = null) {
        if (!currentAnswerElement) return;
        let isMeaningfulContent = text2 && text2.trim().length > 0 || node && node.nodeType !== Node.COMMENT_NODE && (!node.textContent || node.textContent.trim().length > 0);
        if (!firstAnswerTokenReceived && isMeaningfulContent) {
          if (currentAnswerElement.style.display === "none") {
            currentAnswerElement.style.display = "";
          }
          const loadingDots = currentAnswerElement.querySelector(".loading-dots");
          if (loadingDots) {
            loadingDots.remove();
          }
          firstAnswerTokenReceived = true;
        }
        if (node) {
          if (!node.classList || !node.classList.contains("loading-dots")) {
            currentAnswerElement.appendChild(node);
            lastAppendedNode = node;
          }
        } else if (text2 !== null && text2.length > 0) {
          accumulatedAnswerText += text2;
          if (lastAppendedNode && lastAppendedNode.nodeType === Node.TEXT_NODE && lastAppendedNode.parentNode === currentAnswerElement) {
            lastAppendedNode.nodeValue += text2;
          } else {
            const textNode = document.createTextNode(text2);
            currentAnswerElement.appendChild(textNode);
            lastAppendedNode = textNode;
          }
        }
      }
      function finalizeCodeBlock(isTruncated = false) {
        if (currentCodeBlockElement) {
          const blockId = currentCodeBlockElement.closest(".code-block-container")?.id;
          const langClass = currentCodeBlockElement.className;
          console.log(`[finalizeCodeBlock] Attempting highlight on element:`, currentCodeBlockElement);
          console.log(`[finalizeCodeBlock] Element class: ${langClass}`);
          console.log(`[finalizeCodeBlock] Prism.languages.python just before highlight:`, import_prismjs.default.languages.python);
          try {
            currentCodeBlockElement.normalize();
            import_prismjs.default.highlightElement(currentCodeBlockElement);
            console.log(`[finalizeCodeBlock] Highlighting finished successfully for ${blockId}.`);
          } catch (e) {
            console.error(`Prism highlight error on finalize (lang '${currentCodeBlockLang}'):`, e);
          }
        } else {
          console.warn("[finalizeCodeBlock] Called but currentCodeBlockElement is null.");
        }
        currentCodeBlockElement = null;
        currentCodeBlockPreElement = null;
        currentCodeBlockLang = "";
      }
      function resetAllCodeButtonsOnErrorOrClose() {
        console.log("Resetting all code run/stop buttons and statuses due to connection issue.");
        const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;
        document.querySelectorAll(".code-block-container").forEach((container) => {
          const button = container.querySelector(".run-code-btn");
          const outputHeader = container.querySelector(".code-output-header");
          const statusSpan = outputHeader ? outputHeader.querySelector(".code-status-span") : null;
          if (button && button.dataset.status !== "idle") {
            button.dataset.status = "idle";
            button.innerHTML = playIconSvg;
            button.title = "Run Code";
            button.disabled = false;
          }
          if (statusSpan) {
            if (!statusSpan.classList.contains("idle") && !statusSpan.classList.contains("success")) {
              if (outputHeader) outputHeader.style.display = "flex";
              statusSpan.textContent = "Error: Disconnected";
              statusSpan.className = "code-status-span error";
            }
          }
        });
      }
      function connectWebSocket() {
        const wsProtocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${wsProtocol}//${window.location.host}/ws/${clientId}`;
        console.log(`[DEBUG] Attempting to connect to WebSocket: ${wsUrl}`);
        const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;
        try {
          const ws = new WebSocket(wsUrl);
          console.log("connectWebSocket: Creating WebSocket object...");
          ws.onopen = (event) => {
            console.log("[DEBUG] WebSocket connection opened. ws object:", ws);
            websocket = ws;
            if (typeof addSystemMessage !== "function" || typeof setupNewAiTurn !== "function" || typeof appendToAnswer !== "function" || typeof formatAnswerBubbleFinal !== "function" || typeof resetStreamingState !== "function" || typeof setInputDisabledState !== "function") {
              console.error("CRITICAL ERROR: One or more required helper functions are not defined when ws.onopen is called. Check script order.");
              alert("Chat initialization failed. Please refresh the page. (Error: Helpers undefined)");
              setInputDisabledState(true);
              return;
            }
            setInputDisabledState(false);
            addSystemMessage("Connected to the chat server.");
            console.log("[DEBUG ws.onopen] Setting up initial AI turn for welcome message.");
            thinkingRequestedForCurrentTurn = false;
            setupNewAiTurn();
            const welcomeMessage = "Hello! How can I help you today?";
            appendToAnswer(welcomeMessage);
            formatAnswerBubbleFinal();
            console.log("[DEBUG ws.onopen] Resetting state after welcome message.");
            resetStreamingState();
            if (messageInput && messageInput.offsetParent !== null) messageInput.focus();
          };
          ws.onmessage = (event) => {
            let isJsonMessage = false;
            let messageData = null;
            try {
              if (typeof event.data === "string" && event.data.startsWith("{")) {
                messageData = JSON.parse(event.data);
                if (messageData && messageData.type && messageData.payload && messageData.payload.code_block_id) {
                  isJsonMessage = true;
                }
              }
            } catch (e) {
              isJsonMessage = false;
            }
            if (isJsonMessage) {
              const { type, payload } = messageData;
              const { code_block_id } = payload;
              const container = document.getElementById(code_block_id);
              if (!container) {
                console.warn(`Received message for unknown code block ID: ${code_block_id}`, payload);
                return;
              }
              const outputHeader = container.querySelector(".code-output-header");
              const outputConsoleDiv = container.querySelector(".code-output-console");
              const outputPre = outputConsoleDiv ? outputConsoleDiv.querySelector("pre") : null;
              const runStopBtn = container.querySelector(".run-code-btn");
              const statusSpan = outputHeader ? outputHeader.querySelector(".code-status-span") : null;
              if (!outputHeader || !outputPre || !runStopBtn || !statusSpan) {
                console.error(`Missing elements for code block ${code_block_id}. Cannot process message.`);
                return;
              }
              switch (type) {
                case "code_output":
                  const { stream, data } = payload;
                  if (outputHeader.style.display === "none") {
                    outputHeader.style.display = "flex";
                  }
                  if (outputConsoleDiv.style.display === "none") {
                    outputConsoleDiv.style.display = "block";
                    outputConsoleDiv.classList.remove("hidden");
                    const toggleOutputBtn = outputHeader.querySelector(".toggle-output-btn");
                    if (toggleOutputBtn) toggleOutputBtn.textContent = "Hide";
                  }
                  if (runStopBtn.dataset.status === "idle") {
                    const stopIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><rect width="100" height="100" rx="15"/></svg>`;
                    console.warn(`Received code output for ${code_block_id} while button was idle. Forcing state to running.`);
                    runStopBtn.dataset.status = "running";
                    runStopBtn.innerHTML = stopIconSvg;
                    runStopBtn.title = "Stop Execution";
                    runStopBtn.disabled = false;
                    statusSpan.textContent = "Running...";
                    statusSpan.className = "code-status-span running";
                  }
                  addCodeOutput(outputPre, stream, data);
                  break;
                case "code_finished":
                  if (outputHeader.style.display === "none") {
                    outputHeader.style.display = "flex";
                  }
                  if (outputConsoleDiv.style.display === "none") {
                    outputConsoleDiv.style.display = "block";
                    outputConsoleDiv.classList.remove("hidden");
                    const toggleOutputBtn = outputHeader.querySelector(".toggle-output-btn");
                    if (toggleOutputBtn) toggleOutputBtn.textContent = "Hide";
                  }
                  const { exit_code, error } = payload;
                  let finishMessage = "";
                  let statusClass = "";
                  if (error) {
                    if (error === "Execution stopped by user.") {
                      finishMessage = "Stopped";
                      statusClass = "stopped";
                    } else if (error.startsWith("Execution timed out")) {
                      finishMessage = "Timeout";
                      statusClass = "error";
                    } else {
                      finishMessage = `Error (${exit_code !== void 0 ? exit_code : "N/A"})`;
                      statusClass = "error";
                      console.error(`Execution error for ${code_block_id}:`, error);
                    }
                  } else {
                    finishMessage = `Finished (Exit: ${exit_code})`;
                    statusClass = exit_code === 0 ? "success" : "error";
                  }
                  statusSpan.textContent = finishMessage;
                  statusSpan.className = `code-status-span ${statusClass}`;
                  runStopBtn.dataset.status = "idle";
                  runStopBtn.innerHTML = playIconSvg;
                  runStopBtn.title = "Run Code";
                  runStopBtn.disabled = false;
                  break;
                default:
                  console.warn(`Received unknown code execution message type: ${type}`, payload);
              }
            } else {
              let chunk = event.data;
              const currentTurnIdForMsg = currentTurnId;
              if (chunk === "<EOS>") {
                console.log(`%c[ws.onmessage] Turn ${currentTurnIdForMsg}: Received <EOS>. Finalizing turn.`, "color: green; font-weight: bold;");
                if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK) {
                  console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received inside code block. Appending fence buffer and finalizing.`);
                  if (fenceBuffer.length > 0) appendToCodeBlock(fenceBuffer);
                  try {
                    finalizeCodeBlock(true);
                  } catch (e) {
                    console.error("Error finalizing code block on EOS:", e);
                  }
                } else if (currentProcessingMode === MODE_SEEKING_CODE_END_FENCE) {
                  console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received while seeking end fence. Treating '${fenceBuffer}' as code.`);
                  appendToCodeBlock(fenceBuffer);
                  finalizeCodeBlock(true);
                } else if (currentProcessingMode === MODE_SEEKING_CODE_LANGUAGE && langBuffer.length > 0) {
                  console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received while seeking language. Treating '${FENCE + langBuffer}' as text.`);
                  appendToAnswer(FENCE + langBuffer);
                } else if (currentProcessingMode === MODE_SEEKING_CODE_START_FENCE && fenceBuffer.length > 0) {
                  console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received while seeking start fence. Treating '${fenceBuffer}' as text.`);
                  appendToAnswer(fenceBuffer);
                } else if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE || currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY) {
                  console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received inside KaTeX buffer. Attempting render.`);
                  if (currentKatexMarkerId) {
                    renderAndReplaceKatex(currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY, currentKatexMarkerId);
                    currentKatexMarkerId = null;
                  }
                } else if (currentProcessingMode === MODE_INSIDE_THINK || currentProcessingMode === MODE_MAYBE_END_THINK || currentProcessingMode === MODE_SEEKING_TAG) {
                  console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly inside/seeking Think tags. Last mode: ${currentProcessingMode}`);
                  if (thinkingRequestedForCurrentTurn && currentThinkingArea && currentThinkingPreElement) {
                    appendRawTextToThinkingArea("\n--- (EOS received mid-think) ---");
                  }
                }
                formatAnswerBubbleFinal();
                resetStreamingState();
                setInputDisabledState(false);
                if (messageInput && messageInput.offsetParent !== null) {
                  messageInput.focus();
                }
                setTimeout(() => scrollToBottom("smooth"), 50);
                return;
              }
              if (chunk.startsWith("<ERROR>")) {
                const errorMessage = chunk.substring(7);
                console.error(`[ws.onmessage] Turn ${currentTurnIdForMsg}: Received <ERROR>:`, errorMessage);
                addErrorMessage(errorMessage);
                finalizeTurnOnErrorOrClose();
                resetAllCodeButtonsOnErrorOrClose();
                setTimeout(() => scrollToBottom("smooth"), 50);
                return;
              }
              if (chunk.length === 0) {
                return;
              }
              if (!currentAiTurnContainer) {
                if (chunk.trim().length > 0) {
                  console.warn(`%c[ws.onmessage] Turn ${currentTurnIdForMsg}: First non-empty chat chunk received, but turn container not set up? Forcing setup.`, "color: red; font-weight: bold;");
                  setupNewAiTurn();
                } else {
                  return;
                }
              }
              let currentPos = 0;
              while (currentPos < chunk.length) {
                const char = chunk[currentPos];
                let incrementPos = true;
                let previousMode = currentProcessingMode;
                if (char === "\\" && currentPos + 1 < chunk.length) {
                  const nextChar = chunk[currentPos + 1];
                  const escapableChars = "$`*\\<>";
                  if (escapableChars.includes(nextChar)) {
                    if (currentProcessingMode === MODE_INSIDE_THINK) {
                      appendRawTextToThinkingArea(nextChar);
                    } else if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE || currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY) {
                      katexBuffer += nextChar;
                      appendToAnswer(nextChar);
                    } else if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK) {
                      appendToCodeBlock(nextChar);
                    } else {
                      appendToAnswer(nextChar);
                    }
                    currentPos += 2;
                    incrementPos = false;
                    continue;
                  }
                }
                switch (currentProcessingMode) {
                  case MODE_ANSWER:
                    if (char === FENCE[0]) {
                      if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) {
                        appendToAnswer("$");
                      }
                      katexBuffer = "";
                      currentKatexMarkerId = null;
                      fenceBuffer = char;
                      currentProcessingMode = MODE_SEEKING_CODE_START_FENCE;
                    } else if (char === "$") {
                      if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) {
                        appendToAnswer("$");
                      }
                      currentProcessingMode = MODE_MAYBE_START_DISPLAY_KATEX;
                    } else if (char === "<") {
                      if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) {
                        appendToAnswer("$");
                      }
                      tagBuffer = char;
                      currentProcessingMode = MODE_SEEKING_TAG;
                    } else {
                      if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) {
                        appendToAnswer("$");
                      }
                      appendToAnswer(char);
                    }
                    break;
                  case MODE_SEEKING_CODE_START_FENCE:
                    if (char === FENCE[fenceBuffer.length]) {
                      fenceBuffer += char;
                      if (fenceBuffer === FENCE) {
                        fenceBuffer = "";
                        langBuffer = "";
                        currentProcessingMode = MODE_SEEKING_CODE_LANGUAGE;
                      }
                    } else {
                      appendToAnswer(fenceBuffer);
                      fenceBuffer = "";
                      currentProcessingMode = MODE_ANSWER;
                      incrementPos = false;
                    }
                    break;
                  case MODE_SEEKING_CODE_LANGUAGE:
                    if (char === "\n") {
                      currentCodeBlockLang = langBuffer.trim();
                      createCodeBlockStructure(currentCodeBlockLang);
                      appendCodeReference();
                      langBuffer = "";
                      currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                    } else if (langBuffer.length > 50) {
                      console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: Code language line too long. Treating as text.`);
                      appendToAnswer(FENCE + langBuffer + char);
                      langBuffer = "";
                      fenceBuffer = "";
                      currentProcessingMode = MODE_ANSWER;
                    } else {
                      langBuffer += char;
                    }
                    break;
                  case MODE_INSIDE_CODE_BLOCK:
                    if (char === FENCE[0]) {
                      fenceBuffer = char;
                      currentProcessingMode = MODE_SEEKING_CODE_END_FENCE;
                    } else {
                      appendToCodeBlock(char);
                    }
                    break;
                  case MODE_SEEKING_CODE_END_FENCE:
                    if (char === FENCE[fenceBuffer.length]) {
                      fenceBuffer += char;
                      if (fenceBuffer === FENCE) {
                        finalizeCodeBlock();
                        fenceBuffer = "";
                        currentProcessingMode = MODE_ANSWER;
                        lastAppendedNode = null;
                        if (currentPos + 1 < chunk.length && chunk[currentPos + 1] === "\n") {
                          currentPos++;
                          incrementPos = true;
                        }
                      }
                    } else {
                      appendToCodeBlock(fenceBuffer);
                      fenceBuffer = "";
                      currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                      incrementPos = false;
                    }
                    break;
                  case MODE_MAYBE_START_DISPLAY_KATEX:
                    if (char === "$") {
                      currentKatexMarkerId = `katex-marker-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
                      const startMarkerDisp = document.createElement("span");
                      startMarkerDisp.setAttribute("data-katex-start-id", currentKatexMarkerId);
                      startMarkerDisp.style.display = "none";
                      appendToAnswer(null, startMarkerDisp);
                      appendToAnswer("$$");
                      currentProcessingMode = MODE_KATEX_BUFFERING_DISPLAY;
                      katexBuffer = "";
                    } else {
                      currentKatexMarkerId = `katex-marker-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
                      const startMarkerInline = document.createElement("span");
                      startMarkerInline.setAttribute("data-katex-start-id", currentKatexMarkerId);
                      startMarkerInline.style.display = "none";
                      appendToAnswer(null, startMarkerInline);
                      appendToAnswer("$");
                      appendToAnswer(char);
                      currentProcessingMode = MODE_KATEX_BUFFERING_INLINE;
                      katexBuffer = char;
                    }
                    break;
                  case MODE_KATEX_BUFFERING_INLINE:
                    if (char === "$") {
                      appendToAnswer("$");
                      if (currentKatexMarkerId) {
                        renderAndReplaceKatex(false, currentKatexMarkerId);
                        currentKatexMarkerId = null;
                      } else {
                        console.error(`Attempted end inline KaTeX Turn ${currentTurnIdForMsg} no marker ID!`);
                      }
                      currentProcessingMode = MODE_ANSWER;
                    } else {
                      katexBuffer += char;
                      appendToAnswer(char);
                    }
                    break;
                  case MODE_KATEX_BUFFERING_DISPLAY:
                    if (char === "$" && currentPos + 1 < chunk.length && chunk[currentPos + 1] === "$") {
                      appendToAnswer("$$");
                      if (currentKatexMarkerId) {
                        renderAndReplaceKatex(true, currentKatexMarkerId);
                        currentKatexMarkerId = null;
                      } else {
                        console.error(`Attempted end display KaTeX Turn ${currentTurnIdForMsg} no marker ID!`);
                      }
                      currentProcessingMode = MODE_ANSWER;
                      currentPos++;
                    } else {
                      katexBuffer += char;
                      appendToAnswer(char);
                    }
                    break;
                  case MODE_SEEKING_TAG:
                    tagBuffer += char;
                    const lowerTag = tagBuffer.toLowerCase();
                    if (lowerTag === THINK_START_TAG) {
                      thinkBuffer = "";
                      currentProcessingMode = MODE_INSIDE_THINK;
                      tagBuffer = "";
                      lastAppendedNode = null;
                    } else if (THINK_START_TAG.startsWith(lowerTag)) {
                    } else {
                      appendToAnswer(tagBuffer);
                      currentProcessingMode = MODE_ANSWER;
                      tagBuffer = "";
                      incrementPos = false;
                    }
                    if (tagBuffer.length > 20) {
                      console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: Tag buffer excessive, treating as text: ${tagBuffer}`);
                      appendToAnswer(tagBuffer);
                      currentProcessingMode = MODE_ANSWER;
                      tagBuffer = "";
                      incrementPos = false;
                    }
                    break;
                  case MODE_INSIDE_THINK:
                    if (char === "<") {
                      tagBuffer = char;
                      currentProcessingMode = MODE_MAYBE_END_THINK;
                    } else {
                      appendRawTextToThinkingArea(char);
                    }
                    break;
                  case MODE_MAYBE_END_THINK:
                    tagBuffer += char;
                    const lowerEndTag = tagBuffer.toLowerCase();
                    if (lowerEndTag === THINK_END_TAG) {
                      thinkBuffer = "";
                      tagBuffer = "";
                      currentProcessingMode = MODE_ANSWER;
                      lastAppendedNode = null;
                    } else if (THINK_END_TAG.startsWith(lowerEndTag)) {
                    } else {
                      appendRawTextToThinkingArea(tagBuffer);
                      currentProcessingMode = MODE_INSIDE_THINK;
                      tagBuffer = "";
                      incrementPos = false;
                    }
                    if (tagBuffer.length > 20) {
                      console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: End tag buffer excessive, treating as think text: ${tagBuffer}`);
                      appendRawTextToThinkingArea(tagBuffer);
                      currentProcessingMode = MODE_INSIDE_THINK;
                      tagBuffer = "";
                      incrementPos = false;
                    }
                    break;
                  default:
                    console.error(`Unknown processing mode: ${currentProcessingMode} in Turn ${currentTurnIdForMsg}`);
                    appendToAnswer(char);
                    currentProcessingMode = MODE_ANSWER;
                }
                if (incrementPos) {
                  currentPos++;
                }
              }
              scrollToBottom();
            }
          };
          ws.onerror = (event) => {
            console.error("WebSocket error observed:", event);
            addErrorMessage("WebSocket connection error. Please check the server or try refreshing. See console for details.");
            finalizeTurnOnErrorOrClose();
            resetAllCodeButtonsOnErrorOrClose();
            setInputDisabledState(true);
          };
          ws.onclose = (event) => {
            console.log("WebSocket connection closed.", event);
            addSystemMessage(`Connection closed: ${event.reason || "Normal closure"} (Code: ${event.code})`);
            finalizeTurnOnErrorOrClose();
            resetAllCodeButtonsOnErrorOrClose();
            if (event.code !== 1e3 && event.code !== 1005) {
              console.log("Unexpected WebSocket closure. Attempting to reconnect WebSocket in 3 seconds...");
              addSystemMessage("Attempting to reconnect...");
              setInputDisabledState(true);
              setTimeout(() => {
                websocket = null;
                resetStreamingState();
                currentAiTurnContainer = null;
                connectWebSocket();
              }, 3e3);
            } else {
              setInputDisabledState(true);
            }
          };
          console.log("[DEBUG] WebSocket object created and handlers assigned.");
        } catch (error) {
          console.error("[DEBUG] CRITICAL Error creating WebSocket object:", error);
          if (typeof addErrorMessage === "function") {
            addErrorMessage(`WebSocket Creation Error: ${error.message}. Please check server and refresh.`);
          } else {
            alert(`WebSocket Creation Error: ${error.message}. Please check server and refresh.`);
          }
          setInputDisabledState(true);
        }
      }
      if (chatForm) {
        chatForm.addEventListener("submit", (event) => {
          event.preventDefault();
          const userMessage = messageInput.value.trim();
          if (!userMessage) {
            return;
          }
          if (!websocket || websocket.readyState !== WebSocket.OPEN) {
            console.warn("[Submit] WebSocket not ready or not defined. State:", websocket?.readyState);
            addErrorMessage("Not connected to the server. Please wait or refresh.");
            return;
          }
          try {
            addUserMessage(userMessage);
            thinkingRequestedForCurrentTurn = thinkCheckbox ? thinkCheckbox.checked : false;
            let messageToSend = userMessage;
            if (!thinkingRequestedForCurrentTurn) {
              messageToSend = NO_THINK_PREFIX + userMessage;
            } else {
            }
            setupNewAiTurn();
            websocket.send(messageToSend);
            messageInput.value = "";
            setInputDisabledState(true);
          } catch (sendError) {
            console.error("[Submit] !!! ERROR during send attempt or post-send steps:", sendError);
            addErrorMessage(`Failed to send message: ${sendError.message}`);
          }
        });
      } else {
        console.error("CRITICAL ERROR: Could not find chat form element with ID 'chat-form'. Messages cannot be sent.");
        if (typeof addErrorMessage === "function") {
          addErrorMessage("Initialization Error: Chat input form not found.");
        } else {
          alert("Initialization Error: Chat input form not found.");
        }
      }
      setInputDisabledState(true);
      marked.setOptions({
        gfm: true,
        breaks: true,
        sanitize: false,
        smartLists: true,
        smartypants: false
      });
      connectWebSocket();
    }
  });
  require_script();
})();
/*! Bundled license information:

prismjs/prism.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)
*/
//# sourceMappingURL=script.js.map


