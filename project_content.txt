=== Project Directory Structure ===
Root: C:\Users\developer\Documents\repositories\cellmaxtechnologies\scripts\local-llm\ollama-web-chat
Relevant files and folders (excluding specified patterns):

.
├── Readme.md
├── project_content.txt
├── pyproject.toml
├── temp.js
├── temp.py
├── write_project_content_to_file.py
app/
├── __init__.py
├── config.py
├── docker_utils.py
├── llm.py
├── main.py
├── state.py
├── utils.py
├── static/
│   ├── index.html
│   ├── script.js
│   ├── style.css
│   ├── temp.css
│   ├── temp.js


=== File Contents ===

=== Readme.md ===
Readme


=== project_content.txt ===


=== pyproject.toml ===
[tool.poetry]
name = "ollama-web-chat"
version = "0.1.0"
description = "Web chat interface for Ollama using FastAPI and LangChain"
authors = ["Your Name <you@example.com>"]
readme = "README.md" # Optional README
packages = [
    { include = "app" },
]

[tool.poetry.dependencies]
python = "^3.9" # Adjust Python version if needed
fastapi = "^0.110.0"
uvicorn = {extras = ["standard"], version = "^0.29.0"}

# Let Poetry resolve the latest compatible LangChain versions
# Using "*" allows any version, but be aware this might pull in breaking changes in the future.
langchain = "*"
langchain-ollama = "*"
langchain-core = "*"
langchain-community = "*"
langchain-text-splitters = "*"

# Other dependencies
websockets = "^12.0" # Required by FastAPI for WebSockets
python-dotenv = "^1.0.1" # For optional .env file
aiofiles = "^23.2.1" # For serving static files asynchronously
docker = "^7.1.0"

[tool.poetry.scripts]
app = "app.main:start_server" # Command to run the app

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"



=== temp.js ===
// --- DOM Elements ---
const chatHistory = document.getElementById('chat-history');
const chatForm = document.getElementById('chat-form');
const messageInput = document.getElementById('message-input');
const sendButton = document.getElementById('send-button');
const thinkCheckbox = document.getElementById('think-checkbox'); // Restored

// --- WebSocket & Client ID ---
let websocket;
const clientId = `web-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
let currentTurnId = 0; // Simple counter for unique IDs per turn

// --- State Machine Modes ---
const MODE_ANSWER = 'MODE_ANSWER';
const MODE_SEEKING_CODE_START_FENCE = 'MODE_SEEKING_CODE_START_FENCE'; // Looking for ```
const MODE_SEEKING_CODE_LANGUAGE = 'MODE_SEEKING_CODE_LANGUAGE';     // Reading language after ```
const MODE_INSIDE_CODE_BLOCK = 'MODE_INSIDE_CODE_BLOCK';        // Inside the code block
const MODE_SEEKING_CODE_END_FENCE = 'MODE_SEEKING_CODE_END_FENCE';   // Found potential closing ```

// --- State Variables ---
let currentProcessingMode = MODE_ANSWER;
let fenceBuffer = '';             // Buffer for detecting ``` fences
let langBuffer = '';              // Buffer for language string
let codeBuffer = '';              // Buffer for code content within a block
let currentCodeBlockLang = '';    // Detected language for the current block
let currentCodeBlockElement = null; // The <code> element being filled
let currentCodeBlockPreElement = null; // The <pre> element wrapping the code
let currentAiTurnContainer = null;  // The main container for the AI bubble + its code blocks
let currentAnswerElement = null;    // The div.ai-message bubble
let currentCodeBlocksArea = null; // The div below bubble holding code blocks
let codeBlockCounterThisTurn = 0; // Counter for code blocks within the *current* AI turn
let thinkingRequestedForCurrentTurn = false; // Restored
let isFirstContentChunkForTurn = true;

// --- Constants ---
const FENCE = '```';

// --- Helper Functions ---

function scrollToBottom() {
    // Adding a small delay can sometimes help ensure scrolling happens after render
    setTimeout(() => {
        chatHistory.scrollTo({ top: chatHistory.scrollHeight, behavior: 'smooth' });
    }, 50);
}

function addUserMessage(text) {
    const messageElement = document.createElement('div');
    messageElement.classList.add('message', 'user-message');
    messageElement.textContent = text;
    chatHistory.appendChild(messageElement);
    scrollToBottom();
}

function addSystemMessage(text) {
     const messageElement = document.createElement('div');
     messageElement.classList.add('system-message');
     messageElement.textContent = text;
     chatHistory.appendChild(messageElement);
     scrollToBottom();
}

function addErrorMessage(text) {
     console.error("[UI ERROR] ", text);
     const messageElement = document.createElement('div');
     messageElement.classList.add('error-message'); // Use error styling
     messageElement.textContent = `Error: ${text}`;
     if(currentAiTurnContainer) {
         currentAiTurnContainer.appendChild(messageElement); // Append error within the turn container
     } else {
         chatHistory.appendChild(messageElement); // Fallback if no turn container exists
     }
     scrollToBottom();
}

function setInputDisabledState(disabled) {
    messageInput.disabled = disabled;
    sendButton.disabled = disabled;
    if (thinkCheckbox) {
        thinkCheckbox.disabled = disabled;
    }
}

function finalizeTurnOnErrorOrClose() {
    console.log("[DEBUG] finalizeTurnOnErrorOrClose called.");
    if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK && currentCodeBlockElement) {
        console.warn("Stream ended unexpectedly inside a code block.");
        try {
            Prism.highlightElement(currentCodeBlockElement);
        } catch (e) { console.error("Prism highlighting error on incomplete block:", e); }
    }
    resetStreamingState();
    setInputDisabledState(true); // Disable input on error/close
}

function resetStreamingState() {
    console.log("[DEBUG] Resetting streaming state.");
    currentProcessingMode = MODE_ANSWER;
    fenceBuffer = '';
    langBuffer = '';
    codeBuffer = '';
    currentCodeBlockLang = '';
    currentCodeBlockElement = null;
    currentCodeBlockPreElement = null;
    // Note: Turn-specific elements (currentAiTurnContainer, etc.) are managed by setupNewAiTurn
}

function setupNewAiTurn() {
    currentTurnId++;
    codeBlockCounterThisTurn = 0; // Reset code block counter
    isFirstContentChunkForTurn = true; // <<< Reset the flag for the new turn

    currentAiTurnContainer = document.createElement('div');
    currentAiTurnContainer.classList.add('ai-turn-container');
    currentAiTurnContainer.dataset.turnId = currentTurnId;

    currentAnswerElement = document.createElement('div');
    currentAnswerElement.classList.add('message', 'ai-message');
    currentAiTurnContainer.appendChild(currentAnswerElement);

    currentCodeBlocksArea = document.createElement('div');
    currentCodeBlocksArea.classList.add('code-blocks-area');
    currentAiTurnContainer.appendChild(currentCodeBlocksArea);

    chatHistory.appendChild(currentAiTurnContainer);
}

function appendToAnswerBubble(text) {
    if (!currentAnswerElement) {
        console.error("Attempted to append to null answer bubble!");
        // Attempt recovery only if there's actual text content
        if (text.trim().length === 0) return; // Don't try to recover for whitespace only

        if (currentAiTurnContainer && !currentAiTurnContainer.querySelector('.ai-message')) {
             currentAnswerElement = document.createElement('div');
             currentAnswerElement.classList.add('message', 'ai-message');
             currentAiTurnContainer.insertBefore(currentAnswerElement, currentCodeBlocksArea);
        } else if (currentAiTurnContainer) {
             currentAnswerElement = currentAiTurnContainer.querySelector('.ai-message');
             if(!currentAnswerElement) {
                console.error("CRITICAL: Cannot find or create answer bubble in turn container.");
                return;
             }
        } else {
            console.error("CRITICAL: No turn container to recover answer bubble.");
            return;
        }
    }

    // <<< START: Added Leading Whitespace Trim Logic >>>
    let processedText = text;
    if (isFirstContentChunkForTurn) {
        processedText = text.trimStart(); // Remove leading whitespace ONLY for the first chunk
        // Only set flag to false if we actually processed non-empty text after trimming
        if (processedText.length > 0) {
             isFirstContentChunkForTurn = false;
        }
    }
    // <<< END: Added Leading Whitespace Trim Logic >>>

    // Append text content only if there is something left after trimming
    if (processedText.length > 0) {
        currentAnswerElement.appendChild(document.createTextNode(processedText));
    }
}


function appendCodeReference() {
    if (!currentAnswerElement) {
        console.error("Attempted to append code reference to null answer bubble!");
        return;
    }
    codeBlockCounterThisTurn++;
    const refSpan = document.createElement('span');
    refSpan.classList.add('code-reference');
    refSpan.textContent = `[Code ${codeBlockCounterThisTurn}]`;
    currentAnswerElement.appendChild(refSpan); // Append the span node
}

function createCodeBlockStructure(language) {
    if (!currentCodeBlocksArea) {
        console.error("Attempted to create code block in null area!");
        return;
    }

    const blockId = `code-block-turn${currentTurnId}-${codeBlockCounterThisTurn}`;
    // Normalize language: lowercase, trim, default 'plain', handle potential null/undefined
    const safeLanguage = (language || '').trim().toLowerCase() || 'plain';
    // Alias common variations
    const langAlias = {
        'python': 'python', 'py': 'python',
        'javascript': 'javascript', 'js': 'javascript',
        'html': 'markup', 'xml': 'markup', 'svg': 'markup', // Prism uses 'markup' for HTML/XML
        'css': 'css',
        'bash': 'bash', 'shell': 'bash',
        'java': 'java',
        'csharp': 'csharp', 'cs': 'csharp',
        'cpp': 'cpp', 'c++': 'cpp',
        'ruby': 'ruby', 'rb': 'ruby',
        'go': 'go',
        'php': 'php',
        'json': 'json',
        'yaml': 'yaml', 'yml': 'yaml',
        'sql': 'sql',
        'markdown': 'markdown', 'md': 'markdown'
    };
    const prismLang = langAlias[safeLanguage] || safeLanguage; // Use alias or original safe name
    const displayLang = safeLanguage; // Show the user what they typed (or 'plain')


    const container = document.createElement('div');
    container.classList.add('code-block-container');
    container.id = blockId;

    const header = document.createElement('div');
    header.classList.add('code-block-header');

    const title = document.createElement('span');
    title.textContent = `Code ${codeBlockCounterThisTurn} (${displayLang})`;

    const buttonsDiv = document.createElement('div');
    const toggleBtn = document.createElement('button');
    toggleBtn.classList.add('toggle-code-btn');
    toggleBtn.textContent = 'Show'; // Default text
    const copyBtn = document.createElement('button');
    copyBtn.classList.add('copy-code-btn');
    copyBtn.textContent = 'Copy';

    buttonsDiv.appendChild(toggleBtn);
    buttonsDiv.appendChild(copyBtn);

    // Append buttons first, then title
    header.appendChild(buttonsDiv);
    header.appendChild(title);

    // Create pre/code elements but store references locally for listeners
    const preElement = document.createElement('pre');
    const codeElement = document.createElement('code');
    codeElement.classList.add(`language-${prismLang}`);
    preElement.classList.add('hidden'); // Add hidden class by default

    // Assign references for streaming
    currentCodeBlockPreElement = preElement;
    currentCodeBlockElement = codeElement; // This global ref is used *during* streaming

    preElement.appendChild(codeElement);
    container.appendChild(header);
    container.appendChild(preElement);

    // --- Event Listeners ---

    toggleBtn.addEventListener('click', () => {
        // Find the pre element relative to the button clicked
        const containerDiv = toggleBtn.closest('.code-block-container');
        const preToToggle = containerDiv?.querySelector('pre');
        if (preToToggle) {
            const isHidden = preToToggle.classList.toggle('hidden');
            toggleBtn.textContent = isHidden ? 'Show' : 'Hide'; // Toggle text
        }
    });

    copyBtn.addEventListener('click', () => {
        // <<< START: Updated Copy Logic >>>
        // Find the specific container and code element relative to *this* button
        const containerDiv = copyBtn.closest('.code-block-container');
        const codeElementToCopy = containerDiv?.querySelector('pre > code');

        if (!codeElementToCopy) {
            console.error('Could not find code element to copy for button:', copyBtn);
            copyBtn.textContent = 'Error!';
             setTimeout(() => { copyBtn.textContent = 'Copy'; }, 1500);
            return; // Exit if element not found
        }

        const codeContent = codeElementToCopy.textContent;
        navigator.clipboard.writeText(codeContent).then(() => {
            copyBtn.textContent = 'Copied!';
            copyBtn.classList.add('copied'); // Add class for potential styling feedback
            setTimeout(() => {
                // Check if the text is still 'Copied!' before resetting
                // (prevents flicker if user clicks multiple times quickly)
                if (copyBtn.textContent === 'Copied!') {
                    copyBtn.textContent = 'Copy';
                    copyBtn.classList.remove('copied');
                }
            }, 1500); // Reset after 1.5 seconds
        }).catch(err => {
            console.error('Failed to copy code: ', err);
            copyBtn.textContent = 'Error!';
             // Remove copied class if it was somehow added
            copyBtn.classList.remove('copied');
            setTimeout(() => {
                 if (copyBtn.textContent === 'Error!') {
                    copyBtn.textContent = 'Copy';
                 }
            }, 1500); // Reset after 1.5 seconds
        });
        // <<< END: Updated Copy Logic >>>
    });

    currentCodeBlocksArea.appendChild(container);
}

function appendToCodeBlock(text) {
    if (currentCodeBlockElement) {
        // Append text content to the <code> element
         currentCodeBlockElement.appendChild(document.createTextNode(text));
    } else {
        console.error("Attempted to append to null code block element!");
    }
}

function finalizeCodeBlock() {
    if (currentCodeBlockElement) {
        try {
            // Highlight the completed block using Prism
            Prism.highlightElement(currentCodeBlockElement);
            console.log(`[DEBUG] Highlighted code block ${codeBlockCounterThisTurn} (lang: ${currentCodeBlockLang})`);
            // Optional: Add line numbers if plugin is active
            // if (currentCodeBlockPreElement.classList.contains('line-numbers')) {
            //     Prism.plugins.lineNumbers.resize(currentCodeBlockPreElement);
            // }
        } catch (e) {
            console.error(`Prism highlighting error for lang '${currentCodeBlockLang}':`, e);
            // Add a class indicating error?
             currentCodeBlockElement.classList.add('prism-highlight-error');
        }
    }
    // Reset code block specific state
    currentCodeBlockElement = null;
    currentCodeBlockPreElement = null;
    currentCodeBlockLang = '';
    codeBuffer = ''; // Clear code buffer
}

// --- WebSocket Connection ---
function connectWebSocket() {
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${window.location.host}/ws/${clientId}`;
    console.log(`[DEBUG] Attempting to connect to WebSocket: ${wsUrl}`);

    try {
        const ws = new WebSocket(wsUrl);

        ws.onopen = (event) => {
            console.log("[DEBUG] WebSocket connection opened");
            websocket = ws;
            setInputDisabledState(false); // Enable inputs
            addSystemMessage("Connected to the chat server.");
            // Add initial AI message
            setupNewAiTurn();
            appendToAnswerBubble("AI: Hello! How can I help you today?");
            resetStreamingState(); // Reset state machine after initial message

            if(messageInput.offsetParent !== null) messageInput.focus();
        };

        ws.onmessage = (event) => {
            let chunk = event.data;

            // --- Handle Control Messages First ---
            if (chunk === "<EOS>") {
                console.log("[DEBUG] Received <EOS>. Finalizing turn.");
                 // If ended inside a code block, finalize it
                 if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK) {
                    finalizeCodeBlock();
                } else if (currentProcessingMode === MODE_SEEKING_CODE_END_FENCE && fenceBuffer.length > 0) {
                    // Ended while seeking end fence, treat buffer as regular text
                    appendToAnswerBubble(fenceBuffer);
                 } else if (currentProcessingMode === MODE_SEEKING_CODE_LANGUAGE && langBuffer.length > 0) {
                     // Ended while seeking language, treat as regular text
                    appendToAnswerBubble(FENCE + langBuffer);
                 } else if (currentProcessingMode === MODE_SEEKING_CODE_START_FENCE && fenceBuffer.length > 0) {
                     // Ended while seeking start fence, treat as regular text
                    appendToAnswerBubble(fenceBuffer);
                 }

                resetStreamingState();
                setInputDisabledState(false); // Re-enable inputs
                if(messageInput.offsetParent !== null) messageInput.focus();
                scrollToBottom();
                return; // End processing for this message
            }
            if (chunk.startsWith("<ERROR>")) {
                const errorMessage = chunk.substring(7);
                console.error("[DEBUG] Received <ERROR>:", errorMessage);
                addErrorMessage(errorMessage);
                finalizeTurnOnErrorOrClose(); // Disables input
                scrollToBottom();
                return; // End processing for this message
            }

            // <<< --- START: Tag Filtering --- >>>
            // Remove <think> and </think> tags and any surrounding whitespace globally
            chunk = chunk.replace(/\s*<think>\s*/g, '').replace(/\s*<\/think>\s*/g, '');
            // If the chunk becomes empty after filtering, skip further processing for this chunk
            if (chunk.length === 0) {
                return;
            }
            // <<< --- END: Tag Filtering --- >>>


            // Ensure AI turn container exists (should be set up by setupNewAiTurn)
             if (!currentAiTurnContainer) {
                 console.error("CRITICAL: No AI turn container set up before message chunk received!");
                 // Attempt recovery only if chunk contains non-whitespace content after filtering
                 if (chunk.trim().length > 0) {
                    setupNewAiTurn();
                 } else {
                    return; // Don't set up turn for empty/whitespace-only chunks
                 }
            }

            // --- State Machine Processing ---
            let currentPos = 0;
            while (currentPos < chunk.length) {
                const char = chunk[currentPos];
                let incrementPos = true;

                switch (currentProcessingMode) {
                    case MODE_ANSWER:
                        if (char === FENCE[0]) {
                            fenceBuffer = char;
                            currentProcessingMode = MODE_SEEKING_CODE_START_FENCE;
                        } else {
                            appendToAnswerBubble(char);
                        }
                        break;

                    case MODE_SEEKING_CODE_START_FENCE:
                        if (char === FENCE[fenceBuffer.length]) {
                            fenceBuffer += char;
                            if (fenceBuffer === FENCE) {
                                console.log("[DEBUG] Found ``` start fence.");
                                fenceBuffer = '';
                                langBuffer = '';
                                currentProcessingMode = MODE_SEEKING_CODE_LANGUAGE;
                            }
                        } else {
                            appendToAnswerBubble(fenceBuffer + char);
                            fenceBuffer = '';
                            currentProcessingMode = MODE_ANSWER;
                        }
                        break;

                    case MODE_SEEKING_CODE_LANGUAGE:
                        if (char === '\n') {
                            console.log(`[DEBUG] Found language line: '${langBuffer}'`);
                            currentCodeBlockLang = langBuffer; // Keep raw lang buffer for createCodeBlockStructure
                            appendCodeReference();
                            createCodeBlockStructure(currentCodeBlockLang); // Handles normalization/aliasing
                            langBuffer = '';
                            codeBuffer = '';
                            currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                        } else if (langBuffer.length > 50) { // Prevent runaway language buffer
                             console.warn("Language line too long, assuming no language.");
                             appendToAnswerBubble(FENCE + langBuffer + char); // Treat as text
                             langBuffer = '';
                             fenceBuffer = '';
                             currentProcessingMode = MODE_ANSWER;
                        } else {
                            langBuffer += char;
                        }
                        break;

                    case MODE_INSIDE_CODE_BLOCK:
                        if (char === FENCE[0]) {
                            fenceBuffer = char;
                            currentProcessingMode = MODE_SEEKING_CODE_END_FENCE;
                        } else {
                            appendToCodeBlock(char);
                        }
                        break;

                    case MODE_SEEKING_CODE_END_FENCE:
                        if (char === FENCE[fenceBuffer.length]) {
                            fenceBuffer += char;
                            if (fenceBuffer === FENCE) {
                                console.log("[DEBUG] Found ``` end fence.");
                                // Check for immediate newline after fence, common pattern
                                if (currentPos + 1 < chunk.length && chunk[currentPos + 1] === '\n') {
                                     currentPos++; // Consume the newline
                                } else {
                                     // If next char is not newline, maybe check later chunks?
                                     // For simplicity, we'll just finalize here.
                                }
                                finalizeCodeBlock();
                                fenceBuffer = '';
                                currentProcessingMode = MODE_ANSWER;
                            }
                        } else {
                            appendToCodeBlock(fenceBuffer + char);
                            fenceBuffer = '';
                            currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                        }
                        break;

                    default:
                        console.error("Unknown processing mode:", currentProcessingMode);
                        currentProcessingMode = MODE_ANSWER;
                        incrementPos = false;
                }

                if (incrementPos) {
                    currentPos++;
                }
            } // end while loop over chunk

            scrollToBottom();
        }; // end onmessage

        ws.onerror = (event) => {
             console.error("WebSocket error:", event);
             addErrorMessage("WebSocket connection error. Please try refreshing the page.");
             finalizeTurnOnErrorOrClose();
        };

        ws.onclose = (event) => {
             console.log(`[DEBUG] WebSocket connection closed: Code=${event.code}, Reason='${event.reason}', WasClean=${event.wasClean}`);
             addSystemMessage(`Connection closed. ${event.reason ? event.reason : ''} (Code: ${event.code}). Attempting to reconnect...`);
             finalizeTurnOnErrorOrClose();
             websocket = undefined;
             const reconnectDelay = Math.min(1000 * (2 ** Math.min(8, event.code === 1000 ? 0 : 1)), 30000);
             console.log(`[DEBUG] Attempting reconnect in ${reconnectDelay}ms`);
             setTimeout(connectWebSocket, reconnectDelay);
        };

        console.log("[DEBUG] WebSocket object created and handlers assigned.");

    } catch (error) {
        console.error("[DEBUG] Error creating WebSocket:", error);
        addErrorMessage(`Failed to initialize WebSocket connection: ${error.message}. Check browser console.`);
        finalizeTurnOnErrorOrClose();
    }
}

if (chatForm) {
    chatForm.addEventListener('submit', (event) => {
        event.preventDefault(); // Prevent default form submission

        const userMessage = messageInput.value.trim(); // Get user text

        if (!userMessage) {
            return; // Do nothing if message is empty
        }

        // --- Check WebSocket State BEFORE Attempting Send ---
        if (!websocket || websocket.readyState !== WebSocket.OPEN) {
            console.warn("[Submit] WebSocket not ready or not defined. State:", websocket?.readyState);
            addErrorMessage("Not connected to the server. Please wait or refresh.");
            return; // Exit if not connected
        }

        // --- If WebSocket is OPEN, proceed ---
        try {
            // --- Step 1: Display User Message ---
            addUserMessage(userMessage); // Show user's raw message immediately

            // --- Step 2: Determine Thinking State & Prepare Message for Backend ---
            thinkingRequestedForCurrentTurn = thinkCheckbox ? thinkCheckbox.checked : false;
            console.log(`[Submit] Checkbox checked: ${thinkingRequestedForCurrentTurn}.`);

            let messageToSend = userMessage; // Default to the raw user message
            // Ensure NO_THINK_PREFIX is defined globally, e.g., const NO_THINK_PREFIX = "\\no_think";
            if (!thinkingRequestedForCurrentTurn) {
                messageToSend = NO_THINK_PREFIX + userMessage;
                console.log(`[Submit] Prepended '${NO_THINK_PREFIX}'. Prepared message: "${messageToSend.substring(0, 100)}..."`);
            } else {
                console.log(`[Submit] Prepared raw message (thinking requested): "${messageToSend.substring(0, 100)}..."`);
            }

            // --- Step 3: Setup UI for AI Response ---
            setupNewAiTurn(); // Uses thinkingRequestedForCurrentTurn for initial visibility

            // --- Step 4: Attempt to Send Message to WebSocket ---
            console.log(`[Submit] >>> About to call websocket.send(). State: ${websocket?.readyState}`); // Log state right before send

            websocket.send(messageToSend); // *** THE ACTUAL SEND CALL ***

            console.log("[Submit] <<< websocket.send() call completed (no immediate error thrown)."); // Log right after send

            // --- Step 5: Clear Input & Disable ---
            messageInput.value = '';          // Clear the input field
            setInputDisabledState(true); // Disable inputs while waiting for response
            console.log("[Submit] Input cleared and disabled.");

        } catch (sendError) {
            // --- Catch Errors During Send or Subsequent Steps ---
            console.error("[Submit] !!! ERROR during send attempt or post-send steps:", sendError);
            addErrorMessage(`Failed to send message: ${sendError.message}`);
            // Optionally re-enable input if send fails? Or leave disabled?
            // setInputDisabledState(false);
        }

    }); // End of submit handler
} else {
    // Handle case where the form element itself is missing
    console.error("CRITICAL ERROR: Could not find chat form element with ID 'chat-form'. Messages cannot be sent.");
    if (typeof addErrorMessage === 'function') {
        addErrorMessage("Initialization Error: Chat input form not found.");
    } else {
        alert("Initialization Error: Chat input form not found.");
    }
}

// --- Initial Setup ---
setInputDisabledState(true); // Disable inputs until connected
connectWebSocket(); // Start connection (will add initial AI message and enable inputs onopen)

=== temp.py ===
import os
import asyncio
import sys
import uvicorn
import webbrowser
import tempfile
import shutil
import json # Added for WebSocket message parsing/sending
import traceback # For detailed error logging
from pathlib import Path
from dotenv import load_dotenv
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Request, HTTPException
from fastapi.responses import HTMLResponse # JSONResponse no longer needed for run_code
from fastapi.staticfiles import StaticFiles
from fastapi.websockets import WebSocketState # Import WebSocketState
from pydantic import BaseModel # Keep for potential future HTTP models
import docker # Docker SDK
from docker.errors import DockerException, ImageNotFound, APIError, NotFound # Docker specific errors
from docker.models.containers import Container # For type hinting
from langchain_ollama.llms import OllamaLLM
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.output_parsers import StrOutputParser
from langchain.memory import ConversationBufferMemory
from langchain_core.runnables import RunnablePassthrough # RunnableLambda no longer needed here
from langchain_core.messages import HumanMessage, AIMessage

# --- Configuration ---
load_dotenv()
MODEL_ID = os.getenv("MODEL_ID", "qwen3")
OLLAMA_BASE_URL = os.getenv("OLLAMA_BASE_URL", "http://localhost:11434")
# NO_THINK_PREFIX is handled by frontend, backend receives prefixed message
NO_THINK_PREFIX = "\\no_think"

# --- Docker Configuration ---
SUPPORTED_LANGUAGES = {
    "python": {
        "image": "python:3.11-slim",
        "filename": "script.py",
        "command": ["python", "-u", "/app/script.py"] # Added -u for unbuffered output
    },
    "javascript": {
        "image": "node:18-alpine",
        "filename": "script.js",
        "command": ["node", "/app/script.js"]
    },
    # Add more languages here if needed
}
DOCKER_TIMEOUT_SECONDS = 30 # Increased timeout for potentially longer runs
DOCKER_MEM_LIMIT = "128m"

# --- FastAPI App Initialization ---
# Ensure the app object is created correctly
app = FastAPI(title="Ollama Web Chat")

# --- Docker Client Initialization ---
docker_client = None
try:
    docker_client = docker.from_env()
    docker_client.ping()
    print("Successfully connected to Docker daemon.")
except DockerException as e:
    print(f"CRITICAL WARNING: Could not connect to Docker daemon: {e}")
    print("Code execution via Docker will be unavailable.")
    docker_client = None

# --- Static Files Setup ---
# Determine the static files directory relative to this script's location
# This assumes main.py is either in the project root or inside an 'app' directory.
script_location = Path(__file__).parent
static_dir_in_app = script_location / "static"
static_dir_at_root = script_location.parent / "static" # If main.py is in 'app' dir

if static_dir_in_app.is_dir():
    static_dir = static_dir_in_app
    print(f"Found static directory at: {static_dir}")
elif script_location.name == "app" and static_dir_at_root.is_dir():
     # If script is in 'app' and 'static' is sibling to 'app'
     static_dir = static_dir_at_root
     print(f"Found static directory at: {static_dir}")
else:
    # Fallback check if script is in root and static is in root
    if (script_location.parent / "static").is_dir():
         static_dir = script_location.parent / "static"
         print(f"Found static directory at: {static_dir}")
    else:
        print(f"CRITICAL ERROR: Static directory not found near '{script_location}'. Looked for '{static_dir_in_app}' and '{static_dir_at_root}'. Exiting.")
        sys.exit(1)

# Mount static files - THIS MUST BE CORRECT FOR CSS/JS
app.mount("/static", StaticFiles(directory=str(static_dir)), name="static")
print(f"Mounted static directory '{static_dir}' at '/static'")


# --- LangChain Setup ---
try:
    model = OllamaLLM(model=MODEL_ID, base_url=OLLAMA_BASE_URL)
    print(f"Successfully initialized OllamaLLM: {MODEL_ID} at {OLLAMA_BASE_URL}")
except Exception as e:
    print(f"CRITICAL ERROR: OllamaLLM init failed: {e}"); sys.exit(1)

# --- Global State for WebSocket Connections and Running Containers ---
client_memory = {}
# Stores info about currently running code executions
# Format: { "code_block_id": {"container": Container, "stream_task": asyncio.Task, "client_id": str, "websocket": WebSocket, "stop_event": asyncio.Event} }
running_containers = {}
running_containers_lock = asyncio.Lock() # Lock for safe concurrent access

# --- Memory Management Functions (Unchanged) ---
def get_memory_for_client(client_id: str) -> ConversationBufferMemory:
    """Retrieves or creates memory for a specific client."""
    if client_id not in client_memory:
        client_memory[client_id] = ConversationBufferMemory(return_messages=True, memory_key="history")
        print(f"Initialized new memory for client: {client_id}")
    return client_memory[client_id]

def remove_memory_for_client(client_id: str):
    """Removes memory when a client disconnects."""
    if client_id in client_memory:
        del client_memory[client_id]
        print(f"Removed memory for client: {client_id}")

# --- LangChain Prompt and Chain Setup (Unchanged) ---
prompt = ChatPromptTemplate.from_messages([
    ("system", "You are a helpful AI assistant chatting in a web interface. Answer the user's questions concisely. Always use katex for math ($...$ or $$...$$). For a literal dollar sign use \\$. When providing code, use standard markdown code blocks (e.g., ```python ... ```)."),
    MessagesPlaceholder(variable_name="history"),
    ("human", "{input}")
])
output_parser = StrOutputParser()

# --- Helper Functions for WebSocket Code Execution (Unchanged from previous version) ---

async def send_ws_message(websocket: WebSocket, message_type: str, payload: dict):
    """Safely sends a JSON message over the WebSocket."""
    # Check state before sending
    if websocket.client_state != WebSocketState.CONNECTED:
         print(f"WebSocket not connected, cannot send {message_type} for {payload.get('code_block_id', 'N/A')}")
         return
    try:
        await websocket.send_json({"type": message_type, "payload": payload})
    except WebSocketDisconnect:
        print(f"WebSocket disconnected while trying to send {message_type} for {payload.get('code_block_id', 'N/A')}")
    except Exception as e:
        # Catch other potential errors like Runtime Error if connection closed during send
        print(f"Error sending WebSocket message ({message_type}) for {payload.get('code_block_id', 'N/A')}: {e}")
        # traceback.print_exc() # Optional: uncomment for more detail

# This function runs in a separate thread via run_in_executor
def sync_log_streamer(container: Container, websocket: WebSocket, code_block_id: str, loop: asyncio.AbstractEventLoop, stop_event: asyncio.Event):
    """
    Synchronously iterates through Docker logs and schedules sending messages
    back to the main asyncio loop. Runs in an executor thread.
    """
    try:
        # Note: follow=True keeps the stream open until container stops or stream is closed.
        log_stream = container.logs(stream=True, follow=True, stdout=True, stderr=True)
        print(f"[Thread-{code_block_id}] Starting log iteration for container {container.short_id}")

        for line_bytes in log_stream:
            if stop_event.is_set():
                print(f"[Thread-{code_block_id}] Stop event set, breaking log iteration.")
                break

            line_str = line_bytes.decode('utf-8', errors='replace')
            # Schedule the send_ws_message coroutine to run on the main event loop
            asyncio.run_coroutine_threadsafe(
                send_ws_message(websocket, "code_output", {
                    "code_block_id": code_block_id,
                    "stream": "stdout", # Sending all as stdout for simplicity, could try parsing later
                    "data": line_str
                }),
                loop # Pass the main event loop
            )

        print(f"[Thread-{code_block_id}] Finished log iteration for container {container.short_id}")

    except Exception as e:
        # Log error from the thread
        print(f"[Thread-{code_block_id}] Error during log streaming: {e}")
        # Don't print traceback here usually, as it might be expected on stop
        # traceback.print_exc()
        # Try to send an error message back to the client via the main loop
        asyncio.run_coroutine_threadsafe(
            send_ws_message(websocket, "code_output", {
                "code_block_id": code_block_id,
                "stream": "error",
                "data": f"\n[Error streaming logs from container: {str(e)}]"
            }),
            loop
        )

async def stream_docker_logs_via_executor(websocket: WebSocket, container: Container, code_block_id: str, stop_event: asyncio.Event):
    """
    Runs the synchronous log streamer function in an executor thread.
    """
    loop = asyncio.get_running_loop()
    print(f"Scheduling log streaming task in executor for {code_block_id}")
    # Run the sync function in the default executor
    await loop.run_in_executor(
        None, # Use default thread pool executor
        sync_log_streamer, # The function to run
        container, websocket, code_block_id, loop, stop_event # Arguments for the function
    )
    print(f"Executor task for log streaming finished for {code_block_id}")


async def run_code_in_docker_stream(websocket: WebSocket, client_id: str, code_block_id: str, language: str, code: str):
    """Runs code in Docker, streams output via WebSocket, and manages container lifecycle."""
    global docker_client, running_containers, running_containers_lock

    if not docker_client:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": "Docker service is unavailable on the server."
        })
        return

    lang_key = language.lower()
    lang_config = SUPPORTED_LANGUAGES.get(lang_key)
    if not lang_config:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": f"Language '{language}' not supported for execution."
        })
        return

    image_name = lang_config["image"]
    script_filename = lang_config["filename"]
    command = lang_config["command"]
    container_obj: Container | None = None
    stream_task: asyncio.Task | None = None
    tmpdir_obj = None # To hold the TemporaryDirectory object
    stop_event = asyncio.Event() # Event to signal cancellation to the streamer thread

    try:
        # Create temporary directory safely
        tmpdir_obj = tempfile.TemporaryDirectory()
        tmpdir = tmpdir_obj.name # Get the path string
        host_script_path = Path(tmpdir) / script_filename
        with open(host_script_path, "w", encoding="utf-8") as f:
            f.write(code)

        print(f"Attempting to run block {code_block_id} ({lang_key}) in Docker image {image_name}...")

        # Run the container detached
        container_obj = docker_client.containers.run(
            image=image_name,
            command=command,
            volumes={tmpdir: {'bind': '/app', 'mode': 'ro'}}, # Read-only mount
            working_dir='/app',
            mem_limit=DOCKER_MEM_LIMIT,
            stdout=True,
            stderr=True,
            detach=True, # Run in background
            # auto_remove=True, # Cannot auto-remove if we need to wait/get logs/stop
        )
        print(f"Container {container_obj.short_id} started for {code_block_id}")

        # Start the log streaming task using the executor helper
        stream_task = asyncio.create_task(
            stream_docker_logs_via_executor(websocket, container_obj, code_block_id, stop_event),
            name=f"log_stream_{code_block_id}" # Give the task a name for debugging
        )

        # Store container and task info BEFORE waiting
        async with running_containers_lock:
            if code_block_id in running_containers:
                 # This should ideally not happen if frontend disables button, but handle defensively
                 print(f"WARNING: Code block {code_block_id} was already running. Stopping previous run.")
                 # Call stop without await here, as we are inside the lock
                 # stop_docker_container needs to acquire the lock itself, so we schedule it
                 asyncio.create_task(stop_docker_container(code_block_id))


            running_containers[code_block_id] = {
                "container": container_obj,
                "stream_task": stream_task,
                "client_id": client_id,
                "websocket": websocket,
                "stop_event": stop_event # Store the stop event
            }

        # Wait for the container to finish execution or timeout
        print(f"Waiting for container {container_obj.short_id} ({code_block_id}) to finish...")
        loop = asyncio.get_running_loop()
        result = await loop.run_in_executor(
            None, # Use default executor
            lambda: container_obj.wait(timeout=DOCKER_TIMEOUT_SECONDS)
        )
        exit_code = result.get("StatusCode", -1)
        error_msg = result.get("Error", None)
        print(f"Container {container_obj.short_id} ({code_block_id}) finished. Result: {result}")

        # Ensure log streaming task is complete (it should be if container exited naturally)
        # Set stop event first to signal the thread, then wait/cancel task
        stop_event.set()
        try:
            # Wait briefly for the executor task to finish processing final logs
            await asyncio.wait_for(stream_task, timeout=5.0)
        except asyncio.TimeoutError:
            print(f"Warning: Log streaming task for {code_block_id} did not finish quickly after container exit.")
            # If it timed out, ensure it's cancelled (though setting stop_event should handle it)
            if not stream_task.done():
                stream_task.cancel()
        except asyncio.CancelledError:
             print(f"Log streaming task for {code_block_id} was cancelled (likely during stop).")
             pass # Already handled

        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id,
            "exit_code": exit_code,
            "error": error_msg # Send Docker-level error if any
        })

    except asyncio.TimeoutError: # Timeout from container_obj.wait()
        print(f"ERROR: Docker execution timed out for block {code_block_id} after {DOCKER_TIMEOUT_SECONDS}s.")
        await send_ws_message(websocket, "code_finished", {
             "code_block_id": code_block_id, "exit_code": -1,
             "error": f"Execution timed out after {DOCKER_TIMEOUT_SECONDS} seconds."
        })
        # Attempt to stop the timed-out container (this will also cancel the stream task via stop_docker_container)
        # Schedule stop_docker_container as it needs to acquire the lock
        asyncio.create_task(stop_docker_container(code_block_id))


    except ImageNotFound:
        error_msg = f"Server Error: Docker image '{image_name}' not found. Please pull it."
        print(f"ERROR for block {code_block_id}: {error_msg}")
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except APIError as e:
        error_msg = f"Server Error: Docker API error: {e}"
        print(f"ERROR for block {code_block_id}: {error_msg}")
        traceback.print_exc()
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except Exception as e:
        error_msg = f"Server Execution Error: {str(e)}"
        print(f"ERROR during Docker execution setup or wait for block {code_block_id}: {e}")
        traceback.print_exc()
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
        # Ensure stream task is cancelled if it was started
        if stream_task and not stream_task.done():
            print(f"Cancelling stream task for {code_block_id} due to setup/wait error.")
            stop_event.set() # Signal thread to stop
            stream_task.cancel()

    finally:
        # --- Final Cleanup ---
        # Remove from tracking dict if it hasn't been removed by stop_docker_container already
        async with running_containers_lock:
            if code_block_id in running_containers:
                print(f"Performing final cleanup check for {code_block_id}")
                task_to_cancel = running_containers[code_block_id]["stream_task"]
                stop_ev = running_containers[code_block_id]["stop_event"]
                if task_to_cancel and not task_to_cancel.done():
                     print(f"Final cleanup: Cancelling stream task for {code_block_id}")
                     stop_ev.set() # Signal thread
                     task_to_cancel.cancel()
                # Remove from tracking dict
                del running_containers[code_block_id]
                print(f"Removed {code_block_id} from running_containers during final cleanup")

        # Remove container if it exists and hasn't been removed by stop
        if container_obj:
            try:
                # Check if container still exists before removing
                await asyncio.get_running_loop().run_in_executor(None, container_obj.reload)
                print(f"Removing container {container_obj.short_id} ({code_block_id}) in final cleanup")
                # Need to run blocking remove in executor
                await asyncio.get_running_loop().run_in_executor(None, lambda: container_obj.remove(force=True))
            except NotFound:
                 print(f"Container {container_obj.short_id} already removed.")
                 pass # Already removed
            except Exception as rm_err:
                print(f"Error removing container {container_obj.short_id} in final cleanup: {rm_err}")

        # Clean up temporary directory
        if tmpdir_obj:
             try:
                  tmpdir_obj.cleanup()
             except Exception as cleanup_err:
                  print(f"Error cleaning up temp directory {tmpdir}: {cleanup_err}")


async def stop_docker_container(code_block_id: str):
    """Stops a running Docker container and cancels its log stream task."""
    global running_containers, running_containers_lock
    print(f"Attempting to stop execution for code block: {code_block_id}")
    loop = asyncio.get_running_loop()
    container_info = None
    container_obj = None
    stream_task = None
    websocket = None
    stop_event = None

    async with running_containers_lock:
        if code_block_id in running_containers:
            # Pop the entry to prevent others from trying to stop it simultaneously
            container_info = running_containers.pop(code_block_id)
            container_obj = container_info["container"]
            stream_task = container_info["stream_task"]
            websocket = container_info["websocket"] # Get websocket for final message
            stop_event = container_info["stop_event"]
            print(f"Found and removed running container {container_obj.short_id} for {code_block_id} from tracking.")
        else:
            print(f"Stop request for {code_block_id}, but it was not found in running_containers.")
            return # Nothing to stop

    # Perform actions outside the lock

    # 1. Signal the streaming thread to stop and cancel the task
    if stop_event:
        print(f"Setting stop event for {code_block_id}")
        stop_event.set()
    if stream_task and not stream_task.done():
        print(f"Cancelling stream task for {code_block_id}")
        stream_task.cancel()
        try:
            # Wait briefly for cancellation to be processed by the task
            await asyncio.wait_for(stream_task, timeout=1.0)
        except asyncio.TimeoutError:
            print(f"Stream task for {code_block_id} did not cancel quickly.")
        except asyncio.CancelledError:
            print(f"Stream task for {code_block_id} cancelled successfully.")
            pass # Expected

    # 2. Stop the container
    if container_obj:
        try:
            print(f"Stopping container {container_obj.short_id} ({code_block_id})...")
            # Stop needs to run in executor
            await loop.run_in_executor(None, lambda: container_obj.stop(timeout=5))
            print(f"Container {container_obj.short_id} stopped.")
        except Exception as stop_err:
            print(f"Error stopping container {container_obj.short_id}, attempting kill: {stop_err}")
            try:
                # Kill needs to run in executor
                await loop.run_in_executor(None, container_obj.kill)
                print(f"Container {container_obj.short_id} killed.")
            except Exception as kill_err:
                # Ignore kill error if container is already gone
                if "No such container" not in str(kill_err):
                     print(f"Error killing container {container_obj.short_id}: {kill_err}")

        # 3. Remove the container
        try:
            print(f"Removing container {container_obj.short_id} ({code_block_id}) after stop request.")
            # Remove needs to run in executor
            await loop.run_in_executor(None, lambda: container_obj.remove(force=True))
        except NotFound:
             pass # Already removed
        except Exception as rm_err:
            print(f"Error removing container {container_obj.short_id} after stop: {rm_err}")

    # 4. Send final message to client if websocket is still valid
    if websocket and websocket.client_state == WebSocketState.CONNECTED:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id,
            "exit_code": -1, # Indicate abnormal termination
            "error": "Execution stopped by user."
        })
    else:
         print(f"Cannot send stop confirmation for {code_block_id}, WebSocket reference lost or disconnected.")


async def cleanup_client_containers(client_id: str):
    """Stops and cleans up all running containers associated with a client ID."""
    global running_containers, running_containers_lock
    print(f"Cleaning up containers for disconnected client: {client_id}")
    containers_to_stop = []
    # Create a separate list to avoid modifying dict while iterating
    async with running_containers_lock:
         # Find code_block_ids associated with the client
         ids_for_client = [cb_id for cb_id, info in running_containers.items() if info["client_id"] == client_id]
         containers_to_stop.extend(ids_for_client)

    # Stop each container outside the lock to avoid holding it too long
    if containers_to_stop:
         print(f"Found containers to stop for client {client_id}: {containers_to_stop}")
         # Use asyncio.gather to stop them concurrently
         # Note: stop_docker_container already removes the entry from running_containers
         stop_tasks = [stop_docker_container(cb_id) for cb_id in containers_to_stop]
         results = await asyncio.gather(*stop_tasks, return_exceptions=True) # Log exceptions if any stop fails
         for i, result in enumerate(results):
              if isinstance(result, Exception):
                   print(f"Error during cleanup stop for {containers_to_stop[i]}: {result}")
         print(f"Finished cleanup for client {client_id}")
    else:
         print(f"No running containers found for client {client_id} during cleanup.")

# --- FastAPI Routes ---

# Root route to serve the main HTML page
@app.get("/", response_class=HTMLResponse)
async def get_chat_page(request: Request):
    """Serves the main chat HTML page."""
    html_file_path = static_dir / "index.html"
    if not html_file_path.is_file():
         print(f"ERROR: index.html not found at expected location: {html_file_path}")
         raise HTTPException(status_code=404, detail="index.html not found")
    try:
        with open(html_file_path, "r", encoding="utf-8") as f:
            html_content = f.read()
        return HTMLResponse(content=html_content)
    except Exception as e:
        print(f"ERROR reading index.html: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error reading index.html: {e}")


# --- WebSocket Endpoint ---
@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: str):
    """Handles WebSocket connections for chat and code execution."""
    await websocket.accept()
    print(f"WebSocket connection accepted for client: {client_id}")
    memory = get_memory_for_client(client_id)

    # Function to load history using this client's memory (Unchanged)
    def load_memory_for_current_client(_):
        loaded_vars = memory.load_memory_variables({})
        return loaded_vars.get("history", [])

    # Simple chain using the fixed global 'prompt' (Unchanged)
    chain = (
        RunnablePassthrough.assign(history=load_memory_for_current_client)
        | prompt
        | model
        | output_parser
    )
    print(f"LCEL Chain created for client: {client_id}")

    try:
        while True:
            # Check state before receiving
            if websocket.client_state != WebSocketState.CONNECTED:
                 print(f"WebSocket no longer connected for {client_id} before receive. Breaking loop.")
                 break

            received_data = await websocket.receive_text()

            # Check if it's a JSON command or regular chat input
            try:
                message_data = json.loads(received_data)
                message_type = message_data.get("type")
                payload = message_data.get("payload")

                if message_type and payload and isinstance(payload, dict):
                    # --- Handle JSON Commands ---
                    code_block_id = payload.get("code_block_id")
                    if not code_block_id:
                         print(f"Received JSON command without code_block_id: {message_data}")
                         continue

                    if message_type == "run_code":
                        language = payload.get("language")
                        code = payload.get("code")
                        if language and code is not None:
                             print(f"Received 'run_code' request for block {code_block_id} ({language}) from {client_id}")
                             # Start execution in background task
                             asyncio.create_task(
                                 run_code_in_docker_stream(websocket, client_id, code_block_id, language, code)
                             )
                        else:
                             print(f"Invalid 'run_code' payload received: {payload}")
                             await send_ws_message(websocket, "code_finished", {
                                  "code_block_id": code_block_id, "exit_code": -1,
                                  "error": "Invalid run_code request payload from client."
                             })

                    elif message_type == "stop_code":
                        print(f"Received 'stop_code' request for block {code_block_id} from {client_id}")
                        # Stop execution in background task
                        asyncio.create_task(
                             stop_docker_container(code_block_id)
                        )

                    else:
                        print(f"Received unknown JSON command type '{message_type}' from {client_id}")

                else:
                     # Treat as chat if JSON structure is invalid
                     print(f"Received invalid JSON structure from {client_id}, treating as chat: {received_data[:100]}...")
                     await handle_chat_message(chain, memory, websocket, client_id, received_data)

            except json.JSONDecodeError:
                # --- Handle Regular Chat Message ---
                # print(f"Handling text message from {client_id}: '{received_data[:50]}...'")
                await handle_chat_message(chain, memory, websocket, client_id, received_data)

    except WebSocketDisconnect:
        print(f"WebSocket disconnected during receive/process for client: {client_id}")
    except Exception as e:
        print(f"Unknown Error in WebSocket loop for client {client_id}: {e}")
        traceback.print_exc()
    finally:
        # --- Cleanup on Disconnect or Error ---
        print(f"Cleaning up resources for client: {client_id}")
        remove_memory_for_client(client_id)
        # Stop any running containers for this client
        await cleanup_client_containers(client_id)
        # Attempt to close websocket gracefully if it's not already closed
        if websocket.client_state == WebSocketState.CONNECTED:
            try:
                await websocket.close(code=1000) # Normal closure
                print(f"WebSocket closed gracefully for {client_id}")
            except Exception as close_exc:
                # Ignore errors if already closed or cannot close
                 print(f"Ignoring error during explicit WebSocket close for {client_id}: {close_exc}")
                 pass
        else:
             print(f"WebSocket already closed for {client_id} during cleanup.")


async def handle_chat_message(chain, memory, websocket: WebSocket, client_id: str, user_input: str):
     """Handles processing and streaming response for a regular chat message."""
     print(f"Handling chat message from {client_id}: '{user_input[:50]}...'")
     full_response = ""
     try:
         # Stream response using the chain
         async for chunk in chain.astream({"input": user_input}):
             # Check connection before sending each chunk
             if websocket.client_state != WebSocketState.CONNECTED:
                  print(f"WebSocket disconnected during chat stream for {client_id}. Aborting send.")
                  return # Stop sending if disconnected
             await websocket.send_text(chunk)
             full_response += chunk
     except Exception as chain_exc:
         error_msg = f"<ERROR>Error processing message: {chain_exc}"
         print(f"ERROR during chain execution for {client_id}: {chain_exc}")
         traceback.print_exc()
         # Try sending error message only if connected
         if websocket.client_state == WebSocketState.CONNECTED:
              await websocket.send_text(error_msg)
         # Don't save context if chain failed, but allow next message
         return

     # Send End Of Stream marker for chat message only if connected
     if websocket.client_state == WebSocketState.CONNECTED:
          await websocket.send_text("<EOS>")
          print(f"Finished streaming chat response to {client_id}")
          # Save context to memory
          # Note: user_input might contain the NO_THINK_PREFIX, which is fine for memory
          memory.save_context({"input": user_input}, {"output": full_response})
          print(f"Saved chat context to memory for client: {client_id}")
     else:
          print(f"WebSocket disconnected before sending <EOS> for {client_id}.")


# --- Function to run the server ---
def start_server():
    """Starts the Uvicorn server and opens the browser."""
    host = "127.0.0.1"
    port = 8001
    url = f"http://{host}:{port}"
    print(f"Starting server at {url}...")
    print(f"Using Ollama base URL: {OLLAMA_BASE_URL}")
    print(f"Using Model ID: {MODEL_ID}")
    print(f"Static files served from: {static_dir}")
    print(f"Supported execution languages: {list(SUPPORTED_LANGUAGES.keys())}")
    if not docker_client:
        print("WARNING: Docker client unavailable. Code execution will fail.")

    print(f"Attempting to open browser at {url}...")
    try:
        webbrowser.open(url)
    except Exception as browser_err:
        print(f"Warning: Could not automatically open browser: {browser_err}")
        print(f"Please navigate to {url} manually.")

    # --- Uvicorn Run ---
    # IMPORTANT: The target 'app.main:app' assumes this script (main.py)
    # is located inside a directory named 'app' relative to where you
    # run the uvicorn command OR that you run python like: python -m app.main
    # If main.py is at the project root, change the target to "main:app"
    uvicorn_target = "app.main:app"
    # Check if running directly (e.g., python main.py) vs module (python -m app.main)
    # A simple check: if the script's directory is named 'app'
    if Path(__file__).parent.name == "app":
         print(f"Running Uvicorn with target: '{uvicorn_target}' (assuming script is in 'app' directory)")
    else:
         # If not in 'app', assume it's at the root
         uvicorn_target = "main:app"
         print(f"Running Uvicorn with target: '{uvicorn_target}' (assuming script is at project root)")

    uvicorn.run(uvicorn_target, host=host, port=port, log_level="info", reload=True)

if __name__ == "__main__":
    # Add basic check for Docker client availability at startup
    if docker_client is None:
         print("\n---")
         print("WARNING: Docker is not running or accessible.")
         print("Code execution features will be disabled.")
         print("Please start Docker and restart this application for code execution.")
         print("---\n")
    start_server()



=== write_project_content_to_file.py ===
import os
import sys

# --- Configuration ---

# Set the starting directory (e.g., "." for current directory)
root = "."

# Extensions to include
extensions = ('.py', '.html', '.css', '.js', '.json', '.md', '.txt', '.yaml', '.yml', '.toml')

# Directories to completely exclude (will not be walked)
exclude_dirs = (
    '.git',
    '__pycache__',
    '.pytest_cache',
    'node_modules',
    'build',
    'old2',
    'testing-bundles', # Exclude this directory name wherever it appears
    '.venv',           # Common virtual environment folder
    'venv',
    'env',
    '.env',
)

# Files to list in the tree but exclude their *content*
exclude_files = (
    'package-lock.json',
    'yarn.lock',
    'katex.min.css',
    'katex.min.js'
    # Add other large or irrelevant files by name here
)

# Output file name
output_filename = "project_content.txt"

# --- Script Logic ---

try:
    root = os.path.abspath(root)
    print(f"Starting directory: {root}")
    print(f"Output file: {output_filename}")
    print(f"Excluding directories: {exclude_dirs}")
    print(f"Excluding content of files: {exclude_files}")

    # Use a set for faster lookups
    exclude_dirs_set = set(exclude_dirs)
    exclude_files_set = set(exclude_files)

    with open(output_filename, "w", encoding="utf-8", errors="replace") as outfile:
        # === Add Directory Structure ===
        outfile.write("=== Project Directory Structure ===\n")
        outfile.write(f"Root: {root}\n")
        outfile.write("Relevant files and folders (excluding specified patterns):\n\n")

        structure_lines = []
        processed_dirs_for_structure = set()

        for current_root, dirs, files in os.walk(root, topdown=True):
            # Filter directories *in place* to prevent walking into excluded ones
            # Also exclude hidden directories starting with '.' unless root is hidden
            original_dirs = list(dirs) # Keep original for path checking if needed
            dirs[:] = [d for d in dirs if d not in exclude_dirs_set and not (d.startswith('.') and d != '.')]

            rel_path_from_start = os.path.relpath(current_root, root)

            # --- Skip processing if current path is inside an excluded directory ---
            # Check if any component of the relative path is in the exclusion list
            # Normalize path separators for consistent checking
            norm_rel_path = os.path.normpath(rel_path_from_start).replace(os.sep, '/')
            path_components = set(comp for comp in norm_rel_path.split('/') if comp and comp != '.')

            if any(comp in exclude_dirs_set or (comp.startswith('.') and comp != '.') for comp in path_components):
                 continue # Skip this directory entirely if any parent was excluded

            level = norm_rel_path.count('/') if norm_rel_path != '.' else 0

            # Add directory entry
            if rel_path_from_start == '.':
                 structure_lines.append(".\n")
            else:
                 indent = '│   ' * (level - 1) + '├── ' if level > 0 else ''
                 dir_name = os.path.basename(current_root)
                 # Check if this specific dir name should be excluded (e.g., if it's at the root)
                 if dir_name not in exclude_dirs_set and not (dir_name.startswith('.') and dir_name != '.'):
                     structure_lines.append(f"{indent}{dir_name}/\n")
                     processed_dirs_for_structure.add(norm_rel_path)


            # Add file entries for this directory
            file_indent = '│   ' * level + '├── '
            files.sort()
            for file in files:
                if file.endswith(extensions) and not file.startswith('.'):
                     structure_lines.append(f"{file_indent}{file}\n")

        # Write collected structure lines
        for line in structure_lines:
             outfile.write(line)

        outfile.write("\n\n=== File Contents ===\n\n")

        # === Add File Contents ===
        for current_root, dirs, files in os.walk(root, topdown=True):
            # Apply the same directory filtering as in the first walk
            dirs[:] = [d for d in dirs if d not in exclude_dirs_set and not (d.startswith('.') and d != '.')]

            rel_path_from_start = os.path.relpath(current_root, root)

            # --- Skip processing if current path is inside an excluded/hidden directory ---
            norm_rel_path = os.path.normpath(rel_path_from_start).replace(os.sep, '/')
            path_components = set(comp for comp in norm_rel_path.split('/') if comp and comp != '.')
            if any(comp in exclude_dirs_set or (comp.startswith('.') and comp != '.') for comp in path_components):
                 continue # Skip files in this directory

            files.sort()
            for file in files:
                 # Exclude hidden files and check extensions
                 if file.endswith(extensions) and not file.startswith('.'):
                     file_path = os.path.join(current_root, file)
                     relative_path = os.path.relpath(file_path, root)
                     display_path = relative_path.replace(os.sep, '/')

                     outfile.write(f"=== {display_path} ===\n")

                     # Check if the file *content* should be excluded
                     if file in exclude_files_set:
                         outfile.write("--- CONTENT EXCLUDED (listed in exclude_files) ---\n")
                     else:
                         try:
                             # Try reading with utf-8 first
                             with open(file_path, "r", encoding="utf-8") as infile:
                                 outfile.write(infile.read())
                         except UnicodeDecodeError:
                             # Fallback for non-utf8 files
                             try:
                                 with open(file_path, "r", encoding="latin-1") as infile:
                                     outfile.write(infile.read())
                                 outfile.write("\n--- (Warning: Read using latin-1 encoding) ---\n")
                             except Exception as inner_e:
                                 outfile.write(f"--- Error reading file (fallback failed): {inner_e} ---\n")
                         except Exception as e:
                             # Handle other potential file reading errors
                             outfile.write(f"--- Error reading file: {e} ---\n")

                     outfile.write("\n\n") # Add separation between file contents

    print(f"Successfully generated project content file: {output_filename}")

except FileNotFoundError:
    print(f"Error: Starting directory not found: {root}", file=sys.stderr)
except IOError as e:
    print(f"Error writing to output file {output_filename}: {e}", file=sys.stderr)
except Exception as e:
    print(f"An unexpected error occurred: {e}", file=sys.stderr)

=== app/__init__.py ===


=== app/config.py ===
# app/config.py
import os
import sys
from pathlib import Path
from dotenv import load_dotenv

# Load environment variables from a .env file if it exists
load_dotenv()

# --- LLM Configuration ---
# Model ID for the Ollama language model
MODEL_ID = os.getenv("MODEL_ID", "qwen3")
# Base URL for the Ollama API server
OLLAMA_BASE_URL = os.getenv("OLLAMA_BASE_URL", "http://localhost:11434")
# Prefix used by the frontend to signal non-thinking requests (handled by frontend)
NO_THINK_PREFIX = "\\no_think"

# --- Docker Configuration ---
# Dictionary defining supported languages for code execution.
# Each key is the language identifier (lowercase).
# Each value is a dictionary containing:
#   - image: The Docker image to use for execution.
#   - filename: The expected filename for the code snippet inside the container.
#   - command: The command list to execute the code within the container.
SUPPORTED_LANGUAGES = {
    # --- Existing Languages ---
    "python": {
        "image": "python:3.11-slim",
        "filename": "script.py",
        # Run python with unbuffered output (-u)
        "command": ["python", "-u", "/app/script.py"]
    },
    "javascript": {
        # --- UPDATED IMAGE ---
        "image": "node-ts:18", # Use standard Node.js 18 image (same as TypeScript)
        "filename": "script.js",
        "command": ["node", "/app/script.js"]
    },
    # --- Added Languages ---
    "cpp": {
        "image": "gcc:latest", # GNU C++ compiler image
        "filename": "script.cpp",
        # Command compiles script.cpp to an executable, then runs it.
        # Uses 'sh -c' to chain the compilation (g++) and execution steps.
        "command": ["sh", "-c", "g++ /app/script.cpp -o /app/output_executable && /app/output_executable"]
    },
    "c#": {
        "image": "mcr.microsoft.com/dotnet/sdk:latest", # .NET SDK image
        "filename": "Script.cs", # C# convention often uses PascalCase filename
        # Command creates a minimal console project, copies user code, and runs.
        # 'dotnet new' output is suppressed ('> /dev/null').
        "command": ["sh", "-c", "cd /app && dotnet new console --force -o . > /dev/null && cp Script.cs Program.cs && dotnet run"]
    },
    "typescript": {
        "image": "node-ts:18", # Use standard Node.js 18 image (Debian based, includes npm/npx)
        "filename": "script.ts",
        # Compile script.ts to script.js targeting CommonJS, then run with node.
        # Assumes 'tsc' (TypeScript compiler) is available in the 'node:18' image.
        # If 'tsc' is not found, you may need to revert to the previous command with 'npm install'
        # or build a custom image with typescript pre-installed.
        "command": ["sh", "-c", "tsc --module commonjs /app/script.ts && node /app/script.js"]
    },
    "java": {
        "image": "openjdk:17-jdk-slim", # Java Development Kit image
        "filename": "Main.java", # Java requires filename match public class name
        # Command compiles Main.java and then runs the compiled Main class.
        "command": ["sh", "-c", "javac /app/Main.java && java -cp /app Main"]
    },
    "go": {
        "image": "golang:1.21-alpine", # Go language image
        "filename": "script.go",
        # Command uses 'go run' to compile and run the source file directly.
        "command": ["go", "run", "/app/script.go"]
    },
    "rust": {
        "image": "rust:1-slim", # Rust language image
        "filename": "main.rs", # Rust convention often uses main.rs
        # Command compiles main.rs to an executable, then runs it.
        "command": ["sh", "-c", "cd /app && rustc main.rs -o main_executable && ./main_executable"]
    }
    # Add more languages here following the pattern:
    # "language_name": { "image": "docker_image", "filename": "script_name", "command": ["command", "arg1", ...]}
}
# Timeout in seconds for Docker container execution
DOCKER_TIMEOUT_SECONDS = 30
# Memory limit for Docker containers (e.g., "128m", "256m")
DOCKER_MEM_LIMIT = "128m"

# --- Static Files Configuration ---
# Determine the static files directory relative to this config file's location.
# Assumes config.py is inside the 'app' directory.
APP_DIR = Path(__file__).parent
PROJECT_ROOT = APP_DIR.parent
STATIC_DIR_IN_APP = APP_DIR / "static"
STATIC_DIR_AT_ROOT_LEVEL = PROJECT_ROOT / "static" # If static is sibling to 'app'

STATIC_DIR = None
# Check for static directory inside 'app' first
if STATIC_DIR_IN_APP.is_dir():
    STATIC_DIR = STATIC_DIR_IN_APP
    # print(f"Found static directory at: {STATIC_DIR}") # Uncomment for debug
# If not found inside 'app', check at the project root level (sibling to 'app')
elif STATIC_DIR_AT_ROOT_LEVEL.is_dir():
     STATIC_DIR = STATIC_DIR_AT_ROOT_LEVEL
     # print(f"Found static directory at: {STATIC_DIR}") # Uncomment for debug
# If neither location is found, print an error and exit
else:
    print(f"CRITICAL ERROR: Static directory not found. Looked in '{STATIC_DIR_IN_APP}' and '{STATIC_DIR_AT_ROOT_LEVEL}'. Exiting.")
    sys.exit(1)



=== app/docker_utils.py ===
# app/docker_utils.py

import asyncio
import tempfile
import shutil
import traceback
from pathlib import Path
import docker # Docker SDK for Python
from docker.errors import DockerException, ImageNotFound, APIError, NotFound # Docker specific errors
from docker.models.containers import Container # For type hinting container objects
from fastapi import WebSocket # For type hinting WebSockets

# Relative imports for modules within the 'app' package
from . import config
from . import state
from .utils import send_ws_message # Utility function for sending WebSocket messages

# --- Docker Client Initialization ---
# Attempt to initialize the Docker client from the environment settings.
# This typically connects to the Docker daemon running locally.
docker_client = None
try:
    # Get Docker client from environment variables (DOCKER_HOST, etc.)
    docker_client = docker.from_env()
    # Ping the Docker daemon to ensure connectivity
    docker_client.ping()
    print("Successfully connected to Docker daemon.")
except DockerException as e:
    # Handle exceptions if the Docker daemon is not reachable
    print(f"CRITICAL WARNING: Could not connect to Docker daemon: {e}")
    print("Code execution via Docker will be unavailable.")
    docker_client = None # Ensure client is None if connection failed

def get_docker_client():
    """
    Returns the initialized Docker client instance.
    Returns None if the client failed to initialize.
    """
    return docker_client

# --- Log Streaming Logic (Designed to Run in Executor Thread) ---

def sync_log_streamer(container: Container, websocket: WebSocket, code_block_id: str, loop: asyncio.AbstractEventLoop, stop_event: asyncio.Event):
    """
    Synchronously iterates through Docker container logs and schedules sending
    log lines back to the main asyncio event loop via WebSocket.
    This function is blocking and intended to be run in a separate thread using run_in_executor.

    Args:
        container: The Docker container object to stream logs from.
        websocket: The WebSocket connection to send log messages to.
        code_block_id: Identifier for the code block being executed.
        loop: The main asyncio event loop to schedule coroutines on.
        stop_event: An asyncio.Event used to signal when to stop streaming.
    """
    try:
        # Get a blocking generator for log lines (stdout and stderr)
        # follow=True keeps the stream open until the container stops or stop_event is set.
        log_stream = container.logs(stream=True, follow=True, stdout=True, stderr=True)
        print(f"[Thread-{code_block_id}] Starting log iteration for container {container.short_id}")

        # Iterate through the log stream line by line
        for line_bytes in log_stream:
            # Check if the stop event has been set (e.g., by user cancellation)
            if stop_event.is_set():
                print(f"[Thread-{code_block_id}] Stop event set, breaking log iteration.")
                break # Exit the loop if stop is requested

            # Decode bytes to string, replacing errors
            line_str = line_bytes.decode('utf-8', errors='replace')

            # Schedule the asynchronous send_ws_message function to run on the main event loop
            # This is crucial for thread safety when interacting with asyncio objects like WebSockets.
            asyncio.run_coroutine_threadsafe(
                send_ws_message(websocket, "code_output", {
                    "code_block_id": code_block_id,
                    "stream": "stdout", # Simplification: send both stdout/stderr as stdout type for now
                    "data": line_str
                }),
                loop # Pass the main event loop
            )

        print(f"[Thread-{code_block_id}] Finished log iteration for container {container.short_id}")

    except Exception as e:
        # Handle exceptions during log streaming (e.g., container removed unexpectedly)
        print(f"[Thread-{code_block_id}] Error during log streaming: {e}")
        # Schedule sending an error message back to the client via the main loop
        asyncio.run_coroutine_threadsafe(
            send_ws_message(websocket, "code_output", {
                "code_block_id": code_block_id,
                "stream": "error", # Indicate an error stream
                "data": f"\n[Error streaming logs from container: {str(e)}]"
            }),
            loop
        )

async def stream_docker_logs_via_executor(websocket: WebSocket, container: Container, code_block_id: str, stop_event: asyncio.Event):
    """
    Asynchronously runs the synchronous log streamer function (`sync_log_streamer`)
    in a separate thread using asyncio's default executor.

    Args:
        websocket: The WebSocket connection.
        container: The Docker container object.
        code_block_id: Identifier for the code block.
        stop_event: Event to signal stopping the stream.
    """
    loop = asyncio.get_running_loop()
    print(f"Scheduling log streaming task in executor for {code_block_id}")
    # Run the blocking sync_log_streamer function in the thread pool executor
    await loop.run_in_executor(
        None, # Use the default executor
        sync_log_streamer, # The function to run
        # Arguments to pass to sync_log_streamer:
        container, websocket, code_block_id, loop, stop_event
    )
    print(f"Executor task for log streaming finished for {code_block_id}")


# --- Docker Code Execution Core Function ---

async def run_code_in_docker_stream(websocket: WebSocket, client_id: str, code_block_id: str, language: str, code: str):
    """
    Handles the complete process of running user-provided code in a Docker container:
    1. Validates language and Docker availability.
    2. Creates a temporary directory and writes the code to a file.
    3. Starts the appropriate Docker container based on the language config.
    4. Starts a background task to stream container logs back via WebSocket.
    5. Waits for the container to finish or timeout.
    6. Sends a final status message (success, error, timeout) via WebSocket.
    7. Cleans up the container and temporary directory.

    Args:
        websocket: The client's WebSocket connection.
        client_id: The unique ID of the client.
        code_block_id: Identifier for the specific code block being run.
        language: The programming language of the code (e.g., "python", "c++").
        code: The actual code string provided by the user.
    """
    # Get the initialized Docker client instance
    local_docker_client = get_docker_client()

    # Check if Docker client is available
    if not local_docker_client:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": "Docker service is unavailable on the server."
        })
        return

    # Validate the requested language against the configuration
    lang_key = language.lower()
    lang_config = config.SUPPORTED_LANGUAGES.get(lang_key)
    if not lang_config:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": f"Language '{language}' not supported for execution."
        })
        return

    # Extract language-specific configuration
    image_name = lang_config["image"]
    script_filename = lang_config["filename"]
    command = lang_config["command"]

    # Initialize variables for container, task, temp dir, and stop event
    container_obj: Container | None = None
    stream_task: asyncio.Task | None = None
    tmpdir_obj = None # To hold the TemporaryDirectory object for proper cleanup
    stop_event = asyncio.Event() # Event to signal cancellation to the streamer thread

    try:
        # Create a temporary directory to store the script file
        # Using 'with' ensures cleanup even if errors occur later, but we need the path
        # outside the 'with', so we create it manually and clean up in 'finally'.
        tmpdir_obj = tempfile.TemporaryDirectory()
        tmpdir = tmpdir_obj.name # Get the path string
        host_script_path = Path(tmpdir) / script_filename

        # Write the user's code to the script file inside the temp directory
        with open(host_script_path, "w", encoding="utf-8") as f:
            f.write(code)

        print(f"Attempting to run block {code_block_id} ({lang_key}) in Docker image {image_name}...")

        # Run the Docker container
        # This might implicitly pull the image if not found locally
        container_obj = local_docker_client.containers.run(
            image=image_name,
            command=command, # Command defined in config.py
            # Mount the temporary directory read-write into /app inside the container
            # Changed mode from 'ro' to 'rw' to allow compilation output
            volumes={tmpdir: {'bind': '/app', 'mode': 'rw'}}, # <<< CHANGED HERE
            working_dir='/app', # Set working directory inside the container
            mem_limit=config.DOCKER_MEM_LIMIT, # Apply memory limit from config
            stdout=True, # Capture stdout
            stderr=True, # Capture stderr
            detach=True, # Run the container in the background
            # auto_remove=True, # Cannot auto-remove if we need logs/exit code/manual stop
        )
        print(f"Container {container_obj.short_id} started for {code_block_id}")

        # Create and start the background task for streaming logs
        stream_task = asyncio.create_task(
            stream_docker_logs_via_executor(websocket, container_obj, code_block_id, stop_event),
            name=f"log_stream_{code_block_id}" # Name the task for easier debugging
        )

        # Add the running container info to the global state dictionary (thread-safe)
        async with state.running_containers_lock:
            # Check if another execution for the same block ID is already running
            if code_block_id in state.running_containers:
                # This shouldn't happen if frontend disables button, but handle defensively
                print(f"WARNING: Code block {code_block_id} was already running. Stopping previous run.")
                # Schedule stop_docker_container; do not await inside the lock
                asyncio.create_task(stop_docker_container(code_block_id))

            # Store container details in the shared state dictionary
            state.running_containers[code_block_id] = {
                "container": container_obj,
                "stream_task": stream_task,
                "client_id": client_id,
                "websocket": websocket,
                "stop_event": stop_event # Store the stop event for cancellation
            }

        # Wait for the container to finish execution (blocking call run in executor)
        print(f"Waiting for container {container_obj.short_id} ({code_block_id}) to finish...")
        loop = asyncio.get_running_loop()
        # container.wait() is blocking, so run it in the executor
        result = await loop.run_in_executor(
            None, # Use default executor
            lambda: container_obj.wait(timeout=config.DOCKER_TIMEOUT_SECONDS) # Wait with timeout
        )
        # Extract exit code and potential error message from the result
        exit_code = result.get("StatusCode", -1) # Default to -1 if status code missing
        error_msg = result.get("Error", None) # Docker daemon error message
        print(f"Container {container_obj.short_id} ({code_block_id}) finished. Result: {result}")

        # --- Container Finished Normally or Errored ---
        # Signal the log streaming thread that it can stop
        stop_event.set()
        try:
            # Wait briefly for the log streaming task to finish processing final logs
            await asyncio.wait_for(stream_task, timeout=5.0)
        except asyncio.TimeoutError:
            print(f"Warning: Log streaming task for {code_block_id} did not finish quickly after container exit.")
            # Cancel the task if it's still running after the timeout
            if stream_task and not stream_task.done():
                stream_task.cancel()
        except asyncio.CancelledError:
            # Expected if the task was cancelled during stop_docker_container
             print(f"Log streaming task for {code_block_id} was cancelled (likely during stop).")

        # Send the final result message to the client
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id,
            "exit_code": exit_code,
            "error": error_msg # Send Docker-level error if any (e.g., OOMKilled)
        })

    except asyncio.TimeoutError: # Timeout triggered by container_obj.wait()
        # Handle the case where the container ran longer than DOCKER_TIMEOUT_SECONDS
        print(f"ERROR: Docker execution timed out for block {code_block_id} after {config.DOCKER_TIMEOUT_SECONDS}s.")
        await send_ws_message(websocket, "code_finished", {
             "code_block_id": code_block_id, "exit_code": -1,
             "error": f"Execution timed out after {config.DOCKER_TIMEOUT_SECONDS} seconds."
        })
        # Schedule the container stop process in the background
        asyncio.create_task(stop_docker_container(code_block_id))

    except ImageNotFound:
        # Handle case where the specified Docker image doesn't exist locally and couldn't be pulled
        error_msg = f"Server Error: Docker image '{image_name}' not found. Please ensure it's pulled or available."
        print(f"ERROR for block {code_block_id}: {error_msg}")
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except APIError as e:
        # Handle errors from the Docker daemon API
        error_msg = f"Server Error: Docker API error: {e}"
        print(f"ERROR for block {code_block_id}: {error_msg}")
        traceback.print_exc() # Print full traceback for server logs
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except Exception as e:
        # Catch any other unexpected errors during setup or execution
        error_msg = f"Server Execution Error: An unexpected error occurred." # Generic message for client
        print(f"ERROR during Docker execution setup or wait for block {code_block_id}: {e}")
        traceback.print_exc() # Print full traceback for server logs
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
        # Ensure stream task is cancelled if it was started before the error
        if stream_task and not stream_task.done():
            print(f"Cancelling stream task for {code_block_id} due to setup/wait error.")
            stop_event.set() # Signal thread to stop
            stream_task.cancel()

    finally:
        # --- Final Cleanup ---
        # This block executes whether the try block succeeded or failed

        # Remove container info from tracking dict if it hasn't been removed already
        async with state.running_containers_lock:
            if code_block_id in state.running_containers:
                print(f"Performing final cleanup check for {code_block_id}")
                # Retrieve task and event references before deleting the entry
                task_to_cancel = state.running_containers[code_block_id].get("stream_task")
                stop_ev = state.running_containers[code_block_id].get("stop_event")
                # Ensure task is stopped and cancelled if still running
                if task_to_cancel and not task_to_cancel.done():
                    print(f"Final cleanup: Cancelling stream task for {code_block_id}")
                    if stop_ev: stop_ev.set() # Signal thread
                    task_to_cancel.cancel()
                # Remove the entry from the tracking dictionary
                del state.running_containers[code_block_id]
                print(f"Removed {code_block_id} from running_containers during final cleanup")

        # Ensure the Docker container is removed
        if container_obj:
            try:
                # Need to run blocking Docker SDK calls in an executor thread
                loop = asyncio.get_running_loop()
                # Check if container still exists before trying to remove
                await loop.run_in_executor(None, container_obj.reload)
                print(f"Removing container {container_obj.short_id} ({code_block_id}) in final cleanup")
                # Force remove the container
                await loop.run_in_executor(None, lambda: container_obj.remove(force=True))
            except NotFound:
                # Container was already removed (e.g., by stop_docker_container)
                 print(f"Container {container_obj.short_id} already removed.")
            except Exception as rm_err:
                # Log error if removal fails for some other reason
                 print(f"Error removing container {container_obj.short_id} in final cleanup: {rm_err}")

        # Clean up the temporary directory
        if tmpdir_obj:
             try:
                 tmpdir_obj.cleanup() # Deletes the temporary directory and its contents
             except Exception as cleanup_err:
                 print(f"Error cleaning up temp directory {tmpdir_obj.name}: {cleanup_err}")


# --- Container Stopping Logic ---

async def stop_docker_container(code_block_id: str):
    """
    Stops a specific running Docker container identified by code_block_id.
    Handles cancelling the log stream task and removing the container.

    Args:
        code_block_id: The identifier of the code block whose container needs stopping.
    """
    print(f"Attempting to stop execution for code block: {code_block_id}")
    loop = asyncio.get_running_loop()
    container_info = None
    container_obj = None
    stream_task = None
    websocket = None
    stop_event = None

    # Safely access and remove the container info from the shared state
    async with state.running_containers_lock:
        if code_block_id in state.running_containers:
            # Pop the entry to prevent race conditions with other stop requests or cleanup
            container_info = state.running_containers.pop(code_block_id)
            container_obj = container_info.get("container")
            stream_task = container_info.get("stream_task")
            websocket = container_info.get("websocket") # Get websocket for final message
            stop_event = container_info.get("stop_event")
            print(f"Found and removed running container info for {code_block_id} from tracking.")
        else:
            # If not found, it might have finished or been stopped already
            print(f"Stop request for {code_block_id}, but it was not found in running_containers.")
            return # Nothing further to do

    # --- Perform actions outside the lock ---

    # 1. Signal the streaming thread to stop and cancel the asyncio task
    if stop_event:
        print(f"Setting stop event for {code_block_id}")
        stop_event.set()
    if stream_task and not stream_task.done():
        print(f"Cancelling stream task for {code_block_id}")
        stream_task.cancel()
        try:
            # Wait briefly for cancellation to be processed
            await asyncio.wait_for(stream_task, timeout=1.0)
        except asyncio.TimeoutError:
            print(f"Stream task for {code_block_id} did not cancel quickly.")
        except asyncio.CancelledError:
            print(f"Stream task for {code_block_id} cancelled successfully.")
            pass # Expected outcome

    # 2. Stop the Docker container (run blocking calls in executor)
    if container_obj:
        try:
            print(f"Stopping container {container_obj.short_id} ({code_block_id})...")
            # container.stop() is blocking
            await loop.run_in_executor(None, lambda: container_obj.stop(timeout=5))
            print(f"Container {container_obj.short_id} stopped.")
        except Exception as stop_err:
            # If stop fails (e.g., timeout), attempt to kill the container
            print(f"Error stopping container {container_obj.short_id}, attempting kill: {stop_err}")
            try:
                # container.kill() is blocking
                await loop.run_in_executor(None, container_obj.kill)
                print(f"Container {container_obj.short_id} killed.")
            except Exception as kill_err:
                # Ignore "No such container" error if already gone, log others
                 if "No such container" not in str(kill_err):
                     print(f"Error killing container {container_obj.short_id}: {kill_err}")

        # 3. Remove the Docker container (run blocking call in executor)
        try:
            print(f"Removing container {container_obj.short_id} ({code_block_id}) after stop request.")
            # container.remove() is blocking
            await loop.run_in_executor(None, lambda: container_obj.remove(force=True))
        except NotFound:
            pass # Container already removed
        except Exception as rm_err:
            print(f"Error removing container {container_obj.short_id} after stop: {rm_err}")

    # 4. Send final "stopped by user" message if WebSocket is still valid
    if websocket: # Check if websocket reference exists
         try:
             await send_ws_message(websocket, "code_finished", {
                 "code_block_id": code_block_id,
                 "exit_code": -1, # Indicate abnormal termination
                 "error": "Execution stopped by user."
             })
         except Exception as send_err:
              print(f"Error sending stop confirmation for {code_block_id}: {send_err}")
    else:
         print(f"Cannot send stop confirmation for {code_block_id}, WebSocket reference lost.")


# --- Client Disconnect Cleanup ---

async def cleanup_client_containers(client_id: str):
    """
    Stops and cleans up all running Docker containers associated with a specific client ID
    when that client disconnects.

    Args:
        client_id: The ID of the client that disconnected.
    """
    print(f"Cleaning up containers for disconnected client: {client_id}")
    containers_to_stop = []
    # Safely get a list of code_block_ids associated with the disconnected client
    async with state.running_containers_lock:
        # List comprehension to find matching client_id
        ids_for_client = [
            cb_id for cb_id, info in state.running_containers.items()
            if info.get("client_id") == client_id
        ]
        containers_to_stop.extend(ids_for_client)

    # Stop each container concurrently using asyncio.gather
    if containers_to_stop:
        print(f"Found containers to stop for client {client_id}: {containers_to_stop}")
        # Create a list of stop tasks
        stop_tasks = [stop_docker_container(cb_id) for cb_id in containers_to_stop]
        # Run tasks concurrently and gather results (including exceptions)
        results = await asyncio.gather(*stop_tasks, return_exceptions=True)
        # Log any errors that occurred during the cleanup stops
        for i, result in enumerate(results):
             if isinstance(result, Exception):
                 print(f"Error during cleanup stop for {containers_to_stop[i]}: {result}")
        print(f"Finished cleanup for client {client_id}")
    else:
        print(f"No running containers found for client {client_id} during cleanup.")



=== app/llm.py ===
import sys
from langchain_ollama.llms import OllamaLLM
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.output_parsers import StrOutputParser
from langchain.memory import ConversationBufferMemory
from langchain_core.runnables import RunnablePassthrough, Runnable, RunnableLambda
from langchain_core.messages import BaseMessage
from typing import List, Callable

from . import config # Use relative import

# --- LangChain Setup ---
try:
    model = OllamaLLM(model=config.MODEL_ID, base_url=config.OLLAMA_BASE_URL)
    print(f"Successfully initialized OllamaLLM: {config.MODEL_ID} at {config.OLLAMA_BASE_URL}")
except Exception as e:
    print(f"CRITICAL ERROR: OllamaLLM init failed: {e}")
    sys.exit(1)

prompt = ChatPromptTemplate.from_messages([
    ("system", "You are a helpful AI assistant chatting in a web interface. Answer the user's questions concisely. Always use katex for math ($...$ or $$...$$). For a literal dollar sign use \\$. When providing code, use standard markdown code blocks (e.g., ```python ... ```)."),
    MessagesPlaceholder(variable_name="history"),
    ("human", "{input}")
])
output_parser = StrOutputParser()

def create_chain(memory_loader_func: Callable[[dict], List[BaseMessage]]) -> Runnable:
    """
    Creates the LangChain processing chain using a provided memory loading function.
    """
    chain = (
        RunnablePassthrough.assign(history=RunnableLambda(memory_loader_func))
        | prompt
        | model
        | output_parser
    )
    return chain

def get_model() -> OllamaLLM:
    """Returns the initialized Ollama LLM model."""
    return model

=== app/main.py ===
# app/main.py
import os
import sys
import uvicorn
import webbrowser
import traceback
from pathlib import Path
import asyncio
import json
from fastapi import (
    FastAPI,
    Request,
    HTTPException,
    WebSocket,
    WebSocketDisconnect
)
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.websockets import WebSocketState

from . import config
from . import state
from . import llm
from . import docker_utils
from . import utils # For send_ws_message

# --- FastAPI App Initialization ---
app = FastAPI(title="Ollama Web Chat")

# --- Static Files Setup ---
if not config.STATIC_DIR or not config.STATIC_DIR.is_dir():
     print(f"CRITICAL ERROR: Static directory path is invalid or not found: {config.STATIC_DIR}. Exiting.")
     sys.exit(1)

app.mount("/static", StaticFiles(directory=str(config.STATIC_DIR)), name="static")
print(f"Mounted static directory '{config.STATIC_DIR}' at '/static'")

# --- FastAPI HTTP Routes ---
@app.get("/", response_class=HTMLResponse)
async def get_chat_page(request: Request):
    html_file_path = config.STATIC_DIR / "index.html"
    if not html_file_path.is_file():
        print(f"ERROR: index.html not found at expected location: {html_file_path}")
        raise HTTPException(status_code=404, detail="index.html not found")
    try:
        with open(html_file_path, "r", encoding="utf-8") as f:
            html_content = f.read()
        return HTMLResponse(content=html_content)
    except Exception as e:
        print(f"ERROR reading index.html: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error reading index.html: {e}")

# --- WebSocket Endpoint ---
@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: str):
    await websocket.accept()
    print(f"WebSocket connection accepted for client: {client_id}")
    memory = state.get_memory_for_client(client_id)
    model_instance = llm.get_model()

    def load_memory_for_current_client(_):
        loaded_vars = memory.load_memory_variables({})
        return loaded_vars.get("history", [])

    chain = llm.create_chain(load_memory_for_current_client)
    print(f"LCEL Chain created for client: {client_id}")

    try:
        while True:
            if websocket.client_state != WebSocketState.CONNECTED:
                print(f"WebSocket no longer connected for {client_id} before receive. Breaking loop.")
                break

            received_data = await websocket.receive_text()

            try:
                message_data = json.loads(received_data)
                message_type = message_data.get("type")
                payload = message_data.get("payload")

                if message_type and payload and isinstance(payload, dict):
                    code_block_id = payload.get("code_block_id")
                    if not code_block_id:
                        print(f"Received JSON command without code_block_id: {message_data}")
                        continue

                    if message_type == "run_code":
                        language = payload.get("language")
                        code = payload.get("code")
                        if language and code is not None:
                            print(f"Received 'run_code' request for block {code_block_id} ({language}) from {client_id}")
                            asyncio.create_task(
                                docker_utils.run_code_in_docker_stream(websocket, client_id, code_block_id, language, code)
                            )
                        else:
                            print(f"Invalid 'run_code' payload received: {payload}")
                            await utils.send_ws_message(websocket, "code_finished", {
                                "code_block_id": code_block_id, "exit_code": -1,
                                "error": "Invalid run_code request payload from client."
                            })

                    elif message_type == "stop_code":
                        print(f"Received 'stop_code' request for block {code_block_id} from {client_id}")
                        asyncio.create_task(
                            docker_utils.stop_docker_container(code_block_id)
                        )

                    else:
                        print(f"Received unknown JSON command type '{message_type}' from {client_id}")

                else:
                     print(f"Received invalid JSON structure from {client_id}, treating as chat: {received_data[:100]}...")
                     await handle_chat_message(chain, memory, websocket, client_id, received_data)

            except json.JSONDecodeError:
                await handle_chat_message(chain, memory, websocket, client_id, received_data)

    except WebSocketDisconnect:
        print(f"WebSocket disconnected during receive/process for client: {client_id}")
    except Exception as e:
        print(f"Unknown Error in WebSocket loop for client {client_id}: {e}")
        traceback.print_exc()
    finally:
        print(f"Cleaning up resources for client: {client_id}")
        state.remove_memory_for_client(client_id)
        await docker_utils.cleanup_client_containers(client_id)
        if websocket.client_state == WebSocketState.CONNECTED:
            try:
                await websocket.close(code=1000)
                print(f"WebSocket closed gracefully for {client_id}")
            except Exception as close_exc:
                print(f"Ignoring error during explicit WebSocket close for {client_id}: {close_exc}")
        else:
             print(f"WebSocket already closed for {client_id} during cleanup.")


async def handle_chat_message(chain, memory, websocket: WebSocket, client_id: str, user_input: str):
    print(f"Handling chat message from {client_id}: '{user_input[:50]}...'")
    full_response = ""
    try:
        async for chunk in chain.astream({"input": user_input}):
            if websocket.client_state != WebSocketState.CONNECTED:
                print(f"WebSocket disconnected during chat stream for {client_id}. Aborting send.")
                return
            await websocket.send_text(chunk)
            full_response += chunk
    except Exception as chain_exc:
        error_msg = f"<ERROR>Error processing message: {chain_exc}"
        print(f"ERROR during chain execution for {client_id}: {chain_exc}")
        traceback.print_exc()
        if websocket.client_state == WebSocketState.CONNECTED:
            try:
                await websocket.send_text(error_msg)
            except Exception as send_err:
                 print(f"Error sending chain exception message to {client_id}: {send_err}")
        return # Don't save context if chain failed

    if websocket.client_state == WebSocketState.CONNECTED:
        try:
            await websocket.send_text("<EOS>")
            print(f"Finished streaming chat response to {client_id}")
            memory.save_context({"input": user_input}, {"output": full_response})
            print(f"Saved chat context to memory for client: {client_id}")
        except Exception as send_eos_err:
             print(f"Error sending <EOS> or saving context for {client_id}: {send_eos_err}")
    else:
         print(f"WebSocket disconnected before sending <EOS> for {client_id}.")


# --- Function to run the server ---
def start_server():
    host = "127.0.0.1"
    port = 8001
    url = f"http://{host}:{port}"

    print("-" * 30)
    print(f"Starting server at {url}...")
    print(f"Using Ollama base URL: {config.OLLAMA_BASE_URL}")
    print(f"Using Model ID: {config.MODEL_ID}")
    print(f"Static files served from: {config.STATIC_DIR}")
    print(f"Supported execution languages: {list(config.SUPPORTED_LANGUAGES.keys())}")

    if docker_utils.get_docker_client() is None:
        print("WARNING: Docker client unavailable. Code execution will fail.")
    else:
        print("Docker client available.")
    print("-" * 30)

    print(f"Attempting to open browser at {url}...")
    try:
        webbrowser.open(url)
    except Exception as browser_err:
        print(f"Warning: Could not automatically open browser: {browser_err}")
        print(f"Please navigate to {url} manually.")

    uvicorn.run("app.main:app", host=host, port=port, log_level="info", reload=True)

# --- Main Execution Block ---
# This allows running via 'python -m app.main' or 'python app/main.py'
# It's also the entry point for the poetry script 'app.main:start_server'
if __name__ == "__main__":
    start_server()

=== app/state.py ===
import asyncio
from langchain.memory import ConversationBufferMemory
from typing import Dict, Any
from docker.models.containers import Container # For type hinting
from fastapi import WebSocket

# --- Global State for WebSocket Connections and Running Containers ---
client_memory: Dict[str, ConversationBufferMemory] = {}

# Stores info about currently running code executions
# Format: { "code_block_id": {"container": Container, "stream_task": asyncio.Task, "client_id": str, "websocket": WebSocket, "stop_event": asyncio.Event} }
running_containers: Dict[str, Dict[str, Any]] = {}
running_containers_lock = asyncio.Lock() # Lock for safe concurrent access

# --- Memory Management Functions ---
def get_memory_for_client(client_id: str) -> ConversationBufferMemory:
    """Retrieves or creates memory for a specific client."""
    global client_memory
    if client_id not in client_memory:
        client_memory[client_id] = ConversationBufferMemory(return_messages=True, memory_key="history")
        print(f"Initialized new memory for client: {client_id}")
    return client_memory[client_id]

def remove_memory_for_client(client_id: str):
    """Removes memory when a client disconnects."""
    global client_memory
    if client_id in client_memory:
        del client_memory[client_id]
        print(f"Removed memory for client: {client_id}")

=== app/utils.py ===
# app/utils.py
import json
import traceback
from fastapi import WebSocket, WebSocketDisconnect
from fastapi.websockets import WebSocketState

async def send_ws_message(websocket: WebSocket, message_type: str, payload: dict):
    """Safely sends a JSON message over the WebSocket."""
    # Check state before sending (no change needed here)
    if websocket.client_state != WebSocketState.CONNECTED:
        print(f"[utils] WebSocket not connected, cannot send {message_type} for {payload.get('code_block_id', 'N/A')}")
        return
    try:
        await websocket.send_json({"type": message_type, "payload": payload})
    except WebSocketDisconnect:
        print(f"[utils] WebSocket disconnected while trying to send {message_type} for {payload.get('code_block_id', 'N/A')}")
    except Exception as e:
        # Catch other potential errors like Runtime Error if connection closed during send
        print(f"[utils] Error sending WebSocket message ({message_type}) for {payload.get('code_block_id', 'N/A')}: {e}")
        # traceback.print_exc() # Optional: uncomment for more detail

=== app/static/index.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ollama Chat</title>
    <script src="https://cdn.tailwindcss.com"></script>

    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">

    <link rel="stylesheet" href="/static/style.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 flex flex-col h-screen">

    <header class="bg-blue-600 text-white p-4 text-center shadow-md">
        <h1 class="text-2xl font-bold">Tesseracs-Chat</h1>
    </header>

    <div id="chat-history" class="flex-1 overflow-y-auto p-4 space-y-4 flex flex-col bg-white shadow-inner m-4 rounded-lg">
        </div>

    <footer class="p-4 bg-gray-200 border-t border-gray-300">
        <form id="chat-form" class="flex items-center space-x-2">
            <div class="think-checkbox-container">
                <input type="checkbox" id="think-checkbox" checked>
                <label for="think-checkbox">Think</label>
            </div>
            <input type="text" id="message-input" placeholder="Type your message..." autocomplete="off" required
                   class="flex-1 p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            <button type="submit" id="send-button"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                Send
            </button>
        </form>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    
    <script src="/static/script.js" defer></script>
</body>
</html>

=== app/static/script.js ===
/*
 * Full script.js implementing:
 * - WebSocket communication
 * - Basic chat UI updates (user, system, error messages)
 * - State machine for parsing Code Blocks (```)
 * - State machine for buffering and rendering KaTeX ($...$, $$...$$) atomically during stream
 * - State machine for extracting optional Thinking content (<think>...</think>) into a separate area
 * - Final Markdown rendering of the main response bubble content at the end of the stream (<EOS>)
 */

const chatHistory = document.getElementById('chat-history');
const chatForm = document.getElementById('chat-form');
const messageInput = document.getElementById('message-input');
const sendButton = document.getElementById('send-button');
const thinkCheckbox = document.getElementById('think-checkbox');

let websocket;
const clientId = `web-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
let currentTurnId = 0;

const MODE_ANSWER = 'MODE_ANSWER';
const MODE_SEEKING_CODE_LANGUAGE = 'MODE_SEEKING_CODE_LANGUAGE';
const MODE_INSIDE_CODE_BLOCK = 'MODE_INSIDE_CODE_BLOCK';
const MODE_KATEX_BUFFERING_INLINE = 'MODE_KATEX_BUFFERING_INLINE';
const MODE_KATEX_BUFFERING_DISPLAY = 'MODE_KATEX_BUFFERING_DISPLAY';
const MODE_MAYBE_START_DISPLAY_KATEX = 'MODE_MAYBE_START_DISPLAY_KATEX';
const MODE_SEEKING_TAG = 'MODE_SEEKING_TAG';
const MODE_INSIDE_THINK = 'MODE_INSIDE_THINK';
const MODE_MAYBE_END_THINK = 'MODE_MAYBE_END_THINK';
const NO_THINK_PREFIX = "\\no_think"; // Must match the backend main.py
// ---- ADD THESE TWO LINES ----
const MODE_SEEKING_CODE_START_FENCE = 'MODE_SEEKING_CODE_START_FENCE'; // For detecting start ```
const MODE_SEEKING_CODE_END_FENCE = 'MODE_SEEKING_CODE_END_FENCE';   // For detecting end ```
// -----------------------------


let currentProcessingMode = MODE_ANSWER;
let langBuffer = '';
let currentCodeBlockLang = '';
let currentCodeBlockElement = null;
let currentCodeBlockPreElement = null;
let katexBuffer = '';
let currentKatexMarkerId = null;
let thinkBuffer = '';
let tagBuffer = '';
let currentAiTurnContainer = null;
let currentAnswerElement = null;
let currentThinkingArea = null;
let currentThinkingPreElement = null;
let currentCodeBlocksArea = null;
let codeBlockCounterThisTurn = 0;
let thinkingRequestedForCurrentTurn = false; // <<< Reset by resetStreamingState now
let accumulatedAnswerText = '';
let lastAppendedNode = null;
let hasThinkingContentArrivedThisTurn = false;
let firstAnswerTokenReceived = false;

const FENCE = '```';
const THINK_START_TAG = '<think>';
const THINK_END_TAG = '</think>';
const KATEX_PLACEHOLDER_PREFIX = '%%KATEX_PLACEHOLDER_';
const KATEX_RENDERED_ATTR = 'data-katex-rendered';


function scrollToBottom(behavior = 'auto') {
    const isNearBottom = chatHistory.scrollHeight - chatHistory.scrollTop - chatHistory.clientHeight < 100;
    if (isNearBottom) {
        requestAnimationFrame(() => {
             chatHistory.scrollTo({ top: chatHistory.scrollHeight, behavior: behavior });
        });
    }
}

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
};

function addUserMessage(text) {
    const messageElement = document.createElement('div');
    messageElement.classList.add('message', 'user-message');
    messageElement.textContent = text;
    chatHistory.appendChild(messageElement);
    setTimeout(() => scrollToBottom('smooth'), 50);
}

function getCursorPosition(parentElement) {
    const selection = window.getSelection();
    if (selection.rangeCount === 0) return -1; // No selection/cursor

    const range = selection.getRangeAt(0);
    // Ensure the selection is actually within the intended element
    if (!parentElement.contains(range.startContainer)) {
        // console.warn("Selection start container not within the parent element.");
        return -1;
    }

    const preSelectionRange = range.cloneRange();
    // Create a range from the start of the parent element to the cursor position
    preSelectionRange.selectNodeContents(parentElement);
    // Set the end of the range to the cursor's start position
    // This handles cases where the selection might span multiple nodes
    try {
         preSelectionRange.setEnd(range.startContainer, range.startOffset);
    } catch (e) {
         console.error("Error setting preSelectionRange end:", e, "Range:", range);
         return -1; // Indicate error
    }

    // The length of the text content of this range is the cursor offset
    const start = preSelectionRange.toString().length;
    return start;
}

function setCursorPosition(parentElement, offset) {
    const selection = window.getSelection();
    if (!selection) return; // No selection object available

    const range = document.createRange();
    let charCount = 0;
    let foundStart = false;

    // Recursive function to find the text node and offset within it
    function findNodeAndOffset(node) {
        if (foundStart) return; // Stop searching once found

        if (node.nodeType === Node.TEXT_NODE) {
            const nextCharCount = charCount + node.length;
            // Check if the target offset falls within this text node
            if (!foundStart && offset >= charCount && offset <= nextCharCount) {
                try {
                    // Calculate the offset within the current text node
                    const offsetInNode = offset - charCount;
                    range.setStart(node, offsetInNode);
                    foundStart = true; // Mark as found
                } catch (e) {
                     console.error("Error setting range start:", e, "Node:", node, "Offset:", offsetInNode);
                     // Attempt to recover or log, maybe fallback to end?
                }
            }
            charCount = nextCharCount; // Update total character count
        } else {
            // Iterate through child nodes if it's an element node
            for (let i = 0; i < node.childNodes.length; i++) {
                findNodeAndOffset(node.childNodes[i]);
                if (foundStart) break; // Exit inner loop if found
            }
        }
    }

    // Start the search from the parent element
    findNodeAndOffset(parentElement);

    if (foundStart) {
         range.collapse(true); // Collapse the range to a single point (the cursor)
         selection.removeAllRanges(); // Clear any existing selection
         selection.addRange(range); // Set the new cursor position
    } else {
         // Fallback: If the offset was out of bounds or node wasn't found,
         // place the cursor at the very end of the element.
         range.selectNodeContents(parentElement);
         range.collapse(false); // Collapse to the end
         selection.removeAllRanges();
         selection.addRange(range);
         console.warn(`Could not set cursor precisely at offset ${offset}. Placed at end.`);
    }
     // Ensure the element is focused after setting cursor (important!)
     parentElement.focus();
}

function addSystemMessage(text) {
   const messageElement = document.createElement('div');
   messageElement.classList.add('system-message');
   messageElement.textContent = text;
   chatHistory.appendChild(messageElement);
   setTimeout(() => scrollToBottom('smooth'), 50);
}

function addErrorMessage(text) {
   console.error("[UI ERROR] ", text);
   const messageElement = document.createElement('div');
   messageElement.classList.add('error-message');
   messageElement.textContent = `Error: ${text}`;
   if(currentAiTurnContainer) {
       const target = currentAnswerElement || currentCodeBlocksArea || currentAiTurnContainer;
       target.appendChild(messageElement);
   } else { chatHistory.appendChild(messageElement); }
   setTimeout(() => scrollToBottom('smooth'), 50);
}

function setInputDisabledState(disabled) {
    messageInput.disabled = disabled;
    sendButton.disabled = disabled;
    if (thinkCheckbox) {
        thinkCheckbox.disabled = disabled;
    }
}

function setupNewAiTurn() {
    currentTurnId++;
    codeBlockCounterThisTurn = 0;
    accumulatedAnswerText = '';
    lastAppendedNode = null;
    thinkBuffer = '';
    hasThinkingContentArrivedThisTurn = false;
    firstAnswerTokenReceived = false;

    currentAiTurnContainer = null;
    currentThinkingArea = null;
    currentThinkingPreElement = null;
    currentAnswerElement = null;
    currentCodeBlocksArea = null;

    console.log(`[setupNewAiTurn] Starting setup for Turn ID: ${currentTurnId}. thinkingRequestedForCurrentTurn is: ${thinkingRequestedForCurrentTurn}`);

    currentAiTurnContainer = document.createElement('div');
    currentAiTurnContainer.classList.add('ai-turn-container');
    currentAiTurnContainer.dataset.turnId = currentTurnId;

    currentThinkingArea = document.createElement('div');
    currentThinkingArea.classList.add('thinking-area');
    currentThinkingArea.dataset.turnId = currentTurnId;

    if (!thinkingRequestedForCurrentTurn) {
        console.log("[setupNewAiTurn] Setting thinking area style to display:none because thinkingRequested=false.");
        currentThinkingArea.style.display = 'none';
    } else {
         console.log("[setupNewAiTurn] NOT hiding thinking area initially because thinkingRequested=true.");
    }

    const details = document.createElement('details');
    details.id = `thinking-details-${currentTurnId}`;
    const summary = document.createElement('summary');
    summary.classList.add('thinking-summary');
    const summaryTextSpan = document.createElement('span');
    summaryTextSpan.classList.add('text');
    summaryTextSpan.textContent = 'Show Thinking';
    const summaryDotsSpan = document.createElement('span');
    summaryDotsSpan.classList.add('dots');
    summary.appendChild(summaryTextSpan);
    summary.appendChild(summaryDotsSpan);
    currentThinkingPreElement = document.createElement('pre');
    details.appendChild(summary);
    details.appendChild(currentThinkingPreElement);
    currentThinkingArea.appendChild(details);
    currentAiTurnContainer.appendChild(currentThinkingArea);

    details.addEventListener('toggle', (event) => {
        const textSpan = event.target.querySelector('.thinking-summary .text');
        if (!textSpan) return;
        textSpan.textContent = event.target.open ? 'Hide Thinking' : 'Show Thinking';
    });

    currentAnswerElement = document.createElement('div');
    currentAnswerElement.classList.add('message', 'ai-message');

    if (thinkingRequestedForCurrentTurn) {
        console.log("[setupNewAiTurn] Hiding answer bubble initially because thinkingRequested=true.");
        currentAnswerElement.style.display = 'none';
    } else {
        console.log("[setupNewAiTurn] Showing answer bubble immediately with loading dots because thinkingRequested=false.");
         const loadingSpan = document.createElement('span');
         loadingSpan.classList.add('loading-dots');
         currentAnswerElement.appendChild(loadingSpan);
    }
    currentAiTurnContainer.appendChild(currentAnswerElement);

    currentCodeBlocksArea = document.createElement('div');
    currentCodeBlocksArea.classList.add('code-blocks-area');
    currentAiTurnContainer.appendChild(currentCodeBlocksArea);

    chatHistory.appendChild(currentAiTurnContainer);

    console.log(`[setupNewAiTurn] Finished setup for Turn ID: ${currentTurnId}.`);
}

function appendRawTextToThinkingArea(text) {
    if (text && text.trim().length > 0) {
        console.log(`[appendRawTextToThinkingArea] Received non-empty raw think text: "${text}" (length: ${text?.length})`);
    } else if (text !== null) {
         console.log(`[appendRawTextToThinkingArea] Received empty or whitespace raw think text (length: ${text?.length})`);
    }

    console.log(`[appendRawTextToThinkingArea] Checking condition: !thinkingRequestedForCurrentTurn is ${!thinkingRequestedForCurrentTurn} (value: ${thinkingRequestedForCurrentTurn})`);
    if (!thinkingRequestedForCurrentTurn) {
        console.log("[appendRawTextToThinkingArea] Condition met (!thinkingRequested). Returning early. Should NOT display thinking.");
        return;
    }

    console.log("[appendRawTextToThinkingArea] Proceeding because thinking was requested.");

    if (!currentThinkingArea || !currentThinkingPreElement || text.length === 0) {
        return;
    }

    if (!hasThinkingContentArrivedThisTurn) {
        if (currentThinkingArea.style.display === 'none') {
            console.log("[appendRawTextToThinkingArea] First think chunk (and requested). Making area visible NOW. Display style was: " + currentThinkingArea.style.display);
            currentThinkingArea.style.display = '';
        }
        hasThinkingContentArrivedThisTurn = true;
    }

    try {
        currentThinkingPreElement.appendChild(document.createTextNode(text));
    } catch (appendError) {
         console.error("[appendRawTextToThinkingArea] Error appending text node:", appendError, "Pre Element:", currentThinkingPreElement, "Text:", text);
        return;
    }

    const detailsElement = currentThinkingPreElement.closest('details');
    if (detailsElement && detailsElement.open) {
         const isNearBottom = currentThinkingPreElement.scrollHeight - currentThinkingPreElement.scrollTop - currentThinkingPreElement.clientHeight < 50;
         if(isNearBottom) {
             requestAnimationFrame(() => { currentThinkingPreElement.scrollTop = currentThinkingPreElement.scrollHeight; });
         }
    }
}

function appendCodeReference() {
    if (!currentAnswerElement) {
        console.error("Attempted to append code reference to null answer bubble!");
        return;
    }
    // Note: codeBlockCounterThisTurn is already incremented within createCodeBlockStructure
    // So we use the *current* value after it has been incremented there.
    // If createCodeBlockStructure failed, this might reference a non-existent block, but that's an edge case.
    if (codeBlockCounterThisTurn > 0) { // Only add if a block was likely created
         const refSpan = document.createElement('span');
         refSpan.classList.add('code-reference'); // Class for styling
         refSpan.textContent = `[Code ${codeBlockCounterThisTurn}]`;
         // Append the reference to the main answer bubble
         currentAnswerElement.appendChild(refSpan);
         lastAppendedNode = refSpan; // Update tracker as we added to the bubble
    } else {
        console.warn("appendCodeReference called but codeBlockCounterThisTurn is 0.");
    }
}

function formatAnswerBubbleFinal() {
    if (!currentAnswerElement) {
        console.warn("[DEBUG] Skipping final formatting: currentAnswerElement is null.");
        accumulatedAnswerText = ''; lastAppendedNode = null; firstAnswerTokenReceived = false; return;
    }

      if (currentAnswerElement.style.display === 'none' && (currentAnswerElement.hasChildNodes() || accumulatedAnswerText.trim().length > 0)) {
          console.warn("[formatAnswerBubbleFinal] Answer bubble was hidden but contained content. Making visible.");
          currentAnswerElement.style.display = '';
           const loadingDots = currentAnswerElement.querySelector('.loading-dots');
           if (loadingDots) loadingDots.remove();
      }


    const hasVisualContent = currentAnswerElement.hasChildNodes() && !currentAnswerElement.querySelector('.loading-dots');
    const hasAccumulatedContent = accumulatedAnswerText.trim().length > 0;


    if (!hasVisualContent && !hasAccumulatedContent) {
        console.log("[DEBUG] Skipping final formatting: No actual content found.");
         const loadingDots = currentAnswerElement.querySelector('.loading-dots');
         if (loadingDots) loadingDots.remove();
        accumulatedAnswerText = '';
        lastAppendedNode = null;

        return;
    }

    console.log(`[DEBUG formatAnswerBubbleFinal] Proceeding. Has Visual: ${hasVisualContent}, Has Accumulated: ${hasAccumulatedContent}`);


    try {

        const storedKatexNodes = {};
        let placeholderIndex = 0;
        let textForMarkdown = accumulatedAnswerText;


        const katexSpans = Array.from(currentAnswerElement.children).filter(el => el.matches(`span[${KATEX_RENDERED_ATTR}="true"]`));

        if (katexSpans.length > 0) {

             katexSpans.forEach((el) => {
                 if (!el.parentNode) return;
                 const placeholder = `${KATEX_PLACEHOLDER_PREFIX}${placeholderIndex++}`;
                 storedKatexNodes[placeholder] = el.cloneNode(true);

                 try {
                     el.parentNode.replaceChild(document.createTextNode(placeholder), el);

                 } catch (replaceError) {
                     console.error(`[DEBUG] Error replacing KaTeX node with placeholder ${placeholder}:`, replaceError, "Node:", el);

                     try { el.parentNode.removeChild(el); } catch(removeError) { console.error("Failed to remove problematic KaTeX node:", removeError); }
                 }
             });

             textForMarkdown = currentAnswerElement.innerHTML;

        } else {

              if (hasVisualContent && hasAccumulatedContent) {
                  console.log("[DEBUG formatAnswerBubbleFinal] No KaTeX found, clearing visual DOM and using accumulated text for Markdown.");
                  currentAnswerElement.innerHTML = '';
              } else if (!hasAccumulatedContent && hasVisualContent) {
                  console.log("[DEBUG formatAnswerBubbleFinal] No KaTeX found, using existing innerHTML for Markdown.");
                  textForMarkdown = currentAnswerElement.innerHTML;
              } else {

              }
        }


         if (textForMarkdown.trim().length === 0) {

         } else {

             const markdownHtml = marked.parse(textForMarkdown, {
                 mangle: false, headerIds: false, gfm: true, breaks: true, sanitize: false
             });


             currentAnswerElement.innerHTML = markdownHtml;
             lastAppendedNode = null;
         }


         if (Object.keys(storedKatexNodes).length > 0) {

             const walker = document.createTreeWalker(currentAnswerElement, NodeFilter.SHOW_TEXT);
             let node;
             const textNodesContainingPlaceholders = [];
             while (node = walker.nextNode()) {
                 if (node.nodeValue && node.nodeValue.includes(KATEX_PLACEHOLDER_PREFIX)) {
                     textNodesContainingPlaceholders.push(node);
                 }
             }

             textNodesContainingPlaceholders.forEach(textNode => {
                  let currentNodeValue = textNode.nodeValue;
                  let parent = textNode.parentNode;
                  if (!parent) return;

                  let lastNodeInserted = textNode;

                  for (const placeholder in storedKatexNodes) {
                       if (currentNodeValue.includes(placeholder)) {
                           const parts = currentNodeValue.split(placeholder);
                           let firstPart = parts.shift();

                           if (firstPart) {
                                parent.insertBefore(document.createTextNode(firstPart), lastNodeInserted);
                           }
                           const katexNode = storedKatexNodes[placeholder].cloneNode(true);
                           parent.insertBefore(katexNode, lastNodeInserted);

                           currentNodeValue = parts.join(placeholder);
                       }
                  }

                  if (currentNodeValue) {
                       parent.insertBefore(document.createTextNode(currentNodeValue), lastNodeInserted);
                  }
                  parent.removeChild(lastNodeInserted);
             });

         } else {

         }

    } catch (error) {
        console.error("Error during final Markdown/KaTeX formatting:", error);
        addErrorMessage("Failed to perform final message formatting.");

        if (currentAnswerElement && accumulatedAnswerText.trim().length > 0) {
             console.warn("Attempting fallback to raw accumulated text due to formatting error.");
             currentAnswerElement.textContent = accumulatedAnswerText;
        }
    }


    accumulatedAnswerText = '';

}

function resetStreamingState() {
    console.log("[DEBUG] Resetting streaming state.");
    currentProcessingMode = MODE_ANSWER;
    langBuffer = ''; currentCodeBlockLang = '';
    currentCodeBlockElement = null; currentCodeBlockPreElement = null;
    katexBuffer = ''; currentKatexMarkerId = null;
    thinkBuffer = ''; tagBuffer = '';
    lastAppendedNode = null;
    thinkingRequestedForCurrentTurn = false; // <<< FIX: Reset the flag here for the next turn

}

function renderAndReplaceKatex(isDisplay, markerId) {

    if (!currentAnswerElement || !markerId || katexBuffer === null || katexBuffer === undefined) {
        console.error("[KaTeX Replace Marker] Error: Invalid state (element, markerId, or buffer). MarkerID:", markerId, "Buffer:", katexBuffer);

        if (markerId && currentAnswerElement) {
             try {
                 const strayMarker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);
                 if (strayMarker?.parentNode) strayMarker.parentNode.removeChild(strayMarker);
             } catch (e) { console.error("Error cleaning stray marker:", e); }
        }
        katexBuffer = '';

        return false;
    }


    const trimmedKatexBuffer = katexBuffer.trim();




    try {

        const stringToRender = trimmedKatexBuffer.length > 0 ? trimmedKatexBuffer : " ";
        const katexHtml = katex.renderToString(stringToRender, {
            displayMode: isDisplay,
            throwOnError: false,
            output: "html",
            strict: false
        });


        if (katexHtml.includes('katex-error') && trimmedKatexBuffer.length > 0) {
            console.warn(`[KaTeX Replace Marker] KaTeX reported a rendering error for buffer: "${trimmedKatexBuffer}". Marker ID: ${markerId}. Raw text will remain.`);

             try {
                 const marker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);
                 if (marker?.parentNode) marker.parentNode.removeChild(marker);
                 else console.warn("Couldn't find marker to clean up after render error.");
             } catch (cleanupError) { console.error("Error during marker cleanup after render error:", cleanupError); }
            katexBuffer = '';

            return false;
        }




        const startMarker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);

        if (!startMarker) {
            console.error(`[KaTeX Replace Marker] Error: Cannot find start marker span with ID: ${markerId}. Aborting replacement. Content might be inconsistent.`);
            katexBuffer = '';

            return false;
        }

        if (!startMarker.parentNode) {
             console.error(`[KaTeX Replace Marker] Error: Start marker span with ID ${markerId} found but has no parent (already removed?). Aborting.`);
             katexBuffer = '';

             return false;
        }

        const parent = startMarker.parentNode;
        let nodesToRemove = [];
        let currentNode = startMarker.nextSibling;




        while (currentNode) {
            nodesToRemove.push(currentNode);

            if (nodesToRemove.length > 1000) {
                console.error("[KaTeX Replace Marker] Error: Excessive node collection limit reached (1000). Aborting replacement.");
                 try { parent.removeChild(startMarker); } catch(e){}
                 katexBuffer = '';
                 return false;
            }
            currentNode = currentNode.nextSibling;
        }



        const katexSpan = document.createElement('span');
        katexSpan.setAttribute(KATEX_RENDERED_ATTR, 'true');
        katexSpan.innerHTML = katexHtml;


        parent.insertBefore(katexSpan, startMarker);

        parent.removeChild(startMarker);


        nodesToRemove.forEach(node => {
            if (node.parentNode === parent) {
                parent.removeChild(node);
            } else {
                console.warn("[KaTeX Replace Marker] Node parent changed or node removed unexpectedly during collection, skipping removal:", node);
            }
        });


        appendToAnswer(null, katexSpan);


        katexBuffer = '';

        return true;

    } catch (error) {
        console.error("[KaTeX Replace Marker] General error during marker-based replacement:", error);

        try {
            const marker = currentAnswerElement?.querySelector(`span[data-katex-start-id="${markerId}"]`);
            if (marker?.parentNode) marker.parentNode.removeChild(marker);
        } catch (cleanupError) { console.error("Error during marker cleanup after general error:", cleanupError); }
        katexBuffer = '';

        return false;
    }
}

function finalizeTurnOnErrorOrClose() {
    console.log("[DEBUG] finalizeTurnOnErrorOrClose called.");
    if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK && currentCodeBlockElement) {
        console.warn("Stream ended unexpectedly inside code block. Finalizing highlight.");
        try { finalizeCodeBlock(true); } catch (e) { console.error("Prism highlight error on close:", e); }
    }
    if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE ||
        currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY ||
        currentProcessingMode === MODE_MAYBE_START_DISPLAY_KATEX) {
        console.warn("Stream ended unexpectedly inside KaTeX block. Processing raw text.");

        if (currentKatexMarkerId) {
            renderAndReplaceKatex(currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY, currentKatexMarkerId);
            currentKatexMarkerId = null;
        }
    }
     if (currentProcessingMode === MODE_INSIDE_THINK || currentProcessingMode === MODE_MAYBE_END_THINK || currentProcessingMode === MODE_SEEKING_TAG) {
          console.warn("Stream ended unexpectedly inside/seeking Think tags. Finishing think buffer:", thinkBuffer);
          if (currentThinkingArea && currentThinkingArea.style.display !== 'none' && currentThinkingPreElement) {
               appendRawTextToThinkingArea("\n--- (Stream ended unexpectedly during thinking) ---");
          }
     }

    formatAnswerBubbleFinal();
    resetStreamingState(); // <<< This now resets thinkingRequestedForCurrentTurn
    setInputDisabledState(true);
}

function createCodeBlockStructure(language) {
    if (!currentCodeBlocksArea) {
        console.error("Code blocks area is null!");
        return;
    }
    codeBlockCounterThisTurn++;
    const currentCodeNumber = codeBlockCounterThisTurn; // Store for use in output header

    const blockId = `code-block-turn${currentTurnId}-${currentCodeNumber}`;
    const safeLanguage = (language || '').trim().toLowerCase() || 'plain';

    // Language mapping for PrismJS highlighting
    const langAlias = {
        'python': 'python', 'py': 'python',
        'javascript': 'javascript', 'js': 'javascript',
        'html': 'markup', 'xml': 'markup', 'svg': 'markup',
        'css': 'css',
        'bash': 'bash', 'sh': 'bash', 'shell': 'bash',
        'json': 'json',
        'yaml': 'yaml', 'yml': 'yaml',
        'markdown': 'markdown', 'md': 'markdown',
        'sql': 'sql',
        'java': 'java',
        'c': 'c',
        'cpp': 'cpp', 'c++': 'cpp',
        'csharp': 'csharp', 'cs': 'csharp',
        'go': 'go',
        'rust': 'rust',
        'php': 'php',
        'ruby': 'ruby', 'rb': 'ruby',
        'dockerfile': 'docker', 'docker': 'docker',
        'typescript': 'typescript', 'ts': 'typescript',
        'plaintext': 'plain', 'text': 'plain',
     };
    const prismLang = langAlias[safeLanguage] || safeLanguage;
    const displayLang = safeLanguage;

    // --- SVG Icons ---
    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;
    // Stop/Stopping SVGs defined locally in handlers where needed

    // --- Main Container ---
    const container = document.createElement('div');
    container.classList.add('code-block-container');
    container.id = blockId;
    container.dataset.language = safeLanguage;

    // --- Code Header ---
    const codeHeader = document.createElement('div');
    codeHeader.classList.add('code-block-header'); // Use existing class

    // Code Header - Buttons Div (Left)
    const codeButtonsDiv = document.createElement('div');
    codeButtonsDiv.classList.add('code-block-buttons');

    const runStopBtn = document.createElement('button');
    runStopBtn.classList.add('run-code-btn', 'code-action-btn');
    runStopBtn.dataset.status = 'idle';
    runStopBtn.innerHTML = playIconSvg;
    runStopBtn.title = 'Run Code';

    const toggleCodeBtn = document.createElement('button');
    toggleCodeBtn.classList.add('toggle-code-btn', 'code-action-btn');
    toggleCodeBtn.textContent = 'Hide';
    toggleCodeBtn.title = 'Show/Hide Code';

    const copyCodeBtn = document.createElement('button');
    copyCodeBtn.classList.add('copy-code-btn', 'code-action-btn');
    copyCodeBtn.textContent = 'Copy';
    copyCodeBtn.title = 'Copy Code';

    codeButtonsDiv.appendChild(runStopBtn);
    codeButtonsDiv.appendChild(toggleCodeBtn);
    codeButtonsDiv.appendChild(copyCodeBtn);

    // Code Header - Title (Takes remaining space)
    const codeTitle = document.createElement('span');
    codeTitle.classList.add('code-block-title');
    codeTitle.textContent = `Code ${currentCodeNumber} (${displayLang})`;
    codeTitle.style.flexGrow = '1';
    codeTitle.style.textAlign = 'left';

    // Assemble Code Header
    codeHeader.appendChild(codeButtonsDiv);
    codeHeader.appendChild(codeTitle);

    // --- Code Area ---
    const preElement = document.createElement('pre');
    preElement.classList.add('manual');
    const codeElement = document.createElement('code');
    codeElement.classList.add(`language-${prismLang}`);
    codeElement.setAttribute('contenteditable', 'true');
    codeElement.setAttribute('spellcheck', 'false');

    currentCodeBlockPreElement = preElement;
    currentCodeBlockElement = codeElement;

    // --- Output Header ---
    const outputHeader = document.createElement('div');
    outputHeader.classList.add('code-output-header');
    outputHeader.style.display = 'none'; // Initially hidden

    // Output Header - Buttons (Far Left) - Create first
    const outputButtonsDiv = document.createElement('div');
    // Reuse same class as code header buttons for consistent styling
    outputButtonsDiv.classList.add('code-block-buttons'); // CHANGED CLASS

    // ADD PLACEHOLDER SPAN for alignment
    const placeholderSpan = document.createElement('span');
    placeholderSpan.classList.add('output-header-button-placeholder');
    outputButtonsDiv.appendChild(placeholderSpan); // Add placeholder first

    const toggleOutputBtn = document.createElement('button');
    toggleOutputBtn.classList.add('toggle-output-btn', 'code-action-btn');
    toggleOutputBtn.textContent = 'Hide';
    toggleOutputBtn.title = 'Show/Hide Output';

    const copyOutputBtn = document.createElement('button');
    copyOutputBtn.classList.add('copy-output-btn', 'code-action-btn');
    copyOutputBtn.textContent = 'Copy';
    copyOutputBtn.title = 'Copy Output';

    outputButtonsDiv.appendChild(toggleOutputBtn);
    outputButtonsDiv.appendChild(copyOutputBtn);

    // Output Header - Title (Middle) - Create second
    const outputTitle = document.createElement('span');
    outputTitle.classList.add('output-header-title');
    outputTitle.textContent = `Output Code ${currentCodeNumber}`;

    // Output Header - Status Span (Far Right) - Create third
    const codeStatusSpan = document.createElement('span');
    codeStatusSpan.classList.add('code-status-span');
    codeStatusSpan.textContent = 'Idle'; // Initial status

    // Assemble Output Header (NEW ORDER)
    outputHeader.appendChild(outputButtonsDiv); // Buttons first
    outputHeader.appendChild(outputTitle);      // Title next
    outputHeader.appendChild(codeStatusSpan); // Status last (will be pushed right by CSS)


    // --- Output Console Area ---
    const outputConsoleDiv = document.createElement('div');
    outputConsoleDiv.classList.add('code-output-console');
    outputConsoleDiv.style.display = 'none'; // Initially hidden
    const outputPre = document.createElement('pre');
    outputConsoleDiv.appendChild(outputPre);

    // --- Assemble Container ---
    preElement.appendChild(codeElement);
    container.appendChild(codeHeader);
    container.appendChild(preElement);
    container.appendChild(outputHeader); // Add output header
    container.appendChild(outputConsoleDiv);

    // --- Event Listeners ---
    toggleCodeBtn.addEventListener('click', () => {
        const isHidden = preElement.classList.toggle('hidden');
        toggleCodeBtn.textContent = isHidden ? 'Show' : 'Hide';
    });

    copyCodeBtn.addEventListener('click', async () => {
         if (!codeElement) return;
        try {
            await navigator.clipboard.writeText(codeElement.textContent || '');
            copyCodeBtn.textContent = 'Copied!';
            copyCodeBtn.classList.add('copied');
            setTimeout(() => { copyCodeBtn.textContent = 'Copy'; copyCodeBtn.classList.remove('copied'); }, 1500);
        } catch (err) {
            console.error('Failed to copy code: ', err);
            copyCodeBtn.textContent = 'Error';
            setTimeout(() => { copyCodeBtn.textContent = 'Copy'; }, 1500);
        }
    });

    runStopBtn.addEventListener('click', handleRunStopCodeClick);

    // Listener for debounced highlighting on code edit
    const debouncedHighlight = debounce(() => {
         console.log(`Highlighting ${blockId} after edit.`);
        const savedPosition = getCursorPosition(codeElement);
        if (savedPosition === -1) { console.warn("Could not save cursor position or cursor not in element. Highlight may cause cursor jump."); }
        try {
            const tokens = codeElement.querySelectorAll('span[class*="token"]');
            tokens.forEach(span => {
                if (span.textContent) { span.replaceWith(document.createTextNode(span.textContent)); } else { span.remove(); }
            });
            codeElement.normalize();
            Prism.highlightElement(codeElement);
            if (savedPosition !== -1) { setCursorPosition(codeElement, savedPosition); }
        } catch (e) {
            console.error("Error during debounced highlighting:", e);
            if (savedPosition !== -1) { setCursorPosition(codeElement, savedPosition); }
        }
    }, 500);
    codeElement.addEventListener('input', debouncedHighlight);
    codeElement.addEventListener('paste', (e) => { setTimeout(debouncedHighlight, 100); });

    // Output Header Button Listeners
    toggleOutputBtn.addEventListener('click', () => {
        const isHidden = outputConsoleDiv.classList.toggle('hidden');
        toggleOutputBtn.textContent = isHidden ? 'Show' : 'Hide';
    });

    copyOutputBtn.addEventListener('click', async () => {
        if (!outputPre) return;
        try {
            await navigator.clipboard.writeText(outputPre.textContent || '');
            copyOutputBtn.textContent = 'Copied!';
            copyOutputBtn.classList.add('copied');
            setTimeout(() => { copyOutputBtn.textContent = 'Copy'; copyOutputBtn.classList.remove('copied'); }, 1500);
        } catch (err) {
            console.error('Failed to copy output: ', err);
            copyOutputBtn.textContent = 'Error';
            setTimeout(() => { copyOutputBtn.textContent = 'Copy'; }, 1500);
        }
    });

    // --- Append to DOM ---
    currentCodeBlocksArea.appendChild(container);
    lastAppendedNode = null;
}

async function handleRunStopCodeClick(event) {
    const button = event.currentTarget; // This is the run/stop button in code header
    const container = button.closest('.code-block-container');
    if (!container) return;

    const codeBlockId = container.id;
    const language = container.dataset.language;
    const codeElement = container.querySelector('code');
    const outputHeader = container.querySelector('.code-output-header'); // Get output header
    const outputConsoleDiv = container.querySelector('.code-output-console');
    const outputPre = outputConsoleDiv ? outputConsoleDiv.querySelector('pre') : null;
    // Find the status span within the OUTPUT header now
    const statusSpan = outputHeader ? outputHeader.querySelector('.code-status-span') : null;

    if (!language || !codeElement || !outputHeader || !outputConsoleDiv || !outputPre || !statusSpan) {
        console.error(`Missing elements for code block ${codeBlockId}`);
        addErrorMessage(`Cannot run code block ${codeBlockId}: Internal UI error.`);
        return;
    }

    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;
    const stopIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><rect width="100" height="100" rx="15"/></svg>`;
    const stoppingIconSvg = `<svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: block;"><path d="M12 2V6M12 18V22M6 12H2M22 12H18M19.0711 4.92893L16.2426 7.75736M7.75736 16.2426L4.92893 19.0711M19.0711 19.0711L16.2426 16.2426M7.75736 7.75736L4.92893 4.92893" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;

    const code = codeElement.textContent || '';
    const currentStatus = button.dataset.status;

    if (!websocket || websocket.readyState !== WebSocket.OPEN) {
        console.warn("WebSocket not open. Cannot run/stop code.");
        // Update status in output header
        statusSpan.textContent = 'Error: Disconnected';
        statusSpan.className = 'code-status-span error';
        outputHeader.style.display = 'flex'; // Show output header for error
        addErrorMessage("Cannot run/stop code: Not connected to server.");
        return;
    }

    if (currentStatus === 'idle') {
        // --- Request to Run Code ---
        console.log(`Requesting run for block ${codeBlockId} (${language})`);
        button.dataset.status = 'running';
        button.innerHTML = stopIconSvg;
        button.title = 'Stop Execution';

        // Clear previous output and SHOW output header & console
        outputPre.innerHTML = '';
        outputHeader.style.display = 'flex'; // Use flex to show header
        outputConsoleDiv.style.display = 'block'; // Show console
        outputConsoleDiv.classList.remove('hidden');
        const toggleOutputBtn = outputHeader.querySelector('.toggle-output-btn');
        if (toggleOutputBtn) toggleOutputBtn.textContent = 'Hide';

        // Update status span in output header
        statusSpan.textContent = 'Running...';
        statusSpan.className = 'code-status-span running';

        websocket.send(JSON.stringify({
            type: 'run_code',
            payload: { code_block_id: codeBlockId, language: language, code: code }
        }));

    } else if (currentStatus === 'running') {
        // --- Request to Stop Code ---
        console.log(`Requesting stop for block ${codeBlockId}`);
        button.dataset.status = 'stopping';
        button.innerHTML = stoppingIconSvg;
        button.title = 'Stopping...';
        button.disabled = true;

        // Update status span in output header
        statusSpan.textContent = 'Stopping...';
        statusSpan.className = 'code-status-span stopping';

        websocket.send(JSON.stringify({
            type: 'stop_code',
            payload: { code_block_id: codeBlockId }
        }));
    } else if (currentStatus === 'stopping') {
        console.log(`Already stopping block ${codeBlockId}`);
    }
}

function addCodeOutput(outputPreElement, streamType, text) {
    // streamType is 'stdout' or 'stderr'
    if (!outputPreElement || !text) return;

    const span = document.createElement('span');
    // Add class based on stream type for potential specific styling (e.g., red for stderr)
    span.classList.add(streamType === 'stderr' ? 'stderr-output' : 'stdout-output');
    span.textContent = text; // Append the raw text
    outputPreElement.appendChild(span);

    // Auto-scroll the specific pre element
    outputPreElement.scrollTop = outputPreElement.scrollHeight;
}

function appendToCodeBlock(text) {
    if (currentCodeBlockElement) {
        // Directly append text node - more reliable with contenteditable
        currentCodeBlockElement.appendChild(document.createTextNode(text));

        // Scroll the <pre> element if needed
        if(currentCodeBlockPreElement && !currentCodeBlockPreElement.classList.contains('hidden')) {
            const isNearCodeBottom = currentCodeBlockPreElement.scrollHeight - currentCodeBlockPreElement.scrollTop - currentCodeBlockPreElement.clientHeight < 50;
            if(isNearCodeBottom) {
                requestAnimationFrame(() => { currentCodeBlockPreElement.scrollTop = currentCodeBlockPreElement.scrollHeight; });
            }
        }
        // --- REMOVED throttled highlighting call ---
    } else {
        console.error("Attempted to append to null code block element!");
    }
}

function appendToAnswer(text = null, node = null) {
    if (!currentAnswerElement) return;


    let isMeaningfulContent = (text && text.trim().length > 0) ||
                               (node && node.nodeType !== Node.COMMENT_NODE && (!node.textContent || node.textContent.trim().length > 0));



    if (!firstAnswerTokenReceived && isMeaningfulContent) {
         console.log("[appendToAnswer] First meaningful answer content received.");

         if (currentAnswerElement.style.display === 'none') {
             console.log("[appendToAnswer] Making answer element visible.");
             currentAnswerElement.style.display = '';
         }

         const loadingDots = currentAnswerElement.querySelector('.loading-dots');
         if (loadingDots) {
             console.log("[appendToAnswer] Removing loading dots.");
             loadingDots.remove();
         }
         firstAnswerTokenReceived = true;
    }



    if (node) {

        if (!node.classList || !node.classList.contains('loading-dots')) {
             currentAnswerElement.appendChild(node);
             lastAppendedNode = node;
        }
    } else if (text !== null && text.length > 0) {
        accumulatedAnswerText += text;


        if (lastAppendedNode && lastAppendedNode.nodeType === Node.TEXT_NODE && lastAppendedNode.parentNode === currentAnswerElement) {
            lastAppendedNode.nodeValue += text;
        } else {
            const textNode = document.createTextNode(text);
            currentAnswerElement.appendChild(textNode);
            lastAppendedNode = textNode;
        }
    }
}

function finalizeCodeBlock(isTruncated = false) {
    if (currentCodeBlockElement) {
        console.log(`Finalizing and highlighting code block: ${currentCodeBlockElement.closest('.code-block-container')?.id}`);
        try {
            // Ensure normalization before final highlight
            currentCodeBlockElement.normalize();
            Prism.highlightElement(currentCodeBlockElement);
        } catch (e) {
            console.error(`Prism highlight error on finalize (lang '${currentCodeBlockLang}'):`, e);
        }
    } else {
         console.warn("finalizeCodeBlock called but currentCodeBlockElement is null.");
    }
    // Reset tracking variables
    currentCodeBlockElement = null;
    currentCodeBlockPreElement = null;
    currentCodeBlockLang = '';
}

function resetAllCodeButtonsOnErrorOrClose() {
    console.log("Resetting all code run/stop buttons and statuses due to connection issue.");
    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;

    document.querySelectorAll('.code-block-container').forEach(container => {
        const button = container.querySelector('.run-code-btn'); // Button in code header
        const outputHeader = container.querySelector('.code-output-header');
        const statusSpan = outputHeader ? outputHeader.querySelector('.code-status-span') : null; // Status in output header

        // Reset Run/Stop button in code header
        if (button && button.dataset.status !== 'idle') {
            button.dataset.status = 'idle';
            button.innerHTML = playIconSvg;
            button.title = 'Run Code';
            button.disabled = false;
        }
        // Reset status span in output header
        if (statusSpan) {
             if (!statusSpan.classList.contains('idle') && !statusSpan.classList.contains('success')) {
                 // Show output header if hiding status due to error
                 if (outputHeader) outputHeader.style.display = 'flex';
                 statusSpan.textContent = 'Error: Disconnected';
                 statusSpan.className = 'code-status-span error';
             }
        }
    });
}

function connectWebSocket() {

    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${window.location.host}/ws/${clientId}`;
    console.log(`[DEBUG] Attempting to connect to WebSocket: ${wsUrl}`);

    // --- Define SVGs globally for this function scope ---
    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;
    // Note: Stop and Stopping SVGs are defined locally where needed (handleRunStopCodeClick, onmessage)

    try {
        const ws = new WebSocket(wsUrl);
        console.log('connectWebSocket: Creating WebSocket object...');

        ws.onopen = (event) => {
            console.log("[DEBUG] WebSocket connection opened. ws object:", ws);
            websocket = ws; // Assign the opened websocket to the global variable

            // Critical check for required helper functions
            if (typeof addSystemMessage !== 'function' || typeof setupNewAiTurn !== 'function' || typeof appendToAnswer !== 'function' || typeof formatAnswerBubbleFinal !== 'function' || typeof resetStreamingState !== 'function' || typeof setInputDisabledState !== 'function') {
                console.error("CRITICAL ERROR: One or more required helper functions are not defined when ws.onopen is called. Check script order.");
                alert("Chat initialization failed. Please refresh the page. (Error: Helpers undefined)");
                setInputDisabledState(true); // Disable input if init fails
                return;
            }

            setInputDisabledState(false); // Enable input fields now that we are connected
            addSystemMessage("Connected to the chat server.");


            console.log("[DEBUG ws.onopen] Setting up initial AI turn for welcome message.");
            thinkingRequestedForCurrentTurn = false; // Initial greeting never requires thinking display
            setupNewAiTurn(); // Setup the UI containers for the first AI message
            const welcomeMessage = "Hello! How can I help you today?";
            appendToAnswer(welcomeMessage); // Add the welcome text
            formatAnswerBubbleFinal(); // Finalize this simple welcome message bubble
            console.log("[DEBUG ws.onopen] Resetting state after welcome message.");
            resetStreamingState(); // Reset modes and buffers for the user's first input

            // Focus the input field if it's visible
            if(messageInput && messageInput.offsetParent !== null) messageInput.focus();
        };


        ws.onmessage = (event) => {
            // --- Check if it's a JSON message for code execution ---
            let isJsonMessage = false;
            let messageData = null;
            try {
                // Only attempt parse if data looks like JSON (starts with {)
                if (typeof event.data === 'string' && event.data.startsWith('{')) {
                    messageData = JSON.parse(event.data);
                    // Basic validation for code execution messages
                    if (messageData && messageData.type && messageData.payload && messageData.payload.code_block_id) {
                        isJsonMessage = true;
                    }
                }
            } catch (e) {
                // Not JSON or doesn't match expected structure, treat as regular chat chunk
                isJsonMessage = false;
            }

            if (isJsonMessage) {
                // --- Handle Code Execution Messages ---
                console.log("%c[ws.onmessage] Code Execution JSON received:", "color: blue;", messageData);
                const { type, payload } = messageData;
                const { code_block_id } = payload;
                const container = document.getElementById(code_block_id);

                if (!container) {
                    console.warn(`Received message for unknown code block ID: ${code_block_id}`, payload);
                    return; // Ignore if we can't find the block
                }

                // Find associated elements safely
                const outputHeader = container.querySelector('.code-output-header'); // Get output header
                const outputConsoleDiv = container.querySelector('.code-output-console');
                const outputPre = outputConsoleDiv ? outputConsoleDiv.querySelector('pre') : null;
                const runStopBtn = container.querySelector('.run-code-btn'); // Button in code header
                // Find status span in OUTPUT header
                const statusSpan = outputHeader ? outputHeader.querySelector('.code-status-span') : null;

                // Check outputHeader too
                if (!outputHeader || !outputPre || !runStopBtn || !statusSpan) {
                     console.error(`Missing elements for code block ${code_block_id}. Cannot process message.`);
                     return; // Stop processing if UI elements are missing
                }

                switch (type) {
                    case 'code_output':
                        const { stream, data } = payload; // stream: 'stdout' or 'stderr'

                        // Ensure output header/console are visible if receiving output
                        if (outputHeader.style.display === 'none') {
                            console.log(`Showing output header for ${code_block_id} on first output.`);
                            outputHeader.style.display = 'flex'; // Use flex to show header
                        }
                        if (outputConsoleDiv.style.display === 'none') {
                            console.log(`Showing output console for ${code_block_id} on first output.`);
                            outputConsoleDiv.style.display = 'block'; // Show console
                            outputConsoleDiv.classList.remove('hidden'); // Ensure hidden class is removed
                             // Reset toggle button text
                            const toggleOutputBtn = outputHeader.querySelector('.toggle-output-btn');
                            if (toggleOutputBtn) toggleOutputBtn.textContent = 'Hide';
                        }

                        // Force button/status to running if needed
                        if (runStopBtn.dataset.status === 'idle'){
                             // Define Stop SVG here as it's needed for this state transition
                             const stopIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><rect width="100" height="100" rx="15"/></svg>`;
                             console.warn(`Received code output for ${code_block_id} while button was idle. Forcing state to running.`);
                             runStopBtn.dataset.status = 'running';
                             runStopBtn.innerHTML = stopIconSvg; // Set Stop SVG icon
                             runStopBtn.title = 'Stop Execution';
                             runStopBtn.disabled = false;
                             // Update status span in OUTPUT header
                             statusSpan.textContent = 'Running...';
                             statusSpan.className = 'code-status-span running';
                        }
                        // Append ONLY stdout/stderr data to the output console
                        addCodeOutput(outputPre, stream, data); // Pass stream type
                        break;

                    case 'code_finished':
                        // Ensure output header is visible if it wasn't already
                        // (e.g., if execution finished instantly with no output)
                        if (outputHeader.style.display === 'none') {
                            console.log(`Showing output header for ${code_block_id} on finish.`);
                            outputHeader.style.display = 'flex';
                        }
                        // Ensure console is visible if it wasn't (might still be empty)
                         if (outputConsoleDiv.style.display === 'none') {
                            console.log(`Showing output console for ${code_block_id} on finish.`);
                            outputConsoleDiv.style.display = 'block';
                            outputConsoleDiv.classList.remove('hidden');
                             const toggleOutputBtn = outputHeader.querySelector('.toggle-output-btn');
                            if (toggleOutputBtn) toggleOutputBtn.textContent = 'Hide';
                        }

                        const { exit_code, error } = payload;
                        let finishMessage = '';
                        let statusClass = '';

                        // Determine status message and class based on result
                        if (error) {
                            if (error === "Execution stopped by user.") {
                                finishMessage = 'Stopped'; statusClass = 'stopped';
                            } else if (error.startsWith("Execution timed out")) {
                                 finishMessage = 'Timeout'; statusClass = 'error';
                            } else {
                                 finishMessage = `Error (${exit_code !== undefined ? exit_code : 'N/A'})`; statusClass = 'error';
                                 console.error(`Execution error for ${code_block_id}:`, error);
                            }
                        } else {
                            finishMessage = `Finished (Exit: ${exit_code})`;
                            statusClass = exit_code === 0 ? 'success' : 'error'; // Success only if exit code is 0
                        }

                        // Update status span in OUTPUT header
                        statusSpan.textContent = finishMessage;
                        statusSpan.className = `code-status-span ${statusClass}`;

                        // Reset the run/stop button (in code header) to idle/play state
                        runStopBtn.dataset.status = 'idle';
                        runStopBtn.innerHTML = playIconSvg; // Use SVG defined in outer scope
                        runStopBtn.title = 'Run Code';
                        runStopBtn.disabled = false;
                        // Let CSS handle button color via data-status

                        break;

                    default:
                        console.warn(`Received unknown code execution message type: ${type}`, payload);
                }

            } else {
                // --- Handle Regular Chat Message Streaming (Using State Machine) ---
                console.log("%c[ws.onmessage] RAW chat data received:", "color: magenta;", event.data);
                let chunk = event.data;
                const currentTurnIdForMsg = currentTurnId; // Capture turn ID for logging context

                // --- Handle Control Messages First ---
                if (chunk === "<EOS>") {
                    console.log(`%c[ws.onmessage] Turn ${currentTurnIdForMsg}: Received <EOS>. Finalizing turn.`, 'color: green; font-weight: bold;');
                    // If ended inside a state that needs cleanup, handle it
                    if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK) {
                         console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received inside code block. Appending fence buffer and finalizing.`);
                         if (fenceBuffer.length > 0) appendToCodeBlock(fenceBuffer); // Append incomplete fence
                         try { finalizeCodeBlock(true); } catch (e) { console.error("Error finalizing code block on EOS:", e); } // Pass true for truncated
                    } else if (currentProcessingMode === MODE_SEEKING_CODE_END_FENCE) { // Check for this mode on EOS
                         console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received while seeking end fence. Treating '${fenceBuffer}' as code.`);
                         appendToCodeBlock(fenceBuffer); // Append partial fence as code
                         finalizeCodeBlock(true); // Finalize truncated block
                    } else if (currentProcessingMode === MODE_SEEKING_CODE_LANGUAGE && langBuffer.length > 0) {
                         console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received while seeking language. Treating '${FENCE + langBuffer}' as text.`);
                         appendToAnswer(FENCE + langBuffer);
                    } else if (currentProcessingMode === MODE_SEEKING_CODE_START_FENCE && fenceBuffer.length > 0) {
                         console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received while seeking start fence. Treating '${fenceBuffer}' as text.`);
                         appendToAnswer(fenceBuffer);
                    } else if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE || currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY) {
                         console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received inside KaTeX buffer. Attempting render.`);
                         if (currentKatexMarkerId) { renderAndReplaceKatex(currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY, currentKatexMarkerId); currentKatexMarkerId = null; }
                    } else if (currentProcessingMode === MODE_INSIDE_THINK || currentProcessingMode === MODE_MAYBE_END_THINK || currentProcessingMode === MODE_SEEKING_TAG) {
                          console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly inside/seeking Think tags. Last mode: ${currentProcessingMode}`);
                          if (thinkingRequestedForCurrentTurn && currentThinkingArea && currentThinkingPreElement) { appendRawTextToThinkingArea("\n--- (EOS received mid-think) ---"); }
                    }

                    formatAnswerBubbleFinal(); // Format accumulated chat content
                    resetStreamingState();     // Reset modes, buffers, and thinking flag for next turn
                    setInputDisabledState(false); // Re-enable input
                    if (messageInput && messageInput.offsetParent !== null) { messageInput.focus(); }
                    setTimeout(() => scrollToBottom('smooth'), 50);
                    return; // Stop processing this message
                }
                if (chunk.startsWith("<ERROR>")) {
                    const errorMessage = chunk.substring(7);
                    console.error(`[ws.onmessage] Turn ${currentTurnIdForMsg}: Received <ERROR>:`, errorMessage);
                    addErrorMessage(errorMessage); // Display error in chat area
                    finalizeTurnOnErrorOrClose(); // Finalize formatting, reset state, disable input for chat
                    resetAllCodeButtonsOnErrorOrClose(); // Also reset code buttons
                    setTimeout(() => scrollToBottom('smooth'), 50);
                    return; // Stop processing this message
                }

                if (chunk.length === 0) {
                     // console.log(`%c[ws.onmessage] Turn ${currentTurnIdForMsg}: Received empty chunk, ignoring.`, 'color: gray;');
                     return; // Ignore empty chunks
                }

                // Ensure AI turn structure exists for chat messages
                if (!currentAiTurnContainer) {
                    if (chunk.trim().length > 0) { // Only setup if chunk has content
                        console.warn(`%c[ws.onmessage] Turn ${currentTurnIdForMsg}: First non-empty chat chunk received, but turn container not set up? Forcing setup.`, 'color: red; font-weight: bold;');
                        // Use the thinking flag that was set when the user submitted the message
                        setupNewAiTurn();
                    } else {
                        return; // Ignore whitespace chunks if turn not set up
                    }
                }

                // --- State Machine Processing for Chat Content ---
                let currentPos = 0;
                while (currentPos < chunk.length) {
                    const char = chunk[currentPos];
                    let incrementPos = true;
                    let previousMode = currentProcessingMode; // Track previous mode for specific transitions

                    // --- Handle Escaped Characters ---
                    if (char === '\\' && currentPos + 1 < chunk.length) {
                        const nextChar = chunk[currentPos + 1];
                        const escapableChars = '$`*\\<>'; // Chars to unescape
                        if (escapableChars.includes(nextChar)) {
                            // Determine where to append the *unescaped* character based on current mode
                            if (currentProcessingMode === MODE_INSIDE_THINK) { appendRawTextToThinkingArea(nextChar); }
                            else if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE || currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY) { katexBuffer += nextChar; appendToAnswer(nextChar); }
                            else if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK) { appendToCodeBlock(nextChar); } // Append only escaped char to code block content
                            else { appendToAnswer(nextChar); } // Append only the escaped char to main answer bubble
                            currentPos += 2; // Skip both \ and the escaped char
                            incrementPos = false; // We handled position update
                            continue; // Process next character
                        }
                        // If not an escapable char, treat backslash literally (fall through)
                    }

                    // --- Chat State Machine Logic ---
                    switch (currentProcessingMode) {

                        case MODE_ANSWER:
                            // Check for start fence ```
                            if (char === FENCE[0]) {
                                if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                katexBuffer = ''; currentKatexMarkerId = null;
                                fenceBuffer = char;
                                currentProcessingMode = MODE_SEEKING_CODE_START_FENCE;
                            } else if (char === '$') {
                                if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                currentProcessingMode = MODE_MAYBE_START_DISPLAY_KATEX;
                            } else if (char === '<') {
                                 if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                tagBuffer = char;
                                currentProcessingMode = MODE_SEEKING_TAG;
                            } else {
                                if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                appendToAnswer(char);
                            }
                            break;

                        case MODE_SEEKING_CODE_START_FENCE:
                            if (char === FENCE[fenceBuffer.length]) {
                                fenceBuffer += char;
                                if (fenceBuffer === FENCE) {
                                    fenceBuffer = ''; langBuffer = '';
                                    currentProcessingMode = MODE_SEEKING_CODE_LANGUAGE;
                                }
                            } else {
                                appendToAnswer(fenceBuffer);
                                fenceBuffer = '';
                                currentProcessingMode = MODE_ANSWER;
                                incrementPos = false;
                            }
                            break;

                        case MODE_SEEKING_CODE_LANGUAGE:
                             if (char === '\n') {
                                 currentCodeBlockLang = langBuffer.trim();
                                 createCodeBlockStructure(currentCodeBlockLang);
                                 appendCodeReference();
                                 langBuffer = '';
                                 currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                             } else if (langBuffer.length > 50) {
                                 console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: Code language line too long. Treating as text.`);
                                 appendToAnswer(FENCE + langBuffer + char);
                                 langBuffer = ''; fenceBuffer = '';
                                 currentProcessingMode = MODE_ANSWER;
                             } else {
                                 langBuffer += char;
                             }
                             break;

                        case MODE_INSIDE_CODE_BLOCK:
                            if (char === FENCE[0]) {
                                fenceBuffer = char;
                                currentProcessingMode = MODE_SEEKING_CODE_END_FENCE;
                            } else {
                                appendToCodeBlock(char);
                            }
                            break;

                        case MODE_SEEKING_CODE_END_FENCE:
                            if (char === FENCE[fenceBuffer.length]) {
                                fenceBuffer += char;
                                if (fenceBuffer === FENCE) {
                                    finalizeCodeBlock();
                                    fenceBuffer = '';
                                    currentProcessingMode = MODE_ANSWER;
                                    lastAppendedNode = null;
                                    if (currentPos + 1 < chunk.length && chunk[currentPos + 1] === '\n') {
                                        currentPos++;
                                        incrementPos = true;
                                    }
                                }
                            } else {
                                appendToCodeBlock(fenceBuffer);
                                fenceBuffer = '';
                                currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                                incrementPos = false;
                            }
                            break;

                        case MODE_MAYBE_START_DISPLAY_KATEX:
                            if (char === '$') {
                                currentKatexMarkerId = `katex-marker-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
                                const startMarkerDisp = document.createElement('span');
                                startMarkerDisp.setAttribute('data-katex-start-id', currentKatexMarkerId);
                                startMarkerDisp.style.display = 'none';
                                appendToAnswer(null, startMarkerDisp);
                                appendToAnswer('$$');
                                currentProcessingMode = MODE_KATEX_BUFFERING_DISPLAY;
                                katexBuffer = '';
                            } else {
                                currentKatexMarkerId = `katex-marker-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
                                const startMarkerInline = document.createElement('span');
                                startMarkerInline.setAttribute('data-katex-start-id', currentKatexMarkerId);
                                startMarkerInline.style.display = 'none';
                                appendToAnswer(null, startMarkerInline);
                                appendToAnswer('$');
                                appendToAnswer(char);
                                currentProcessingMode = MODE_KATEX_BUFFERING_INLINE;
                                katexBuffer = char;
                            }
                            break;

                        case MODE_KATEX_BUFFERING_INLINE:
                            if (char === '$') {
                                appendToAnswer('$');
                                if (currentKatexMarkerId) { renderAndReplaceKatex(false, currentKatexMarkerId); currentKatexMarkerId = null; }
                                else { console.error(`Attempted end inline KaTeX Turn ${currentTurnIdForMsg} no marker ID!`); }
                                currentProcessingMode = MODE_ANSWER;
                            } else { katexBuffer += char; appendToAnswer(char); }
                            break;

                        case MODE_KATEX_BUFFERING_DISPLAY:
                             if (char === '$' && currentPos + 1 < chunk.length && chunk[currentPos + 1] === '$') {
                                 appendToAnswer('$$');
                                 if (currentKatexMarkerId) { renderAndReplaceKatex(true, currentKatexMarkerId); currentKatexMarkerId = null; }
                                 else { console.error(`Attempted end display KaTeX Turn ${currentTurnIdForMsg} no marker ID!`); }
                                 currentProcessingMode = MODE_ANSWER; currentPos++;
                             } else { katexBuffer += char; appendToAnswer(char); }
                             break;

                        case MODE_SEEKING_TAG:
                            tagBuffer += char;
                            const lowerTag = tagBuffer.toLowerCase();
                            if (lowerTag === THINK_START_TAG) {
                                thinkBuffer = ''; currentProcessingMode = MODE_INSIDE_THINK; tagBuffer = ''; lastAppendedNode = null;
                            } else if (THINK_START_TAG.startsWith(lowerTag)) { /* Keep buffering */ }
                            else {
                                appendToAnswer(tagBuffer); currentProcessingMode = MODE_ANSWER; tagBuffer = ''; incrementPos = false;
                            }
                            if (tagBuffer.length > 20) {
                                 console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: Tag buffer excessive, treating as text: ${tagBuffer}`);
                                 appendToAnswer(tagBuffer); currentProcessingMode = MODE_ANSWER; tagBuffer = ''; incrementPos = false;
                            }
                            break;

                         case MODE_INSIDE_THINK:
                             if (char === '<') {
                                 tagBuffer = char; currentProcessingMode = MODE_MAYBE_END_THINK;
                             } else { appendRawTextToThinkingArea(char); }
                             break;

                         case MODE_MAYBE_END_THINK:
                             tagBuffer += char;
                             const lowerEndTag = tagBuffer.toLowerCase();
                             if (lowerEndTag === THINK_END_TAG) {
                                 thinkBuffer = ''; tagBuffer = ''; currentProcessingMode = MODE_ANSWER; lastAppendedNode = null;
                             } else if (THINK_END_TAG.startsWith(lowerEndTag)) { /* Keep buffering */ }
                             else {
                                 appendRawTextToThinkingArea(tagBuffer);
                                 currentProcessingMode = MODE_INSIDE_THINK; tagBuffer = ''; incrementPos = false;
                             }
                             if (tagBuffer.length > 20) {
                                  console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: End tag buffer excessive, treating as think text: ${tagBuffer}`);
                                  appendRawTextToThinkingArea(tagBuffer); currentProcessingMode = MODE_INSIDE_THINK; tagBuffer = ''; incrementPos = false;
                             }
                             break;

                        default:
                            console.error(`Unknown processing mode: ${currentProcessingMode} in Turn ${currentTurnIdForMsg}`);
                            appendToAnswer(char);
                            currentProcessingMode = MODE_ANSWER;
                    } // End Switch

                    if (incrementPos) { currentPos++; }
                } // end while loop over chunk characters
                scrollToBottom(); // Scroll chat history after processing chat chunk
            }
        }; // end ws.onmessage

        ws.onerror = (event) => {
            console.error("WebSocket error observed:", event);
            addErrorMessage("WebSocket connection error. Please check the server or try refreshing. See console for details.");
            finalizeTurnOnErrorOrClose();
            resetAllCodeButtonsOnErrorOrClose(); // This needs update
            setInputDisabledState(true);
        };

        ws.onclose = (event) => {
            console.log("WebSocket connection closed.", event);
            addSystemMessage(`Connection closed: ${event.reason || 'Normal closure'} (Code: ${event.code})`);
            finalizeTurnOnErrorOrClose();
            resetAllCodeButtonsOnErrorOrClose(); // This needs update
            if (event.code !== 1000 && event.code !== 1005) {
                console.log("Unexpected WebSocket closure. Attempting to reconnect WebSocket in 3 seconds...");
                addSystemMessage("Attempting to reconnect...");
                setInputDisabledState(true);
                setTimeout(() => { websocket = null; resetStreamingState(); currentAiTurnContainer = null; connectWebSocket(); }, 3000);
            } else { setInputDisabledState(true); }
        };

        console.log("[DEBUG] WebSocket object created and handlers assigned.");

     } catch (error) {
        console.error("[DEBUG] CRITICAL Error creating WebSocket object:", error);
        if (typeof addErrorMessage === 'function') { addErrorMessage(`WebSocket Creation Error: ${error.message}. Please check server and refresh.`); }
        else { alert(`WebSocket Creation Error: ${error.message}. Please check server and refresh.`); }
        setInputDisabledState(true);
    }
} // end connectWebSocket


if (chatForm) {
    chatForm.addEventListener('submit', (event) => {
        event.preventDefault(); // Prevent default form submission

        const userMessage = messageInput.value.trim(); // Get user text

        if (!userMessage) {
            return; // Do nothing if message is empty
        }

        // --- Check WebSocket State BEFORE Attempting Send ---
        if (!websocket || websocket.readyState !== WebSocket.OPEN) {
            console.warn("[Submit] WebSocket not ready or not defined. State:", websocket?.readyState);
            addErrorMessage("Not connected to the server. Please wait or refresh.");
            return; // Exit if not connected
        }

        // --- If WebSocket is OPEN, proceed ---
        try {
            // --- Step 1: Display User Message ---
            addUserMessage(userMessage); // Show user's raw message immediately

            // --- Step 2: Determine Thinking State & Prepare Message for Backend ---
            thinkingRequestedForCurrentTurn = thinkCheckbox ? thinkCheckbox.checked : false;
            console.log(`[Submit] Checkbox checked: ${thinkingRequestedForCurrentTurn}.`);

            let messageToSend = userMessage; // Default to the raw user message
            // Ensure NO_THINK_PREFIX constant is defined globally, e.g., const NO_THINK_PREFIX = "\\no_think";
            if (!thinkingRequestedForCurrentTurn) {
                messageToSend = NO_THINK_PREFIX + userMessage;
                console.log(`[Submit] Prepended '${NO_THINK_PREFIX}'. Prepared message: "${messageToSend.substring(0, 100)}..."`);
            } else {
                console.log(`[Submit] Prepared raw message (thinking requested): "${messageToSend.substring(0, 100)}..."`);
            }

            // --- Step 3: Setup UI for AI Response ---
            setupNewAiTurn(); // Uses thinkingRequestedForCurrentTurn for initial visibility

            // --- Step 4: Send Message to WebSocket ---
            console.log(`[Submit] Sending final message to WebSocket: "${messageToSend.substring(0, 100)}..."`); // Log before sending

            // ****** ADD THIS LINE BACK ******
            websocket.send(messageToSend);
            // ********************************

            console.log("[Submit] websocket.send() call completed."); // Optional log after successful send initiation

            // --- Step 5: Clear Input & Disable ---
            messageInput.value = '';          // Clear the input field
            setInputDisabledState(true); // Disable inputs while waiting for response
            console.log("[Submit] Input cleared and disabled.");

        } catch (sendError) {
            // --- Catch Errors During Send or Subsequent Steps ---
            console.error("[Submit] !!! ERROR during send attempt or post-send steps:", sendError);
            addErrorMessage(`Failed to send message: ${sendError.message}`);
            // Consider re-enabling input if send fails criticaly
            // setInputDisabledState(false);
        }

    }); // End of submit handler
} else {
    // Handle case where the form element itself is missing
    console.error("CRITICAL ERROR: Could not find chat form element with ID 'chat-form'. Messages cannot be sent.");
    if (typeof addErrorMessage === 'function') {
        addErrorMessage("Initialization Error: Chat input form not found.");
    } else {
        alert("Initialization Error: Chat input form not found.");
    }
}

setInputDisabledState(true);
marked.setOptions({
  gfm: true, breaks: true, sanitize: false, smartLists: true, smartypants: false,
});
connectWebSocket();



=== app/static/style.css ===
/* --- General Styles & Scrollbar --- */
html, body {
    height: 100%;
    margin: 0;
    font-family: 'Inter', sans-serif;
    background-color: #f3f4f6; /* Light gray background for the whole page */
}

#chat-history {
    flex: 1;
    overflow-y: auto;
    padding: 1rem; /* Use rem for scalable padding */
    display: flex;
    flex-direction: column;
    background-color: #ffffff; /* White background for chat area */
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
    margin: 1rem; /* Add margin around the chat history */
    border-radius: 0.5rem; /* Rounded corners */
}

/* Custom scrollbar for chat history */
#chat-history::-webkit-scrollbar { width: 8px; }
#chat-history::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
#chat-history::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
#chat-history::-webkit-scrollbar-thumb:hover { background: #555; }

/* --- Message Styling --- */
.message {
    padding: 0.5rem 0.75rem; /* Use rem */
    margin-bottom: 0.5rem;
    border-radius: 0.5rem;
    max-width: 90%;
    word-wrap: break-word;
    line-height: 1.5; /* Improve readability */
}

.user-message {
    background-color: #dbeafe; /* Tailwind blue-100 */
    align-self: flex-end;
    margin-left: auto;
    white-space: pre-wrap; /* Preserve user whitespace */
}

/* Container for a full AI turn (thinking + bubble + code blocks) */
.ai-turn-container {
    display: flex;
    flex-direction: column;
    align-items: flex-start; /* Align items to the left */
    width: 100%; /* Take full width to allow max-width on children */
    margin-bottom: 0.5rem; /* Consistent spacing */
}

.ai-message {
    background-color: #e5e7eb; /* Tailwind gray-200 */
    align-self: flex-start;
    margin-right: auto;
    max-width: 90%; /* Limit width */
    padding: 0.5rem 0.75rem; /* Added padding for consistency */
    border-radius: 0.5rem; /* Added radius for consistency */
}

/* Styling for Markdown elements rendered inside .ai-message */
.ai-message p { margin-bottom: 0.5em; }
.ai-message p:last-child { margin-bottom: 0; }
.ai-message ul, .ai-message ol { margin-left: 1.5em; margin-top: 0.5em; margin-bottom: 0.5em; }
.ai-message li { margin-bottom: 0.25em; }
.ai-message blockquote { border-left: 3px solid #ccc; padding-left: 0.8em; margin-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; color: #555; }
.ai-message code { /* Inline code */
    background-color: rgba(0, 0, 0, 0.06);
    padding: 0.1em 0.3em;
    border-radius: 3px;
    font-family: monospace;
    font-size: 0.9em;
}
/* Avoid double background for code elements within Prism blocks */
.ai-message pre[class*="language-"] code {
    background-color: transparent;
    padding: 0;
    border-radius: 0;
    font-size: inherit; /* Inherit size from pre */
}
.ai-message a { color: #007bff; text-decoration: underline; }
.ai-message a:hover { color: #0056b3; }
.ai-message hr { border: none; border-top: 1px solid #ccc; margin: 1em 0; }
.ai-message table { border-collapse: collapse; margin: 1em 0; width: auto; }
.ai-message th, .ai-message td { border: 1px solid #ccc; padding: 0.3em 0.6em; text-align: left; }
.ai-message th { background-color: #f2f2f2; font-weight: bold; }

/* Code reference style in the main bubble */
.code-reference {
    font-family: monospace;
    background-color: rgba(0, 0, 0, 0.08); /* Light gray background */
    padding: 1px 5px; /* Small padding */
    border-radius: 4px; /* Rounded corners */
    font-size: 0.85em; /* Slightly smaller font */
    white-space: nowrap; /* Prevent breaking */
    margin: 0 2px; /* Add slight spacing around it */
}

/* --- Loading/Thinking Indicators --- */
.loading-dots { display: inline-block; }
.loading-dots::after {
    display: inline-block; position: relative; left: 1px;
    animation: ellipsis 1.5s infinite; content: ".";
    width: 1.5em; text-align: left; vertical-align: bottom;
}
@keyframes ellipsis {
    0% { content: "."; } 33% { content: ".."; } 66% { content: "..."; }
}

/* --- Thinking Area Styling --- */
.thinking-area {
    width: 100%; max-width: 90%; margin-bottom: 4px;
    align-self: flex-start; font-size: 0.9em;
}
.thinking-area details {
    width: 100%; border: 1px dashed #aaa; border-radius: 6px;
    background-color: #f0f0f0; overflow: hidden;
}
.thinking-summary {
    padding: 3px 8px; cursor: pointer; font-weight: normal; color: #444;
    background-color: #e0e0e0; border-bottom: 1px dashed #aaa;
    outline: none; user-select: none; list-style: none; display: block;
    transition: background-color 0.15s ease;
}
.thinking-summary:hover { background-color: #d0d0d0; }
.thinking-summary::-webkit-details-marker { display: none; }
.thinking-summary .dots { display: inline-block; margin-left: 4px; }
.thinking-summary .dots::after { /* Uses ellipsis animation defined above */
    display: inline-block; position: relative; left: 1px;
    animation: ellipsis 1.5s infinite; content: ".";
    width: 1.5em; text-align: left; vertical-align: bottom;
}
.thinking-area details[open] > .thinking-summary .dots { display: none; }
.thinking-area details pre {
    margin: 0; padding: 8px; background-color: #f8f8f8;
    white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word;
    max-height: 200px; overflow-y: auto;
}

/* --- Code Block Area --- */
.code-blocks-area {
    width: 100%; /* Allow blocks to take full width */
    max-width: 90%; /* Match AI bubble width */
    align-self: flex-start; /* Align with AI bubble */
    margin-top: 0.5rem; /* Space above code blocks */
}

.code-block-container {
    margin-bottom: 0.75rem; /* Space between code blocks */
    border-radius: 0.375rem; /* 6px - Applied to the whole container */
    overflow: hidden; /* Crucial: clips children to the container's radius */
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

/* --- Unified Code Block Header Styles --- */
.code-block-header,
.code-output-header {
    display: flex;
    align-items: center;
    background-color: #e5e7eb; /* Tailwind gray-200 (Unified Style) */
    padding: 0.25rem 0.5rem;    /* Unified Style */
    font-size: 0.8em;          /* Unified Style */
    color: #4b5563;            /* Unified Style (Gray-600) */
    gap: 0.625rem;             /* Unified Style (10px) */
}

/* Specific adjustment for Output Header spacing */
.code-output-header {
    margin-top: 0.25rem; /* Keep space above output header */
    /* border-top: none; /* Ensure no top border if previously added */
}

/* --- Header Content Alignment --- */

/* Buttons Div (Shared) */
.code-block-buttons,
.output-header-buttons { /* Combined selector */
    display: flex;
    align-items: center;
    gap: 0.375rem; /* 6px */
    flex-shrink: 0;
}

/* Title (Shared Properties) */
.code-block-title,
.output-header-title { /* Combined selector */
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* Code Header Title Specifics */
.code-block-title {
    flex-shrink: 1; /* Allow title to shrink if needed */
    flex-grow: 1; /* Allow title to grow */
    text-align: left;
}

/* Output Header Title Specifics */
.output-header-title {
    flex-shrink: 0; /* Don't let title shrink */
    margin-right: 0.625rem; /* Space after title, before status */
}

/* Placeholder for alignment in Output Header */
.output-header-button-placeholder {
    display: inline-block;
    width: 24px;
    height: 24px;
    flex-shrink: 0;
}

/* Status Span (Only in Output Header) */
.code-status-span {
    margin-left: auto; /* Pushes this element to the far right */
    text-align: right;
    font-style: italic;
    font-size: 0.9em; /* Relative to header font-size */
    padding: 0 0.3125rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    color: #6b7280; /* Default Idle color */
    flex-shrink: 0; /* Prevent status from shrinking */
}
.code-status-span.running, .code-status-span.stopping { color: #ca8a04; font-weight: 500; }
.code-status-span.success { color: #16a34a; font-weight: 500; }
.code-status-span.error, .code-status-span.stopped { color: #dc2626; font-weight: 500; }


/* --- Code Block Action Buttons (Shared Base Style) --- */
.code-action-btn {
    background-color: #d1d5db; /* Tailwind gray-300 */
    color: #4b5563; /* Gray-600 */
    border: none;
    padding: 0.1875rem 0.4375rem; /* 3px 7px */
    border-radius: 0.25rem; /* 4px */
    cursor: pointer;
    font-size: 0.9em; /* Relative to header font-size */
    line-height: 1.2;
    transition: background-color 0.2s ease, color 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    white-space: nowrap;
}
.code-action-btn:hover { background-color: #9ca3af; color: #1f2937; }
.code-action-btn:disabled { opacity: 0.6; cursor: not-allowed; }
.code-action-btn.copied { background-color: #16a34a; color: white; }

/* --- Button Style Override for Output Header (Ensures consistency) --- */
/* This rule overrides browser defaults/resets for buttons specifically in the output header */
.code-output-header .code-action-btn {
    /* Re-apply key styles from .code-action-btn to ensure they take precedence */
    background-color: #d1d5db;
    color: #4b5563;
    border: none;
    padding: 0.1875rem 0.4375rem;
    border-radius: 0.25rem;
    cursor: pointer;
    font-size: 0.9em;
    line-height: 1.2;
    transition: background-color 0.2s ease, color 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    white-space: nowrap;
}
.code-output-header .code-action-btn:hover {
     background-color: #9ca3af;
     color: #1f2937;
}
/* Add other states (:disabled, .copied) if needed for output header specifically */
/* e.g., .code-output-header .code-action-btn.copied { ... } */


/* Specific Run/Stop Button Styling (Only in Code Header) */
.run-code-btn { /* This class is only applied in the code header */
    padding: 4px; width: 24px; height: 24px; font-size: 1em; /* Relative to header font-size */
    background-color: transparent !important; border: none !important;
    color: #9ca3af; transition: color 0.2s ease;
}
.run-code-btn:hover { color: #4b5563; background-color: transparent !important; }
.run-code-btn[data-status="idle"] { color: #16a34a; }
.run-code-btn[data-status="idle"]:hover { color: #15803d; }
.run-code-btn[data-status="running"] { color: #dc2626; }
.run-code-btn[data-status="running"]:hover { color: #b91c1c; }
.run-code-btn[data-status="stopping"] { color: #f59e0b; cursor: wait; animation: spin 1s linear infinite; }
.run-code-btn[data-status="stopping"]:hover { color: #d97706; }
@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

/* --- Code Area & Output Console --- */

/* Style for the <pre> containing the code input */
.code-block-container > pre[class*="language-"] { /* More specific selector */
    margin: 0;
    border: 1px solid #d1d5db; /* Lighter border for code input */
    border-top: none;
    border-bottom: none !important; /* Remove bottom border if output follows */
    overflow: hidden;
    /* Background comes from Prism theme */
}

/* Style for the editable code element itself */
.code-block-container > pre[class*="language-"] > code[class*="language-"] {
    outline: none;
    white-space: pre-wrap !important;
    word-wrap: break-word !important;
    display: block;
    min-height: 1.5em;
    padding: 0.5em; /* Padding inside code input */
}
.code-block-container > pre[class*="language-"] > code[class*="language-"]:focus {
    background-color: rgba(0, 0, 0, 0.03); /* Slight focus indicator */
}

/* Output Console Container */
.code-output-console {
    background-color: #1f2937; /* Dark background */
    color: #f3f4f6;            /* Light text */
    padding: 0;                /* No padding on container */
    border: 1px solid #4b5563; /* Darker border */
    border-top: none !important;/* No top border */
    max-height: 250px;
    overflow-y: auto;
    font-family: monospace;
    font-size: 0.85em;         /* Slightly smaller than code input */
    line-height: 1.4;
}

/* Style for the <pre> inside the Output Console */
.code-output-console pre {
    margin: 0;
    white-space: pre-wrap;
    word-wrap: break-word;
    color: inherit;
    border: none !important; /* Explicitly remove border */
    padding: 0.5rem;         /* Padding for the output text */
    background-color: transparent; /* Use parent's background */
    outline: none !important;
}

/* Styles for the output text spans */
.code-output-console span { display: inline; white-space: pre-wrap; }
.code-output-console span.stdout-output { color: #ffffff; }
.code-output-console span.stderr-output { color: #f87171; } /* Lighter Red */

/* --- Hide/Show Functionality --- */
.code-block-container > pre.hidden, /* Hides code input pre */
.code-output-console.hidden,        /* Hides output console div */
.code-output-header.hidden          /* Hides output header */
 { display: none !important; }


/* --- Footer & Input --- */
footer { padding: 1rem; background-color: #e5e7eb; border-top: 1px solid #d1d5db; }
#chat-form { display: flex; align-items: center; gap: 0.5rem; }
.think-checkbox-container { display: flex; align-items: center; font-size: 0.9em; color: #4b5563; }
.think-checkbox-container input { margin-right: 4px; cursor: pointer; }
.think-checkbox-container label { cursor: pointer; user-select: none;}
#message-input {
    flex-grow: 1; padding: 0.5rem 0.75rem; border: 1px solid #d1d5db;
    border-radius: 0.5rem; outline: none;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
}
#message-input:focus { border-color: #2563eb; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); }
#send-button {
    background-color: #2563eb; color: white; font-weight: 500; padding: 0.5rem 1rem;
    border-radius: 0.5rem; border: none; cursor: pointer; transition: background-color 0.2s ease;
}
#send-button:hover { background-color: #1d4ed8; }
#send-button:disabled { opacity: 0.6; cursor: not-allowed; }

/* --- Error/System Messages --- */
.error-message {
    background-color: #fee2e2; color: #991b1b; border: 1px solid #fecaca;
    align-self: flex-start; margin-right: auto; padding: 0.5rem 0.75rem;
    border-radius: 0.5rem; max-width: 90%; word-wrap: break-word;
    margin-bottom: 0.5rem; white-space: pre-wrap;
}
.system-message {
    width: 100%; text-align: center; font-size: 0.875rem; color: #6b7280;
    font-style: italic; margin: 0.25rem 0;
}

/* --- KaTeX Specific Styling --- */
span[data-katex-rendered="true"] .katex-display { margin: 0.5em 0; overflow-x: auto; overflow-y: hidden; padding: 0.2em 0; }
span[data-katex-rendered="true"] .katex { line-height: normal; vertical-align: baseline; font-size: 1em; }
.katex-error { color: #cc0000; background-color: #fdd; border: 1px solid #cc0000; padding: 2px 4px; border-radius: 3px; }

/* --- Utility --- */
.hidden { display: none !important; }

/* Add Prism.js theme styles separately */
/* Link to a theme in your HTML or include the theme CSS rules here */
/* e.g., @import url('path/to/prism-theme.css'); */


=== app/static/temp.css ===
/* --- General Styles & Scrollbar --- */
html, body {
    height: 100%;
    margin: 0;
    font-family: 'Inter', sans-serif;
    background-color: #f3f4f6; /* Light gray background for the whole page */
}

#chat-history {
    flex: 1;
    overflow-y: auto;
    padding: 1rem; /* Use rem for scalable padding */
    display: flex;
    flex-direction: column;
    background-color: #ffffff; /* White background for chat area */
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
    margin: 1rem; /* Add margin around the chat history */
    border-radius: 0.5rem; /* Rounded corners */
}

/* Custom scrollbar for chat history */
#chat-history::-webkit-scrollbar { width: 8px; }
#chat-history::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
#chat-history::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
#chat-history::-webkit-scrollbar-thumb:hover { background: #555; }

/* --- Message Styling --- */
.message {
    padding: 0.5rem 0.75rem; /* Use rem */
    margin-bottom: 0.5rem;
    border-radius: 0.5rem;
    max-width: 90%;
    word-wrap: break-word;
    line-height: 1.5; /* Improve readability */
}

.user-message {
    background-color: #dbeafe; /* Tailwind blue-100 */
    align-self: flex-end;
    margin-left: auto;
    white-space: pre-wrap; /* Preserve user whitespace */
}

/* Container for a full AI turn (thinking + bubble + code blocks) */
.ai-turn-container {
    display: flex;
    flex-direction: column;
    align-items: flex-start; /* Align items to the left */
    width: 100%; /* Take full width to allow max-width on children */
    margin-bottom: 0.5rem; /* Consistent spacing */
}

.ai-message {
    background-color: #e5e7eb; /* Tailwind gray-200 */
    align-self: flex-start;
    margin-right: auto;
    max-width: 90%; /* Limit width */
    /* white-space is handled by content now (Markdown, KaTeX, etc.) */
}

/* Styling for Markdown elements rendered inside .ai-message */
.ai-message p { margin-bottom: 0.5em; }
.ai-message p:last-child { margin-bottom: 0; }
.ai-message ul, .ai-message ol { margin-left: 1.5em; margin-top: 0.5em; margin-bottom: 0.5em; }
.ai-message li { margin-bottom: 0.25em; }
.ai-message blockquote { border-left: 3px solid #ccc; padding-left: 0.8em; margin-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; color: #555; }
.ai-message code {
    background-color: rgba(0, 0, 0, 0.06);
    padding: 0.1em 0.3em;
    border-radius: 3px;
    font-family: monospace;
    font-size: 0.9em;
}
/* Avoid double background for code elements within Prism blocks */
.ai-message pre[class*="language-"] code {
    background-color: transparent;
    padding: 0;
    border-radius: 0;
    font-size: inherit; /* Inherit size from pre */
}
.ai-message a { color: #007bff; text-decoration: underline; }
.ai-message a:hover { color: #0056b3; }
.ai-message hr { border: none; border-top: 1px solid #ccc; margin: 1em 0; }
.ai-message table { border-collapse: collapse; margin: 1em 0; width: auto; }
.ai-message th, .ai-message td { border: 1px solid #ccc; padding: 0.3em 0.6em; text-align: left; }
.ai-message th { background-color: #f2f2f2; font-weight: bold; }

/* Code reference style in the main bubble */
.code-reference {
    font-family: monospace;
    background-color: rgba(0, 0, 0, 0.08); /* Light gray background */
    padding: 1px 5px; /* Small padding */
    border-radius: 4px; /* Rounded corners */
    font-size: 0.85em; /* Slightly smaller font */
    white-space: nowrap; /* Prevent breaking */
    margin: 0 2px; /* Add slight spacing around it */
}

/* --- Loading/Thinking Indicators --- */
.loading-dots { display: inline-block; }
.loading-dots::after {
    display: inline-block; position: relative; left: 1px;
    animation: ellipsis 1.5s infinite; content: ".";
    width: 1.5em; text-align: left; vertical-align: bottom;
}
@keyframes ellipsis {
    0% { content: "."; } 33% { content: ".."; } 66% { content: "..."; }
}

/* --- Thinking Area Styling --- */
.thinking-area {
    width: 100%; max-width: 90%; margin-bottom: 4px;
    align-self: flex-start; font-size: 0.9em;
}
.thinking-area details {
    width: 100%; border: 1px dashed #aaa; border-radius: 6px;
    background-color: #f0f0f0; overflow: hidden;
}
.thinking-summary {
    padding: 3px 8px; cursor: pointer; font-weight: normal; color: #444;
    background-color: #e0e0e0; border-bottom: 1px dashed #aaa;
    outline: none; user-select: none; list-style: none; display: block;
    transition: background-color 0.15s ease;
}
.thinking-summary:hover { background-color: #d0d0d0; }
.thinking-summary::-webkit-details-marker { display: none; }
.thinking-summary .dots { display: inline-block; margin-left: 4px; }
.thinking-summary .dots::after { /* Uses ellipsis animation defined above */
    display: inline-block; position: relative; left: 1px;
    animation: ellipsis 1.5s infinite; content: ".";
    width: 1.5em; text-align: left; vertical-align: bottom;
}
.thinking-area details[open] > .thinking-summary .dots { display: none; }
.thinking-area details pre {
    margin: 0; padding: 8px; background-color: #f8f8f8;
    white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word;
    max-height: 200px; overflow-y: auto;
}

/* --- Code Block Area --- */
.code-blocks-area {
    width: 100%; /* Allow blocks to take full width */
    max-width: 90%; /* Match AI bubble width */
    align-self: flex-start; /* Align with AI bubble */
    margin-top: 0.5rem; /* Space above code blocks */
}

.code-block-container {
    margin-bottom: 0.75rem; /* Space between code blocks */
    border-radius: 0.375rem; /* 6px */
    overflow: hidden; /* Ensure children respect border radius */
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

/* --- Code Block Header (Refined Layout) --- */
.code-block-header {
    display: flex;
    align-items: center; /* Vertically align items */
    background-color: #e5e7eb; /* Tailwind gray-200 */
    padding: 0.25rem 0.5rem; /* 4px 8px */
    font-size: 0.8em;
    color: #4b5563; /* Tailwind gray-600 */
    gap: 0.625rem; /* 10px */
}

/* Buttons Div - Now on the left */
.code-block-buttons {
    display: flex;
    align-items: center;
    gap: 0.375rem; /* 6px */
    flex-shrink: 0; /* Prevent shrinking */
}

/* Title - Now in the middle */
.code-block-title {
    font-weight: 500;
    flex-shrink: 0; /* Prevent shrinking */
    margin-right: 0.625rem; /* 10px space after title */
    white-space: nowrap; /* Prevent title wrapping */
}

/* Status Span - Pushed to the right */
.code-status-span {
    margin-left: auto; /* Pushes this element to the far right */
    text-align: right;
    font-style: italic;
    font-size: 0.9em;
    padding: 0 0.3125rem; /* 5px */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    color: #6b7280; /* Default Idle color (gray-500) */
}
.code-status-span.running,
.code-status-span.stopping { color: #ca8a04; font-weight: 500; } /* Amber-600 */
.code-status-span.success { color: #16a34a; font-weight: 500; } /* Green-600 */
.code-status-span.error,
.code-status-span.stopped { color: #dc2626; font-weight: 500; } /* Red-600 */

/* --- Code Block Action Buttons --- */
.code-action-btn {
    background-color: #d1d5db; /* Tailwind gray-300 */
    color: #4b5563; /* Gray-600 */
    border: none;
    padding: 0.1875rem 0.4375rem; /* 3px 7px */
    border-radius: 0.25rem; /* 4px */
    cursor: pointer;
    font-size: 0.9em;
    line-height: 1.2; /* Adjusted for potential icons/text */
    transition: background-color 0.2s ease, color 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    white-space: nowrap; /* Prevent text wrapping */
}
.code-action-btn:hover {
    background-color: #9ca3af; /* Gray-400 */
    color: #1f2937; /* Gray-800 */
}
.code-action-btn:disabled { opacity: 0.6; cursor: not-allowed; }
.code-action-btn.copied { background-color: #16a34a; color: white; }

/* Specific Run/Stop Button Styling (SVG based) */
.run-code-btn {
    padding: 4px; /* Keep padding for click area */
    width: 24px;  /* Fixed width */
    height: 24px; /* Fixed height */
    font-size: 1em; /* Control SVG size */
    background-color: transparent !important; /* No background */
    border: none !important; /* No border */
    color: #9ca3af; /* Default icon color (gray-400) */
    transition: color 0.2s ease; /* Transition color only */
}
.run-code-btn:hover {
    color: #4b5563; /* Darker gray on hover */
    background-color: transparent !important; /* Ensure no bg on hover */
}

.run-code-btn[data-status="idle"] { color: #16a34a; } /* Green Play */
.run-code-btn[data-status="idle"]:hover { color: #15803d; } /* Darker Green */

.run-code-btn[data-status="running"] { color: #dc2626; } /* Red Stop */
.run-code-btn[data-status="running"]:hover { color: #b91c1c; } /* Darker Red */

.run-code-btn[data-status="stopping"] {
    color: #f59e0b; /* Amber-500 */
    cursor: wait;
    animation: spin 1s linear infinite;
}
.run-code-btn[data-status="stopping"]:hover { color: #d97706; } /* Darker Amber */

/* Spin animation for stopping icon */
@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

/* --- Code Area & Output Console --- */
.code-block-container pre { /* Style the pre containing the code */
    margin: 0;
    border-bottom-left-radius: 0.375rem; /* Match container */
    border-bottom-right-radius: 0.375rem;
    border: 1px solid #d1d5db; /* Lighter border (gray-300) */
    border-top: none;
    overflow: hidden; /* Hide potential overflow */
    /* Inherit background from Prism theme */
}

/* Style for the editable code element itself */
pre[class*="language-"] > code[class*="language-"] {
    outline: none;
    white-space: pre-wrap !important;
    word-wrap: break-word !important;
    display: block;
    min-height: 1.5em;
    padding: 0.5em; /* Internal padding for code */
    /* Font size/family inherited from Prism theme usually */
}

/* Optional: Style when focused */
pre[class*="language-"] > code[class*="language-"]:focus {
    background-color: rgba(0, 0, 0, 0.03); /* Very subtle focus background */
    /* box-shadow: inset 0 0 0 1px rgba(0, 122, 255, 0.5); */ /* Optional focus border */
}

/* Output Console */
.code-output-console {
    background-color: #1f2937; /* Dark Gray/Black */
    color: #f3f4f6; /* Light Gray default text */
    margin-top: -1px; /* Overlap border slightly */
    border-bottom-left-radius: 0.375rem;
    border-bottom-right-radius: 0.375rem;
    padding: 0.5rem; /* 8px */
    border: 1px solid #4b5563; /* Darker border for console */
    border-top: none;
    max-height: 250px;
    overflow-y: auto;
    font-family: monospace;
    font-size: 0.85em;
    line-height: 1.4;
}
.code-output-console pre { margin: 0; padding: 0; white-space: pre-wrap; word-wrap: break-word; color: inherit; }
.code-output-console span { display: inline; white-space: pre-wrap; }
.code-output-console span.stdout-output { color: #ffffff; }
.code-output-console span.stderr-output { color: #f87171; } /* Lighter Red */

/* Hide code/console when toggle button is clicked */
.code-block-container pre.hidden,
.code-block-container .code-output-console.hidden { display: none !important; }

/* --- Footer & Input --- */
footer {
    padding: 1rem;
    background-color: #e5e7eb; /* Gray-200 */
    border-top: 1px solid #d1d5db; /* Gray-300 */
}
#chat-form { display: flex; align-items: center; gap: 0.5rem; /* 8px */ }
.think-checkbox-container {
    display: flex; align-items: center; font-size: 0.9em; color: #4b5563;
}
.think-checkbox-container input { margin-right: 4px; cursor: pointer; }
.think-checkbox-container label { cursor: pointer; user-select: none;}
#message-input {
    flex-grow: 1; padding: 0.5rem 0.75rem; border: 1px solid #d1d5db;
    border-radius: 0.5rem; outline: none;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
}
#message-input:focus {
    border-color: #2563eb; /* Blue-600 */
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); /* Blue focus ring */
}
#send-button {
    background-color: #2563eb; /* Blue-600 */
    color: white; font-weight: 500; padding: 0.5rem 1rem; border-radius: 0.5rem;
    border: none; cursor: pointer; transition: background-color 0.2s ease;
}
#send-button:hover { background-color: #1d4ed8; /* Blue-700 */ }
#send-button:disabled { opacity: 0.6; cursor: not-allowed; }

/* --- Error/System Messages --- */
.error-message {
    background-color: #fee2e2; /* Red-100 */
    color: #991b1b; /* Red-800 */
    border: 1px solid #fecaca; /* Red-200 */
    align-self: flex-start; margin-right: auto; padding: 0.5rem 0.75rem;
    border-radius: 0.5rem; max-width: 90%; word-wrap: break-word;
    margin-bottom: 0.5rem; white-space: pre-wrap;
}
.system-message {
    width: 100%; text-align: center; font-size: 0.875rem; color: #6b7280;
    font-style: italic; margin: 0.25rem 0;
}

/* --- KaTeX Specific Styling --- */
span[data-katex-rendered="true"] .katex-display {
    margin: 0.5em 0; overflow-x: auto; overflow-y: hidden; padding: 0.2em 0;
}
span[data-katex-rendered="true"] .katex { line-height: normal; vertical-align: baseline; font-size: 1em; }
.katex-error { color: #cc0000; background-color: #fdd; border: 1px solid #cc0000; padding: 2px 4px; border-radius: 3px; }

/* --- Utility --- */
.hidden { display: none !important; }

/* Add Prism.js theme styles separately */
/* Link to a theme in your HTML or include the theme CSS rules here */
/* e.g., @import url('path/to/prism-theme.css'); */



=== app/static/temp.js ===
if (chatForm) {
    chatForm.addEventListener('submit', (event) => {
        event.preventDefault();

        const userMessage = messageInput.value.trim();

        if (!userMessage) {
            return;
        }

        if (websocket && websocket.readyState === WebSocket.OPEN) {
            addUserMessage(userMessage);

            thinkingRequestedForCurrentTurn = thinkCheckbox ? thinkCheckbox.checked : false;
            console.log(`[Submit] Checkbox checked: ${thinkCheckbox?.checked}, thinkingRequestedForCurrentTurn set to: ${thinkingRequestedForCurrentTurn}`);

            setupNewAiTurn();

            const messageToSend = userMessage;
            console.log("[DEBUG] Sending message to WebSocket:", messageToSend);
            websocket.send(messageToSend);

            messageInput.value = '';
            setInputDisabledState(true);

        } else {
            console.warn("Debug: WebSocket not ready or not defined. State:", websocket?.readyState);
            addErrorMessage("Not connected to the server. Please wait or refresh.");
        }
    });
} else {
    console.error("CRITICAL ERROR: Could not find chat form element with ID 'chat-form'. Messages cannot be sent.");
    if (typeof addErrorMessage === 'function') {
        addErrorMessage("Initialization Error: Chat input form not found.");
    } else {
        alert("Initialization Error: Chat input form not found.");
    }
}

function setupNewAiTurn() {
    currentTurnId++;
    codeBlockCounterThisTurn = 0;
    accumulatedAnswerText = '';
    lastAppendedNode = null;
    thinkBuffer = '';
    hasThinkingContentArrivedThisTurn = false;
    firstAnswerTokenReceived = false;

    currentAiTurnContainer = null;
    currentThinkingArea = null;
    currentThinkingPreElement = null;
    currentAnswerElement = null;
    currentCodeBlocksArea = null;

    console.log(`[setupNewAiTurn] Starting setup for Turn ID: ${currentTurnId}. thinkingRequestedForCurrentTurn is: ${thinkingRequestedForCurrentTurn}`);

    currentAiTurnContainer = document.createElement('div');
    currentAiTurnContainer.classList.add('ai-turn-container');
    currentAiTurnContainer.dataset.turnId = currentTurnId;

    currentThinkingArea = document.createElement('div');
    currentThinkingArea.classList.add('thinking-area');
    currentThinkingArea.dataset.turnId = currentTurnId;

    if (!thinkingRequestedForCurrentTurn) {
        console.log("[setupNewAiTurn] Setting thinking area style to display:none because thinkingRequested=false.");
        currentThinkingArea.style.display = 'none';
    } else {
         console.log("[setupNewAiTurn] NOT hiding thinking area initially because thinkingRequested=true.");
    }

    const details = document.createElement('details');
    details.id = `thinking-details-${currentTurnId}`;
    const summary = document.createElement('summary');
    summary.classList.add('thinking-summary');
    const summaryTextSpan = document.createElement('span');
    summaryTextSpan.classList.add('text');
    summaryTextSpan.textContent = 'Show Thinking';
    const summaryDotsSpan = document.createElement('span');
    summaryDotsSpan.classList.add('dots');
    summary.appendChild(summaryTextSpan);
    summary.appendChild(summaryDotsSpan);
    currentThinkingPreElement = document.createElement('pre');
    details.appendChild(summary);
    details.appendChild(currentThinkingPreElement);
    currentThinkingArea.appendChild(details);
    currentAiTurnContainer.appendChild(currentThinkingArea);

    details.addEventListener('toggle', (event) => {
        const textSpan = event.target.querySelector('.thinking-summary .text');
        if (!textSpan) return;
        textSpan.textContent = event.target.open ? 'Hide Thinking' : 'Show Thinking';
    });

    currentAnswerElement = document.createElement('div');
    currentAnswerElement.classList.add('message', 'ai-message');

    if (thinkingRequestedForCurrentTurn) {
        console.log("[setupNewAiTurn] Hiding answer bubble initially because thinkingRequested=true.");
        currentAnswerElement.style.display = 'none';
    } else {
        console.log("[setupNewAiTurn] Showing answer bubble immediately with loading dots because thinkingRequested=false.");
         const loadingSpan = document.createElement('span');
         loadingSpan.classList.add('loading-dots');
         currentAnswerElement.appendChild(loadingSpan);
    }
    currentAiTurnContainer.appendChild(currentAnswerElement);

    currentCodeBlocksArea = document.createElement('div');
    currentCodeBlocksArea.classList.add('code-blocks-area');
    currentAiTurnContainer.appendChild(currentCodeBlocksArea);

    chatHistory.appendChild(currentAiTurnContainer);

    console.log(`[setupNewAiTurn] Finished setup for Turn ID: ${currentTurnId}.`);
}


function appendRawTextToThinkingArea(text) {
    if (text && text.trim().length > 0) {
        console.log(`[appendRawTextToThinkingArea] Received non-empty raw think text: "${text}" (length: ${text?.length})`);
    } else if (text !== null) {
         console.log(`[appendRawTextToThinkingArea] Received empty or whitespace raw think text (length: ${text?.length})`);
    }

    console.log(`[appendRawTextToThinkingArea] Checking condition: !thinkingRequestedForCurrentTurn is ${!thinkingRequestedForCurrentTurn} (value: ${thinkingRequestedForCurrentTurn})`);
    if (!thinkingRequestedForCurrentTurn) {
        console.log("[appendRawTextToThinkingArea] Condition met (!thinkingRequested). Returning early. Should NOT display thinking.");
        return;
    }

    console.log("[appendRawTextToThinkingArea] Proceeding because thinking was requested.");

    if (!currentThinkingArea || !currentThinkingPreElement || text.length === 0) {
        return;
    }

    if (!hasThinkingContentArrivedThisTurn) {
        if (currentThinkingArea.style.display === 'none') {
            console.log("[appendRawTextToThinkingArea] First think chunk (and requested). Making area visible NOW. Display style was: " + currentThinkingArea.style.display);
            currentThinkingArea.style.display = '';
        }
        hasThinkingContentArrivedThisTurn = true;
    }

    try {
        currentThinkingPreElement.appendChild(document.createTextNode(text));
    } catch (appendError) {
         console.error("[appendRawTextToThinkingArea] Error appending text node:", appendError, "Pre Element:", currentThinkingPreElement, "Text:", text);
        return;
    }

    const detailsElement = currentThinkingPreElement.closest('details');
    if (detailsElement && detailsElement.open) {
         const isNearBottom = currentThinkingPreElement.scrollHeight - currentThinkingPreElement.scrollTop - currentThinkingPreElement.clientHeight < 50;
         if(isNearBottom) {
             requestAnimationFrame(() => { currentThinkingPreElement.scrollTop = currentThinkingPreElement.scrollHeight; });
         }
    }
}

