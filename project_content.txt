=== Project Directory Structure ===
Root: C:\Users\viktor.jonsson\OneDrive - CellMax Technologies AB\Documents\Repositories\svenviktorjonsson\tesseracs-chat
Relevant files and folders (excluding specified patterns):

.
├── Readme.md
├── build.js
├── fetch_assets.py
├── package-lock.json
├── package.json
├── postcss.config.js
├── project_content.txt
├── pyproject.toml
├── tailwind.config.js
├── temp.js
├── temp.py
├── write_project_content_to_file.py
app/
├── __init__.py
├── auth.py
├── config.py
├── database.py
├── docker_utils.py
├── email_utils.py
├── llm.py
├── main.py
├── state.py
├── utils.py
├── static/
│   ├── _sidebar.html
│   ├── chat-session.html
│   ├── input.css
│   ├── login.html
│   ├── script.js
│   ├── session-choice.html
│   ├── js/
│   │   ├── app-ui.js


=== File Contents ===

=== Readme.md ===
Readme


=== build.js ===
// build.js

const esbuild = require('esbuild');
const stylePlugin = require('esbuild-style-plugin');
// const path = require('path'); // Not used

async function build() {
    console.log("--- Starting esbuild build process (Revised Approach with Explicit PostCSS Plugins) ---");
    try {
        await esbuild.build({
            entryPoints: {
                'script': 'app/static/script.js',
                'input': 'app/static/input.css'
            },
            bundle: true,
            outdir: 'app/static/dist',
            entryNames: '[name]',
            format: 'iife',
            platform: 'browser',
            sourcemap: true,
            minify: false,
            loader: {
                '.woff': 'file',
                '.woff2': 'file',
                '.ttf': 'file',
                '.eot': 'file',
                '.svg': 'file'
            },
            plugins: [
                stylePlugin({
                    postcss: {
                        // Explicitly define PostCSS plugins here
                        plugins: [
                            require('tailwindcss')('./tailwind.config.js'), // Pass config path explicitly
                            require('autoprefixer'),
                        ],
                    },
                })
            ],
            assetNames: 'assets/[name]-[hash]',
        });
        console.log('Build successful!');
    } catch (error) {
        console.error('Build failed:', error);
        process.exit(1);
    }
}

build();

=== fetch_assets.py ===
import os
import requests
import sys

# --- Configuration ---
# Get the directory where the script is located
script_dir = os.path.dirname(os.path.abspath(__file__))
print(f"DEBUG: Script is running from directory: {script_dir}") # <-- Added Debug Print

# Define paths relative to the script's location
static_dir = os.path.join(script_dir, 'app', 'static')
assets_dir = os.path.join(static_dir, 'assets')
css_dir = os.path.join(assets_dir, 'css')
fonts_dir = os.path.join(assets_dir, 'fonts') # Define fonts dir for creation

# Print the calculated target directories for verification
print(f"DEBUG: Target static directory: {static_dir}")
print(f"DEBUG: Target assets directory: {assets_dir}")
print(f"DEBUG: Target CSS directory: {css_dir}")
print(f"DEBUG: Target fonts directory: {fonts_dir}") # <-- Added Debug Print

# List of CSS files to download
css_files_to_download = [
    {
        'name': 'katex.min.css',
        'url': 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css',
        'dest': os.path.join(css_dir, 'katex.min.css')
    },
    {
        'name': 'prism-tomorrow.min.css',
        'url': 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css',
        'dest': os.path.join(css_dir, 'prism-tomorrow.min.css')
    }
]

# --- Helper Functions ---
def ensure_dir_exists(dir_path):
    """Creates a directory if it doesn't exist."""
    if not os.path.exists(dir_path):
        print(f"Creating directory: {dir_path}")
        try:
            os.makedirs(dir_path, exist_ok=True)
        except OSError as e:
            print(f"Error creating directory {dir_path}: {e}", file=sys.stderr)
            sys.exit(1) # Exit if directory creation fails

def download_file(url, destination_path):
    """Downloads a file from a URL to a destination path."""
    print(f"Attempting to download {os.path.basename(destination_path)} to {destination_path} from {url}...") # <-- Added Debug Print
    try:
        response = requests.get(url, stream=True, timeout=30) # Added timeout
        response.raise_for_status() # Raise an exception for bad status codes (4xx or 5xx)

        with open(destination_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
        print(f"Successfully downloaded: {os.path.basename(destination_path)}")
        return True
    except requests.exceptions.RequestException as e:
        print(f"Error downloading {url}: {e}", file=sys.stderr)
        # Clean up partially downloaded file if it exists
        if os.path.exists(destination_path):
            try:
                os.remove(destination_path)
                print(f"Removed partially downloaded file: {os.path.basename(destination_path)}")
            except OSError as remove_error:
                print(f"Error removing partial file {destination_path}: {remove_error}", file=sys.stderr)
        return False
    except Exception as e:
        print(f"An unexpected error occurred during download of {url}: {e}", file=sys.stderr)
        return False


# --- Main Execution ---
def main():
    print("Starting Python asset fetching process...")

    # 1. Ensure directories exist
    print("Ensuring necessary directories exist...")
    ensure_dir_exists(static_dir)
    ensure_dir_exists(assets_dir)
    ensure_dir_exists(css_dir)
    ensure_dir_exists(fonts_dir) # Also create fonts dir
    print("Directory check complete.")

    # 2. Download CSS files
    print("\nDownloading CSS files...")
    success_count = 0
    failure_count = 0
    for file_info in css_files_to_download:
        # Print the destination path before downloading
        print(f"DEBUG: Calculated destination for {file_info['name']}: {file_info['dest']}") # <-- Added Debug Print
        if download_file(file_info['url'], file_info['dest']):
            success_count += 1
        else:
            failure_count += 1

    print(f"\nDownload summary: {success_count} succeeded, {failure_count} failed.")

    if failure_count > 0:
        print("\nOne or more downloads failed. Please check the errors above.", file=sys.stderr)
        sys.exit(1) # Exit with error code if any download failed
    else:
        print("\nPython asset fetching process completed successfully.")
        print("CSS files downloaded to:", css_dir)
        print("Ensure font files are placed in:", fonts_dir)

if __name__ == "__main__":
    main()


=== package-lock.json ===
--- CONTENT EXCLUDED (listed in exclude_files) ---


=== package.json ===
{
  "name": "tesseracs-chat",
  "version": "1.0.0",
  "description": "Readme",
  "main": "temp.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "node build.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/svenviktorjonsson/tesseracs-chat.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/svenviktorjonsson/tesseracs-chat/issues"
  },
  "homepage": "https://github.com/svenviktorjonsson/tesseracs-chat#readme",
  "devDependencies": {
    "autoprefixer": "^10.4.21",
    "esbuild": "^0.25.4",
    "esbuild-style-plugin": "^1.6.3",
    "postcss": "^8.5.3",
    "tailwindcss": "^3.4.17"
  },
  "dependencies": {
    "katex": "^0.16.22",
    "marked": "^15.0.11",
    "prismjs": "^1.29.0"
  }
}


=== postcss.config.js ===
// postcss.config.js
module.exports = {
  plugins: {
    'tailwindcss': {}, // Use 'tailwindcss' for v3
    'autoprefixer': {},
  },
}

=== project_content.txt ===


=== pyproject.toml ===
[tool.poetry]
name = "tesseracs-chat"
version = "1.0.0"
description = "Web chat interface for Ollama using FastAPI and LangChain"
authors = ["Viktor Jonsson <viktor.jonsson@tesseracs.com>"]
readme = "README.md" # Optional README
packages = [
    { include = "app" },
]

[tool.poetry.dependencies]
python = "^3.9" # Adjust Python version if needed
fastapi = "^0.110.0"
uvicorn = {extras = ["standard"], version = "^0.29.0"}

# Let Poetry resolve the latest compatible LangChain versions
# Using "*" allows any version, but be aware this might pull in breaking changes in the future.
langchain = "*"
langchain-ollama = "*"
langchain-core = "*"
langchain-community = "*"
langchain-text-splitters = "*"

# Other dependencies
websockets = "^12.0" # Required by FastAPI for WebSockets
python-dotenv = "^1.0.1" # For optional .env file
aiofiles = "^23.2.1" # For serving static files asynchronously
docker = "^7.1.0"
requests = "^2.32.3"
python-multipart = "^0.0.20"
fastapi-mail = "^1.4.2"
certifi = "^2025.4.26"
pydantic = "^2.11.4"

[tool.poetry.scripts]
app = "app.main:start_server" # Command to run the app

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"



=== tailwind.config.js ===
/** @type {import('tailwindcss').Config} */
module.exports = {
    content: [
      "./app/static/**/*.html", // Scan HTML files in static
      "./app/static/**/*.js",   // Scan JS files in static
    ],
    theme: {
      extend: {},
    },
    plugins: [],
  }

=== temp.js ===
// --- DOM Elements ---
const chatHistory = document.getElementById('chat-history');
const chatForm = document.getElementById('chat-form');
const messageInput = document.getElementById('message-input');
const sendButton = document.getElementById('send-button');
const thinkCheckbox = document.getElementById('think-checkbox'); // Restored

// --- WebSocket & Client ID ---
let websocket;
const clientId = `web-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
let currentTurnId = 0; // Simple counter for unique IDs per turn

// --- State Machine Modes ---
const MODE_ANSWER = 'MODE_ANSWER';
const MODE_SEEKING_CODE_START_FENCE = 'MODE_SEEKING_CODE_START_FENCE'; // Looking for ```
const MODE_SEEKING_CODE_LANGUAGE = 'MODE_SEEKING_CODE_LANGUAGE';     // Reading language after ```
const MODE_INSIDE_CODE_BLOCK = 'MODE_INSIDE_CODE_BLOCK';        // Inside the code block
const MODE_SEEKING_CODE_END_FENCE = 'MODE_SEEKING_CODE_END_FENCE';   // Found potential closing ```

// --- State Variables ---
let currentProcessingMode = MODE_ANSWER;
let fenceBuffer = '';             // Buffer for detecting ``` fences
let langBuffer = '';              // Buffer for language string
let codeBuffer = '';              // Buffer for code content within a block
let currentCodeBlockLang = '';    // Detected language for the current block
let currentCodeBlockElement = null; // The <code> element being filled
let currentCodeBlockPreElement = null; // The <pre> element wrapping the code
let currentAiTurnContainer = null;  // The main container for the AI bubble + its code blocks
let currentAnswerElement = null;    // The div.ai-message bubble
let currentCodeBlocksArea = null; // The div below bubble holding code blocks
let codeBlockCounterThisTurn = 0; // Counter for code blocks within the *current* AI turn
let thinkingRequestedForCurrentTurn = false; // Restored
let isFirstContentChunkForTurn = true;

// --- Constants ---
const FENCE = '```';

// --- Helper Functions ---

function scrollToBottom() {
    // Adding a small delay can sometimes help ensure scrolling happens after render
    setTimeout(() => {
        chatHistory.scrollTo({ top: chatHistory.scrollHeight, behavior: 'smooth' });
    }, 50);
}

function addUserMessage(text) {
    const messageElement = document.createElement('div');
    messageElement.classList.add('message', 'user-message');
    messageElement.textContent = text;
    chatHistory.appendChild(messageElement);
    scrollToBottom();
}

function addSystemMessage(text) {
     const messageElement = document.createElement('div');
     messageElement.classList.add('system-message');
     messageElement.textContent = text;
     chatHistory.appendChild(messageElement);
     scrollToBottom();
}

function addErrorMessage(text) {
     console.error("[UI ERROR] ", text);
     const messageElement = document.createElement('div');
     messageElement.classList.add('error-message'); // Use error styling
     messageElement.textContent = `Error: ${text}`;
     if(currentAiTurnContainer) {
         currentAiTurnContainer.appendChild(messageElement); // Append error within the turn container
     } else {
         chatHistory.appendChild(messageElement); // Fallback if no turn container exists
     }
     scrollToBottom();
}

function setInputDisabledState(disabled) {
    messageInput.disabled = disabled;
    sendButton.disabled = disabled;
    if (thinkCheckbox) {
        thinkCheckbox.disabled = disabled;
    }
}

function finalizeTurnOnErrorOrClose() {
    console.log("[DEBUG] finalizeTurnOnErrorOrClose called.");
    if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK && currentCodeBlockElement) {
        console.warn("Stream ended unexpectedly inside a code block.");
        try {
            Prism.highlightElement(currentCodeBlockElement);
        } catch (e) { console.error("Prism highlighting error on incomplete block:", e); }
    }
    resetStreamingState();
    setInputDisabledState(true); // Disable input on error/close
}

function resetStreamingState() {
    console.log("[DEBUG] Resetting streaming state.");
    currentProcessingMode = MODE_ANSWER;
    fenceBuffer = '';
    langBuffer = '';
    codeBuffer = '';
    currentCodeBlockLang = '';
    currentCodeBlockElement = null;
    currentCodeBlockPreElement = null;
    // Note: Turn-specific elements (currentAiTurnContainer, etc.) are managed by setupNewAiTurn
}

function setupNewAiTurn() {
    currentTurnId++;
    codeBlockCounterThisTurn = 0; // Reset code block counter
    isFirstContentChunkForTurn = true; // <<< Reset the flag for the new turn

    currentAiTurnContainer = document.createElement('div');
    currentAiTurnContainer.classList.add('ai-turn-container');
    currentAiTurnContainer.dataset.turnId = currentTurnId;

    currentAnswerElement = document.createElement('div');
    currentAnswerElement.classList.add('message', 'ai-message');
    currentAiTurnContainer.appendChild(currentAnswerElement);

    currentCodeBlocksArea = document.createElement('div');
    currentCodeBlocksArea.classList.add('code-blocks-area');
    currentAiTurnContainer.appendChild(currentCodeBlocksArea);

    chatHistory.appendChild(currentAiTurnContainer);
}

function appendToAnswerBubble(text) {
    if (!currentAnswerElement) {
        console.error("Attempted to append to null answer bubble!");
        // Attempt recovery only if there's actual text content
        if (text.trim().length === 0) return; // Don't try to recover for whitespace only

        if (currentAiTurnContainer && !currentAiTurnContainer.querySelector('.ai-message')) {
             currentAnswerElement = document.createElement('div');
             currentAnswerElement.classList.add('message', 'ai-message');
             currentAiTurnContainer.insertBefore(currentAnswerElement, currentCodeBlocksArea);
        } else if (currentAiTurnContainer) {
             currentAnswerElement = currentAiTurnContainer.querySelector('.ai-message');
             if(!currentAnswerElement) {
                console.error("CRITICAL: Cannot find or create answer bubble in turn container.");
                return;
             }
        } else {
            console.error("CRITICAL: No turn container to recover answer bubble.");
            return;
        }
    }

    // <<< START: Added Leading Whitespace Trim Logic >>>
    let processedText = text;
    if (isFirstContentChunkForTurn) {
        processedText = text.trimStart(); // Remove leading whitespace ONLY for the first chunk
        // Only set flag to false if we actually processed non-empty text after trimming
        if (processedText.length > 0) {
             isFirstContentChunkForTurn = false;
        }
    }
    // <<< END: Added Leading Whitespace Trim Logic >>>

    // Append text content only if there is something left after trimming
    if (processedText.length > 0) {
        currentAnswerElement.appendChild(document.createTextNode(processedText));
    }
}


function appendCodeReference() {
    if (!currentAnswerElement) {
        console.error("Attempted to append code reference to null answer bubble!");
        return;
    }
    codeBlockCounterThisTurn++;
    const refSpan = document.createElement('span');
    refSpan.classList.add('code-reference');
    refSpan.textContent = `[Code ${codeBlockCounterThisTurn}]`;
    currentAnswerElement.appendChild(refSpan); // Append the span node
}

function createCodeBlockStructure(language) {
    if (!currentCodeBlocksArea) {
        console.error("Attempted to create code block in null area!");
        return;
    }

    const blockId = `code-block-turn${currentTurnId}-${codeBlockCounterThisTurn}`;
    // Normalize language: lowercase, trim, default 'plain', handle potential null/undefined
    const safeLanguage = (language || '').trim().toLowerCase() || 'plain';
    // Alias common variations
    const langAlias = {
        'python': 'python', 'py': 'python',
        'javascript': 'javascript', 'js': 'javascript',
        'html': 'markup', 'xml': 'markup', 'svg': 'markup', // Prism uses 'markup' for HTML/XML
        'css': 'css',
        'bash': 'bash', 'shell': 'bash',
        'java': 'java',
        'csharp': 'csharp', 'cs': 'csharp',
        'cpp': 'cpp', 'c++': 'cpp',
        'ruby': 'ruby', 'rb': 'ruby',
        'go': 'go',
        'php': 'php',
        'json': 'json',
        'yaml': 'yaml', 'yml': 'yaml',
        'sql': 'sql',
        'markdown': 'markdown', 'md': 'markdown'
    };
    const prismLang = langAlias[safeLanguage] || safeLanguage; // Use alias or original safe name
    const displayLang = safeLanguage; // Show the user what they typed (or 'plain')


    const container = document.createElement('div');
    container.classList.add('code-block-container');
    container.id = blockId;

    const header = document.createElement('div');
    header.classList.add('code-block-header');

    const title = document.createElement('span');
    title.textContent = `Code ${codeBlockCounterThisTurn} (${displayLang})`;

    const buttonsDiv = document.createElement('div');
    const toggleBtn = document.createElement('button');
    toggleBtn.classList.add('toggle-code-btn');
    toggleBtn.textContent = 'Show'; // Default text
    const copyBtn = document.createElement('button');
    copyBtn.classList.add('copy-code-btn');
    copyBtn.textContent = 'Copy';

    buttonsDiv.appendChild(toggleBtn);
    buttonsDiv.appendChild(copyBtn);

    // Append buttons first, then title
    header.appendChild(buttonsDiv);
    header.appendChild(title);

    // Create pre/code elements but store references locally for listeners
    const preElement = document.createElement('pre');
    const codeElement = document.createElement('code');
    codeElement.classList.add(`language-${prismLang}`);
    preElement.classList.add('hidden'); // Add hidden class by default

    // Assign references for streaming
    currentCodeBlockPreElement = preElement;
    currentCodeBlockElement = codeElement; // This global ref is used *during* streaming

    preElement.appendChild(codeElement);
    container.appendChild(header);
    container.appendChild(preElement);

    // --- Event Listeners ---

    toggleBtn.addEventListener('click', () => {
        // Find the pre element relative to the button clicked
        const containerDiv = toggleBtn.closest('.code-block-container');
        const preToToggle = containerDiv?.querySelector('pre');
        if (preToToggle) {
            const isHidden = preToToggle.classList.toggle('hidden');
            toggleBtn.textContent = isHidden ? 'Show' : 'Hide'; // Toggle text
        }
    });

    copyBtn.addEventListener('click', () => {
        // <<< START: Updated Copy Logic >>>
        // Find the specific container and code element relative to *this* button
        const containerDiv = copyBtn.closest('.code-block-container');
        const codeElementToCopy = containerDiv?.querySelector('pre > code');

        if (!codeElementToCopy) {
            console.error('Could not find code element to copy for button:', copyBtn);
            copyBtn.textContent = 'Error!';
             setTimeout(() => { copyBtn.textContent = 'Copy'; }, 1500);
            return; // Exit if element not found
        }

        const codeContent = codeElementToCopy.textContent;
        navigator.clipboard.writeText(codeContent).then(() => {
            copyBtn.textContent = 'Copied!';
            copyBtn.classList.add('copied'); // Add class for potential styling feedback
            setTimeout(() => {
                // Check if the text is still 'Copied!' before resetting
                // (prevents flicker if user clicks multiple times quickly)
                if (copyBtn.textContent === 'Copied!') {
                    copyBtn.textContent = 'Copy';
                    copyBtn.classList.remove('copied');
                }
            }, 1500); // Reset after 1.5 seconds
        }).catch(err => {
            console.error('Failed to copy code: ', err);
            copyBtn.textContent = 'Error!';
             // Remove copied class if it was somehow added
            copyBtn.classList.remove('copied');
            setTimeout(() => {
                 if (copyBtn.textContent === 'Error!') {
                    copyBtn.textContent = 'Copy';
                 }
            }, 1500); // Reset after 1.5 seconds
        });
        // <<< END: Updated Copy Logic >>>
    });

    currentCodeBlocksArea.appendChild(container);
}

function appendToCodeBlock(text) {
    if (currentCodeBlockElement) {
        // Append text content to the <code> element
         currentCodeBlockElement.appendChild(document.createTextNode(text));
    } else {
        console.error("Attempted to append to null code block element!");
    }
}

function finalizeCodeBlock() {
    if (currentCodeBlockElement) {
        try {
            // Highlight the completed block using Prism
            Prism.highlightElement(currentCodeBlockElement);
            console.log(`[DEBUG] Highlighted code block ${codeBlockCounterThisTurn} (lang: ${currentCodeBlockLang})`);
            // Optional: Add line numbers if plugin is active
            // if (currentCodeBlockPreElement.classList.contains('line-numbers')) {
            //     Prism.plugins.lineNumbers.resize(currentCodeBlockPreElement);
            // }
        } catch (e) {
            console.error(`Prism highlighting error for lang '${currentCodeBlockLang}':`, e);
            // Add a class indicating error?
             currentCodeBlockElement.classList.add('prism-highlight-error');
        }
    }
    // Reset code block specific state
    currentCodeBlockElement = null;
    currentCodeBlockPreElement = null;
    currentCodeBlockLang = '';
    codeBuffer = ''; // Clear code buffer
}

// --- WebSocket Connection ---
function connectWebSocket() {
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${window.location.host}/ws/${clientId}`;
    console.log(`[DEBUG] Attempting to connect to WebSocket: ${wsUrl}`);

    try {
        const ws = new WebSocket(wsUrl);

        ws.onopen = (event) => {
            console.log("[DEBUG] WebSocket connection opened");
            websocket = ws;
            setInputDisabledState(false); // Enable inputs
            addSystemMessage("Connected to the chat server.");
            // Add initial AI message
            setupNewAiTurn();
            appendToAnswerBubble("AI: Hello! How can I help you today?");
            resetStreamingState(); // Reset state machine after initial message

            if(messageInput.offsetParent !== null) messageInput.focus();
        };

        ws.onmessage = (event) => {
            let chunk = event.data;

            // --- Handle Control Messages First ---
            if (chunk === "<EOS>") {
                console.log("[DEBUG] Received <EOS>. Finalizing turn.");
                 // If ended inside a code block, finalize it
                 if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK) {
                    finalizeCodeBlock();
                } else if (currentProcessingMode === MODE_SEEKING_CODE_END_FENCE && fenceBuffer.length > 0) {
                    // Ended while seeking end fence, treat buffer as regular text
                    appendToAnswerBubble(fenceBuffer);
                 } else if (currentProcessingMode === MODE_SEEKING_CODE_LANGUAGE && langBuffer.length > 0) {
                     // Ended while seeking language, treat as regular text
                    appendToAnswerBubble(FENCE + langBuffer);
                 } else if (currentProcessingMode === MODE_SEEKING_CODE_START_FENCE && fenceBuffer.length > 0) {
                     // Ended while seeking start fence, treat as regular text
                    appendToAnswerBubble(fenceBuffer);
                 }

                resetStreamingState();
                setInputDisabledState(false); // Re-enable inputs
                if(messageInput.offsetParent !== null) messageInput.focus();
                scrollToBottom();
                return; // End processing for this message
            }
            if (chunk.startsWith("<ERROR>")) {
                const errorMessage = chunk.substring(7);
                console.error("[DEBUG] Received <ERROR>:", errorMessage);
                addErrorMessage(errorMessage);
                finalizeTurnOnErrorOrClose(); // Disables input
                scrollToBottom();
                return; // End processing for this message
            }

            // <<< --- START: Tag Filtering --- >>>
            // Remove <think> and </think> tags and any surrounding whitespace globally
            chunk = chunk.replace(/\s*<think>\s*/g, '').replace(/\s*<\/think>\s*/g, '');
            // If the chunk becomes empty after filtering, skip further processing for this chunk
            if (chunk.length === 0) {
                return;
            }
            // <<< --- END: Tag Filtering --- >>>


            // Ensure AI turn container exists (should be set up by setupNewAiTurn)
             if (!currentAiTurnContainer) {
                 console.error("CRITICAL: No AI turn container set up before message chunk received!");
                 // Attempt recovery only if chunk contains non-whitespace content after filtering
                 if (chunk.trim().length > 0) {
                    setupNewAiTurn();
                 } else {
                    return; // Don't set up turn for empty/whitespace-only chunks
                 }
            }

            // --- State Machine Processing ---
            let currentPos = 0;
            while (currentPos < chunk.length) {
                const char = chunk[currentPos];
                let incrementPos = true;

                switch (currentProcessingMode) {
                    case MODE_ANSWER:
                        if (char === FENCE[0]) {
                            fenceBuffer = char;
                            currentProcessingMode = MODE_SEEKING_CODE_START_FENCE;
                        } else {
                            appendToAnswerBubble(char);
                        }
                        break;

                    case MODE_SEEKING_CODE_START_FENCE:
                        if (char === FENCE[fenceBuffer.length]) {
                            fenceBuffer += char;
                            if (fenceBuffer === FENCE) {
                                console.log("[DEBUG] Found ``` start fence.");
                                fenceBuffer = '';
                                langBuffer = '';
                                currentProcessingMode = MODE_SEEKING_CODE_LANGUAGE;
                            }
                        } else {
                            appendToAnswerBubble(fenceBuffer + char);
                            fenceBuffer = '';
                            currentProcessingMode = MODE_ANSWER;
                        }
                        break;

                    case MODE_SEEKING_CODE_LANGUAGE:
                        if (char === '\n') {
                            console.log(`[DEBUG] Found language line: '${langBuffer}'`);
                            currentCodeBlockLang = langBuffer; // Keep raw lang buffer for createCodeBlockStructure
                            appendCodeReference();
                            createCodeBlockStructure(currentCodeBlockLang); // Handles normalization/aliasing
                            langBuffer = '';
                            codeBuffer = '';
                            currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                        } else if (langBuffer.length > 50) { // Prevent runaway language buffer
                             console.warn("Language line too long, assuming no language.");
                             appendToAnswerBubble(FENCE + langBuffer + char); // Treat as text
                             langBuffer = '';
                             fenceBuffer = '';
                             currentProcessingMode = MODE_ANSWER;
                        } else {
                            langBuffer += char;
                        }
                        break;

                    case MODE_INSIDE_CODE_BLOCK:
                        if (char === FENCE[0]) {
                            fenceBuffer = char;
                            currentProcessingMode = MODE_SEEKING_CODE_END_FENCE;
                        } else {
                            appendToCodeBlock(char);
                        }
                        break;

                    case MODE_SEEKING_CODE_END_FENCE:
                        if (char === FENCE[fenceBuffer.length]) {
                            fenceBuffer += char;
                            if (fenceBuffer === FENCE) {
                                console.log("[DEBUG] Found ``` end fence.");
                                // Check for immediate newline after fence, common pattern
                                if (currentPos + 1 < chunk.length && chunk[currentPos + 1] === '\n') {
                                     currentPos++; // Consume the newline
                                } else {
                                     // If next char is not newline, maybe check later chunks?
                                     // For simplicity, we'll just finalize here.
                                }
                                finalizeCodeBlock();
                                fenceBuffer = '';
                                currentProcessingMode = MODE_ANSWER;
                            }
                        } else {
                            appendToCodeBlock(fenceBuffer + char);
                            fenceBuffer = '';
                            currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                        }
                        break;

                    default:
                        console.error("Unknown processing mode:", currentProcessingMode);
                        currentProcessingMode = MODE_ANSWER;
                        incrementPos = false;
                }

                if (incrementPos) {
                    currentPos++;
                }
            } // end while loop over chunk

            scrollToBottom();
        }; // end onmessage

        ws.onerror = (event) => {
             console.error("WebSocket error:", event);
             addErrorMessage("WebSocket connection error. Please try refreshing the page.");
             finalizeTurnOnErrorOrClose();
        };

        ws.onclose = (event) => {
             console.log(`[DEBUG] WebSocket connection closed: Code=${event.code}, Reason='${event.reason}', WasClean=${event.wasClean}`);
             addSystemMessage(`Connection closed. ${event.reason ? event.reason : ''} (Code: ${event.code}). Attempting to reconnect...`);
             finalizeTurnOnErrorOrClose();
             websocket = undefined;
             const reconnectDelay = Math.min(1000 * (2 ** Math.min(8, event.code === 1000 ? 0 : 1)), 30000);
             console.log(`[DEBUG] Attempting reconnect in ${reconnectDelay}ms`);
             setTimeout(connectWebSocket, reconnectDelay);
        };

        console.log("[DEBUG] WebSocket object created and handlers assigned.");

    } catch (error) {
        console.error("[DEBUG] Error creating WebSocket:", error);
        addErrorMessage(`Failed to initialize WebSocket connection: ${error.message}. Check browser console.`);
        finalizeTurnOnErrorOrClose();
    }
}

if (chatForm) {
    chatForm.addEventListener('submit', (event) => {
        event.preventDefault(); // Prevent default form submission

        const userMessage = messageInput.value.trim(); // Get user text

        if (!userMessage) {
            return; // Do nothing if message is empty
        }

        // --- Check WebSocket State BEFORE Attempting Send ---
        if (!websocket || websocket.readyState !== WebSocket.OPEN) {
            console.warn("[Submit] WebSocket not ready or not defined. State:", websocket?.readyState);
            addErrorMessage("Not connected to the server. Please wait or refresh.");
            return; // Exit if not connected
        }

        // --- If WebSocket is OPEN, proceed ---
        try {
            // --- Step 1: Display User Message ---
            addUserMessage(userMessage); // Show user's raw message immediately

            // --- Step 2: Determine Thinking State & Prepare Message for Backend ---
            thinkingRequestedForCurrentTurn = thinkCheckbox ? thinkCheckbox.checked : false;
            console.log(`[Submit] Checkbox checked: ${thinkingRequestedForCurrentTurn}.`);

            let messageToSend = userMessage; // Default to the raw user message
            // Ensure NO_THINK_PREFIX is defined globally, e.g., const NO_THINK_PREFIX = "\\no_think";
            if (!thinkingRequestedForCurrentTurn) {
                messageToSend = NO_THINK_PREFIX + userMessage;
                console.log(`[Submit] Prepended '${NO_THINK_PREFIX}'. Prepared message: "${messageToSend.substring(0, 100)}..."`);
            } else {
                console.log(`[Submit] Prepared raw message (thinking requested): "${messageToSend.substring(0, 100)}..."`);
            }

            // --- Step 3: Setup UI for AI Response ---
            setupNewAiTurn(); // Uses thinkingRequestedForCurrentTurn for initial visibility

            // --- Step 4: Attempt to Send Message to WebSocket ---
            console.log(`[Submit] >>> About to call websocket.send(). State: ${websocket?.readyState}`); // Log state right before send

            websocket.send(messageToSend); // *** THE ACTUAL SEND CALL ***

            console.log("[Submit] <<< websocket.send() call completed (no immediate error thrown)."); // Log right after send

            // --- Step 5: Clear Input & Disable ---
            messageInput.value = '';          // Clear the input field
            setInputDisabledState(true); // Disable inputs while waiting for response
            console.log("[Submit] Input cleared and disabled.");

        } catch (sendError) {
            // --- Catch Errors During Send or Subsequent Steps ---
            console.error("[Submit] !!! ERROR during send attempt or post-send steps:", sendError);
            addErrorMessage(`Failed to send message: ${sendError.message}`);
            // Optionally re-enable input if send fails? Or leave disabled?
            // setInputDisabledState(false);
        }

    }); // End of submit handler
} else {
    // Handle case where the form element itself is missing
    console.error("CRITICAL ERROR: Could not find chat form element with ID 'chat-form'. Messages cannot be sent.");
    if (typeof addErrorMessage === 'function') {
        addErrorMessage("Initialization Error: Chat input form not found.");
    } else {
        alert("Initialization Error: Chat input form not found.");
    }
}

// --- Initial Setup ---
setInputDisabledState(true); // Disable inputs until connected
connectWebSocket(); // Start connection (will add initial AI message and enable inputs onopen)

=== temp.py ===
import os
import asyncio
import sys
import uvicorn
import webbrowser
import tempfile
import shutil
import json # Added for WebSocket message parsing/sending
import traceback # For detailed error logging
from pathlib import Path
from dotenv import load_dotenv
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Request, HTTPException
from fastapi.responses import HTMLResponse # JSONResponse no longer needed for run_code
from fastapi.staticfiles import StaticFiles
from fastapi.websockets import WebSocketState # Import WebSocketState
from pydantic import BaseModel # Keep for potential future HTTP models
import docker # Docker SDK
from docker.errors import DockerException, ImageNotFound, APIError, NotFound # Docker specific errors
from docker.models.containers import Container # For type hinting
from langchain_ollama.llms import OllamaLLM
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.output_parsers import StrOutputParser
from langchain.memory import ConversationBufferMemory
from langchain_core.runnables import RunnablePassthrough # RunnableLambda no longer needed here
from langchain_core.messages import HumanMessage, AIMessage

# --- Configuration ---
load_dotenv()
MODEL_ID = os.getenv("MODEL_ID", "qwen3")
OLLAMA_BASE_URL = os.getenv("OLLAMA_BASE_URL", "http://localhost:11434")
# NO_THINK_PREFIX is handled by frontend, backend receives prefixed message
NO_THINK_PREFIX = "\\no_think"

# --- Docker Configuration ---
SUPPORTED_LANGUAGES = {
    "python": {
        "image": "python:3.11-slim",
        "filename": "script.py",
        "command": ["python", "-u", "/app/script.py"] # Added -u for unbuffered output
    },
    "javascript": {
        "image": "node:18-alpine",
        "filename": "script.js",
        "command": ["node", "/app/script.js"]
    },
    # Add more languages here if needed
}
DOCKER_TIMEOUT_SECONDS = 30 # Increased timeout for potentially longer runs
DOCKER_MEM_LIMIT = "128m"

# --- FastAPI App Initialization ---
# Ensure the app object is created correctly
app = FastAPI(title="Ollama Web Chat")

# --- Docker Client Initialization ---
docker_client = None
try:
    docker_client = docker.from_env()
    docker_client.ping()
    print("Successfully connected to Docker daemon.")
except DockerException as e:
    print(f"CRITICAL WARNING: Could not connect to Docker daemon: {e}")
    print("Code execution via Docker will be unavailable.")
    docker_client = None

# --- Static Files Setup ---
# Determine the static files directory relative to this script's location
# This assumes main.py is either in the project root or inside an 'app' directory.
script_location = Path(__file__).parent
static_dir_in_app = script_location / "static"
static_dir_at_root = script_location.parent / "static" # If main.py is in 'app' dir

if static_dir_in_app.is_dir():
    static_dir = static_dir_in_app
    print(f"Found static directory at: {static_dir}")
elif script_location.name == "app" and static_dir_at_root.is_dir():
     # If script is in 'app' and 'static' is sibling to 'app'
     static_dir = static_dir_at_root
     print(f"Found static directory at: {static_dir}")
else:
    # Fallback check if script is in root and static is in root
    if (script_location.parent / "static").is_dir():
         static_dir = script_location.parent / "static"
         print(f"Found static directory at: {static_dir}")
    else:
        print(f"CRITICAL ERROR: Static directory not found near '{script_location}'. Looked for '{static_dir_in_app}' and '{static_dir_at_root}'. Exiting.")
        sys.exit(1)

# Mount static files - THIS MUST BE CORRECT FOR CSS/JS
app.mount("/static", StaticFiles(directory=str(static_dir)), name="static")
print(f"Mounted static directory '{static_dir}' at '/static'")


# --- LangChain Setup ---
try:
    model = OllamaLLM(model=MODEL_ID, base_url=OLLAMA_BASE_URL)
    print(f"Successfully initialized OllamaLLM: {MODEL_ID} at {OLLAMA_BASE_URL}")
except Exception as e:
    print(f"CRITICAL ERROR: OllamaLLM init failed: {e}"); sys.exit(1)

# --- Global State for WebSocket Connections and Running Containers ---
client_memory = {}
# Stores info about currently running code executions
# Format: { "code_block_id": {"container": Container, "stream_task": asyncio.Task, "client_id": str, "websocket": WebSocket, "stop_event": asyncio.Event} }
running_containers = {}
running_containers_lock = asyncio.Lock() # Lock for safe concurrent access

# --- Memory Management Functions (Unchanged) ---
def get_memory_for_client(client_id: str) -> ConversationBufferMemory:
    """Retrieves or creates memory for a specific client."""
    if client_id not in client_memory:
        client_memory[client_id] = ConversationBufferMemory(return_messages=True, memory_key="history")
        print(f"Initialized new memory for client: {client_id}")
    return client_memory[client_id]

def remove_memory_for_client(client_id: str):
    """Removes memory when a client disconnects."""
    if client_id in client_memory:
        del client_memory[client_id]
        print(f"Removed memory for client: {client_id}")

# --- LangChain Prompt and Chain Setup (Unchanged) ---
prompt = ChatPromptTemplate.from_messages([
    ("system", "You are a helpful AI assistant chatting in a web interface. Answer the user's questions concisely. Always use katex for math ($...$ or $$...$$). For a literal dollar sign use \\$. When providing code, use standard markdown code blocks (e.g., ```python ... ```)."),
    MessagesPlaceholder(variable_name="history"),
    ("human", "{input}")
])
output_parser = StrOutputParser()

# --- Helper Functions for WebSocket Code Execution (Unchanged from previous version) ---

async def send_ws_message(websocket: WebSocket, message_type: str, payload: dict):
    """Safely sends a JSON message over the WebSocket."""
    # Check state before sending
    if websocket.client_state != WebSocketState.CONNECTED:
         print(f"WebSocket not connected, cannot send {message_type} for {payload.get('code_block_id', 'N/A')}")
         return
    try:
        await websocket.send_json({"type": message_type, "payload": payload})
    except WebSocketDisconnect:
        print(f"WebSocket disconnected while trying to send {message_type} for {payload.get('code_block_id', 'N/A')}")
    except Exception as e:
        # Catch other potential errors like Runtime Error if connection closed during send
        print(f"Error sending WebSocket message ({message_type}) for {payload.get('code_block_id', 'N/A')}: {e}")
        # traceback.print_exc() # Optional: uncomment for more detail

# This function runs in a separate thread via run_in_executor
def sync_log_streamer(container: Container, websocket: WebSocket, code_block_id: str, loop: asyncio.AbstractEventLoop, stop_event: asyncio.Event):
    """
    Synchronously iterates through Docker logs and schedules sending messages
    back to the main asyncio loop. Runs in an executor thread.
    """
    try:
        # Note: follow=True keeps the stream open until container stops or stream is closed.
        log_stream = container.logs(stream=True, follow=True, stdout=True, stderr=True)
        print(f"[Thread-{code_block_id}] Starting log iteration for container {container.short_id}")

        for line_bytes in log_stream:
            if stop_event.is_set():
                print(f"[Thread-{code_block_id}] Stop event set, breaking log iteration.")
                break

            line_str = line_bytes.decode('utf-8', errors='replace')
            # Schedule the send_ws_message coroutine to run on the main event loop
            asyncio.run_coroutine_threadsafe(
                send_ws_message(websocket, "code_output", {
                    "code_block_id": code_block_id,
                    "stream": "stdout", # Sending all as stdout for simplicity, could try parsing later
                    "data": line_str
                }),
                loop # Pass the main event loop
            )

        print(f"[Thread-{code_block_id}] Finished log iteration for container {container.short_id}")

    except Exception as e:
        # Log error from the thread
        print(f"[Thread-{code_block_id}] Error during log streaming: {e}")
        # Don't print traceback here usually, as it might be expected on stop
        # traceback.print_exc()
        # Try to send an error message back to the client via the main loop
        asyncio.run_coroutine_threadsafe(
            send_ws_message(websocket, "code_output", {
                "code_block_id": code_block_id,
                "stream": "error",
                "data": f"\n[Error streaming logs from container: {str(e)}]"
            }),
            loop
        )

async def stream_docker_logs_via_executor(websocket: WebSocket, container: Container, code_block_id: str, stop_event: asyncio.Event):
    """
    Runs the synchronous log streamer function in an executor thread.
    """
    loop = asyncio.get_running_loop()
    print(f"Scheduling log streaming task in executor for {code_block_id}")
    # Run the sync function in the default executor
    await loop.run_in_executor(
        None, # Use default thread pool executor
        sync_log_streamer, # The function to run
        container, websocket, code_block_id, loop, stop_event # Arguments for the function
    )
    print(f"Executor task for log streaming finished for {code_block_id}")


async def run_code_in_docker_stream(websocket: WebSocket, client_id: str, code_block_id: str, language: str, code: str):
    """Runs code in Docker, streams output via WebSocket, and manages container lifecycle."""
    global docker_client, running_containers, running_containers_lock

    if not docker_client:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": "Docker service is unavailable on the server."
        })
        return

    lang_key = language.lower()
    lang_config = SUPPORTED_LANGUAGES.get(lang_key)
    if not lang_config:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": f"Language '{language}' not supported for execution."
        })
        return

    image_name = lang_config["image"]
    script_filename = lang_config["filename"]
    command = lang_config["command"]
    container_obj: Container | None = None
    stream_task: asyncio.Task | None = None
    tmpdir_obj = None # To hold the TemporaryDirectory object
    stop_event = asyncio.Event() # Event to signal cancellation to the streamer thread

    try:
        # Create temporary directory safely
        tmpdir_obj = tempfile.TemporaryDirectory()
        tmpdir = tmpdir_obj.name # Get the path string
        host_script_path = Path(tmpdir) / script_filename
        with open(host_script_path, "w", encoding="utf-8") as f:
            f.write(code)

        print(f"Attempting to run block {code_block_id} ({lang_key}) in Docker image {image_name}...")

        # Run the container detached
        container_obj = docker_client.containers.run(
            image=image_name,
            command=command,
            volumes={tmpdir: {'bind': '/app', 'mode': 'ro'}}, # Read-only mount
            working_dir='/app',
            mem_limit=DOCKER_MEM_LIMIT,
            stdout=True,
            stderr=True,
            detach=True, # Run in background
            # auto_remove=True, # Cannot auto-remove if we need to wait/get logs/stop
        )
        print(f"Container {container_obj.short_id} started for {code_block_id}")

        # Start the log streaming task using the executor helper
        stream_task = asyncio.create_task(
            stream_docker_logs_via_executor(websocket, container_obj, code_block_id, stop_event),
            name=f"log_stream_{code_block_id}" # Give the task a name for debugging
        )

        # Store container and task info BEFORE waiting
        async with running_containers_lock:
            if code_block_id in running_containers:
                 # This should ideally not happen if frontend disables button, but handle defensively
                 print(f"WARNING: Code block {code_block_id} was already running. Stopping previous run.")
                 # Call stop without await here, as we are inside the lock
                 # stop_docker_container needs to acquire the lock itself, so we schedule it
                 asyncio.create_task(stop_docker_container(code_block_id))


            running_containers[code_block_id] = {
                "container": container_obj,
                "stream_task": stream_task,
                "client_id": client_id,
                "websocket": websocket,
                "stop_event": stop_event # Store the stop event
            }

        # Wait for the container to finish execution or timeout
        print(f"Waiting for container {container_obj.short_id} ({code_block_id}) to finish...")
        loop = asyncio.get_running_loop()
        result = await loop.run_in_executor(
            None, # Use default executor
            lambda: container_obj.wait(timeout=DOCKER_TIMEOUT_SECONDS)
        )
        exit_code = result.get("StatusCode", -1)
        error_msg = result.get("Error", None)
        print(f"Container {container_obj.short_id} ({code_block_id}) finished. Result: {result}")

        # Ensure log streaming task is complete (it should be if container exited naturally)
        # Set stop event first to signal the thread, then wait/cancel task
        stop_event.set()
        try:
            # Wait briefly for the executor task to finish processing final logs
            await asyncio.wait_for(stream_task, timeout=5.0)
        except asyncio.TimeoutError:
            print(f"Warning: Log streaming task for {code_block_id} did not finish quickly after container exit.")
            # If it timed out, ensure it's cancelled (though setting stop_event should handle it)
            if not stream_task.done():
                stream_task.cancel()
        except asyncio.CancelledError:
             print(f"Log streaming task for {code_block_id} was cancelled (likely during stop).")
             pass # Already handled

        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id,
            "exit_code": exit_code,
            "error": error_msg # Send Docker-level error if any
        })

    except asyncio.TimeoutError: # Timeout from container_obj.wait()
        print(f"ERROR: Docker execution timed out for block {code_block_id} after {DOCKER_TIMEOUT_SECONDS}s.")
        await send_ws_message(websocket, "code_finished", {
             "code_block_id": code_block_id, "exit_code": -1,
             "error": f"Execution timed out after {DOCKER_TIMEOUT_SECONDS} seconds."
        })
        # Attempt to stop the timed-out container (this will also cancel the stream task via stop_docker_container)
        # Schedule stop_docker_container as it needs to acquire the lock
        asyncio.create_task(stop_docker_container(code_block_id))


    except ImageNotFound:
        error_msg = f"Server Error: Docker image '{image_name}' not found. Please pull it."
        print(f"ERROR for block {code_block_id}: {error_msg}")
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except APIError as e:
        error_msg = f"Server Error: Docker API error: {e}"
        print(f"ERROR for block {code_block_id}: {error_msg}")
        traceback.print_exc()
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except Exception as e:
        error_msg = f"Server Execution Error: {str(e)}"
        print(f"ERROR during Docker execution setup or wait for block {code_block_id}: {e}")
        traceback.print_exc()
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
        # Ensure stream task is cancelled if it was started
        if stream_task and not stream_task.done():
            print(f"Cancelling stream task for {code_block_id} due to setup/wait error.")
            stop_event.set() # Signal thread to stop
            stream_task.cancel()

    finally:
        # --- Final Cleanup ---
        # Remove from tracking dict if it hasn't been removed by stop_docker_container already
        async with running_containers_lock:
            if code_block_id in running_containers:
                print(f"Performing final cleanup check for {code_block_id}")
                task_to_cancel = running_containers[code_block_id]["stream_task"]
                stop_ev = running_containers[code_block_id]["stop_event"]
                if task_to_cancel and not task_to_cancel.done():
                     print(f"Final cleanup: Cancelling stream task for {code_block_id}")
                     stop_ev.set() # Signal thread
                     task_to_cancel.cancel()
                # Remove from tracking dict
                del running_containers[code_block_id]
                print(f"Removed {code_block_id} from running_containers during final cleanup")

        # Remove container if it exists and hasn't been removed by stop
        if container_obj:
            try:
                # Check if container still exists before removing
                await asyncio.get_running_loop().run_in_executor(None, container_obj.reload)
                print(f"Removing container {container_obj.short_id} ({code_block_id}) in final cleanup")
                # Need to run blocking remove in executor
                await asyncio.get_running_loop().run_in_executor(None, lambda: container_obj.remove(force=True))
            except NotFound:
                 print(f"Container {container_obj.short_id} already removed.")
                 pass # Already removed
            except Exception as rm_err:
                print(f"Error removing container {container_obj.short_id} in final cleanup: {rm_err}")

        # Clean up temporary directory
        if tmpdir_obj:
             try:
                  tmpdir_obj.cleanup()
             except Exception as cleanup_err:
                  print(f"Error cleaning up temp directory {tmpdir}: {cleanup_err}")


async def stop_docker_container(code_block_id: str):
    """Stops a running Docker container and cancels its log stream task."""
    global running_containers, running_containers_lock
    print(f"Attempting to stop execution for code block: {code_block_id}")
    loop = asyncio.get_running_loop()
    container_info = None
    container_obj = None
    stream_task = None
    websocket = None
    stop_event = None

    async with running_containers_lock:
        if code_block_id in running_containers:
            # Pop the entry to prevent others from trying to stop it simultaneously
            container_info = running_containers.pop(code_block_id)
            container_obj = container_info["container"]
            stream_task = container_info["stream_task"]
            websocket = container_info["websocket"] # Get websocket for final message
            stop_event = container_info["stop_event"]
            print(f"Found and removed running container {container_obj.short_id} for {code_block_id} from tracking.")
        else:
            print(f"Stop request for {code_block_id}, but it was not found in running_containers.")
            return # Nothing to stop

    # Perform actions outside the lock

    # 1. Signal the streaming thread to stop and cancel the task
    if stop_event:
        print(f"Setting stop event for {code_block_id}")
        stop_event.set()
    if stream_task and not stream_task.done():
        print(f"Cancelling stream task for {code_block_id}")
        stream_task.cancel()
        try:
            # Wait briefly for cancellation to be processed by the task
            await asyncio.wait_for(stream_task, timeout=1.0)
        except asyncio.TimeoutError:
            print(f"Stream task for {code_block_id} did not cancel quickly.")
        except asyncio.CancelledError:
            print(f"Stream task for {code_block_id} cancelled successfully.")
            pass # Expected

    # 2. Stop the container
    if container_obj:
        try:
            print(f"Stopping container {container_obj.short_id} ({code_block_id})...")
            # Stop needs to run in executor
            await loop.run_in_executor(None, lambda: container_obj.stop(timeout=5))
            print(f"Container {container_obj.short_id} stopped.")
        except Exception as stop_err:
            print(f"Error stopping container {container_obj.short_id}, attempting kill: {stop_err}")
            try:
                # Kill needs to run in executor
                await loop.run_in_executor(None, container_obj.kill)
                print(f"Container {container_obj.short_id} killed.")
            except Exception as kill_err:
                # Ignore kill error if container is already gone
                if "No such container" not in str(kill_err):
                     print(f"Error killing container {container_obj.short_id}: {kill_err}")

        # 3. Remove the container
        try:
            print(f"Removing container {container_obj.short_id} ({code_block_id}) after stop request.")
            # Remove needs to run in executor
            await loop.run_in_executor(None, lambda: container_obj.remove(force=True))
        except NotFound:
             pass # Already removed
        except Exception as rm_err:
            print(f"Error removing container {container_obj.short_id} after stop: {rm_err}")

    # 4. Send final message to client if websocket is still valid
    if websocket and websocket.client_state == WebSocketState.CONNECTED:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id,
            "exit_code": -1, # Indicate abnormal termination
            "error": "Execution stopped by user."
        })
    else:
         print(f"Cannot send stop confirmation for {code_block_id}, WebSocket reference lost or disconnected.")


async def cleanup_client_containers(client_id: str):
    """Stops and cleans up all running containers associated with a client ID."""
    global running_containers, running_containers_lock
    print(f"Cleaning up containers for disconnected client: {client_id}")
    containers_to_stop = []
    # Create a separate list to avoid modifying dict while iterating
    async with running_containers_lock:
         # Find code_block_ids associated with the client
         ids_for_client = [cb_id for cb_id, info in running_containers.items() if info["client_id"] == client_id]
         containers_to_stop.extend(ids_for_client)

    # Stop each container outside the lock to avoid holding it too long
    if containers_to_stop:
         print(f"Found containers to stop for client {client_id}: {containers_to_stop}")
         # Use asyncio.gather to stop them concurrently
         # Note: stop_docker_container already removes the entry from running_containers
         stop_tasks = [stop_docker_container(cb_id) for cb_id in containers_to_stop]
         results = await asyncio.gather(*stop_tasks, return_exceptions=True) # Log exceptions if any stop fails
         for i, result in enumerate(results):
              if isinstance(result, Exception):
                   print(f"Error during cleanup stop for {containers_to_stop[i]}: {result}")
         print(f"Finished cleanup for client {client_id}")
    else:
         print(f"No running containers found for client {client_id} during cleanup.")

# --- FastAPI Routes ---

# Root route to serve the main HTML page
@app.get("/", response_class=HTMLResponse)
async def get_chat_page(request: Request):
    """Serves the main chat HTML page."""
    html_file_path = static_dir / "index.html"
    if not html_file_path.is_file():
         print(f"ERROR: index.html not found at expected location: {html_file_path}")
         raise HTTPException(status_code=404, detail="index.html not found")
    try:
        with open(html_file_path, "r", encoding="utf-8") as f:
            html_content = f.read()
        return HTMLResponse(content=html_content)
    except Exception as e:
        print(f"ERROR reading index.html: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error reading index.html: {e}")


# --- WebSocket Endpoint ---
@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: str):
    """Handles WebSocket connections for chat and code execution."""
    await websocket.accept()
    print(f"WebSocket connection accepted for client: {client_id}")
    memory = get_memory_for_client(client_id)

    # Function to load history using this client's memory (Unchanged)
    def load_memory_for_current_client(_):
        loaded_vars = memory.load_memory_variables({})
        return loaded_vars.get("history", [])

    # Simple chain using the fixed global 'prompt' (Unchanged)
    chain = (
        RunnablePassthrough.assign(history=load_memory_for_current_client)
        | prompt
        | model
        | output_parser
    )
    print(f"LCEL Chain created for client: {client_id}")

    try:
        while True:
            # Check state before receiving
            if websocket.client_state != WebSocketState.CONNECTED:
                 print(f"WebSocket no longer connected for {client_id} before receive. Breaking loop.")
                 break

            received_data = await websocket.receive_text()

            # Check if it's a JSON command or regular chat input
            try:
                message_data = json.loads(received_data)
                message_type = message_data.get("type")
                payload = message_data.get("payload")

                if message_type and payload and isinstance(payload, dict):
                    # --- Handle JSON Commands ---
                    code_block_id = payload.get("code_block_id")
                    if not code_block_id:
                         print(f"Received JSON command without code_block_id: {message_data}")
                         continue

                    if message_type == "run_code":
                        language = payload.get("language")
                        code = payload.get("code")
                        if language and code is not None:
                             print(f"Received 'run_code' request for block {code_block_id} ({language}) from {client_id}")
                             # Start execution in background task
                             asyncio.create_task(
                                 run_code_in_docker_stream(websocket, client_id, code_block_id, language, code)
                             )
                        else:
                             print(f"Invalid 'run_code' payload received: {payload}")
                             await send_ws_message(websocket, "code_finished", {
                                  "code_block_id": code_block_id, "exit_code": -1,
                                  "error": "Invalid run_code request payload from client."
                             })

                    elif message_type == "stop_code":
                        print(f"Received 'stop_code' request for block {code_block_id} from {client_id}")
                        # Stop execution in background task
                        asyncio.create_task(
                             stop_docker_container(code_block_id)
                        )

                    else:
                        print(f"Received unknown JSON command type '{message_type}' from {client_id}")

                else:
                     # Treat as chat if JSON structure is invalid
                     print(f"Received invalid JSON structure from {client_id}, treating as chat: {received_data[:100]}...")
                     await handle_chat_message(chain, memory, websocket, client_id, received_data)

            except json.JSONDecodeError:
                # --- Handle Regular Chat Message ---
                # print(f"Handling text message from {client_id}: '{received_data[:50]}...'")
                await handle_chat_message(chain, memory, websocket, client_id, received_data)

    except WebSocketDisconnect:
        print(f"WebSocket disconnected during receive/process for client: {client_id}")
    except Exception as e:
        print(f"Unknown Error in WebSocket loop for client {client_id}: {e}")
        traceback.print_exc()
    finally:
        # --- Cleanup on Disconnect or Error ---
        print(f"Cleaning up resources for client: {client_id}")
        remove_memory_for_client(client_id)
        # Stop any running containers for this client
        await cleanup_client_containers(client_id)
        # Attempt to close websocket gracefully if it's not already closed
        if websocket.client_state == WebSocketState.CONNECTED:
            try:
                await websocket.close(code=1000) # Normal closure
                print(f"WebSocket closed gracefully for {client_id}")
            except Exception as close_exc:
                # Ignore errors if already closed or cannot close
                 print(f"Ignoring error during explicit WebSocket close for {client_id}: {close_exc}")
                 pass
        else:
             print(f"WebSocket already closed for {client_id} during cleanup.")


async def handle_chat_message(chain, memory, websocket: WebSocket, client_id: str, user_input: str):
     """Handles processing and streaming response for a regular chat message."""
     print(f"Handling chat message from {client_id}: '{user_input[:50]}...'")
     full_response = ""
     try:
         # Stream response using the chain
         async for chunk in chain.astream({"input": user_input}):
             # Check connection before sending each chunk
             if websocket.client_state != WebSocketState.CONNECTED:
                  print(f"WebSocket disconnected during chat stream for {client_id}. Aborting send.")
                  return # Stop sending if disconnected
             await websocket.send_text(chunk)
             full_response += chunk
     except Exception as chain_exc:
         error_msg = f"<ERROR>Error processing message: {chain_exc}"
         print(f"ERROR during chain execution for {client_id}: {chain_exc}")
         traceback.print_exc()
         # Try sending error message only if connected
         if websocket.client_state == WebSocketState.CONNECTED:
              await websocket.send_text(error_msg)
         # Don't save context if chain failed, but allow next message
         return

     # Send End Of Stream marker for chat message only if connected
     if websocket.client_state == WebSocketState.CONNECTED:
          await websocket.send_text("<EOS>")
          print(f"Finished streaming chat response to {client_id}")
          # Save context to memory
          # Note: user_input might contain the NO_THINK_PREFIX, which is fine for memory
          memory.save_context({"input": user_input}, {"output": full_response})
          print(f"Saved chat context to memory for client: {client_id}")
     else:
          print(f"WebSocket disconnected before sending <EOS> for {client_id}.")


# --- Function to run the server ---
def start_server():
    """Starts the Uvicorn server and opens the browser."""
    host = "127.0.0.1"
    port = 8001
    url = f"http://{host}:{port}"
    print(f"Starting server at {url}...")
    print(f"Using Ollama base URL: {OLLAMA_BASE_URL}")
    print(f"Using Model ID: {MODEL_ID}")
    print(f"Static files served from: {static_dir}")
    print(f"Supported execution languages: {list(SUPPORTED_LANGUAGES.keys())}")
    if not docker_client:
        print("WARNING: Docker client unavailable. Code execution will fail.")

    print(f"Attempting to open browser at {url}...")
    try:
        webbrowser.open(url)
    except Exception as browser_err:
        print(f"Warning: Could not automatically open browser: {browser_err}")
        print(f"Please navigate to {url} manually.")

    # --- Uvicorn Run ---
    # IMPORTANT: The target 'app.main:app' assumes this script (main.py)
    # is located inside a directory named 'app' relative to where you
    # run the uvicorn command OR that you run python like: python -m app.main
    # If main.py is at the project root, change the target to "main:app"
    uvicorn_target = "app.main:app"
    # Check if running directly (e.g., python main.py) vs module (python -m app.main)
    # A simple check: if the script's directory is named 'app'
    if Path(__file__).parent.name == "app":
         print(f"Running Uvicorn with target: '{uvicorn_target}' (assuming script is in 'app' directory)")
    else:
         # If not in 'app', assume it's at the root
         uvicorn_target = "main:app"
         print(f"Running Uvicorn with target: '{uvicorn_target}' (assuming script is at project root)")

    uvicorn.run(uvicorn_target, host=host, port=port, log_level="info", reload=True)

if __name__ == "__main__":
    # Add basic check for Docker client availability at startup
    if docker_client is None:
         print("\n---")
         print("WARNING: Docker is not running or accessible.")
         print("Code execution features will be disabled.")
         print("Please start Docker and restart this application for code execution.")
         print("---\n")
    start_server()



=== write_project_content_to_file.py ===
import os
import sys

# --- Configuration ---

# Set the starting directory (e.g., "." for current directory)
root = "."

# Extensions to include
extensions = ('.py', '.html', '.css', '.js', '.json', '.md', '.txt', '.yaml', '.yml', '.toml')

# Directories to completely exclude (will not be walked)
exclude_dirs = (
    '.git',
    '__pycache__',
    '.pytest_cache',
    'node_modules',
    'build',
    'old2',
    'testing-bundles', # Exclude this directory name wherever it appears
    '.venv',           # Common virtual environment folder
    'venv',
    'env',
    '.env',
    'dist',
    "assets"
)

# Files to list in the tree but exclude their *content*
exclude_files = (
    'package-lock.json',
    'yarn.lock',
    'katex.min.css',
    'katex.min.js'
    # Add other large or irrelevant files by name here
)

# Output file name
output_filename = "project_content.txt"

# --- Script Logic ---

try:
    root = os.path.abspath(root)
    print(f"Starting directory: {root}")
    print(f"Output file: {output_filename}")
    print(f"Excluding directories: {exclude_dirs}")
    print(f"Excluding content of files: {exclude_files}")

    # Use a set for faster lookups
    exclude_dirs_set = set(exclude_dirs)
    exclude_files_set = set(exclude_files)

    with open(output_filename, "w", encoding="utf-8", errors="replace") as outfile:
        # === Add Directory Structure ===
        outfile.write("=== Project Directory Structure ===\n")
        outfile.write(f"Root: {root}\n")
        outfile.write("Relevant files and folders (excluding specified patterns):\n\n")

        structure_lines = []
        processed_dirs_for_structure = set()

        for current_root, dirs, files in os.walk(root, topdown=True):
            # Filter directories *in place* to prevent walking into excluded ones
            # Also exclude hidden directories starting with '.' unless root is hidden
            original_dirs = list(dirs) # Keep original for path checking if needed
            dirs[:] = [d for d in dirs if d not in exclude_dirs_set and not (d.startswith('.') and d != '.')]

            rel_path_from_start = os.path.relpath(current_root, root)

            # --- Skip processing if current path is inside an excluded directory ---
            # Check if any component of the relative path is in the exclusion list
            # Normalize path separators for consistent checking
            norm_rel_path = os.path.normpath(rel_path_from_start).replace(os.sep, '/')
            path_components = set(comp for comp in norm_rel_path.split('/') if comp and comp != '.')

            if any(comp in exclude_dirs_set or (comp.startswith('.') and comp != '.') for comp in path_components):
                 continue # Skip this directory entirely if any parent was excluded

            level = norm_rel_path.count('/') if norm_rel_path != '.' else 0

            # Add directory entry
            if rel_path_from_start == '.':
                 structure_lines.append(".\n")
            else:
                 indent = '│   ' * (level - 1) + '├── ' if level > 0 else ''
                 dir_name = os.path.basename(current_root)
                 # Check if this specific dir name should be excluded (e.g., if it's at the root)
                 if dir_name not in exclude_dirs_set and not (dir_name.startswith('.') and dir_name != '.'):
                     structure_lines.append(f"{indent}{dir_name}/\n")
                     processed_dirs_for_structure.add(norm_rel_path)


            # Add file entries for this directory
            file_indent = '│   ' * level + '├── '
            files.sort()
            for file in files:
                if file.endswith(extensions) and not file.startswith('.'):
                     structure_lines.append(f"{file_indent}{file}\n")

        # Write collected structure lines
        for line in structure_lines:
             outfile.write(line)

        outfile.write("\n\n=== File Contents ===\n\n")

        # === Add File Contents ===
        for current_root, dirs, files in os.walk(root, topdown=True):
            # Apply the same directory filtering as in the first walk
            dirs[:] = [d for d in dirs if d not in exclude_dirs_set and not (d.startswith('.') and d != '.')]

            rel_path_from_start = os.path.relpath(current_root, root)

            # --- Skip processing if current path is inside an excluded/hidden directory ---
            norm_rel_path = os.path.normpath(rel_path_from_start).replace(os.sep, '/')
            path_components = set(comp for comp in norm_rel_path.split('/') if comp and comp != '.')
            if any(comp in exclude_dirs_set or (comp.startswith('.') and comp != '.') for comp in path_components):
                 continue # Skip files in this directory

            files.sort()
            for file in files:
                 # Exclude hidden files and check extensions
                 if file.endswith(extensions) and not file.startswith('.'):
                     file_path = os.path.join(current_root, file)
                     relative_path = os.path.relpath(file_path, root)
                     display_path = relative_path.replace(os.sep, '/')

                     outfile.write(f"=== {display_path} ===\n")

                     # Check if the file *content* should be excluded
                     if file in exclude_files_set:
                         outfile.write("--- CONTENT EXCLUDED (listed in exclude_files) ---\n")
                     else:
                         try:
                             # Try reading with utf-8 first
                             with open(file_path, "r", encoding="utf-8") as infile:
                                 outfile.write(infile.read())
                         except UnicodeDecodeError:
                             # Fallback for non-utf8 files
                             try:
                                 with open(file_path, "r", encoding="latin-1") as infile:
                                     outfile.write(infile.read())
                                 outfile.write("\n--- (Warning: Read using latin-1 encoding) ---\n")
                             except Exception as inner_e:
                                 outfile.write(f"--- Error reading file (fallback failed): {inner_e} ---\n")
                         except Exception as e:
                             # Handle other potential file reading errors
                             outfile.write(f"--- Error reading file: {e} ---\n")

                     outfile.write("\n\n") # Add separation between file contents

    print(f"Successfully generated project content file: {output_filename}")

except FileNotFoundError:
    print(f"Error: Starting directory not found: {root}", file=sys.stderr)
except IOError as e:
    print(f"Error writing to output file {output_filename}: {e}", file=sys.stderr)
except Exception as e:
    print(f"An unexpected error occurred: {e}", file=sys.stderr)

=== app/__init__.py ===


=== app/auth.py ===
# app/auth.py
import datetime
import sqlite3
import traceback
from fastapi import Request, Response, HTTPException, Depends
from fastapi.security import APIKeyCookie
from starlette.status import HTTP_302_FOUND, HTTP_401_UNAUTHORIZED
from typing import Optional, Dict, Any

from .database import get_db_connection, hash_value, generate_secure_token

# Configuration for the session cookie
SESSION_COOKIE_NAME = "tesseracs_chat_session_token"
SESSION_DURATION_DAYS = 7
MAGIC_LINK_DURATION_MINUTES = 15

# Dependency for getting the session token from the cookie
cookie_scheme = APIKeyCookie(name=SESSION_COOKIE_NAME, auto_error=False)

async def create_user_session(response: Response, user_id: int) -> str:
    """
    Creates a new session token in the database, and sets the raw token
    in an HTTPOnly cookie.
    """
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        session_token_raw = generate_secure_token(32)
        session_token_hashed = hash_value(session_token_raw)
        now_utc = datetime.datetime.now(datetime.timezone.utc)
        expires_at = now_utc + datetime.timedelta(days=SESSION_DURATION_DAYS)
        cursor.execute(
            "INSERT INTO auth_tokens (user_id, token_hash, token_type, expires_at) VALUES (?, ?, ?, ?)",
            (user_id, session_token_hashed, "session", expires_at.isoformat())
        )
        conn.commit()
        print(f"AUTH: Session token stored in DB for user_id: {user_id}")
    except Exception as e:
        if conn: conn.rollback()
        print(f"AUTH ERROR: Storing session token failed: {e}")
        raise HTTPException(status_code=500, detail="Could not create session due to a database error.")
    finally:
        if conn: conn.close()

    # Set the cookie in the response - being very explicit
    response.set_cookie(
        key=SESSION_COOKIE_NAME,
        value=session_token_raw,
        httponly=True,         # MUST be True for security
        secure=False,          # MUST be False for local HTTP testing
        samesite="lax",        # 'lax' is usually best for logins, allows top-level navigation redirects
        max_age=int(datetime.timedelta(days=SESSION_DURATION_DAYS).total_seconds()),
        path="/",              # CRITICAL: Ensure cookie applies to the whole site ('/' path)
        domain=None            # Explicitly None uses the current host (127.0.0.1)
    )
    # Log exactly what was set
    print(f"AUTH: Session cookie '{SESSION_COOKIE_NAME}' set in response for user_id: {user_id}. Secure=False, HttpOnly=True, SameSite=lax, Path=/, Domain=None")
    return session_token_raw


async def get_current_user(
    request: Request, # Add Request object to directly inspect cookies
    session_token_raw: Optional[str] = Depends(cookie_scheme) # Keep Depends for standard way
) -> Optional[Dict[str, Any]]:
    """
    Dependency to get the current authenticated user based on the session token in the cookie.
    Returns a user dictionary if authenticated and active, otherwise None.
    """
    # --- ENHANCED DEBUG LOGGING ---
    print(f"AUTH get_current_user: Request path: {request.url.path}") # Log path being accessed
    print(f"AUTH get_current_user: All cookies received in request: {request.cookies}")
    cookie_from_headers = request.cookies.get(SESSION_COOKIE_NAME)
    print(f"AUTH get_current_user: Reading '{SESSION_COOKIE_NAME}' directly from request.cookies: {'Present' if cookie_from_headers else 'Not Found'}")
    print(f"AUTH get_current_user: Value via Depends(cookie_scheme): {'Present' if session_token_raw else 'Not Found'}")
    # --- END ENHANCED DEBUG LOGGING ---

    token_to_verify = session_token_raw
    if not token_to_verify:
         # print(f"AUTH get_current_user: NO session token found via Depends(cookie_scheme).")
         if cookie_from_headers:
              # print(f"AUTH get_current_user: WARNING - Token found directly in headers but not via Depends. Using header value.")
              token_to_verify = cookie_from_headers
         else:
              # print(f"AUTH get_current_user: Token not found via direct header reading either. Returning None.")
              return None
    # else:
         # print(f"AUTH get_current_user: Using token found via Depends (raw prefix): {token_to_verify[:5]}...")

    session_token_hashed = hash_value(token_to_verify)
    conn = None
    user_dict = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        now_utc_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
        cursor.execute(
            """
            SELECT u.id, u.name, u.email, u.is_active
            FROM users u JOIN auth_tokens at ON u.id = at.user_id
            WHERE at.token_hash = ? AND at.token_type = 'session'
              AND at.expires_at > ? AND at.used_at IS NULL
            """,
            (session_token_hashed, now_utc_iso)
        )
        user_row = cursor.fetchone()
        if user_row:
            user_dict = dict(user_row)
            if not user_dict["is_active"]:
                print(f"AUTH get_current_user: User {user_dict.get('email')} found but is INACTIVE.")
                user_dict = None
            else:
                print(f"AUTH get_current_user: User {user_dict.get('email')} authenticated successfully via session token.")
        else:
            print(f"AUTH get_current_user: No valid, active user session found for provided token hash {session_token_hashed[:10]}...")
            user_dict = None
    except Exception as e:
        print(f"AUTH ERROR: Exception during token verification: {e}")
        traceback.print_exc()
        user_dict = None
    finally:
        if conn: conn.close()
    return user_dict


async def get_current_active_user(user: Optional[Dict[str, Any]] = Depends(get_current_user)) -> Optional[Dict[str, Any]]:
    """Convenience dependency returning the user dict if found and active."""
    return user


async def create_magic_link_token(user_id: int, conn: Optional[sqlite3.Connection] = None) -> str:
    """Creates a magic link token, storing hash in DB. Uses provided conn if available."""
    # (Implementation from previous step is correct)
    local_conn = False
    if conn is None:
        try: conn = get_db_connection(); local_conn = True
        except Exception as e: raise HTTPException(status_code=500, detail="Database connection error.")
    if conn is None: raise HTTPException(status_code=500, detail="DB connection is unexpectedly None.")
    cursor = conn.cursor()
    try:
        cursor.execute("SELECT id FROM users WHERE id = ?", (user_id,))
        if not cursor.fetchone(): raise HTTPException(status_code=404, detail=f"User ID {user_id} not found.")
        magic_token_raw = generate_secure_token(24)
        magic_token_hashed = hash_value(magic_token_raw)
        now_utc = datetime.datetime.now(datetime.timezone.utc)
        expires_at = now_utc + datetime.timedelta(minutes=MAGIC_LINK_DURATION_MINUTES)
        cursor.execute(
            "INSERT INTO auth_tokens (user_id, token_hash, token_type, expires_at) VALUES (?, ?, ?, ?)",
            (user_id, magic_token_hashed, "magic_login", expires_at.isoformat())
        )
        if local_conn: conn.commit()
        return magic_token_raw
    except HTTPException as http_exc:
        if local_conn: conn.rollback()
        raise http_exc
    except Exception as e:
        print(f"AUTH ERROR (Unexpected in create_magic_link): {type(e).__name__} - {e}")
        traceback.print_exc();
        if local_conn: conn.rollback()
        raise HTTPException(status_code=500, detail=f"Server error creating token ({type(e).__name__}).")
    finally:
        if local_conn and conn: conn.close()


async def verify_magic_link_token(token_raw: str) -> Optional[Dict[str, Any]]:
    """Verifies a raw magic link token, marks it as used, returns user info if valid."""
    # (Implementation from previous step is correct)
    token_hashed = hash_value(token_raw)
    conn = None
    try:
        conn = get_db_connection(); cursor = conn.cursor()
        now_utc = datetime.datetime.now(datetime.timezone.utc); now_utc_iso = now_utc.isoformat()
        cursor.execute(
            """SELECT at.user_id, at.expires_at, at.used_at, u.is_active, u.name, u.email, u.id as user_db_id
               FROM auth_tokens at JOIN users u ON at.user_id = u.id
               WHERE at.token_hash = ? AND at.token_type = 'magic_login'""", (token_hashed,)
        )
        row = cursor.fetchone()
        if not row or row["used_at"] is not None: return None
        expires_at_dt = datetime.datetime.fromisoformat(row["expires_at"].replace('Z', '+00:00'))
        if expires_at_dt.tzinfo is None: expires_at_dt = expires_at_dt.replace(tzinfo=datetime.timezone.utc)
        if expires_at_dt < now_utc or not row["is_active"]: return None
        cursor.execute(
            "UPDATE auth_tokens SET used_at = ? WHERE token_hash = ? AND token_type = 'magic_login'",
            (now_utc_iso, token_hashed)
        )
        conn.commit()
        return { "id": row["user_db_id"], "name": row["name"], "email": row["email"], "is_active": row["is_active"] }
    except Exception as e:
        if conn: conn.rollback(); print(f"AUTH ERROR: Verifying magic link token: {e}")
        return None
    finally:
        if conn: conn.close()

async def get_user_by_session_token(session_token_raw: str) -> Optional[Dict[str, Any]]:
    """
    Authenticates a user based purely on a raw session token string.
    Returns a user dictionary if authenticated and active, otherwise None.
    Suitable for WebSocket authentication.
    """
    if not session_token_raw:
        print("AUTH (get_user_by_session_token): No session token provided.")
        return None

    session_token_hashed = hash_value(session_token_raw)
    conn = None
    user_dict = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        # Ensure datetime is timezone-aware for comparison if expires_at is stored as UTC
        now_utc = datetime.datetime.now(datetime.timezone.utc)
        now_utc_iso = now_utc.isoformat()

        cursor.execute(
            """
            SELECT u.id, u.name, u.email, u.is_active
            FROM users u JOIN auth_tokens at ON u.id = at.user_id
            WHERE at.token_hash = ? AND at.token_type = 'session'
              AND at.expires_at > ? AND at.used_at IS NULL
            """,
            (session_token_hashed, now_utc_iso)
        )
        user_row = cursor.fetchone()
        if user_row:
            user_dict = dict(user_row)
            if not user_dict["is_active"]:
                print(f"AUTH (get_user_by_session_token): User {user_dict.get('email')} found but is INACTIVE.")
                user_dict = None 
            else:
                print(f"AUTH (get_user_by_session_token): User {user_dict.get('email')} authenticated successfully for WebSocket.")
        else:
            print(f"AUTH (get_user_by_session_token): No valid, active user session found for token hash {session_token_hashed[:10]}...")
    except Exception as e:
        print(f"AUTH ERROR (get_user_by_session_token): Exception during token verification: {e}")
        traceback.print_exc()
        user_dict = None
    finally:
        if conn: conn.close()
    return user_dict

async def logout_user(response: Response, session_token_raw: Optional[str] = Depends(cookie_scheme)):
    """Logs out user: invalidates session token in DB & clears browser cookie."""
    # (Implementation from previous step is correct)
    if session_token_raw:
        session_token_hashed = hash_value(session_token_raw); conn = None
        try:
            conn = get_db_connection(); cursor = conn.cursor()
            now_utc_iso = datetime.datetime.now(datetime.timezone.utc).isoformat()
            cursor.execute(
                "UPDATE auth_tokens SET used_at = ?, expires_at = ? WHERE token_hash = ? AND token_type = 'session'",
                (now_utc_iso, now_utc_iso, session_token_hashed)
            )
            conn.commit(); # print(f"AUTH: Session token invalidated in DB.")
        except Exception as e:
            if conn: conn.rollback(); print(f"AUTH ERROR: Invalidating session token: {e}")
        finally:
            if conn: conn.close()
    response.delete_cookie(SESSION_COOKIE_NAME, httponly=True, secure=False, samesite="lax", path="/")
    # print(f"AUTH: Session cookie cleared from browser.")
    return {"message": "Successfully logged out"}


=== app/config.py ===
# app/config.py
import os
import sys
from pathlib import Path
from dotenv import load_dotenv

# Load environment variables from a .env file if it exists
load_dotenv()

# --- LLM Configuration ---
MODEL_ID = os.getenv("MODEL_ID", "qwen3:8B")
OLLAMA_BASE_URL = os.getenv("OLLAMA_BASE_URL", "http://localhost:11434")
NO_THINK_PREFIX = "\\no_think"

# --- Docker Configuration ---
SUPPORTED_LANGUAGES = {
    "python": {
        "image": "python:3.11-slim",
        "filename": "script.py",
        "command": ["python", "-u", "/app/script.py"]
    },
    "javascript": {
        "image": "node:18-alpine",
        "filename": "script.js",
        "command": ["node", "/app/script.js"]
    },
    "cpp": {
        "image": "gcc:latest",
        "filename": "script.cpp",
        "command": ["sh", "-c", "g++ /app/script.cpp -o /app/output_executable && /app/output_executable"]
    },
    "csharp": {
        "image": "mcr.microsoft.com/dotnet/sdk:latest",
        "filename": "Script.cs",
        "command": [
            "sh", "-c",
            "cd /app && dotnet new console --force -o . > /dev/null && cp Script.cs Program.cs && rm Script.cs && dotnet run"
        ]
    },
    "typescript": {
        "image": "node:18-alpine",
        "filename": "script.ts",
        "command": ["sh", "-c", "tsc --module commonjs /app/script.ts && node /app/script.js"]
    },
    "java": {
        "image": "openjdk:17-jdk-slim",
        "filename": "Main.java",
        "command": ["sh", "-c", "javac /app/Main.java && java -cp /app Main"]
    },
    "go": {
        "image": "golang:1.21-alpine",
        "filename": "script.go",
        "command": ["go", "run", "/app/script.go"]
    },
    "rust": {
        "image": "rust:1-slim",
        "filename": "main.rs",
        "command": ["sh", "-c", "cd /app && rustc main.rs -o main_executable && ./main_executable"]
    }
}
DOCKER_TIMEOUT_SECONDS = int(os.getenv("DOCKER_TIMEOUT_SECONDS", 30))
DOCKER_MEM_LIMIT = os.getenv("DOCKER_MEM_LIMIT", "128m")

# --- Static Files Configuration ---
APP_DIR = Path(__file__).parent
PROJECT_ROOT = APP_DIR.parent
STATIC_DIR_IN_APP = APP_DIR / "static"
STATIC_DIR_AT_ROOT_LEVEL = PROJECT_ROOT / "static"
STATIC_DIR = None
if STATIC_DIR_IN_APP.is_dir(): STATIC_DIR = STATIC_DIR_IN_APP
elif STATIC_DIR_AT_ROOT_LEVEL.is_dir(): STATIC_DIR = STATIC_DIR_AT_ROOT_LEVEL
else:
    print(f"CRITICAL ERROR: Static directory not found. Looked in '{STATIC_DIR_IN_APP}' and '{STATIC_DIR_AT_ROOT_LEVEL}'. Exiting.")
    sys.exit(1)

# --- Email Configuration ---
MAIL_CONFIG = {
    "MAIL_USERNAME": os.getenv("MAIL_USERNAME"),
    "MAIL_PASSWORD": os.getenv("MAIL_PASSWORD"),
    "MAIL_FROM": os.getenv("MAIL_FROM"),
    "MAIL_PORT": int(os.getenv("MAIL_PORT", 465)), # Keep 465 from last attempt
    "MAIL_SERVER": os.getenv("MAIL_SERVER"),
    "MAIL_FROM_NAME": os.getenv("MAIL_FROM_NAME", "Tesseracs Chat"),
    "MAIL_STARTTLS": os.getenv("MAIL_STARTTLS", 'False').lower() in ('true', '1', 't'), # Keep False
    "MAIL_SSL_TLS": os.getenv("MAIL_SSL_TLS", 'True').lower() in ('true', '1', 't'),    # Keep True
    "USE_CREDENTIALS": True,
    # Read validation setting from env, default to True (secure)
    "VALIDATE_CERTS": os.getenv("MAIL_VALIDATE_CERTS", 'True').lower() in ('true', '1', 't')
}

if not all([MAIL_CONFIG["MAIL_USERNAME"], MAIL_CONFIG["MAIL_PASSWORD"], MAIL_CONFIG["MAIL_SERVER"]]):
    print("WARNING: Essential email configuration missing in .env file.")

# Print validation status being used for clarity
print(f"DEBUG config: Email certificate validation (VALIDATE_CERTS) is set to: {MAIL_CONFIG['VALIDATE_CERTS']}")



=== app/database.py ===
# app/database.py
import sqlite3
import os
from pathlib import Path
import hashlib # For password hashing (even if magic links are primary)
import secrets # For generating secure tokens
import datetime # For timestamps

# Determine the project root directory based on the location of this file
# Assuming this file is app/database.py
APP_DIR = Path(__file__).parent
PROJECT_ROOT = APP_DIR.parent
DATABASE_NAME = "tesseracs_chat.db"
DATABASE_PATH = PROJECT_ROOT / DATABASE_NAME

def get_db_connection():
    """Establishes a connection to the SQLite database."""
    # print(f"Attempting to connect to database at: {DATABASE_PATH}")
    conn = sqlite3.connect(DATABASE_PATH)
    conn.row_factory = sqlite3.Row # Access columns by name
    return conn

def init_db():
    """Initializes the database schema if it doesn't exist."""
    # Check if the database file already exists; if so, skip full init to preserve data.
    # For development, you might want to delete the DB file to re-init fresh.
    # if os.path.exists(DATABASE_PATH):
    #     print(f"Database already exists at {DATABASE_PATH}. Schema creation skipped to preserve data.")
    #     # You might still want to add ALTER TABLE commands here for migrations in the future.
    #     return

    print(f"Initializing database schema at {DATABASE_PATH}...")
    conn = get_db_connection()
    cursor = conn.cursor()

    # Users Table
    # Stores user information.
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        email TEXT UNIQUE NOT NULL,
        password_hash TEXT, -- Hashed password (can be NULL if only using magic links)
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        is_active BOOLEAN DEFAULT TRUE NOT NULL -- To allow deactivating users
    );
    """)
    print("Ensured 'users' table exists.")

    # Auth Tokens Table
    # Stores tokens for magic links, session management, password resets etc.
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS auth_tokens (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        token_hash TEXT UNIQUE NOT NULL, -- Store hashed version of the token
        token_type TEXT NOT NULL CHECK(token_type IN ('magic_login', 'session', 'password_reset')),
        expires_at TIMESTAMP NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        used_at TIMESTAMP, -- Timestamp when the token was used (for single-use tokens like magic links)
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
    );
    """)
    print("Ensured 'auth_tokens' table exists.")

    # Sessions Table
    # Represents a chat session instance.
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS sessions (
        id TEXT PRIMARY KEY, -- Unique session identifier (e.g., UUID)
        host_user_id INTEGER NOT NULL, -- The user who created/hosted the session
        name TEXT, -- Optional, user-defined name for the session
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        last_accessed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        is_active BOOLEAN DEFAULT TRUE NOT NULL, -- To mark sessions as active or archived
        FOREIGN KEY (host_user_id) REFERENCES users (id) ON DELETE CASCADE
    );
    """)
    print("Ensured 'sessions' table exists.")

    # Session Participants Table
    # Links users to sessions, for multi-user chat capabilities.
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS session_participants (
        session_id TEXT NOT NULL,
        user_id INTEGER NOT NULL,
        joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (session_id, user_id), -- Ensures a user is only listed once per session
        FOREIGN KEY (session_id) REFERENCES sessions (id) ON DELETE CASCADE,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
    );
    """)
    print("Ensured 'session_participants' table exists.")

    # Chat Messages Table
    # Stores individual chat messages for each session.
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS chat_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id TEXT NOT NULL,         -- Which session this message belongs to
        user_id INTEGER,                  -- Who sent the message (NULL for AI/system if not tied to a specific user account)
        sender_name TEXT,                 -- Display name of the sender (e.g., User's name, "AI")
        sender_type TEXT NOT NULL CHECK(sender_type IN ('user', 'ai', 'system', 'anon_user')), -- Type of sender
        content TEXT NOT NULL,            -- The actual message content
        client_id_temp TEXT,              -- Temp field for WebSocket client_id if message is pre-auth or anonymous
        turn_id INTEGER,                  -- For grouping stream of messages in one interaction
        thinking_content TEXT,            -- If AI is thinking, its thoughts can be stored here
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (session_id) REFERENCES sessions (id) ON DELETE CASCADE,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE SET NULL -- If user deleted, keep message but nullify user_id
    );
    """)
    print("Ensured 'chat_messages' table exists.")

    # Add indexes for frequently queried columns for performance
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_users_email ON users (email);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_auth_tokens_token_hash ON auth_tokens (token_hash);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_auth_tokens_user_id ON auth_tokens (user_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_sessions_host_user_id ON sessions (host_user_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_session_participants_session_id ON session_participants (session_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_session_participants_user_id ON session_participants (user_id);")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_chat_messages_session_id ON chat_messages (session_id);")
    print("Ensured indexes exist.")

    conn.commit()
    conn.close()
    print("Database initialization process complete.")

def hash_value(value: str) -> str:
    """Hashes a string value (e.g., password or token) using SHA256."""
    return hashlib.sha256(value.encode('utf-8')).hexdigest()

def generate_secure_token(length: int = 32) -> str:
    """Generates a cryptographically secure URL-safe token."""
    return secrets.token_urlsafe(length)

# You can run this file directly to initialize the database:
# python -m app.database
if __name__ == "__main__":
    print(f"Running database script directly. CWD: {Path.cwd()}")
    print(f"Project Root should be: {PROJECT_ROOT}")
    print(f"Database will be created/checked at: {DATABASE_PATH}")
    # Ensure the parent directory for the database exists
    DATABASE_PATH.parent.mkdir(parents=True, exist_ok=True)
    init_db()

=== app/docker_utils.py ===
# app/docker_utils.py

import asyncio
import tempfile
import shutil
import traceback
from pathlib import Path
import docker # Docker SDK for Python
from docker.errors import DockerException, ImageNotFound, APIError, NotFound # Docker specific errors
from docker.models.containers import Container # For type hinting container objects
from fastapi import WebSocket # For type hinting WebSockets

# Relative imports for modules within the 'app' package
from . import config
from . import state
from .utils import send_ws_message # Utility function for sending WebSocket messages

# --- Docker Client Initialization ---
# Attempt to initialize the Docker client from the environment settings.
# This typically connects to the Docker daemon running locally.
docker_client = None
try:
    # Get Docker client from environment variables (DOCKER_HOST, etc.)
    docker_client = docker.from_env()
    # Ping the Docker daemon to ensure connectivity
    docker_client.ping()
    print("Successfully connected to Docker daemon.")
except DockerException as e:
    # Handle exceptions if the Docker daemon is not reachable
    print(f"CRITICAL WARNING: Could not connect to Docker daemon: {e}")
    print("Code execution via Docker will be unavailable.")
    docker_client = None # Ensure client is None if connection failed

def get_docker_client():
    """
    Returns the initialized Docker client instance.
    Returns None if the client failed to initialize.
    """
    return docker_client

# --- Log Streaming Logic (Designed to Run in Executor Thread) ---

def sync_log_streamer(container: Container, websocket: WebSocket, code_block_id: str, loop: asyncio.AbstractEventLoop, stop_event: asyncio.Event):
    """
    Synchronously iterates through Docker container logs and schedules sending
    log lines back to the main asyncio event loop via WebSocket.
    This function is blocking and intended to be run in a separate thread using run_in_executor.

    Args:
        container: The Docker container object to stream logs from.
        websocket: The WebSocket connection to send log messages to.
        code_block_id: Identifier for the code block being executed.
        loop: The main asyncio event loop to schedule coroutines on.
        stop_event: An asyncio.Event used to signal when to stop streaming.
    """
    try:
        # Get a blocking generator for log lines (stdout and stderr)
        # follow=True keeps the stream open until the container stops or stop_event is set.
        log_stream = container.logs(stream=True, follow=True, stdout=True, stderr=True)
        print(f"[Thread-{code_block_id}] Starting log iteration for container {container.short_id}")

        # Iterate through the log stream line by line
        for line_bytes in log_stream:
            # Check if the stop event has been set (e.g., by user cancellation)
            if stop_event.is_set():
                print(f"[Thread-{code_block_id}] Stop event set, breaking log iteration.")
                break # Exit the loop if stop is requested

            # Decode bytes to string, replacing errors
            line_str = line_bytes.decode('utf-8', errors='replace')

            # Schedule the asynchronous send_ws_message function to run on the main event loop
            # This is crucial for thread safety when interacting with asyncio objects like WebSockets.
            asyncio.run_coroutine_threadsafe(
                send_ws_message(websocket, "code_output", {
                    "code_block_id": code_block_id,
                    "stream": "stdout", # Simplification: send both stdout/stderr as stdout type for now
                    "data": line_str
                }),
                loop # Pass the main event loop
            )

        print(f"[Thread-{code_block_id}] Finished log iteration for container {container.short_id}")

    except Exception as e:
        # Handle exceptions during log streaming (e.g., container removed unexpectedly)
        print(f"[Thread-{code_block_id}] Error during log streaming: {e}")
        # Schedule sending an error message back to the client via the main loop
        asyncio.run_coroutine_threadsafe(
            send_ws_message(websocket, "code_output", {
                "code_block_id": code_block_id,
                "stream": "error", # Indicate an error stream
                "data": f"\n[Error streaming logs from container: {str(e)}]"
            }),
            loop
        )

async def stream_docker_logs_via_executor(websocket: WebSocket, container: Container, code_block_id: str, stop_event: asyncio.Event):
    """
    Asynchronously runs the synchronous log streamer function (`sync_log_streamer`)
    in a separate thread using asyncio's default executor.

    Args:
        websocket: The WebSocket connection.
        container: The Docker container object.
        code_block_id: Identifier for the code block.
        stop_event: Event to signal stopping the stream.
    """
    loop = asyncio.get_running_loop()
    print(f"Scheduling log streaming task in executor for {code_block_id}")
    # Run the blocking sync_log_streamer function in the thread pool executor
    await loop.run_in_executor(
        None, # Use the default executor
        sync_log_streamer, # The function to run
        # Arguments to pass to sync_log_streamer:
        container, websocket, code_block_id, loop, stop_event
    )
    print(f"Executor task for log streaming finished for {code_block_id}")


# --- Docker Code Execution Core Function ---

async def run_code_in_docker_stream(websocket: WebSocket, client_id: str, code_block_id: str, language: str, code: str):
    """
    Handles the complete process of running user-provided code in a Docker container:
    1. Validates language and Docker availability.
    2. Creates a temporary directory and writes the code to a file.
    3. Starts the appropriate Docker container based on the language config.
    4. Starts a background task to stream container logs back via WebSocket.
    5. Waits for the container to finish or timeout.
    6. Sends a final status message (success, error, timeout) via WebSocket.
    7. Cleans up the container and temporary directory.

    Args:
        websocket: The client's WebSocket connection.
        client_id: The unique ID of the client.
        code_block_id: Identifier for the specific code block being run.
        language: The programming language of the code (e.g., "python", "c++").
        code: The actual code string provided by the user.
    """
    # Get the initialized Docker client instance
    local_docker_client = get_docker_client()

    # Check if Docker client is available
    if not local_docker_client:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": "Docker service is unavailable on the server."
        })
        return

    # Validate the requested language against the configuration
    lang_key = language.lower()
    lang_config = config.SUPPORTED_LANGUAGES.get(lang_key)
    if not lang_config:
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id, "exit_code": -1,
            "error": f"Language '{language}' not supported for execution."
        })
        return

    # Extract language-specific configuration
    image_name = lang_config["image"]
    script_filename = lang_config["filename"]
    command = lang_config["command"]

    # Initialize variables for container, task, temp dir, and stop event
    container_obj: Container | None = None
    stream_task: asyncio.Task | None = None
    tmpdir_obj = None # To hold the TemporaryDirectory object for proper cleanup
    stop_event = asyncio.Event() # Event to signal cancellation to the streamer thread

    try:
        # Create a temporary directory to store the script file
        # Using 'with' ensures cleanup even if errors occur later, but we need the path
        # outside the 'with', so we create it manually and clean up in 'finally'.
        tmpdir_obj = tempfile.TemporaryDirectory()
        tmpdir = tmpdir_obj.name # Get the path string
        host_script_path = Path(tmpdir) / script_filename

        # Write the user's code to the script file inside the temp directory
        with open(host_script_path, "w", encoding="utf-8") as f:
            f.write(code)

        print(f"Attempting to run block {code_block_id} ({lang_key}) in Docker image {image_name}...")

        # Run the Docker container
        # This might implicitly pull the image if not found locally
        container_obj = local_docker_client.containers.run(
            image=image_name,
            command=command, # Command defined in config.py
            # Mount the temporary directory read-write into /app inside the container
            # Changed mode from 'ro' to 'rw' to allow compilation output
            volumes={tmpdir: {'bind': '/app', 'mode': 'rw'}}, # <<< CHANGED HERE
            working_dir='/app', # Set working directory inside the container
            mem_limit=config.DOCKER_MEM_LIMIT, # Apply memory limit from config
            stdout=True, # Capture stdout
            stderr=True, # Capture stderr
            detach=True, # Run the container in the background
            # auto_remove=True, # Cannot auto-remove if we need logs/exit code/manual stop
        )
        print(f"Container {container_obj.short_id} started for {code_block_id}")

        # Create and start the background task for streaming logs
        stream_task = asyncio.create_task(
            stream_docker_logs_via_executor(websocket, container_obj, code_block_id, stop_event),
            name=f"log_stream_{code_block_id}" # Name the task for easier debugging
        )

        # Add the running container info to the global state dictionary (thread-safe)
        async with state.running_containers_lock:
            # Check if another execution for the same block ID is already running
            if code_block_id in state.running_containers:
                # This shouldn't happen if frontend disables button, but handle defensively
                print(f"WARNING: Code block {code_block_id} was already running. Stopping previous run.")
                # Schedule stop_docker_container; do not await inside the lock
                asyncio.create_task(stop_docker_container(code_block_id))

            # Store container details in the shared state dictionary
            state.running_containers[code_block_id] = {
                "container": container_obj,
                "stream_task": stream_task,
                "client_id": client_id,
                "websocket": websocket,
                "stop_event": stop_event # Store the stop event for cancellation
            }

        # Wait for the container to finish execution (blocking call run in executor)
        print(f"Waiting for container {container_obj.short_id} ({code_block_id}) to finish...")
        loop = asyncio.get_running_loop()
        # container.wait() is blocking, so run it in the executor
        result = await loop.run_in_executor(
            None, # Use default executor
            lambda: container_obj.wait(timeout=config.DOCKER_TIMEOUT_SECONDS) # Wait with timeout
        )
        # Extract exit code and potential error message from the result
        exit_code = result.get("StatusCode", -1) # Default to -1 if status code missing
        error_msg = result.get("Error", None) # Docker daemon error message
        print(f"Container {container_obj.short_id} ({code_block_id}) finished. Result: {result}")

        # --- Container Finished Normally or Errored ---
        # Signal the log streaming thread that it can stop
        stop_event.set()
        try:
            # Wait briefly for the log streaming task to finish processing final logs
            await asyncio.wait_for(stream_task, timeout=5.0)
        except asyncio.TimeoutError:
            print(f"Warning: Log streaming task for {code_block_id} did not finish quickly after container exit.")
            # Cancel the task if it's still running after the timeout
            if stream_task and not stream_task.done():
                stream_task.cancel()
        except asyncio.CancelledError:
            # Expected if the task was cancelled during stop_docker_container
             print(f"Log streaming task for {code_block_id} was cancelled (likely during stop).")

        # Send the final result message to the client
        await send_ws_message(websocket, "code_finished", {
            "code_block_id": code_block_id,
            "exit_code": exit_code,
            "error": error_msg # Send Docker-level error if any (e.g., OOMKilled)
        })

    except asyncio.TimeoutError: # Timeout triggered by container_obj.wait()
        # Handle the case where the container ran longer than DOCKER_TIMEOUT_SECONDS
        print(f"ERROR: Docker execution timed out for block {code_block_id} after {config.DOCKER_TIMEOUT_SECONDS}s.")
        await send_ws_message(websocket, "code_finished", {
             "code_block_id": code_block_id, "exit_code": -1,
             "error": f"Execution timed out after {config.DOCKER_TIMEOUT_SECONDS} seconds."
        })
        # Schedule the container stop process in the background
        asyncio.create_task(stop_docker_container(code_block_id))

    except ImageNotFound:
        # Handle case where the specified Docker image doesn't exist locally and couldn't be pulled
        error_msg = f"Server Error: Docker image '{image_name}' not found. Please ensure it's pulled or available."
        print(f"ERROR for block {code_block_id}: {error_msg}")
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except APIError as e:
        # Handle errors from the Docker daemon API
        error_msg = f"Server Error: Docker API error: {e}"
        print(f"ERROR for block {code_block_id}: {error_msg}")
        traceback.print_exc() # Print full traceback for server logs
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
    except Exception as e:
        # Catch any other unexpected errors during setup or execution
        error_msg = f"Server Execution Error: An unexpected error occurred." # Generic message for client
        print(f"ERROR during Docker execution setup or wait for block {code_block_id}: {e}")
        traceback.print_exc() # Print full traceback for server logs
        await send_ws_message(websocket, "code_finished", {"code_block_id": code_block_id, "exit_code": -1, "error": error_msg})
        # Ensure stream task is cancelled if it was started before the error
        if stream_task and not stream_task.done():
            print(f"Cancelling stream task for {code_block_id} due to setup/wait error.")
            stop_event.set() # Signal thread to stop
            stream_task.cancel()

    finally:
        # --- Final Cleanup ---
        # This block executes whether the try block succeeded or failed

        # Remove container info from tracking dict if it hasn't been removed already
        async with state.running_containers_lock:
            if code_block_id in state.running_containers:
                print(f"Performing final cleanup check for {code_block_id}")
                # Retrieve task and event references before deleting the entry
                task_to_cancel = state.running_containers[code_block_id].get("stream_task")
                stop_ev = state.running_containers[code_block_id].get("stop_event")
                # Ensure task is stopped and cancelled if still running
                if task_to_cancel and not task_to_cancel.done():
                    print(f"Final cleanup: Cancelling stream task for {code_block_id}")
                    if stop_ev: stop_ev.set() # Signal thread
                    task_to_cancel.cancel()
                # Remove the entry from the tracking dictionary
                del state.running_containers[code_block_id]
                print(f"Removed {code_block_id} from running_containers during final cleanup")

        # Ensure the Docker container is removed
        if container_obj:
            try:
                # Need to run blocking Docker SDK calls in an executor thread
                loop = asyncio.get_running_loop()
                # Check if container still exists before trying to remove
                await loop.run_in_executor(None, container_obj.reload)
                print(f"Removing container {container_obj.short_id} ({code_block_id}) in final cleanup")
                # Force remove the container
                await loop.run_in_executor(None, lambda: container_obj.remove(force=True))
            except NotFound:
                # Container was already removed (e.g., by stop_docker_container)
                 print(f"Container {container_obj.short_id} already removed.")
            except Exception as rm_err:
                # Log error if removal fails for some other reason
                 print(f"Error removing container {container_obj.short_id} in final cleanup: {rm_err}")

        # Clean up the temporary directory
        if tmpdir_obj:
             try:
                 tmpdir_obj.cleanup() # Deletes the temporary directory and its contents
             except Exception as cleanup_err:
                 print(f"Error cleaning up temp directory {tmpdir_obj.name}: {cleanup_err}")


# --- Container Stopping Logic ---

async def stop_docker_container(code_block_id: str):
    """
    Stops a specific running Docker container identified by code_block_id.
    Handles cancelling the log stream task and removing the container.

    Args:
        code_block_id: The identifier of the code block whose container needs stopping.
    """
    print(f"Attempting to stop execution for code block: {code_block_id}")
    loop = asyncio.get_running_loop()
    container_info = None
    container_obj = None
    stream_task = None
    websocket = None
    stop_event = None

    # Safely access and remove the container info from the shared state
    async with state.running_containers_lock:
        if code_block_id in state.running_containers:
            # Pop the entry to prevent race conditions with other stop requests or cleanup
            container_info = state.running_containers.pop(code_block_id)
            container_obj = container_info.get("container")
            stream_task = container_info.get("stream_task")
            websocket = container_info.get("websocket") # Get websocket for final message
            stop_event = container_info.get("stop_event")
            print(f"Found and removed running container info for {code_block_id} from tracking.")
        else:
            # If not found, it might have finished or been stopped already
            print(f"Stop request for {code_block_id}, but it was not found in running_containers.")
            return # Nothing further to do

    # --- Perform actions outside the lock ---

    # 1. Signal the streaming thread to stop and cancel the asyncio task
    if stop_event:
        print(f"Setting stop event for {code_block_id}")
        stop_event.set()
    if stream_task and not stream_task.done():
        print(f"Cancelling stream task for {code_block_id}")
        stream_task.cancel()
        try:
            # Wait briefly for cancellation to be processed
            await asyncio.wait_for(stream_task, timeout=1.0)
        except asyncio.TimeoutError:
            print(f"Stream task for {code_block_id} did not cancel quickly.")
        except asyncio.CancelledError:
            print(f"Stream task for {code_block_id} cancelled successfully.")
            pass # Expected outcome

    # 2. Stop the Docker container (run blocking calls in executor)
    if container_obj:
        try:
            print(f"Stopping container {container_obj.short_id} ({code_block_id})...")
            # container.stop() is blocking
            await loop.run_in_executor(None, lambda: container_obj.stop(timeout=5))
            print(f"Container {container_obj.short_id} stopped.")
        except Exception as stop_err:
            # If stop fails (e.g., timeout), attempt to kill the container
            print(f"Error stopping container {container_obj.short_id}, attempting kill: {stop_err}")
            try:
                # container.kill() is blocking
                await loop.run_in_executor(None, container_obj.kill)
                print(f"Container {container_obj.short_id} killed.")
            except Exception as kill_err:
                # Ignore "No such container" error if already gone, log others
                 if "No such container" not in str(kill_err):
                     print(f"Error killing container {container_obj.short_id}: {kill_err}")

        # 3. Remove the Docker container (run blocking call in executor)
        try:
            print(f"Removing container {container_obj.short_id} ({code_block_id}) after stop request.")
            # container.remove() is blocking
            await loop.run_in_executor(None, lambda: container_obj.remove(force=True))
        except NotFound:
            pass # Container already removed
        except Exception as rm_err:
            print(f"Error removing container {container_obj.short_id} after stop: {rm_err}")

    # 4. Send final "stopped by user" message if WebSocket is still valid
    if websocket: # Check if websocket reference exists
         try:
             await send_ws_message(websocket, "code_finished", {
                 "code_block_id": code_block_id,
                 "exit_code": -1, # Indicate abnormal termination
                 "error": "Execution stopped by user."
             })
         except Exception as send_err:
              print(f"Error sending stop confirmation for {code_block_id}: {send_err}")
    else:
         print(f"Cannot send stop confirmation for {code_block_id}, WebSocket reference lost.")


# --- Client Disconnect Cleanup ---

async def cleanup_client_containers(client_id: str):
    """
    Stops and cleans up all running Docker containers associated with a specific client ID
    when that client disconnects.

    Args:
        client_id: The ID of the client that disconnected.
    """
    print(f"Cleaning up containers for disconnected client: {client_id}")
    containers_to_stop = []
    # Safely get a list of code_block_ids associated with the disconnected client
    async with state.running_containers_lock:
        # List comprehension to find matching client_id
        ids_for_client = [
            cb_id for cb_id, info in state.running_containers.items()
            if info.get("client_id") == client_id
        ]
        containers_to_stop.extend(ids_for_client)

    # Stop each container concurrently using asyncio.gather
    if containers_to_stop:
        print(f"Found containers to stop for client {client_id}: {containers_to_stop}")
        # Create a list of stop tasks
        stop_tasks = [stop_docker_container(cb_id) for cb_id in containers_to_stop]
        # Run tasks concurrently and gather results (including exceptions)
        results = await asyncio.gather(*stop_tasks, return_exceptions=True)
        # Log any errors that occurred during the cleanup stops
        for i, result in enumerate(results):
             if isinstance(result, Exception):
                 print(f"Error during cleanup stop for {containers_to_stop[i]}: {result}")
        print(f"Finished cleanup for client {client_id}")
    else:
        print(f"No running containers found for client {client_id} during cleanup.")



=== app/email_utils.py ===
# app/email_utils.py
from fastapi_mail import FastMail, MessageSchema, ConnectionConfig
from pathlib import Path
import traceback
from . import config # Import your config module

# Create the ConnectionConfig using settings from config.py
# REMOVED TEMPLATE_FOLDER setting as we are not using file-based templates currently.
conf = ConnectionConfig(
    MAIL_USERNAME=config.MAIL_CONFIG.get("MAIL_USERNAME"),
    MAIL_PASSWORD=config.MAIL_CONFIG.get("MAIL_PASSWORD"),
    MAIL_FROM=config.MAIL_CONFIG.get("MAIL_FROM"),
    MAIL_PORT=config.MAIL_CONFIG.get("MAIL_PORT", 587),
    MAIL_SERVER=config.MAIL_CONFIG.get("MAIL_SERVER"),
    MAIL_FROM_NAME=config.MAIL_CONFIG.get("MAIL_FROM_NAME"),
    MAIL_STARTTLS=config.MAIL_CONFIG.get("MAIL_STARTTLS", True),
    MAIL_SSL_TLS=config.MAIL_CONFIG.get("MAIL_SSL_TLS", False),
    USE_CREDENTIALS=config.MAIL_CONFIG.get("USE_CREDENTIALS", True),
    VALIDATE_CERTS=config.MAIL_CONFIG.get("VALIDATE_CERTS", True)
    # TEMPLATE_FOLDER removed
)

# Initialize FastMail instance
fm = FastMail(conf)

async def send_magic_link_email(
    recipient_email: str,
    recipient_name: str,
    magic_link: str,
    duration_minutes: int
):
    """Sends the magic link email asynchronously."""

    # Basic check if email config seems valid before attempting
    if not conf.MAIL_USERNAME or not conf.MAIL_PASSWORD or not conf.MAIL_SERVER:
        print("EMAIL ERROR: Mail configuration is incomplete. Cannot send email.")
        # In a real app, you might raise an internal error or log more formally
        return False # Indicate failure

    subject = "Your Tesseracs Chat Login Link"

    # Simple HTML Body (consider using templates for more complex emails later)
    html_body = f"""
    <html>
        <body>
            <h2>Tesseracs Chat Login</h2>
            <p>Hello {recipient_name},</p>
            <p>Click the button below or copy the link to log in to Tesseracs Chat. This link is valid for {duration_minutes} minutes.</p>
            <p style="text-align: center; margin: 25px 0;">
                <a href="{magic_link}"
                   style="background-color: #2563eb; color: white; padding: 12px 25px; text-decoration: none; border-radius: 5px; font-size: 16px;"
                   target="_blank">
                   Login to Tesseracs Chat
                </a>
            </p>
            <p>If the button doesn't work, copy and paste this link into your browser:</p>
            <p><a href="{magic_link}" target="_blank">{magic_link}</a></p>
            <p>If you didn't request this email, please ignore it.</p>
            <hr>
            <p><small>Sent from Tesseracs Chat</small></p>
        </body>
    </html>
    """

    message = MessageSchema(
        subject=subject,
        recipients=[recipient_email],
        body=html_body, # Use body for HTML content
        subtype="html" # Specify HTML subtype
    )

    try:
        print(f"EMAIL: Attempting to send magic link to {recipient_email} via {conf.MAIL_SERVER}:{conf.MAIL_PORT}")
        await fm.send_message(message)
        print(f"EMAIL: Magic link email successfully sent to {recipient_email}.")
        return True # Indicate success
    except Exception as e:
        print(f"EMAIL ERROR: Failed to send magic link email to {recipient_email}")
        print(f"EMAIL ERROR DETAILS: {type(e).__name__} - {e}")
        traceback.print_exc()
        # Depending on the error, you might want specific handling
        # e.g., authentication errors (bad password), connection errors, etc.
        return False # Indicate failure



=== app/llm.py ===
# app/llm.py
import sys
import os # Import os for environment variable check
from langchain_ollama.llms import OllamaLLM
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.output_parsers import StrOutputParser
# from langchain.memory import ConversationBufferMemory # Not used directly here
from langchain_core.runnables import RunnablePassthrough, Runnable, RunnableLambda
from langchain_core.messages import BaseMessage
from typing import List, Callable, Optional

# Use absolute import based on project structure if needed, or relative
# Assuming config is in the same directory or Python path is set correctly
from . import config

# --- LangChain Setup ---

# Global variable to hold the model instance
_model_instance: Optional[OllamaLLM] = None
_last_model_id_used: Optional[str] = None
_last_base_url_used: Optional[str] = None

def get_model() -> OllamaLLM:
    """
    Initializes and returns the Ollama LLM model instance.
    Re-initializes if config changes (relevant with Uvicorn reload).
    """
    global _model_instance, _last_model_id_used, _last_base_url_used

    # Check if config has changed since last initialization
    # This is important because Uvicorn reload might not fully re-import everything
    config_changed = (
        _model_instance is None or
        config.MODEL_ID != _last_model_id_used or
        config.OLLAMA_BASE_URL != _last_base_url_used
    )

    if config_changed:
        print(f"DEBUG get_model: Configuration changed or first init. Initializing OllamaLLM with model='{config.MODEL_ID}' at base_url='{config.OLLAMA_BASE_URL}'")
        try:
            _model_instance = OllamaLLM(model=config.MODEL_ID, base_url=config.OLLAMA_BASE_URL)
            _last_model_id_used = config.MODEL_ID
            _last_base_url_used = config.OLLAMA_BASE_URL
            print(f"Successfully initialized/updated OllamaLLM: {_last_model_id_used} at {_last_base_url_used}")
        except Exception as e:
            print(f"CRITICAL ERROR: OllamaLLM init failed in get_model: {e}")
            # Re-raise the exception so the calling function knows initialization failed
            raise e
    # else:
    #     print(f"DEBUG get_model: Using existing OllamaLLM instance for model='{_last_model_id_used}'")


    if _model_instance is None:
         # This should ideally not happen if the try/except above works, but as a safeguard:
         print("CRITICAL ERROR: _model_instance is None after attempting initialization in get_model.")
         sys.exit(1) # Or raise a more specific error

    return _model_instance

# Define prompt structure (can stay global)
prompt = ChatPromptTemplate.from_messages([
    ("system", "You are a helpful AI assistant chatting in a web interface. Answer the user's questions concisely. Always use katex for math ($...$ or $$...$$). For a literal dollar sign use \\$. When providing code, use standard markdown code blocks (e.g., ```python ... ```)."),
    MessagesPlaceholder(variable_name="history"),
    ("human", "{input}")
])

# Define output parser (can stay global)
output_parser = StrOutputParser()

def create_chain(memory_loader_func: Callable[[dict], List[BaseMessage]]) -> Runnable:
    """
    Creates the LangChain processing chain using a provided memory loading function.
    Ensures the model is initialized before creating the chain.
    """
    try:
        # Get the (potentially re-initialized) model instance
        current_model = get_model()
    except Exception as model_init_error:
        # Propagate the error if model initialization failed
        print(f"ERROR in create_chain: Failed to get model instance: {model_init_error}")
        raise model_init_error # Re-raise to prevent chain creation with bad model

    chain = (
        RunnablePassthrough.assign(history=RunnableLambda(memory_loader_func))
        | prompt
        | current_model # Use the obtained model instance
        | output_parser
    )
    return chain

# Remove the old global initialization attempt
# try:
#     model = OllamaLLM(model=config.MODEL_ID, base_url=config.OLLAMA_BASE_URL)
#     print(f"Successfully initialized OllamaLLM: {config.MODEL_ID} at {config.OLLAMA_BASE_URL}")
# except Exception as e:
#     print(f"CRITICAL ERROR: OllamaLLM init failed: {e}")
#     sys.exit(1)


=== app/main.py ===
# app/main.py


from pydantic import BaseModel, Field # Add these for the request body model

import os
import sys
import uvicorn
import webbrowser
import traceback
from pathlib import Path
import asyncio
import json
import sqlite3
import uuid
from fastapi import (
    FastAPI,
    Request,
    HTTPException,
    WebSocket,
    WebSocketDisconnect,
    Form,
    Depends,
    Response as FastAPIResponse,
    Path as FastApiPath,
    Body,
    status
)
from fastapi.responses import HTMLResponse, FileResponse, RedirectResponse, Response # Ensure Response is imported
from fastapi.staticfiles import StaticFiles
from fastapi.websockets import WebSocketState
import datetime
from typing import Optional, Dict, Any, List # Ensure Optional is imported

# Project local imports
from . import config
from . import state
from . import llm
from . import docker_utils
from . import utils
from . import database
from . import auth
from . import email_utils

# --- FastAPI App Initialization ---
app = FastAPI(title="Tesseracs Chat")

class SessionUpdateRequest(BaseModel):
    """Defines the expected request body for updating a session's name."""
    name: str = Field(
        ..., # Ellipsis means this field is required
        min_length=1, 
        max_length=100, 
        description="The new name for the session (1-100 characters)."
    )

# --- Database Initialization on Startup ---
@app.on_event("startup")
async def startup_event():
    print("Application startup: Initializing database...")
    database.DATABASE_PATH.parent.mkdir(parents=True, exist_ok=True)
    database.init_db()
    print("Database initialization check complete.")
    if docker_utils.get_docker_client() is None:
        print("WARNING: Docker client unavailable during startup.")
    else:
        print("Docker client confirmed available at startup.")
    try:
        llm.get_model()
        print("LLM model connection checked successfully.")
    except Exception as e:
        print(f"CRITICAL ERROR during startup LLM check: {e}")

# --- Static Files Setup ---
if not config.STATIC_DIR or not config.STATIC_DIR.is_dir():
    sys.exit(f"CRITICAL ERROR: Base static directory invalid: {config.STATIC_DIR}")
dist_dir = config.STATIC_DIR / "dist"
if not dist_dir.is_dir():
    sys.exit(f"CRITICAL ERROR: Bundled assets dir not found: {dist_dir}. Run 'npm run build'.")
app.mount("/dist", StaticFiles(directory=dist_dir), name="dist_assets")
app.mount("/static", StaticFiles(directory=config.STATIC_DIR), name="static_pages")
print(f"Mounted bundled assets from '{dist_dir}' at '/dist'")
print(f"Mounted static pages directory '{config.STATIC_DIR}' at '/static'")


# --- Authentication HTTP Routes ---

@app.patch("/api/sessions/{session_id}", response_model=Dict[str, Any])
async def rename_session(
    session_id: str = FastApiPath(..., title="Session ID", description="The ID of the session to rename."),
    update_data: SessionUpdateRequest = Body(...), # Uses the Pydantic model defined in the previous step
    user: Dict[str, Any] = Depends(auth.get_current_active_user) # Requires active user
):
    """
    Updates the name of a specific chat session.
    Requires the user to be a participant in the session.
    """
    if not user:
        raise HTTPException(status_code=401, detail="Not authenticated")

    user_id = user['id']
    new_name = update_data.name.strip() # Get name from validated request body

    if not new_name:
         raise HTTPException(status_code=400, detail="Session name cannot be empty.")

    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()

        # First, verify the session exists AND the user is a participant
        cursor.execute(
            """
            SELECT s.id 
            FROM sessions s
            JOIN session_participants sp ON s.id = sp.session_id
            WHERE s.id = ? AND sp.user_id = ? AND s.is_active = 1 
            """,
            (session_id, user_id)
        )
        session_row = cursor.fetchone()

        if not session_row:
            # Session doesn't exist, is inactive, or user is not a participant
            raise HTTPException(status_code=404, detail="Session not found or user lacks permission.") 
            # Use 404 or 403 depending on whether you want to reveal existence

        # If verification passed, update the name
        cursor.execute(
            "UPDATE sessions SET name = ? WHERE id = ?",
            (new_name, session_id)
        )
        
        if cursor.rowcount == 0:
             # Should not happen if the verification above passed, but good practice
             conn.rollback()
             raise HTTPException(status_code=404, detail="Session not found during update.")

        conn.commit()
        print(f"API: Renamed session {session_id} to '{new_name}' for user ID {user_id}")
        
        # Return the updated session info (or just a success message)
        return {"id": session_id, "name": new_name, "message": "Session renamed successfully"}

    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        print(f"API ERROR (/api/sessions/{session_id} PATCH): Database error for user {user_id}: {db_err}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Database error renaming session.")
    except HTTPException as http_exc:
         # Re-raise HTTPExceptions (like 404/403 from check)
         raise http_exc
    except Exception as e:
        if conn: conn.rollback()
        print(f"API ERROR (/api/sessions/{session_id} PATCH): Unexpected error for user {user_id}: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Server error renaming session.")
    finally:
        if conn: conn.close()

@app.get("/login", response_class=HTMLResponse)
async def get_login_page_route(request: Request, user: Optional[Dict] = Depends(auth.get_current_user)):
    if user:
        return RedirectResponse(url="/", status_code=302)
    login_html_path = config.STATIC_DIR / "login.html"
    if not login_html_path.is_file():
        raise HTTPException(status_code=404, detail="login.html not found.")
    return FileResponse(login_html_path)

@app.post("/login")
async def handle_login_or_register_route(
    request: Request, response: FastAPIResponse, name: str = Form(...), email_form: str = Form(..., alias="email")
):
    # (Implementation from previous step is correct, no changes needed here)
    email = email_form.lower().strip()
    cleaned_name = name.strip()
    if not cleaned_name or not email or "@" not in email or "." not in email.split("@")[-1]:
        raise HTTPException(status_code=400, detail="Valid name and email are required.")
    conn = None
    try:
        conn = database.get_db_connection(); cursor = conn.cursor()
        message_to_client = ""; magic_link_sent_flag = False; user_id: Optional[int] = None
        cursor.execute("SELECT id, name, is_active FROM users WHERE email = ?", (email,))
        user_row = cursor.fetchone()
        if user_row:
            user_id = user_row["id"]
            if not user_row["is_active"]: raise HTTPException(status_code=403, detail="Account inactive.")
            if user_row["name"] != cleaned_name: cursor.execute("UPDATE users SET name = ? WHERE id = ?", (cleaned_name, user_id))
        else:
            cursor.execute("INSERT INTO users (name, email, is_active) VALUES (?, ?, ?)", (cleaned_name, email, True))
            user_id = cursor.lastrowid
            if user_id is None: raise sqlite3.Error("Failed to get lastrowid.")
        if user_id is not None:
            magic_token_raw = await auth.create_magic_link_token(user_id=user_id, conn=conn)
            base_url = str(request.base_url).rstrip('/')
            magic_login_path = request.url_for("process_magic_link_route").path
            full_magic_link = f"{base_url}{magic_login_path}?token={magic_token_raw}"
            email_sent = await email_utils.send_magic_link_email(
                recipient_email=email, recipient_name=cleaned_name,
                magic_link=full_magic_link, duration_minutes=auth.MAGIC_LINK_DURATION_MINUTES
            )
            if email_sent:
                magic_link_sent_flag = True
                message_to_client = f"Magic link sent successfully to {email}. Please check your inbox."
                conn.commit()
            else:
                conn.rollback()
                raise HTTPException(status_code=502, detail="Could not send the login email.")
        else:
            conn.rollback(); raise HTTPException(status_code=500, detail="User ID not established.")
    except HTTPException as http_exc:
        if conn: conn.rollback(); raise http_exc
    except Exception as e:
        if conn: conn.rollback(); print(f"ROUTE /login: Unhandled error: {type(e).__name__} - {e}"); traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"An internal server error occurred ({type(e).__name__}).")
    finally:
        if conn: conn.close()
    return {"message": message_to_client, "magic_link_sent": magic_link_sent_flag}


@app.get("/magic_login", response_class=HTMLResponse) # response_class acts as a default
async def process_magic_link_route(token: str, request: Request, response: Response): # Inject starlette.responses.Response
    """Processes the magic link token, sets session cookie, and uses JS to redirect."""
    user_data = await auth.verify_magic_link_token(token)

    if user_data and user_data.get("id"):
        # auth.create_user_session will modify the 'response' object passed in,
        # adding the Set-Cookie header to it.
        await auth.create_user_session(response, user_data["id"])
        print(f"User {user_data['email']} logged in via magic link. Cookie set on 'response' object. Headers: {response.headers.raw}")

        # Prepare the HTML content for the JS redirect
        redirect_url = request.url_for("get_session_choice_page")
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Logging In...</title>
            <meta http-equiv="refresh" content="0.5;url={redirect_url}">
            <script type="text/javascript">
                // Fallback redirect with a small delay
                // Allowing a fraction of a second can sometimes help browsers process cookies
                // before navigation, though the primary fix is server-side.
                setTimeout(function() {{
                    window.location.href = "{redirect_url}";
                }}, 500); // 500 milliseconds
            </script>
            <style> body {{ font-family: sans-serif; padding: 2em; }} </style>
        </head>
        <body>
            <h1>Login Successful!</h1>
            <p>You are being redirected to the application...</p>
            <p>If you are not redirected automatically, <a href="{redirect_url}">click here</a>.</p>
        </body>
        </html>
        """
        
        # Now, set the content of the *MODIFIED* 'response' parameter (which already has the cookie)
        # and return IT. This ensures the browser gets both the cookie and the HTML.
        response.status_code = 200
        response.media_type = "text/html"
        response.body = html_content.encode("utf-8")
        return response # Return the modified injected response object

    else:
        # Token is invalid, expired, or already used
        print(f"Magic link verification failed for token: {token[:10]}...")
        login_url = request.url_for("get_login_page_route")
        error_content = f"""
        <html><head><title>Login Error</title></head><body>
        <h1>Login Link Error</h1>
        <p>This login link is invalid, expired, or has already been used.</p>
        <p><a href='{login_url}'>Please try requesting a new link via the login page.</a></p>
        </body></html>
        """
        # For an error, we're not setting a cookie, so returning a new HTMLResponse is fine.
        return HTMLResponse(content=error_content, status_code=400)

@app.get("/logout")
async def logout_route(response: FastAPIResponse, session_token_value: Optional[str] = Depends(auth.cookie_scheme)):
    await auth.logout_user(response, session_token_value)
    return RedirectResponse(url="/login", status_code=302)

# --- Main Application Routes (Protected) ---

@app.get("/", response_class=HTMLResponse, name="get_session_choice_page") # Added name for url_for
async def get_session_choice_page(request: Request, user: Optional[Dict] = Depends(auth.get_current_active_user)):
    # (Implementation from previous step is correct, no changes needed here)
    if not user:
        return RedirectResponse(url="/login", status_code=302)
    session_choice_html_path = config.STATIC_DIR / "session-choice.html"
    if not session_choice_html_path.is_file():
        raise HTTPException(status_code=404, detail="session-choice.html not found.")
    try:
        with open(session_choice_html_path, "r", encoding="utf-8") as f: html_content = f.read()
        html_content = html_content.replace("[User Name]", user.get("name", "User"))
        return HTMLResponse(content=html_content)
    except Exception as e:
        print(f"Error reading/serving session-choice.html: {e}"); traceback.print_exc()
        raise HTTPException(status_code=500, detail="Error loading session choice page.")

@app.post("/sessions/create", status_code=302) # Use status_code decorator for redirects
async def create_new_session_route(
    request: Request,
    user: Dict[str, Any] = Depends(auth.get_current_active_user)
):
    """
    Creates a new chat session, sets the default name based on creation time,
    adds the creator as a participant, and redirects to the new chat page.
    """
    if not user:
         raise HTTPException(status_code=401, detail="Not authenticated")

    new_session_id = str(uuid.uuid4())
    host_user_id = user["id"]
    conn = None
    default_session_name = "" # Initialize

    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()

        # Insert the new session, letting created_at default
        # Insert NULL for name initially
        cursor.execute(
            """
            INSERT INTO sessions (id, host_user_id, name, is_active) 
            VALUES (?, ?, ?, ?)
            """,
            (new_session_id, host_user_id, None, True) # Insert None for name
        )

        # Immediately fetch the created_at timestamp for the new session
        cursor.execute(
            "SELECT created_at FROM sessions WHERE id = ?", (new_session_id,)
        )
        session_row = cursor.fetchone()
        
        # Format the timestamp for the default name
        if not session_row or not session_row["created_at"]:
             # Fallback name if fetch fails (should be rare with DEFAULT)
             default_session_name = f"Session ({new_session_id[:4]})"
             print(f"WARNING: Could not fetch created_at for session {new_session_id}. Using fallback name.")
        else:
            try:
                # Handle potential timezone info (Z or +00:00) if stored by DB
                created_at_str = session_row["created_at"].replace('Z', '+00:00')
                # Parse ISO string, making it timezone-aware if offset is present
                created_dt = datetime.datetime.fromisoformat(created_at_str)
                # Format Example: "May 08, 2025 10:30 PM" 
                # Adjust format string as desired (e.g., "%Y-%m-%d %H:%M")
                default_session_name = created_dt.strftime("%b %d, %Y %I:%M %p") 
            except (ValueError, TypeError) as fmt_err:
                 print(f"WARNING: Error formatting timestamp '{session_row['created_at']}': {fmt_err}. Using fallback name.")
                 default_session_name = f"Session ({new_session_id[:4]})"


        # Update the session with the generated default name
        cursor.execute(
            "UPDATE sessions SET name = ? WHERE id = ?",
            (default_session_name, new_session_id)
        )

        # Add the host as a participant
        cursor.execute(
            "INSERT INTO session_participants (session_id, user_id) VALUES (?, ?)",
            (new_session_id, host_user_id)
        )

        conn.commit()
        print(f"New session created: ID {new_session_id}, Name: '{default_session_name}', Hosted by User ID {host_user_id}")

    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        print(f"Database error creating session: {db_err}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Could not create new session due to a database error.")
    except Exception as e:
        if conn: conn.rollback()
        print(f"Unexpected error creating session: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Could not create new session due to a server error.")
    finally:
        if conn: conn.close()

    # Redirect to the new chat session page
    chat_url = request.url_for("get_chat_page_for_session", session_id=new_session_id)
    # Use 303 See Other for redirect after POST
    return RedirectResponse(url=str(chat_url), status_code=303)

@app.get("/chat/{session_id}", response_class=HTMLResponse, name="get_chat_page_for_session") # Added name
async def get_chat_page_for_session(
    request: Request, session_id: str = FastApiPath(...), user: Optional[Dict] = Depends(auth.get_current_active_user)
):
    # (Implementation from previous step is correct, no changes needed here)
    if not user: return RedirectResponse(url="/login", status_code=302)
    user_id = user['id']; conn = None
    try:
        conn = database.get_db_connection(); cursor = conn.cursor()
        cursor.execute("SELECT id, name FROM sessions WHERE id = ?", (session_id,))
        session_row = cursor.fetchone()
        if not session_row: raise HTTPException(status_code=404, detail="Chat session not found.")
        cursor.execute("SELECT 1 FROM session_participants WHERE session_id = ? AND user_id = ?", (session_id, user_id))
        if not cursor.fetchone(): raise HTTPException(status_code=403, detail="You do not have access to this chat session.")
        print(f"User {user['email']} accessing chat for session: {session_id}")
    except HTTPException as http_exc: raise http_exc
    except Exception as e: print(f"Error verifying session access: {e}"); traceback.print_exc(); raise HTTPException(status_code=500, detail="Error verifying session access.")
    finally:
        if conn: conn.close()
    chat_html_path = config.STATIC_DIR / "chat-session.html"
    if not chat_html_path.is_file(): raise HTTPException(status_code=404, detail="Chat interface file not found.")
    return FileResponse(chat_html_path)

async def handle_chat_message(
    chain: Any, memory: Any, websocket: WebSocket, client_js_id: str,
    current_user: Dict, session_id: str, user_input: str
):
    """
    Handles incoming chat messages from the user, processes them with the LLM,
    and streams the response back.
    (This is assumed to be your existing function, ensure it's defined or imported)
    """
    user_name = current_user.get('name', 'User') # Use .get for safety
    user_db_id = current_user['id']
    full_response = ""
    db_conn_user_msg = None

    # Log user message to database
    try:
        db_conn_user_msg = database.get_db_connection()
        db_cursor_user_msg = db_conn_user_msg.cursor()
        db_cursor_user_msg.execute(
            """INSERT INTO chat_messages (session_id, user_id, sender_name, sender_type, content, client_id_temp) 
               VALUES (?, ?, ?, ?, ?, ?)""",
            (session_id, user_db_id, user_name, 'user', user_input, client_js_id)
        )
        db_conn_user_msg.commit()
        print(f"WS: User message from {user_name} for session {session_id} (client {client_js_id}) saved to DB.")
    except Exception as db_err:
        print(f"DB ERROR saving user message for session {session_id} (client {client_js_id}): {db_err}")
        if db_conn_user_msg:
            db_conn_user_msg.rollback()
    finally:
        if db_conn_user_msg:
            db_conn_user_msg.close()

    # Process message with LLM chain
    try:
        print(f"WS: Processing chat message from {user_name} for session {session_id} (client {client_js_id}). Input: {user_input[:50]}...")
        async for chunk_data in chain.astream({"input": user_input}):
            # Assuming chunk_data is the actual string content or can be converted to string
            # If chain.astream yields dicts like {'content': '...'}, adjust accordingly:
            # chunk_str = chunk_data.get('content', '') if isinstance(chunk_data, dict) else str(chunk_data)
            chunk_str = str(chunk_data) # Adjust if your chain yields structured data

            if websocket.client_state != WebSocketState.CONNECTED:
                print(f"WS: WebSocket disconnected during LLM stream for session {session_id}. Aborting.")
                return 
            await websocket.send_text(chunk_str)
            full_response += chunk_str
        
        print(f"WS: Finished streaming LLM response for session {session_id} (client {client_js_id}).")

    except Exception as chain_exc:
        error_msg = f"<ERROR>LLM Error: Processing your message failed. Please try again. Details: {chain_exc}"
        print(f"LLM chain error for session {session_id} (client {client_js_id}): {chain_exc}")
        traceback.print_exc()
        if websocket.client_state == WebSocketState.CONNECTED:
            try:
                await websocket.send_text(error_msg)
            except Exception as send_err:
                print(f"WS ERROR: Could not send LLM error to client for session {session_id}: {send_err}")
        return # Stop further processing on LLM error

    # After successful streaming
    if websocket.client_state == WebSocketState.CONNECTED:
        try:
            await websocket.send_text("<EOS>") # End Of Stream marker
            memory.save_context({"input": user_input}, {"output": full_response})
            print(f"WS: EOS sent and context saved for session {session_id} (client {client_js_id}).")

            # Log AI message to database
            db_conn_ai_msg = None
            try:
                db_conn_ai_msg = database.get_db_connection()
                db_cursor_ai_msg = db_conn_ai_msg.cursor()
                db_cursor_ai_msg.execute(
                    """INSERT INTO chat_messages (session_id, sender_name, sender_type, content, client_id_temp) 
                       VALUES (?, ?, ?, ?, ?)""",
                    (session_id, "AI", 'ai', full_response, client_js_id)
                )
                db_conn_ai_msg.commit()
                print(f"WS: AI message for session {session_id} (client {client_js_id}) saved to DB.")
            except Exception as db_err:
                print(f"DB ERROR saving AI message for session {session_id} (client {client_js_id}): {db_err}")
                if db_conn_ai_msg:
                    db_conn_ai_msg.rollback()
            finally:
                if db_conn_ai_msg:
                    db_conn_ai_msg.close()
        except Exception as send_eos_err:
            print(f"CHAT ERROR: Post-stream processing for session {session_id} (client {client_js_id}): {send_eos_err}")


@app.websocket("/ws/{session_id_ws}/{client_js_id}")
async def websocket_endpoint(
    websocket: WebSocket, 
    session_id_ws: str = FastApiPath(..., title="Session ID", description="The ID of the chat session."),
    client_js_id: str = FastApiPath(..., title="Client JS ID", description="A unique ID generated by the client-side JavaScript.")
):
    """
    Handles WebSocket connections for real-time chat, code execution, and LLM interaction.
    Authenticates the user via session cookie, verifies participation in the session,
    and then manages the bi-directional communication.
    """
    # Step 1: Authenticate the user based on the session cookie
    session_token_from_cookie = websocket.cookies.get(auth.SESSION_COOKIE_NAME)
    current_ws_user: Optional[Dict[str, Any]] = None

    if session_token_from_cookie:
        # Use the dedicated function for WebSocket authentication
        current_ws_user = await auth.get_user_by_session_token(session_token_from_cookie)
    
    if not current_ws_user:
        ws_log_prefix = f"WS ({websocket.client.host}:{websocket.client.port}) for session {session_id_ws}, client {client_js_id}:"
        print(f"{ws_log_prefix} Authentication failed. Cookie value was {'present but invalid/expired' if session_token_from_cookie else 'missing'}. Closing WebSocket.")
        await websocket.close(code=1008) # Policy Violation - Authentication failure
        return

    user_id = current_ws_user['id']
    user_email = current_ws_user.get('email', f'UserID_{user_id}') # Use .get for safety, provide fallback
    ws_log_prefix = f"WS (User: {user_email}, Session: {session_id_ws}, ClientJS: {client_js_id}):"
    print(f"{ws_log_prefix} User successfully authenticated via session token.")

    # Step 2: Verify the authenticated user is a participant in this specific chat session
    conn_verify = None
    is_participant = False
    try:
        conn_verify = database.get_db_connection()
        cursor_verify = conn_verify.cursor()
        cursor_verify.execute("SELECT 1 FROM session_participants WHERE session_id = ? AND user_id = ?", (session_id_ws, user_id))
        is_participant = cursor_verify.fetchone() is not None
        if not is_participant:
            print(f"{ws_log_prefix} User is NOT a participant in this session. Closing WebSocket.")
    except Exception as e:
        print(f"{ws_log_prefix} DB error verifying participation: {e}")
        traceback.print_exc()
        await websocket.close(code=1011) # Internal Server Error
        return
    finally:
        if conn_verify: conn_verify.close()

    if not is_participant:
        await websocket.close(code=1008) # Policy Violation - Not authorized for this session
        return
    
    print(f"{ws_log_prefix} User confirmed as participant.")

    # Step 3: Accept the WebSocket connection
    try:
        await websocket.accept()
        print(f"{ws_log_prefix} WebSocket connection accepted.")
    except Exception as accept_err:
        print(f"{ws_log_prefix} Error accepting WebSocket connection: {accept_err}")
        # Connection might already be closed or in a weird state, so just return
        return

    # Step 4: Set up chat memory and LLM chain for this session
    memory_key = f"session_{session_id_ws}" # Memory key should be per session, not per client if shared
    # If memory is per-client within a session, you might use: f"session_{session_id_ws}_client_{client_js_id}"
    # For now, assuming shared session memory based on original code.
    
    memory = state.get_memory_for_client(memory_key) 
    
    def load_memory_for_current_session(_ignored_input_map=None):
        # This function is passed to the LLM chain to load chat history.
        # The parameter _ignored_input_map is to match Langchain's expected signature for some memory types.
        history = memory.load_memory_variables({}).get("history", [])
        # print(f"{ws_log_prefix} Loaded memory for chain: {history}") # Can be very verbose
        return history

    chain: Any
    try:
        chain = llm.create_chain(load_memory_for_current_session)
        print(f"{ws_log_prefix} LLM chain created successfully.")
    except Exception as chain_init_error:
        print(f"{ws_log_prefix} ERROR creating LCEL chain: {chain_init_error}")
        traceback.print_exc()
        # Try to send an error message to the client before closing
        if websocket.client_state == WebSocketState.CONNECTED:
            await utils.send_ws_message(websocket, "error", {"message": "Server error: Could not initialize chat."})
        await websocket.close(code=1011) # Internal Server Error
        return

    # Step 5: Main loop to handle incoming messages
    try:
        while True:
            if websocket.client_state != WebSocketState.CONNECTED:
                print(f"{ws_log_prefix} WebSocket no longer connected. Breaking message loop.")
                break
            
            received_data = await websocket.receive_text()
            print(f"{ws_log_prefix} Received data: {received_data[:100]}{'...' if len(received_data) > 100 else ''}")

            try:
                message_data = json.loads(received_data)
                message_type = message_data.get("type")
                payload = message_data.get("payload")

                if message_type == "run_code" and payload and payload.get("code_block_id"):
                    language = payload.get("language")
                    code = payload.get("code")
                    code_block_id = payload.get("code_block_id")
                    print(f"{ws_log_prefix} Received 'run_code' command for block {code_block_id}, lang: {language}.")
                    if language and code is not None:
                        # Schedule as a background task
                        asyncio.create_task(docker_utils.run_code_in_docker_stream(websocket, client_js_id, code_block_id, language, code))
                    else:
                        print(f"{ws_log_prefix} Invalid 'run_code' payload for block {code_block_id}.")
                        await utils.send_ws_message(websocket, "code_finished", {"code_block_id": payload.get("code_block_id","unknown"), "exit_code": -1, "error": "Invalid run_code payload: Missing language or code."})
                
                elif message_type == "stop_code" and payload and payload.get("code_block_id"):
                    code_block_id = payload.get("code_block_id")
                    print(f"{ws_log_prefix} Received 'stop_code' command for block {code_block_id}.")
                    # Schedule as a background task
                    asyncio.create_task(docker_utils.stop_docker_container(code_block_id))
                
                else: # Assume it's a chat message if not a known command type or if payload is just a string
                    print(f"{ws_log_prefix} Treating as chat message (type: {message_type}).")
                    # If message_type is 'chat_message' and payload is the text, or if it's just text
                    chat_input_text = payload if isinstance(payload, str) else received_data # Fallback
                    if message_type == "chat_message" and isinstance(payload, dict) and "text" in payload:
                        chat_input_text = payload["text"]
                    elif not isinstance(payload, str) and message_type is None : # if it was just a string, not json
                         chat_input_text = received_data

                    await handle_chat_message(chain, memory, websocket, client_js_id, current_ws_user, session_id_ws, chat_input_text)

            except json.JSONDecodeError:
                # If data is not JSON, treat it as a plain text chat message
                print(f"{ws_log_prefix} Data not JSON, treating as plain chat message.")
                await handle_chat_message(chain, memory, websocket, client_js_id, current_ws_user, session_id_ws, received_data)
            
            except Exception as handler_exc:
                # Catch errors from message handling logic
                print(f"{ws_log_prefix} ERROR handling received message: {handler_exc}")
                traceback.print_exc()
                if websocket.client_state == WebSocketState.CONNECTED:
                    await utils.send_ws_message(websocket, "error", {"message": "Server error processing your request."})

    except WebSocketDisconnect:
        print(f"{ws_log_prefix} WebSocket disconnected by client.")
    except Exception as e:
        # Catch other unexpected errors in the main loop
        print(f"{ws_log_prefix} ERROR in WebSocket main loop: {e}")
        traceback.print_exc()
        if websocket.client_state == WebSocketState.CONNECTED:
            try:
                await websocket.close(code=1011) # Internal Server Error
            except Exception:
                pass # Ignore errors during this close attempt
    finally:
        # Step 6: Cleanup resources
        print(f"{ws_log_prefix} Cleaning up resources...")
        state.remove_memory_for_client(memory_key) # Ensure this matches how memory was keyed
        await docker_utils.cleanup_client_containers(client_js_id) # Cleanup containers for this specific client
        
        if websocket.client_state == WebSocketState.CONNECTED:
            print(f"{ws_log_prefix} WebSocket still connected in finally block, attempting graceful close.")
            try:
                await websocket.close(code=1000) # Normal Closure
            except Exception as final_close_err:
                print(f"{ws_log_prefix} Error during final WebSocket close: {final_close_err}")
        print(f"{ws_log_prefix} Cleanup complete. WebSocket connection definitively closed.")


@app.get("/api/sessions", response_model=List[Dict[str, Any]]) # Use List from typing
async def get_user_sessions(
    request: Request, # Keep request if needed for context
    user: Dict[str, Any] = Depends(auth.get_current_active_user) # Require active user
):
    """
    Fetches a list of chat sessions the current user is a participant in.
    Returns a list of session objects, each containing 'id', 'name', and 'last_active',
    ordered by the most recently active session first.
    """
    if not user:
        # This dependency should already handle redirection/errors for unauthenticated users,
        # but an explicit check can be kept if desired for clarity in an API.
        # However, Depends(auth.get_current_active_user) should raise its own HTTPException
        # if the user is not active or not found, making this redundant.
        # For an API, consistently relying on the dependency is cleaner.
        # If get_current_active_user returns None for unauthenticated instead of raising,
        # then this check is necessary. Let's assume it raises or provides a valid user.
        pass

    user_id = user['id']
    sessions_list = [] # Renamed to avoid conflict with 'sessions' table/module
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()
        
        # Fetches sessions where the user is a participant, ordered by most recent activity.
        # Uses 'last_accessed_at' for "last active" status.
        cursor.execute(
            """
            SELECT s.id, s.name, s.last_accessed_at AS last_active
            FROM sessions s
            JOIN session_participants sp ON s.id = sp.session_id
            WHERE sp.user_id = ? AND s.is_active = 1 
            ORDER BY s.last_accessed_at DESC 
            """,
            (user_id,)
        )

        rows = cursor.fetchall()
        for row in rows:
            sessions_list.append(dict(row)) # Convert sqlite3.Row to dict

        print(f"API: Fetched {len(sessions_list)} sessions for user ID {user_id}, ordered by last active.")
        return sessions_list

    except sqlite3.Error as db_err:
        print(f"API ERROR (/api/sessions): Database error for user {user_id}: {db_err}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Database error fetching sessions.")
    except Exception as e:
        print(f"API ERROR (/api/sessions): Unexpected error for user {user_id}: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Server error fetching sessions.")
    finally:
        if conn:
            conn.close()

@app.delete("/api/sessions/{session_id}", status_code=204) # 204 No Content is typical for successful DELETE
async def delete_session_route(
    session_id: str = FastApiPath(..., title="Session ID", description="The ID of the session to delete."),
    user: Dict[str, Any] = Depends(auth.get_current_active_user) # Require active user
):
    """
    Deletes a specific chat session.
    Requires the user to be the host of the session to delete it.
    (Or adjust permissions as per your application's rules)
    """
    if not user:
        # Should be handled by Depends, but as a safeguard if Depends can return None
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")

    user_id = user['id']
    conn = None
    try:
        conn = database.get_db_connection()
        cursor = conn.cursor()

        # First, verify the session exists AND the current user is the host.
        # Adjust this logic if other users (e.g., admins, participants with special rights) can delete.
        cursor.execute(
            "SELECT host_user_id FROM sessions WHERE id = ? AND is_active = 1",
            (session_id,)
        )
        session_row = cursor.fetchone()

        if not session_row:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Session not found or is inactive.")
        
        if session_row["host_user_id"] != user_id:
            # User is not the host of this session
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="You do not have permission to delete this session.")

        # If verification passed, delete the session.
        # ON DELETE CASCADE in your schema for session_participants and chat_messages
        # should handle deletion of related records in those tables.
        cursor.execute(
            "DELETE FROM sessions WHERE id = ?",
            (session_id,)
        )
        
        if cursor.rowcount == 0:
            # This case should ideally not be reached if the above checks passed,
            # but it's a safeguard.
            conn.rollback() # Rollback if no rows were affected, indicating an issue.
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Session found but could not be deleted (e.g., already deleted by another request).")

        conn.commit()
        print(f"API: Deleted session {session_id} by user ID {user_id}")
        
        # For a DELETE request, returning status_code=204 means no content body is expected.
        # FastAPI will handle sending the correct empty response.
        return 

    except sqlite3.Error as db_err:
        if conn: conn.rollback()
        print(f"API ERROR (DELETE /api/sessions/{session_id}): Database error for user {user_id}: {db_err}")
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Database error deleting session.")
    except HTTPException as http_exc:
        # Re-raise HTTPExceptions (like 404/403 from checks)
        if conn: conn.rollback() # Ensure rollback on known HTTP exceptions too if transaction started
        raise http_exc
    except Exception as e:
        if conn: conn.rollback()
        print(f"API ERROR (DELETE /api/sessions/{session_id}): Unexpected error for user {user_id}: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Server error deleting session.")
    finally:
        if conn:
            conn.close()

# --- Server Start Function ---
def start_server():
    # (Implementation from previous step is correct, no changes needed here)
    host = os.getenv("HOST", "127.0.0.1"); port = int(os.getenv("PORT", 8001)); url = f"http://{host}:{port}"
    print("-" * 30); print(f"Tesseracs Chat Server Starting..."); print(f"Access via: {url}/login")
    print(f"Using Config: Model='{config.MODEL_ID}', Ollama='{config.OLLAMA_BASE_URL}'")
    print(f"Static files from: {config.STATIC_DIR}, Bundles from: {dist_dir}")
    print("-" * 30)
    try: webbrowser.open(f"{url}/login")
    except Exception as browser_err: print(f"Warning: Could not open browser: {browser_err}")
    uvicorn.run("app.main:app", host=host, port=port, log_level="info", reload=True)

if __name__ == "__main__":
    start_server()


=== app/state.py ===
import asyncio
from langchain.memory import ConversationBufferMemory
from typing import Dict, Any
from docker.models.containers import Container # For type hinting
from fastapi import WebSocket

# --- Global State for WebSocket Connections and Running Containers ---
client_memory: Dict[str, ConversationBufferMemory] = {}

# Stores info about currently running code executions
# Format: { "code_block_id": {"container": Container, "stream_task": asyncio.Task, "client_id": str, "websocket": WebSocket, "stop_event": asyncio.Event} }
running_containers: Dict[str, Dict[str, Any]] = {}
running_containers_lock = asyncio.Lock() # Lock for safe concurrent access

# --- Memory Management Functions ---
def get_memory_for_client(client_id: str) -> ConversationBufferMemory:
    """Retrieves or creates memory for a specific client."""
    global client_memory
    if client_id not in client_memory:
        client_memory[client_id] = ConversationBufferMemory(return_messages=True, memory_key="history")
        print(f"Initialized new memory for client: {client_id}")
    return client_memory[client_id]

def remove_memory_for_client(client_id: str):
    """Removes memory when a client disconnects."""
    global client_memory
    if client_id in client_memory:
        del client_memory[client_id]
        print(f"Removed memory for client: {client_id}")

=== app/utils.py ===
# app/utils.py
import json
import traceback
from fastapi import WebSocket, WebSocketDisconnect
from fastapi.websockets import WebSocketState

async def send_ws_message(websocket: WebSocket, message_type: str, payload: dict):
    """Safely sends a JSON message over the WebSocket."""
    # Check state before sending (no change needed here)
    if websocket.client_state != WebSocketState.CONNECTED:
        print(f"[utils] WebSocket not connected, cannot send {message_type} for {payload.get('code_block_id', 'N/A')}")
        return
    try:
        await websocket.send_json({"type": message_type, "payload": payload})
    except WebSocketDisconnect:
        print(f"[utils] WebSocket disconnected while trying to send {message_type} for {payload.get('code_block_id', 'N/A')}")
    except Exception as e:
        # Catch other potential errors like Runtime Error if connection closed during send
        print(f"[utils] Error sending WebSocket message ({message_type}) for {payload.get('code_block_id', 'N/A')}: {e}")
        # traceback.print_exc() # Optional: uncomment for more detail

=== app/static/_sidebar.html ===
<div class="p-4 border-b border-gray-700">
    <h2 class="text-xl font-semibold text-white">Tesseracs</h2>
</div>

<nav class="flex-1 p-4 space-y-2 sidebar-scrollable">
    <form action="/sessions/create" method="POST" class="mb-4" id="new-chat-form-sidebar">
        <button type="submit" class="w-full flex items-center justify-center px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-md text-white font-medium transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
            New Chat
        </button>
    </form>

    <div class="text-sm text-gray-400 uppercase tracking-wider mb-2">Sessions</div>
    <ul id="session-list" class="space-y-1">
        <li class="px-3 py-1 text-gray-400 italic text-sm">Loading sessions...</li>
    </ul>

    <div class="mt-auto pt-4 border-t border-gray-700">
        <a href="#" id="settings-link-sidebar" class="flex items-center px-3 py-2 text-gray-300 hover:bg-gray-700 hover:text-white rounded-md text-sm">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826 3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
            Settings
        </a>
    </div>
</nav>

<div class="p-4 border-t border-gray-700">
    <a href="/logout" id="logout-link-sidebar" class="flex items-center justify-center w-full px-4 py-2 border border-gray-600 hover:bg-gray-700 rounded-md text-sm font-medium text-gray-300 hover:text-white transition duration-150 ease-in-out">
        Logout
    </a>
</div>

=== app/static/chat-session.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tesseracs Chat Session</title>
    <link rel="stylesheet" href="/dist/input.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        .sidebar-scrollable { overflow-y: auto; scrollbar-width: thin; scrollbar-color: #a0aec0 #edf2f7; }
        .sidebar-scrollable::-webkit-scrollbar { width: 6px; }
        .sidebar-scrollable::-webkit-scrollbar-track { background: #edf2f7; border-radius: 3px; }
        .sidebar-scrollable::-webkit-scrollbar-thumb { background-color: #a0aec0; border-radius: 3px; border: 1px solid #edf2f7; }
    </style>
</head>
<body class="font-sans bg-gray-100 text-gray-800">

    <div class="flex h-screen overflow-hidden">
        <aside id="sidebar-loader-target" class="w-64 bg-gray-800 text-gray-200 flex flex-col overflow-hidden">
            </aside>

        <main class="flex-1 flex flex-col overflow-hidden">
            <header class="bg-white border-b border-gray-200 p-4 shadow-sm">
                <h1 id="chat-session-title" class="text-lg font-semibold text-gray-800">Chat Session</h1>
            </header>
            <div id="chat-history" class="flex-1 overflow-y-auto p-4 space-y-4 bg-white shadow-inner m-4 rounded-lg">
                </div>
            <footer class="p-4 bg-gray-200 border-t border-gray-300">
                <form id="chat-form" class="flex items-center space-x-2">
                    <div class="think-checkbox-container flex items-center text-sm text-gray-600 mr-2">
                        <input type="checkbox" id="think-checkbox" class="mr-1 h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 cursor-pointer">
                        <label for="think-checkbox" class="cursor-pointer select-none">Think</label>
                    </div>
                    <input type="text" id="message-input" placeholder="Type your message..." autocomplete="off" required
                           class="flex-1 p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                    <button type="submit" id="send-button"
                            class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                        Send
                    </button>
                </form>
            </footer>
        </main>
    </div>

    <script type="module">
        import { loadSidebarHTML, populateSessionList } from '/static/js/app-ui.js';

        document.addEventListener('DOMContentLoaded', async () => {
            console.log("Chat Session Page: DOMContentLoaded. Attempting to load UI components.");
            // **MODIFIED PATH HERE** Assuming _sidebar.html is in your static folder.
            // If _sidebar.html is truly at the root, and /_sidebar.html got a 404,
            // ensure the file exists at the root and the server serves it.
            const sidebarLoaded = await loadSidebarHTML('/static/_sidebar.html', 'sidebar-loader-target');
            if (sidebarLoaded) {
                await populateSessionList('/api/sessions', 'session-list', '/chat-session.html');
            } else {
                console.error("Chat Session Page: Sidebar loading failed, session list will not be populated by app-ui.js.");
            }
        });
    </script>
    <script src="/dist/script.js" defer></script>
</body>
</html>

=== app/static/input.css ===
/* app/static/input.css */

/* --- Imports for Prism and KaTeX --- */
@import 'prismjs/themes/prism-tomorrow.css';
@import 'katex/dist/katex.min.css';
/* ----------------------------------- */

/* --- Tailwind CSS Directives --- */
@tailwind base;
@tailwind components;
@tailwind utilities;
/* ----------------------------------- */

/* --- General Styles & Scrollbar --- */
html, body {
    height: 100%;
    margin: 0;
    font-family: 'Inter', sans-serif;
    background-color: #f3f4f6; /* Light gray background for the whole page */
}

#chat-history {
    flex: 1;
    overflow-y: auto;
    padding: 1rem; /* Use rem for scalable padding */
    display: flex;
    flex-direction: column;
    background-color: #ffffff; /* White background for chat area */
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
    margin: 1rem; /* Add margin around the chat history */
    border-radius: 0.5rem; /* Rounded corners */
}

/* Custom scrollbar for chat history */
#chat-history::-webkit-scrollbar { width: 8px; }
#chat-history::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
#chat-history::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
#chat-history::-webkit-scrollbar-thumb:hover { background: #555; }

/* --- Message Styling --- */
.message {
    padding: 0.5rem 0.75rem; /* Use rem */
    margin-bottom: 0.5rem;
    border-radius: 0.5rem;
    max-width: 90%;
    word-wrap: break-word;
    line-height: 1.5; /* Improve readability */
}

.user-message {
    background-color: #dbeafe; /* Tailwind blue-100 */
    align-self: flex-end;
    margin-left: auto;
    white-space: pre-wrap; /* Preserve user whitespace */
}

/* Container for a full AI turn (thinking + bubble + code blocks) */
.ai-turn-container {
    display: flex;
    flex-direction: column;
    align-items: flex-start; /* Align items to the left */
    width: 100%; /* Take full width to allow max-width on children */
    margin-bottom: 0.5rem; /* Consistent spacing */
}

.ai-message {
    background-color: #e5e7eb; /* Tailwind gray-200 */
    align-self: flex-start;
    margin-right: auto;
    max-width: 90%; /* Limit width */
    padding: 0.5rem 0.75rem; /* Added padding for consistency */
    border-radius: 0.5rem; /* Added radius for consistency */
}

/* Styling for Markdown elements rendered inside .ai-message */
.ai-message p { margin-bottom: 0.5em; }
.ai-message p:last-child { margin-bottom: 0; }
.ai-message ul, .ai-message ol { margin-left: 1.5em; margin-top: 0.5em; margin-bottom: 0.5em; }
.ai-message li { margin-bottom: 0.25em; }
.ai-message blockquote { border-left: 3px solid #ccc; padding-left: 0.8em; margin-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; color: #555; }
.ai-message code { /* Inline code */
    background-color: rgba(0, 0, 0, 0.06);
    padding: 0.1em 0.3em;
    border-radius: 3px;
    font-family: monospace;
    font-size: 0.9em;
}
/* Avoid double background for code elements within Prism blocks */
.ai-message pre[class*="language-"] code {
    background-color: transparent;
    padding: 0;
    border-radius: 0;
    font-size: inherit; /* Inherit size from pre */
}
.ai-message a { color: #007bff; text-decoration: underline; }
.ai-message a:hover { color: #0056b3; }
.ai-message hr { border: none; border-top: 1px solid #ccc; margin: 1em 0; }
.ai-message table { border-collapse: collapse; margin: 1em 0; width: auto; }
.ai-message th, .ai-message td { border: 1px solid #ccc; padding: 0.3em 0.6em; text-align: left; }
.ai-message th { background-color: #f2f2f2; font-weight: bold; }

/* Code reference style in the main bubble */
.code-reference {
    font-family: monospace;
    background-color: rgba(0, 0, 0, 0.08); /* Light gray background */
    padding: 1px 5px; /* Small padding */
    border-radius: 4px; /* Rounded corners */
    font-size: 0.85em; /* Slightly smaller font */
    white-space: nowrap; /* Prevent breaking */
    margin: 0 2px; /* Add slight spacing around it */
}

/* --- Loading/Thinking Indicators --- */
.loading-dots { display: inline-block; }
.loading-dots::after {
    display: inline-block; position: relative; left: 1px;
    animation: ellipsis 1.5s infinite; content: ".";
    width: 1.5em; text-align: left; vertical-align: bottom;
}
@keyframes ellipsis {
    0% { content: "."; } 33% { content: ".."; } 66% { content: "..."; }
}

/* --- Thinking Area Styling --- */
.thinking-area {
    width: 100%; max-width: 90%; margin-bottom: 4px;
    align-self: flex-start; font-size: 0.9em;
}
.thinking-area details {
    width: 100%; border: 1px dashed #aaa; border-radius: 6px;
    background-color: #f0f0f0; overflow: hidden;
}
.thinking-summary {
    padding: 3px 8px; cursor: pointer; font-weight: normal; color: #444;
    background-color: #e0e0e0; border-bottom: 1px dashed #aaa;
    outline: none; user-select: none; list-style: none; display: block;
    transition: background-color 0.15s ease;
}
.thinking-summary:hover { background-color: #d0d0d0; }
.thinking-summary::-webkit-details-marker { display: none; }
.thinking-summary .dots { display: inline-block; margin-left: 4px; }
.thinking-summary .dots::after { /* Uses ellipsis animation defined above */
    display: inline-block; position: relative; left: 1px;
    animation: ellipsis 1.5s infinite; content: ".";
    width: 1.5em; text-align: left; vertical-align: bottom;
}
.thinking-area details[open] > .thinking-summary .dots { display: none; }
.thinking-area details pre {
    margin: 0; padding: 8px; background-color: #f8f8f8;
    white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word;
    max-height: 200px; overflow-y: auto;
}

/* --- Code Block Area --- */
.code-blocks-area {
    width: 100%; /* Allow blocks to take full width */
    max-width: 90%; /* Match AI bubble width */
    align-self: flex-start; /* Align with AI bubble */
    margin-top: 0.5rem; /* Space above code blocks */
}

.code-block-container {
    margin-bottom: 0.75rem; /* Space between code blocks */
    border-radius: 0.375rem; /* 6px - Applied to the whole container */
    overflow: hidden; /* Crucial: clips children to the container's radius */
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

/* --- Unified Code Block Header Styles --- */
.code-block-header,
.code-output-header {
    display: flex;
    align-items: center;
    background-color: #e5e7eb; /* Tailwind gray-200 (Unified Style) */
    padding: 0.25rem 0.5rem;    /* Unified Style */
    font-size: 0.8em;          /* Unified Style */
    color: #4b5563;            /* Unified Style (Gray-600) */
    gap: 0.625rem;             /* Unified Style (10px) */
}

/* Specific adjustment for Output Header spacing */
.code-output-header {
    margin-top: 0.25rem; /* Keep space above output header */
    /* border-top: none; /* Ensure no top border if previously added */
}

/* --- Header Content Alignment --- */

/* Buttons Div (Shared) */
.code-block-buttons,
.output-header-buttons { /* Combined selector */
    display: flex;
    align-items: center;
    gap: 0.375rem; /* 6px */
    flex-shrink: 0;
}

/* Title (Shared Properties) */
.code-block-title,
.output-header-title { /* Combined selector */
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* Code Header Title Specifics */
.code-block-title {
    flex-shrink: 1; /* Allow title to shrink if needed */
    flex-grow: 1; /* Allow title to grow */
    text-align: left;
}

/* Output Header Title Specifics */
.output-header-title {
    flex-shrink: 0; /* Don't let title shrink */
    margin-right: 0.625rem; /* Space after title, before status */
}

/* Placeholder for alignment in Output Header */
.output-header-button-placeholder {
    display: inline-block;
    width: 24px;
    height: 24px;
    flex-shrink: 0;
}

/* Status Span (Only in Output Header) */
.code-status-span {
    margin-left: auto; /* Pushes this element to the far right */
    text-align: right;
    font-style: italic;
    font-size: 0.9em; /* Relative to header font-size */
    padding: 0 0.3125rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    color: #6b7280; /* Default Idle color */
    flex-shrink: 0; /* Prevent status from shrinking */
}
.code-status-span.running, .code-status-span.stopping { color: #ca8a04; font-weight: 500; }
.code-status-span.success { color: #16a34a; font-weight: 500; }
.code-status-span.error, .code-status-span.stopped { color: #dc2626; font-weight: 500; }


/* --- Code Block Action Buttons (Shared Base Style) --- */
.code-action-btn {
    background-color: #d1d5db; /* Tailwind gray-300 */
    color: #4b5563; /* Gray-600 */
    border: none;
    padding: 0.1875rem 0.4375rem; /* 3px 7px */
    border-radius: 0.25rem; /* 4px */
    cursor: pointer;
    font-size: 0.9em; /* Relative to header font-size */
    line-height: 1.2;
    transition: background-color 0.2s ease, color 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    white-space: nowrap;
}
.code-action-btn:hover { background-color: #9ca3af; color: #1f2937; }
.code-action-btn:disabled { opacity: 0.6; cursor: not-allowed; }
.code-action-btn.copied { background-color: #16a34a; color: white; }

/* --- Button Style Override for Output Header (Ensures consistency) --- */
/* This rule overrides browser defaults/resets for buttons specifically in the output header */
.code-output-header .code-action-btn {
    /* Re-apply key styles from .code-action-btn to ensure they take precedence */
    background-color: #d1d5db;
    color: #4b5563;
    border: none;
    padding: 0.1875rem 0.4375rem;
    border-radius: 0.25rem;
    cursor: pointer;
    font-size: 0.9em;
    line-height: 1.2;
    transition: background-color 0.2s ease, color 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    white-space: nowrap;
}
.code-output-header .code-action-btn:hover {
     background-color: #9ca3af;
     color: #1f2937;
}
/* Add other states (:disabled, .copied) if needed for output header specifically */
/* e.g., .code-output-header .code-action-btn.copied { ... } */


/* Specific Run/Stop Button Styling (Only in Code Header) */
.run-code-btn { /* This class is only applied in the code header */
    padding: 4px; width: 24px; height: 24px; font-size: 1em; /* Relative to header font-size */
    background-color: transparent !important; border: none !important;
    color: #9ca3af; transition: color 0.2s ease;
}
.run-code-btn:hover { color: #4b5563; background-color: transparent !important; }
.run-code-btn[data-status="idle"] { color: #16a34a; }
.run-code-btn[data-status="idle"]:hover { color: #15803d; }
.run-code-btn[data-status="running"] { color: #dc2626; }
.run-code-btn[data-status="running"]:hover { color: #b91c1c; }
.run-code-btn[data-status="stopping"] { color: #f59e0b; cursor: wait; animation: spin 1s linear infinite; }
.run-code-btn[data-status="stopping"]:hover { color: #d97706; }
@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

/* --- Code Area & Output Console --- */

/* Style for the <pre> containing the code input */
.code-block-container > pre[class*="language-"] { /* More specific selector */
    margin: 0;
    border: 1px solid #d1d5db; /* Lighter border for code input */
    border-top: none;
    border-bottom: none !important; /* Remove bottom border if output follows */
    overflow: hidden;
    /* Background comes from Prism theme */
}

/* Style for the editable code element itself */
.code-block-container > pre[class*="language-"] > code[class*="language-"] {
    outline: none;
    white-space: pre-wrap !important;
    word-wrap: break-word !important;
    display: block;
    min-height: 1.5em;
    padding: 0.5em; /* Padding inside code input */
}
.code-block-container > pre[class*="language-"] > code[class*="language-"]:focus {
    background-color: rgba(0, 0, 0, 0.03); /* Slight focus indicator */
}

/* Output Console Container */
.code-output-console {
    background-color: #1f2937; /* Dark background */
    color: #f3f4f6;            /* Light text */
    padding: 0;                /* No padding on container */
    border: 1px solid #4b5563; /* Darker border */
    border-top: none !important;/* No top border */
    max-height: 250px;
    overflow-y: auto;
    font-family: monospace;
    font-size: 0.85em;         /* Slightly smaller than code input */
    line-height: 1.4;
}

/* Style for the <pre> inside the Output Console */
.code-output-console pre {
    margin: 0;
    white-space: pre-wrap;
    word-wrap: break-word;
    color: inherit;
    border: none !important; /* Explicitly remove border */
    padding: 0.5rem;         /* Padding for the output text */
    background-color: transparent; /* Use parent's background */
    outline: none !important;
}

/* Styles for the output text spans */
.code-output-console span { display: inline; white-space: pre-wrap; }
.code-output-console span.stdout-output { color: #ffffff; }
.code-output-console span.stderr-output { color: #f87171; } /* Lighter Red */

/* --- Hide/Show Functionality --- */
.code-block-container > pre.hidden, /* Hides code input pre */
.code-output-console.hidden,        /* Hides output console div */
.code-output-header.hidden          /* Hides output header */
 { display: none !important; }


/* --- Footer & Input --- */
footer { padding: 1rem; background-color: #e5e7eb; border-top: 1px solid #d1d5db; }
#chat-form { display: flex; align-items: center; gap: 0.5rem; }
.think-checkbox-container { display: flex; align-items: center; font-size: 0.9em; color: #4b5563; }
.think-checkbox-container input { margin-right: 4px; cursor: pointer; }
.think-checkbox-container label { cursor: pointer; user-select: none;}
#message-input {
    flex-grow: 1; padding: 0.5rem 0.75rem; border: 1px solid #d1d5db;
    border-radius: 0.5rem; outline: none;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
}
#message-input:focus { border-color: #2563eb; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); }
#send-button {
    background-color: #2563eb; color: white; font-weight: 500; padding: 0.5rem 1rem;
    border-radius: 0.5rem; border: none; cursor: pointer; transition: background-color 0.2s ease;
}
#send-button:hover { background-color: #1d4ed8; }
#send-button:disabled { opacity: 0.6; cursor: not-allowed; }

/* --- Error/System Messages --- */
.error-message {
    background-color: #fee2e2; color: #991b1b; border: 1px solid #fecaca;
    align-self: flex-start; margin-right: auto; padding: 0.5rem 0.75rem;
    border-radius: 0.5rem; max-width: 90%; word-wrap: break-word;
    margin-bottom: 0.5rem; white-space: pre-wrap;
}
.system-message {
    width: 100%; text-align: center; font-size: 0.875rem; color: #6b7280;
    font-style: italic; margin: 0.25rem 0;
}

/* --- KaTeX Specific Styling --- */
span[data-katex-rendered="true"] .katex-display { margin: 0.5em 0; overflow-x: auto; overflow-y: hidden; padding: 0.2em 0; }
span[data-katex-rendered="true"] .katex { line-height: normal; vertical-align: baseline; font-size: 1em; }
.katex-error { color: #cc0000; background-color: #fdd; border: 1px solid #cc0000; padding: 2px 4px; border-radius: 3px; }

/* --- Utility --- */
.hidden { display: none !important; }

/* Add Prism.js theme styles separately */
/* Link to a theme in your HTML or include the theme CSS rules here */
/* e.g., @import url('path/to/prism-theme.css'); */


=== app/static/login.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Login - Tesseracs Chat</title>
    <link rel="stylesheet" href="/dist/input.css">
</head>
<body class="flex flex-col justify-center items-center min-h-screen bg-gray-100 font-sans p-4">
    <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-md">
        <h1 class="text-center mb-6 text-2xl font-semibold text-gray-900">Tesseracs Chat</h1>

        <div id="message-area" class="p-3 rounded-md text-sm text-center" style="display: none;"></div>

        <form id="login-form" class="mt-4">
            <div class="mb-5">
                <label for="name" class="block mb-2 text-sm font-medium text-gray-700">Name:</label>
                <input type="text" id="name" name="name" required autocomplete="name" class="block w-full py-2.5 px-3 border border-gray-300 rounded-md text-sm transition-colors duration-200 ease-in-out focus:border-blue-600 focus:ring-2 focus:ring-blue-300 focus:outline-none">
            </div>
            <div class="mb-5">
                <label for="email" class="block mb-2 text-sm font-medium text-gray-700">Email:</label>
                <input type="email" id="email" name="email" required autocomplete="email" class="block w-full py-2.5 px-3 border border-gray-300 rounded-md text-sm transition-colors duration-200 ease-in-out focus:border-blue-600 focus:ring-2 focus:ring-blue-300 focus:outline-none">
            </div>
            <button type="submit" id="submit-button" class="w-full py-3 bg-blue-600 text-white rounded-md text-sm font-medium cursor-pointer transition-colors duration-200 ease-in-out hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed">Continue with Email</button>
        </form>
        <p class="text-xs text-center mt-6 text-gray-500">
            Enter your name and email. We'll send you a secure magic link to log in or create your account.
        </p>
    </div>

    <script>
        document.getElementById('login-form').addEventListener('submit', async function(event) {
            event.preventDefault();
            const form = event.target;
            const nameInput = document.getElementById('name');
            const emailInput = document.getElementById('email');
            const submitButton = document.getElementById('submit-button');
            const messageArea = document.getElementById('message-area');

            messageArea.style.display = 'none';
            messageArea.textContent = '';
            messageArea.className = 'p-3 rounded-md text-sm text-center'; // Reset classes, keep base Tailwind
            submitButton.disabled = true;
            submitButton.textContent = 'Processing...';

            const formData = new FormData();
            formData.append('name', nameInput.value.trim());
            formData.append('email', emailInput.value.trim().toLowerCase());

            try {
                const response = await fetch('/login', {
                    method: 'POST',
                    body: formData
                });
                const result = await response.json();

                if (response.ok) {
                    messageArea.textContent = result.message || 'Magic link sent! Please check your email.';
                    messageArea.classList.remove('text-red-700', 'bg-red-100', 'border-red-300'); // Remove error classes if any
                    messageArea.classList.add('text-green-700', 'bg-green-100', 'border', 'border-green-300');
                    nameInput.value = ''; 
                    emailInput.value = '';
                } else {
                    messageArea.textContent = result.detail || 'An error occurred. Please try again.';
                    messageArea.classList.remove('text-green-700', 'bg-green-100', 'border-green-300'); // Remove success classes if any
                    messageArea.classList.add('text-red-700', 'bg-red-100', 'border', 'border-red-300');
                }
            } catch (error) {
                console.error('Login form submission error:', error);
                messageArea.textContent = 'A network error occurred. Please try again.';
                messageArea.classList.remove('text-green-700', 'bg-green-100', 'border-green-300');
                messageArea.classList.add('text-red-700', 'bg-red-100', 'border', 'border-red-300');
            } finally {
                messageArea.style.display = 'block';
                submitButton.disabled = false;
                submitButton.textContent = 'Continue with Email';
            }
        });
    </script>
</body>
</html>

=== app/static/script.js ===
// --- JS Imports ---
import { marked } from 'marked';
import katex from 'katex';
import Prism from 'prismjs';

// --- Prism Components ---

import 'prismjs/components/prism-clike';
import 'prismjs/components/prism-python';
import 'prismjs/components/prism-javascript';
import 'prismjs/components/prism-css';
import 'prismjs/components/prism-bash';
import 'prismjs/components/prism-json';
import 'prismjs/components/prism-yaml';
import 'prismjs/components/prism-sql';
import 'prismjs/components/prism-java';
import 'prismjs/components/prism-csharp';
import 'prismjs/components/prism-go';
import 'prismjs/components/prism-rust';
import 'prismjs/components/prism-docker';
import 'prismjs/components/prism-typescript';
import 'prismjs/components/prism-c';
import 'prismjs/components/prism-cpp';
// import 'prismjs/components/prism-php'; // not working
// import 'prismjs/components/prism-ruby'; // not working
// --------------------------

// --- Constants and Variables ---
const chatHistory = document.getElementById('chat-history');
const chatForm = document.getElementById('chat-form');
const messageInput = document.getElementById('message-input');
const sendButton = document.getElementById('send-button');
const thinkCheckbox = document.getElementById('think-checkbox');

let websocket;
const clientId = `web-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
let currentTurnId = 0;

const MODE_ANSWER = 'MODE_ANSWER';
const MODE_SEEKING_CODE_LANGUAGE = 'MODE_SEEKING_CODE_LANGUAGE';
const MODE_INSIDE_CODE_BLOCK = 'MODE_INSIDE_CODE_BLOCK';
const MODE_KATEX_BUFFERING_INLINE = 'MODE_KATEX_BUFFERING_INLINE';
const MODE_KATEX_BUFFERING_DISPLAY = 'MODE_KATEX_BUFFERING_DISPLAY';
const MODE_MAYBE_START_DISPLAY_KATEX = 'MODE_MAYBE_START_DISPLAY_KATEX';
const MODE_SEEKING_TAG = 'MODE_SEEKING_TAG';
const MODE_INSIDE_THINK = 'MODE_INSIDE_THINK';
const MODE_MAYBE_END_THINK = 'MODE_MAYBE_END_THINK';
const NO_THINK_PREFIX = "\\no_think";
const MODE_SEEKING_CODE_START_FENCE = 'MODE_SEEKING_CODE_START_FENCE';
const MODE_SEEKING_CODE_END_FENCE = 'MODE_SEEKING_CODE_END_FENCE';

let currentProcessingMode = MODE_ANSWER;
let langBuffer = '';
let currentCodeBlockLang = ''; // Stores the language name (e.g., 'python')
let currentCodeBlockElement = null; // The <code> element
let currentCodeBlockPreElement = null; // The <pre> element wrapping the code
let katexBuffer = '';
let currentKatexMarkerId = null;
let thinkBuffer = '';
let tagBuffer = '';
let fenceBuffer = ''; // Added for fence detection
let currentAiTurnContainer = null;
let currentAnswerElement = null;
let currentThinkingArea = null;
let currentThinkingPreElement = null;
let currentCodeBlocksArea = null;
let codeBlockCounterThisTurn = 0;
let thinkingRequestedForCurrentTurn = false;
let accumulatedAnswerText = '';
let lastAppendedNode = null;
let hasThinkingContentArrivedThisTurn = false;
let firstAnswerTokenReceived = false;

const FENCE = '```';
const THINK_START_TAG = '<think>';
const THINK_END_TAG = '</think>';
const KATEX_PLACEHOLDER_PREFIX = '%%KATEX_PLACEHOLDER_';
const KATEX_RENDERED_ATTR = 'data-katex-rendered';


/**
 * Extracts the session ID from the current URL path.
 * Assumes URL is like /chat/SESSION_ID/...
 * Returns the session ID string or null if not found or invalid.
 */
function getSessionIdFromPath() {
    const pathName = window.location.pathname; // Get the path part of the URL (e.g., "/chat/some-session-id")
    const pathParts = pathName.split('/');    // Split the path by "/"
                                            // For "/chat/some-session-id", pathParts will be ["", "chat", "some-session-id"]

    // Check if the path structure is as expected:
    // 1. pathParts.length >= 3 (e.g., "", "chat", "session_id")
    // 2. pathParts[1] is exactly "chat"
    if (pathParts.length >= 3 && pathParts[1] === 'chat') {
        const sessionId = pathParts[2]; // The session ID is the third part
        if (sessionId && sessionId.trim() !== "") { // Ensure it's not empty
            // console.log("Extracted session ID:", sessionId); // Keep for debugging if needed
            return sessionId;
        } else {
            console.error("Session ID extracted from path is empty or invalid.");
            return null;
        }
    }

    // console.log("Not on a chat page or session ID invalid:", pathName); // Keep for debugging if needed
    return null; // Return null if the path doesn't match the expected structure
}

// --- Utility Functions ---

function scrollToBottom(behavior = 'auto') {
    const isNearBottom = chatHistory.scrollHeight - chatHistory.scrollTop - chatHistory.clientHeight < 100;
    if (isNearBottom) {
        requestAnimationFrame(() => {
            chatHistory.scrollTo({ top: chatHistory.scrollHeight, behavior: behavior });
        });
    }
}

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
};

function getCursorPosition(parentElement) {
    const selection = window.getSelection();
    if (selection.rangeCount === 0) return -1;

    const range = selection.getRangeAt(0);
    if (!parentElement.contains(range.startContainer)) {
        return -1;
    }

    const preSelectionRange = range.cloneRange();
    preSelectionRange.selectNodeContents(parentElement);
    try {
        preSelectionRange.setEnd(range.startContainer, range.startOffset);
    } catch (e) {
        console.error("Error setting preSelectionRange end:", e, "Range:", range);
        return -1;
    }
    return preSelectionRange.toString().length;
}

function setCursorPosition(parentElement, offset) {
    const selection = window.getSelection();
    if (!selection) return;

    const range = document.createRange();
    let charCount = 0;
    let foundStart = false;

    function findNodeAndOffset(node) {
        if (foundStart) return;

        if (node.nodeType === Node.TEXT_NODE) {
            const nextCharCount = charCount + node.length;
            if (!foundStart && offset >= charCount && offset <= nextCharCount) {
                try {
                    const offsetInNode = offset - charCount;
                    range.setStart(node, offsetInNode);
                    foundStart = true;
                } catch (e) {
                    console.error("Error setting range start:", e, "Node:", node, "Offset:", offsetInNode);
                }
            }
            charCount = nextCharCount;
        } else {
            for (let i = 0; i < node.childNodes.length; i++) {
                findNodeAndOffset(node.childNodes[i]);
                if (foundStart) break;
            }
        }
    }

    findNodeAndOffset(parentElement);

    if (foundStart) {
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
    } else {
        range.selectNodeContents(parentElement);
        range.collapse(false);
        selection.removeAllRanges();
        selection.addRange(range);
        console.warn(`Could not set cursor precisely at offset ${offset}. Placed at end.`);
    }
    parentElement.focus();
}

/**
 * Fetches the list of user sessions from the API and displays them in the sidebar.
 */
async function fetchAndDisplaySessions() {
    console.log("[fetchAndDisplaySessions] Function called."); // Log: Start of function

    const sessionListElement = document.getElementById('session-list');
    const chatSessionTitle = document.getElementById('chat-session-title');

    if (!sessionListElement) {
        console.log("[fetchAndDisplaySessions] Session list element (#session-list) not found. Exiting.");
        return;
    }

    console.log("[fetchAndDisplaySessions] Setting loading state.");
    sessionListElement.innerHTML = '<li class="px-3 py-1 text-gray-400 italic text-sm">Loading sessions...</li>';

    try {
        console.log("[fetchAndDisplaySessions] Making fetch request to /api/sessions...");
        const response = await fetch('/api/sessions');
        console.log(`[fetchAndDisplaySessions] Fetch response status: ${response.status}`); // Log: Response status

        if (!response.ok) {
            let errorDetail = `HTTP error ${response.status}`;
            try {
                const errorJson = await response.json();
                errorDetail = errorJson.detail || errorDetail;
            } catch (e) { /* Ignore */ }
            console.error(`[fetchAndDisplaySessions] Error fetching sessions: ${errorDetail}`);
            sessionListElement.innerHTML = `<li class="px-3 py-1 text-red-400 italic text-sm">Error loading sessions</li>`;
            return;
        }

        const sessions = await response.json();
        console.log("[fetchAndDisplaySessions] Received sessions:", sessions); // Log: The received data

        sessionListElement.innerHTML = ''; // Clear loading/error

        if (sessions.length === 0) {
            console.log("[fetchAndDisplaySessions] No sessions found. Displaying message.");
            sessionListElement.innerHTML = '<li class="px-3 py-1 text-gray-400 italic text-sm">No sessions yet</li>';
        } else {
            console.log(`[fetchAndDisplaySessions] Processing ${sessions.length} sessions...`);
            const activeSessionId = getSessionIdFromPath(); // Assumes getSessionIdFromPath() exists and works
            console.log(`[fetchAndDisplaySessions] Current active session ID from path: ${activeSessionId}`);

            sessions.forEach((session, index) => {
                // console.log(`[fetchAndDisplaySessions] Adding session ${index + 1}: ID=${session.id}, Name=${session.name}`); // Optional: Log each session
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = `/chat/${session.id}`;
                a.classList.add('block', 'px-3', 'py-2', 'rounded-md', 'text-sm', 'text-gray-300', 'hover:bg-gray-700', 'hover:text-white', 'truncate');

                if (session.id === activeSessionId) {
                    // console.log(`[fetchAndDisplaySessions] Highlighting active session: ${session.id}`);
                    a.classList.add('bg-gray-900', 'text-white');
                    a.setAttribute('aria-current', 'page');
                    if (chatSessionTitle) {
                        chatSessionTitle.textContent = session.name || `Chat Session ${session.id.substring(0, 4)}`;
                    }
                }

                a.textContent = session.name || `Session ${session.id.substring(0, 8)}`;
                a.title = session.name || `Session ${session.id}`;

                // Placeholder for Rename/Delete buttons
                // const iconsSpan = document.createElement('span');
                // iconsSpan.innerHTML = `...`;
                // a.appendChild(iconsSpan);

                li.appendChild(a);
                sessionListElement.appendChild(li);
            });
            console.log("[fetchAndDisplaySessions] Finished processing sessions.");
        }

    } catch (error) {
        console.error("[fetchAndDisplaySessions] Failed to fetch or display sessions:", error);
        sessionListElement.innerHTML = `<li class="px-3 py-1 text-red-400 italic text-sm">Error loading sessions</li>`;
    }
}

function addUserMessage(text) {
    const messageElement = document.createElement('div');
    messageElement.classList.add('message', 'user-message');
    messageElement.textContent = text;
    chatHistory.appendChild(messageElement);
    setTimeout(() => scrollToBottom('smooth'), 50);
}

function addSystemMessage(text) {
   const messageElement = document.createElement('div');
   messageElement.classList.add('system-message');
   messageElement.textContent = text;
   chatHistory.appendChild(messageElement);
   setTimeout(() => scrollToBottom('smooth'), 50);
}

function addErrorMessage(text) {
   console.error("[UI ERROR] ", text);
   const messageElement = document.createElement('div');
   messageElement.classList.add('error-message');
   messageElement.textContent = `Error: ${text}`;
   if(currentAiTurnContainer) {
       const target = currentAnswerElement || currentCodeBlocksArea || currentAiTurnContainer;
       target.appendChild(messageElement);
   } else { chatHistory.appendChild(messageElement); }
   setTimeout(() => scrollToBottom('smooth'), 50);
}

function setInputDisabledState(disabled) {
    messageInput.disabled = disabled;
    sendButton.disabled = disabled;
    if (thinkCheckbox) {
        thinkCheckbox.disabled = disabled;
    }
}

function setupNewAiTurn() {
    currentTurnId++;
    codeBlockCounterThisTurn = 0;
    accumulatedAnswerText = '';
    lastAppendedNode = null;
    thinkBuffer = '';
    hasThinkingContentArrivedThisTurn = false;
    firstAnswerTokenReceived = false;

    currentAiTurnContainer = null;
    currentThinkingArea = null;
    currentThinkingPreElement = null;
    currentAnswerElement = null;
    currentCodeBlocksArea = null;

    console.log(`[setupNewAiTurn] Starting setup for Turn ID: ${currentTurnId}. thinkingRequestedForCurrentTurn is: ${thinkingRequestedForCurrentTurn}`);

    currentAiTurnContainer = document.createElement('div');
    currentAiTurnContainer.classList.add('ai-turn-container');
    currentAiTurnContainer.dataset.turnId = currentTurnId;

    currentThinkingArea = document.createElement('div');
    currentThinkingArea.classList.add('thinking-area');
    currentThinkingArea.dataset.turnId = currentTurnId;

    if (!thinkingRequestedForCurrentTurn) {
        console.log("[setupNewAiTurn] Setting thinking area style to display:none because thinkingRequested=false.");
        currentThinkingArea.style.display = 'none';
    } else {
        console.log("[setupNewAiTurn] NOT hiding thinking area initially because thinkingRequested=true.");
    }

    const details = document.createElement('details');
    details.id = `thinking-details-${currentTurnId}`;
    const summary = document.createElement('summary');
    summary.classList.add('thinking-summary');
    const summaryTextSpan = document.createElement('span');
    summaryTextSpan.classList.add('text');
    summaryTextSpan.textContent = 'Show Thinking';
    const summaryDotsSpan = document.createElement('span');
    summaryDotsSpan.classList.add('dots');
    summary.appendChild(summaryTextSpan);
    summary.appendChild(summaryDotsSpan);
    currentThinkingPreElement = document.createElement('pre');
    details.appendChild(summary);
    details.appendChild(currentThinkingPreElement);
    currentThinkingArea.appendChild(details);
    currentAiTurnContainer.appendChild(currentThinkingArea);

    details.addEventListener('toggle', (event) => {
        const textSpan = event.target.querySelector('.thinking-summary .text');
        if (!textSpan) return;
        textSpan.textContent = event.target.open ? 'Hide Thinking' : 'Show Thinking';
    });

    currentAnswerElement = document.createElement('div');
    currentAnswerElement.classList.add('message', 'ai-message');

    if (thinkingRequestedForCurrentTurn) {
        console.log("[setupNewAiTurn] Hiding answer bubble initially because thinkingRequested=true.");
        currentAnswerElement.style.display = 'none';
    } else {
        console.log("[setupNewAiTurn] Showing answer bubble immediately with loading dots because thinkingRequested=false.");
         const loadingSpan = document.createElement('span');
         loadingSpan.classList.add('loading-dots');
         currentAnswerElement.appendChild(loadingSpan);
    }
    currentAiTurnContainer.appendChild(currentAnswerElement);

    currentCodeBlocksArea = document.createElement('div');
    currentCodeBlocksArea.classList.add('code-blocks-area');
    currentAiTurnContainer.appendChild(currentCodeBlocksArea);

    chatHistory.appendChild(currentAiTurnContainer);

    console.log(`[setupNewAiTurn] Finished setup for Turn ID: ${currentTurnId}.`);
}

function appendRawTextToThinkingArea(text) {
    if (text && text.trim().length > 0) {
        // console.log(`[appendRawTextToThinkingArea] Received non-empty raw think text: "${text}" (length: ${text?.length})`);
    } else if (text !== null) {
        // console.log(`[appendRawTextToThinkingArea] Received empty or whitespace raw think text (length: ${text?.length})`);
    }

    // console.log(`[appendRawTextToThinkingArea] Checking condition: !thinkingRequestedForCurrentTurn is ${!thinkingRequestedForCurrentTurn} (value: ${thinkingRequestedForCurrentTurn})`);
    if (!thinkingRequestedForCurrentTurn) {
        // console.log("[appendRawTextToThinkingArea] Condition met (!thinkingRequested). Returning early. Should NOT display thinking.");
        return;
    }

    // console.log("[appendRawTextToThinkingArea] Proceeding because thinking was requested.");

    if (!currentThinkingArea || !currentThinkingPreElement || text.length === 0) {
        return;
    }

    if (!hasThinkingContentArrivedThisTurn) {
        if (currentThinkingArea.style.display === 'none') {
            // console.log("[appendRawTextToThinkingArea] First think chunk (and requested). Making area visible NOW. Display style was: " + currentThinkingArea.style.display);
            currentThinkingArea.style.display = '';
        }
        hasThinkingContentArrivedThisTurn = true;
    }

    try {
        currentThinkingPreElement.appendChild(document.createTextNode(text));
    } catch (appendError) {
         console.error("[appendRawTextToThinkingArea] Error appending text node:", appendError, "Pre Element:", currentThinkingPreElement, "Text:", text);
        return;
    }

    const detailsElement = currentThinkingPreElement.closest('details');
    if (detailsElement && detailsElement.open) {
         const isNearBottom = currentThinkingPreElement.scrollHeight - currentThinkingPreElement.scrollTop - currentThinkingPreElement.clientHeight < 50;
         if(isNearBottom) {
             requestAnimationFrame(() => { currentThinkingPreElement.scrollTop = currentThinkingPreElement.scrollHeight; });
         }
    }
}

function appendCodeReference() {
    if (!currentAnswerElement) {
        console.error("Attempted to append code reference to null answer bubble!");
        return;
    }
    if (codeBlockCounterThisTurn > 0) {
         const refSpan = document.createElement('span');
         refSpan.classList.add('code-reference');
         refSpan.textContent = `[Code ${codeBlockCounterThisTurn}]`;
         currentAnswerElement.appendChild(refSpan);
         lastAppendedNode = refSpan;
    } else {
        console.warn("appendCodeReference called but codeBlockCounterThisTurn is 0.");
    }
}

function formatAnswerBubbleFinal() {
    if (!currentAnswerElement) {
        console.warn("[DEBUG] Skipping final formatting: currentAnswerElement is null.");
        accumulatedAnswerText = ''; lastAppendedNode = null; firstAnswerTokenReceived = false; return;
    }

     if (currentAnswerElement.style.display === 'none' && (currentAnswerElement.hasChildNodes() || accumulatedAnswerText.trim().length > 0)) {
         console.warn("[formatAnswerBubbleFinal] Answer bubble was hidden but contained content. Making visible.");
         currentAnswerElement.style.display = '';
          const loadingDots = currentAnswerElement.querySelector('.loading-dots');
          if (loadingDots) loadingDots.remove();
     }

    const hasVisualContent = currentAnswerElement.hasChildNodes() && !currentAnswerElement.querySelector('.loading-dots');
    const hasAccumulatedContent = accumulatedAnswerText.trim().length > 0;

    if (!hasVisualContent && !hasAccumulatedContent) {
        console.log("[DEBUG] Skipping final formatting: No actual content found.");
         const loadingDots = currentAnswerElement.querySelector('.loading-dots');
         if (loadingDots) loadingDots.remove();
        accumulatedAnswerText = '';
        lastAppendedNode = null;
        return;
    }

    // console.log(`[DEBUG formatAnswerBubbleFinal] Proceeding. Has Visual: ${hasVisualContent}, Has Accumulated: ${hasAccumulatedContent}`);

    try {
        const storedKatexNodes = {};
        let placeholderIndex = 0;
        let textForMarkdown = accumulatedAnswerText;

        const katexSpans = Array.from(currentAnswerElement.children).filter(el => el.matches(`span[${KATEX_RENDERED_ATTR}="true"]`));

        if (katexSpans.length > 0) {
             katexSpans.forEach((el) => {
                 if (!el.parentNode) return;
                 const placeholder = `${KATEX_PLACEHOLDER_PREFIX}${placeholderIndex++}`;
                 storedKatexNodes[placeholder] = el.cloneNode(true);
                 try {
                     el.parentNode.replaceChild(document.createTextNode(placeholder), el);
                 } catch (replaceError) {
                     console.error(`[DEBUG] Error replacing KaTeX node with placeholder ${placeholder}:`, replaceError, "Node:", el);
                     try { el.parentNode.removeChild(el); } catch(removeError) { console.error("Failed to remove problematic KaTeX node:", removeError); }
                 }
             });
             textForMarkdown = currentAnswerElement.innerHTML;
        } else {
             if (hasVisualContent && hasAccumulatedContent) {
                 // console.log("[DEBUG formatAnswerBubbleFinal] No KaTeX found, clearing visual DOM and using accumulated text for Markdown.");
                 currentAnswerElement.innerHTML = '';
             } else if (!hasAccumulatedContent && hasVisualContent) {
                 // console.log("[DEBUG formatAnswerBubbleFinal] No KaTeX found, using existing innerHTML for Markdown.");
                 textForMarkdown = currentAnswerElement.innerHTML;
             }
        }

         if (textForMarkdown.trim().length === 0) {
            // console.log("[DEBUG formatAnswerBubbleFinal] textForMarkdown is empty, skipping marked parse.");
         } else {
             const markdownHtml = marked.parse(textForMarkdown, {
                 mangle: false, headerIds: false, gfm: true, breaks: true, sanitize: false
             });
             currentAnswerElement.innerHTML = markdownHtml;
             lastAppendedNode = null;
         }

         if (Object.keys(storedKatexNodes).length > 0) {
             // console.log("[DEBUG formatAnswerBubbleFinal] Reinserting KaTeX nodes.");
             const walker = document.createTreeWalker(currentAnswerElement, NodeFilter.SHOW_TEXT);
             let node;
             const textNodesContainingPlaceholders = [];
             while (node = walker.nextNode()) {
                 if (node.nodeValue && node.nodeValue.includes(KATEX_PLACEHOLDER_PREFIX)) {
                     textNodesContainingPlaceholders.push(node);
                 }
             }

             textNodesContainingPlaceholders.forEach(textNode => {
                 let currentNodeValue = textNode.nodeValue;
                 let parent = textNode.parentNode;
                 if (!parent) return;
                 let lastNodeInserted = textNode;
                 for (const placeholder in storedKatexNodes) {
                      if (currentNodeValue.includes(placeholder)) {
                           const parts = currentNodeValue.split(placeholder);
                           let firstPart = parts.shift();
                           if (firstPart) {
                               parent.insertBefore(document.createTextNode(firstPart), lastNodeInserted);
                           }
                           const katexNode = storedKatexNodes[placeholder].cloneNode(true);
                           parent.insertBefore(katexNode, lastNodeInserted);
                           currentNodeValue = parts.join(placeholder);
                       }
                 }
                 if (currentNodeValue) {
                     parent.insertBefore(document.createTextNode(currentNodeValue), lastNodeInserted);
                 }
                 parent.removeChild(lastNodeInserted);
             });
         } else {
            // console.log("[DEBUG formatAnswerBubbleFinal] No KaTeX nodes to reinsert.");
         }

    } catch (error) {
        console.error("Error during final Markdown/KaTeX formatting:", error);
        addErrorMessage("Failed to perform final message formatting.");
        if (currentAnswerElement && accumulatedAnswerText.trim().length > 0) {
             console.warn("Attempting fallback to raw accumulated text due to formatting error.");
             currentAnswerElement.textContent = accumulatedAnswerText;
        }
    }
    accumulatedAnswerText = '';
}

function resetStreamingState() {
    // console.log("[DEBUG] Resetting streaming state.");
    currentProcessingMode = MODE_ANSWER;
    langBuffer = ''; currentCodeBlockLang = '';
    currentCodeBlockElement = null; currentCodeBlockPreElement = null;
    katexBuffer = ''; currentKatexMarkerId = null;
    thinkBuffer = ''; tagBuffer = ''; fenceBuffer = ''; // Reset fenceBuffer
    lastAppendedNode = null;
    thinkingRequestedForCurrentTurn = false;
}

function renderAndReplaceKatex(isDisplay, markerId) {

    if (!currentAnswerElement || !markerId || katexBuffer === null || katexBuffer === undefined) {
        console.error("[KaTeX Replace Marker] Error: Invalid state (element, markerId, or buffer). MarkerID:", markerId, "Buffer:", katexBuffer);
        if (markerId && currentAnswerElement) {
             try {
                 const strayMarker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);
                 if (strayMarker?.parentNode) strayMarker.parentNode.removeChild(strayMarker);
             } catch (e) { console.error("Error cleaning stray marker:", e); }
        }
        katexBuffer = '';
        return false;
    }

    const trimmedKatexBuffer = katexBuffer.trim();

    try {
        const stringToRender = trimmedKatexBuffer.length > 0 ? trimmedKatexBuffer : " ";
        const katexHtml = katex.renderToString(stringToRender, {
            displayMode: isDisplay,
            throwOnError: false,
            output: "html",
            strict: false
        });

        if (katexHtml.includes('katex-error') && trimmedKatexBuffer.length > 0) {
            console.warn(`[KaTeX Replace Marker] KaTeX reported a rendering error for buffer: "${trimmedKatexBuffer}". Marker ID: ${markerId}. Raw text will remain.`);
             try {
                 const marker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);
                 if (marker?.parentNode) marker.parentNode.removeChild(marker);
                 else console.warn("Couldn't find marker to clean up after render error.");
             } catch (cleanupError) { console.error("Error during marker cleanup after render error:", cleanupError); }
            katexBuffer = '';
            return false;
        }

        const startMarker = currentAnswerElement.querySelector(`span[data-katex-start-id="${markerId}"]`);

        if (!startMarker) {
            console.error(`[KaTeX Replace Marker] Error: Cannot find start marker span with ID: ${markerId}. Aborting replacement. Content might be inconsistent.`);
            katexBuffer = '';
            return false;
        }

        if (!startMarker.parentNode) {
             console.error(`[KaTeX Replace Marker] Error: Start marker span with ID ${markerId} found but has no parent (already removed?). Aborting.`);
             katexBuffer = '';
             return false;
        }

        const parent = startMarker.parentNode;
        let nodesToRemove = [];
        let currentNode = startMarker.nextSibling;

        while (currentNode) {
            nodesToRemove.push(currentNode);
            if (nodesToRemove.length > 1000) {
                console.error("[KaTeX Replace Marker] Error: Excessive node collection limit reached (1000). Aborting replacement.");
                 try { parent.removeChild(startMarker); } catch(e){}
                 katexBuffer = '';
                 return false;
            }
            currentNode = currentNode.nextSibling;
        }

        const katexSpan = document.createElement('span');
        katexSpan.setAttribute(KATEX_RENDERED_ATTR, 'true');
        katexSpan.innerHTML = katexHtml;

        parent.insertBefore(katexSpan, startMarker);
        parent.removeChild(startMarker);

        nodesToRemove.forEach(node => {
            if (node.parentNode === parent) {
                parent.removeChild(node);
            } else {
                console.warn("[KaTeX Replace Marker] Node parent changed or node removed unexpectedly during collection, skipping removal:", node);
            }
        });

        appendToAnswer(null, katexSpan);
        katexBuffer = '';
        return true;

    } catch (error) {
        console.error("[KaTeX Replace Marker] General error during marker-based replacement:", error);
        try {
            const marker = currentAnswerElement?.querySelector(`span[data-katex-start-id="${markerId}"]`);
            if (marker?.parentNode) marker.parentNode.removeChild(marker);
        } catch (cleanupError) { console.error("Error during marker cleanup after general error:", cleanupError); }
        katexBuffer = '';
        return false;
    }
}

function finalizeTurnOnErrorOrClose() {
    console.log("[DEBUG] finalizeTurnOnErrorOrClose called.");
    if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK && currentCodeBlockElement) {
        console.warn("Stream ended unexpectedly inside code block. Finalizing highlight.");
        try { finalizeCodeBlock(true); } catch (e) { console.error("Prism highlight error on close:", e); }
    }
    if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE ||
        currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY ||
        currentProcessingMode === MODE_MAYBE_START_DISPLAY_KATEX) {
        console.warn("Stream ended unexpectedly inside KaTeX block. Processing raw text.");
        if (currentKatexMarkerId) {
            renderAndReplaceKatex(currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY, currentKatexMarkerId);
            currentKatexMarkerId = null;
        }
    }
     if (currentProcessingMode === MODE_INSIDE_THINK || currentProcessingMode === MODE_MAYBE_END_THINK || currentProcessingMode === MODE_SEEKING_TAG) {
         console.warn("Stream ended unexpectedly inside/seeking Think tags. Finishing think buffer:", thinkBuffer);
         if (currentThinkingArea && currentThinkingArea.style.display !== 'none' && currentThinkingPreElement) {
              appendRawTextToThinkingArea("\n--- (Stream ended unexpectedly during thinking) ---");
         }
     }

    formatAnswerBubbleFinal();
    resetStreamingState();
    setInputDisabledState(true);
}

// --- Code Block Functions ---

function createCodeBlockStructure(language) {
    if (!currentCodeBlocksArea) {
        console.error("Code blocks area is null!");
        return;
    }
    codeBlockCounterThisTurn++;
    const currentCodeNumber = codeBlockCounterThisTurn;
    const blockId = `code-block-turn${currentTurnId}-${currentCodeNumber}`;
    const safeLanguage = (language || '').trim().toLowerCase() || 'plain';

    const langAlias = {
        'python': 'python', 'py': 'python',
        'javascript': 'javascript', 'js': 'javascript',
        'html': 'markup', 'xml': 'markup', 'svg': 'markup',
        'css': 'css',
        'bash': 'bash', 'sh': 'bash', 'shell': 'bash',
        'json': 'json',
        'yaml': 'yaml', 'yml': 'yaml',
        'markdown': 'markdown', 'md': 'markdown',
        'sql': 'sql',
        'java': 'java',
        'c': 'c',
        'cpp': 'cpp', 'c++': 'cpp',
        'csharp': 'csharp', 'cs': 'csharp',
        'go': 'go',
        'rust': 'rust',
        'php': 'php',
        'ruby': 'ruby', 'rb': 'ruby',
        'dockerfile': 'docker', 'docker': 'docker',
        'typescript': 'typescript', 'ts': 'typescript',
        'plaintext': 'plain', 'text': 'plain',
       };
    const prismLang = langAlias[safeLanguage] || safeLanguage;
    const displayLang = safeLanguage;
    currentCodeBlockLang = prismLang; // Store the actual Prism language used

    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;

    const container = document.createElement('div');
    container.classList.add('code-block-container');
    container.id = blockId;
    container.dataset.language = safeLanguage;

    const codeHeader = document.createElement('div');
    codeHeader.classList.add('code-block-header');

    const codeButtonsDiv = document.createElement('div');
    codeButtonsDiv.classList.add('code-block-buttons');

    const runStopBtn = document.createElement('button');
    runStopBtn.classList.add('run-code-btn', 'code-action-btn');
    runStopBtn.dataset.status = 'idle';
    runStopBtn.innerHTML = playIconSvg;
    runStopBtn.title = 'Run Code';

    const toggleCodeBtn = document.createElement('button');
    toggleCodeBtn.classList.add('toggle-code-btn', 'code-action-btn');
    toggleCodeBtn.textContent = 'Hide';
    toggleCodeBtn.title = 'Show/Hide Code';

    const copyCodeBtn = document.createElement('button');
    copyCodeBtn.classList.add('copy-code-btn', 'code-action-btn');
    copyCodeBtn.textContent = 'Copy';
    copyCodeBtn.title = 'Copy Code';

    codeButtonsDiv.appendChild(runStopBtn);
    codeButtonsDiv.appendChild(toggleCodeBtn);
    codeButtonsDiv.appendChild(copyCodeBtn);

    const codeTitle = document.createElement('span');
    codeTitle.classList.add('code-block-title');
    codeTitle.textContent = `Code ${currentCodeNumber} (${displayLang})`;
    codeTitle.style.flexGrow = '1';
    codeTitle.style.textAlign = 'left';

    codeHeader.appendChild(codeButtonsDiv);
    codeHeader.appendChild(codeTitle);

    const preElement = document.createElement('pre');
    preElement.classList.add('manual'); // Keep manual class if needed for other styles
    const codeElement = document.createElement('code');
    // IMPORTANT: Set the class required by PrismJS
    codeElement.className = `language-${prismLang}`;
    codeElement.setAttribute('contenteditable', 'true');
    codeElement.setAttribute('spellcheck', 'false');

    currentCodeBlockPreElement = preElement;
    currentCodeBlockElement = codeElement;

    const outputHeader = document.createElement('div');
    outputHeader.classList.add('code-output-header');
    outputHeader.style.display = 'none';

    const outputButtonsDiv = document.createElement('div');
    outputButtonsDiv.classList.add('code-block-buttons');

    const placeholderSpan = document.createElement('span');
    placeholderSpan.classList.add('output-header-button-placeholder');
    outputButtonsDiv.appendChild(placeholderSpan);

    const toggleOutputBtn = document.createElement('button');
    toggleOutputBtn.classList.add('toggle-output-btn', 'code-action-btn');
    toggleOutputBtn.textContent = 'Hide';
    toggleOutputBtn.title = 'Show/Hide Output';

    const copyOutputBtn = document.createElement('button');
    copyOutputBtn.classList.add('copy-output-btn', 'code-action-btn');
    copyOutputBtn.textContent = 'Copy';
    copyOutputBtn.title = 'Copy Output';

    outputButtonsDiv.appendChild(toggleOutputBtn);
    outputButtonsDiv.appendChild(copyOutputBtn);

    const outputTitle = document.createElement('span');
    outputTitle.classList.add('output-header-title');
    outputTitle.textContent = `Output Code ${currentCodeNumber}`;

    const codeStatusSpan = document.createElement('span');
    codeStatusSpan.classList.add('code-status-span');
    codeStatusSpan.textContent = 'Idle';

    outputHeader.appendChild(outputButtonsDiv);
    outputHeader.appendChild(outputTitle);
    outputHeader.appendChild(codeStatusSpan);

    const outputConsoleDiv = document.createElement('div');
    outputConsoleDiv.classList.add('code-output-console');
    outputConsoleDiv.style.display = 'none';
    const outputPre = document.createElement('pre');
    outputConsoleDiv.appendChild(outputPre);

    preElement.appendChild(codeElement);
    container.appendChild(codeHeader);
    container.appendChild(preElement);
    container.appendChild(outputHeader);
    container.appendChild(outputConsoleDiv);

    toggleCodeBtn.addEventListener('click', () => {
        const isHidden = preElement.classList.toggle('hidden');
        toggleCodeBtn.textContent = isHidden ? 'Show' : 'Hide';
    });

    copyCodeBtn.addEventListener('click', async () => {
         if (!codeElement) return;
        try {
            await navigator.clipboard.writeText(codeElement.textContent || '');
            copyCodeBtn.textContent = 'Copied!';
            copyCodeBtn.classList.add('copied');
            setTimeout(() => { copyCodeBtn.textContent = 'Copy'; copyCodeBtn.classList.remove('copied'); }, 1500);
        } catch (err) {
            console.error('Failed to copy code: ', err);
            copyCodeBtn.textContent = 'Error';
            setTimeout(() => { copyCodeBtn.textContent = 'Copy'; }, 1500);
        }
    });

    runStopBtn.addEventListener('click', handleRunStopCodeClick);

    const debouncedHighlight = debounce(() => {
         // console.log(`Highlighting ${blockId} after edit.`);
        const savedPosition = getCursorPosition(codeElement);
        if (savedPosition === -1) { console.warn("Could not save cursor position or cursor not in element. Highlight may cause cursor jump."); }
        try {
            // Remove existing spans before re-highlighting
            // This is simpler than trying to replace nodes in place
            const currentText = codeElement.textContent;
            codeElement.innerHTML = ''; // Clear spans
            codeElement.textContent = currentText; // Restore text

            Prism.highlightElement(codeElement);
            if (savedPosition !== -1) { setCursorPosition(codeElement, savedPosition); }
        } catch (e) {
            console.error("Error during debounced highlighting:", e);
            if (savedPosition !== -1) { setCursorPosition(codeElement, savedPosition); }
        }
    }, 500);
    codeElement.addEventListener('input', debouncedHighlight);
    codeElement.addEventListener('paste', (e) => { setTimeout(debouncedHighlight, 100); });

    toggleOutputBtn.addEventListener('click', () => {
        const isHidden = outputConsoleDiv.classList.toggle('hidden');
        toggleOutputBtn.textContent = isHidden ? 'Show' : 'Hide';
    });

    copyOutputBtn.addEventListener('click', async () => {
        if (!outputPre) return;
        try {
            await navigator.clipboard.writeText(outputPre.textContent || '');
            copyOutputBtn.textContent = 'Copied!';
            copyOutputBtn.classList.add('copied');
            setTimeout(() => { copyOutputBtn.textContent = 'Copy'; copyOutputBtn.classList.remove('copied'); }, 1500);
        } catch (err) {
            console.error('Failed to copy output: ', err);
            copyOutputBtn.textContent = 'Error';
            setTimeout(() => { copyOutputBtn.textContent = 'Copy'; }, 1500);
        }
    });

    currentCodeBlocksArea.appendChild(container);
    lastAppendedNode = null;
}

async function handleRunStopCodeClick(event) {
    const button = event.currentTarget;
    const container = button.closest('.code-block-container');
    if (!container) return;

    const codeBlockId = container.id;
    const language = container.dataset.language;
    const codeElement = container.querySelector('code');
    const outputHeader = container.querySelector('.code-output-header');
    const outputConsoleDiv = container.querySelector('.code-output-console');
    const outputPre = outputConsoleDiv ? outputConsoleDiv.querySelector('pre') : null;
    const statusSpan = outputHeader ? outputHeader.querySelector('.code-status-span') : null;

    if (!language || !codeElement || !outputHeader || !outputConsoleDiv || !outputPre || !statusSpan) {
        console.error(`Missing elements for code block ${codeBlockId}`);
        addErrorMessage(`Cannot run code block ${codeBlockId}: Internal UI error.`);
        return;
    }

    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;
    const stopIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><rect width="100" height="100" rx="15"/></svg>`;
    const stoppingIconSvg = `<svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: block;"><path d="M12 2V6M12 18V22M6 12H2M22 12H18M19.0711 4.92893L16.2426 7.75736M7.75736 16.2426L4.92893 19.0711M19.0711 19.0711L16.2426 16.2426M7.75736 7.75736L4.92893 4.92893" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;

    const code = codeElement.textContent || '';
    const currentStatus = button.dataset.status;

    if (!websocket || websocket.readyState !== WebSocket.OPEN) {
        console.warn("WebSocket not open. Cannot run/stop code.");
        statusSpan.textContent = 'Error: Disconnected';
        statusSpan.className = 'code-status-span error';
        outputHeader.style.display = 'flex';
        addErrorMessage("Cannot run/stop code: Not connected to server.");
        return;
    }

    if (currentStatus === 'idle') {
        console.log(`Requesting run for block ${codeBlockId} (${language})`);
        button.dataset.status = 'running';
        button.innerHTML = stopIconSvg;
        button.title = 'Stop Execution';

        outputPre.innerHTML = '';
        outputHeader.style.display = 'flex';
        outputConsoleDiv.style.display = 'block';
        outputConsoleDiv.classList.remove('hidden');
        const toggleOutputBtn = outputHeader.querySelector('.toggle-output-btn');
        if (toggleOutputBtn) toggleOutputBtn.textContent = 'Hide';

        statusSpan.textContent = 'Running...';
        statusSpan.className = 'code-status-span running';

        websocket.send(JSON.stringify({
            type: 'run_code',
            payload: { code_block_id: codeBlockId, language: language, code: code }
        }));

    } else if (currentStatus === 'running') {
        console.log(`Requesting stop for block ${codeBlockId}`);
        button.dataset.status = 'stopping';
        button.innerHTML = stoppingIconSvg;
        button.title = 'Stopping...';
        button.disabled = true;

        statusSpan.textContent = 'Stopping...';
        statusSpan.className = 'code-status-span stopping';

        websocket.send(JSON.stringify({
            type: 'stop_code',
            payload: { code_block_id: codeBlockId }
        }));
    } else if (currentStatus === 'stopping') {
        console.log(`Already stopping block ${codeBlockId}`);
    }
}

function addCodeOutput(outputPreElement, streamType, text) {
    if (!outputPreElement || !text) return;

    const span = document.createElement('span');
    span.classList.add(streamType === 'stderr' ? 'stderr-output' : 'stdout-output');
    span.textContent = text;
    outputPreElement.appendChild(span);
    outputPreElement.scrollTop = outputPreElement.scrollHeight;
}

function appendToCodeBlock(text) {
    if (currentCodeBlockElement) {
        currentCodeBlockElement.appendChild(document.createTextNode(text));
        if(currentCodeBlockPreElement && !currentCodeBlockPreElement.classList.contains('hidden')) {
            const isNearCodeBottom = currentCodeBlockPreElement.scrollHeight - currentCodeBlockPreElement.scrollTop - currentCodeBlockPreElement.clientHeight < 50;
            if(isNearCodeBottom) {
                requestAnimationFrame(() => { currentCodeBlockPreElement.scrollTop = currentCodeBlockPreElement.scrollHeight; });
            }
        }
    } else {
        console.error("Attempted to append to null code block element!");
    }
}

function appendToAnswer(text = null, node = null) {
    if (!currentAnswerElement) return;

    let isMeaningfulContent = (text && text.trim().length > 0) ||
                                (node && node.nodeType !== Node.COMMENT_NODE && (!node.textContent || node.textContent.trim().length > 0));

    if (!firstAnswerTokenReceived && isMeaningfulContent) {
        // console.log("[appendToAnswer] First meaningful answer content received.");
        if (currentAnswerElement.style.display === 'none') {
            // console.log("[appendToAnswer] Making answer element visible.");
            currentAnswerElement.style.display = '';
        }
        const loadingDots = currentAnswerElement.querySelector('.loading-dots');
        if (loadingDots) {
            // console.log("[appendToAnswer] Removing loading dots.");
            loadingDots.remove();
        }
        firstAnswerTokenReceived = true;
    }

    if (node) {
        if (!node.classList || !node.classList.contains('loading-dots')) {
             currentAnswerElement.appendChild(node);
             lastAppendedNode = node;
        }
    } else if (text !== null && text.length > 0) {
        accumulatedAnswerText += text;
        if (lastAppendedNode && lastAppendedNode.nodeType === Node.TEXT_NODE && lastAppendedNode.parentNode === currentAnswerElement) {
            lastAppendedNode.nodeValue += text;
        } else {
            const textNode = document.createTextNode(text);
            currentAnswerElement.appendChild(textNode);
            lastAppendedNode = textNode;
        }
    }
}

function finalizeCodeBlock(isTruncated = false) {
    if (currentCodeBlockElement) {
        const blockId = currentCodeBlockElement.closest('.code-block-container')?.id;
        const langClass = currentCodeBlockElement.className; // Get the class name

        // --- Add these detailed logs ---
        console.log(`[finalizeCodeBlock] Attempting highlight on element:`, currentCodeBlockElement);
        console.log(`[finalizeCodeBlock] Element class: ${langClass}`);
        console.log(`[finalizeCodeBlock] Prism.languages.python just before highlight:`, Prism.languages.python);
        // -------------------------------

        try {
            // Ensure normalization before final highlight
            currentCodeBlockElement.normalize();
            // Explicitly call highlightElement
            Prism.highlightElement(currentCodeBlockElement);
            console.log(`[finalizeCodeBlock] Highlighting finished successfully for ${blockId}.`); // Log success
        } catch (e) {
            // Log errors specifically from Prism.highlightElement
            console.error(`Prism highlight error on finalize (lang '${currentCodeBlockLang}'):`, e);
        }
    } else {
         console.warn("[finalizeCodeBlock] Called but currentCodeBlockElement is null.");
    }
    // Reset tracking variables AFTER the block logic
    currentCodeBlockElement = null;
    currentCodeBlockPreElement = null;
    currentCodeBlockLang = '';
}


function resetAllCodeButtonsOnErrorOrClose() {
    console.log("Resetting all code run/stop buttons and statuses due to connection issue.");
    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;

    document.querySelectorAll('.code-block-container').forEach(container => {
        const button = container.querySelector('.run-code-btn');
        const outputHeader = container.querySelector('.code-output-header');
        const statusSpan = outputHeader ? outputHeader.querySelector('.code-status-span') : null;

        if (button && button.dataset.status !== 'idle') {
            button.dataset.status = 'idle';
            button.innerHTML = playIconSvg;
            button.title = 'Run Code';
            button.disabled = false;
        }
        if (statusSpan) {
             if (!statusSpan.classList.contains('idle') && !statusSpan.classList.contains('success')) {
                 if (outputHeader) outputHeader.style.display = 'flex';
                 statusSpan.textContent = 'Error: Disconnected';
                 statusSpan.className = 'code-status-span error';
             }
        }
    });
}

function connectWebSocket() {

    let sessionId = null;
    const pathParts = window.location.pathname.split('/');
    // Example: /chat/ef7a41e6-2ba7-4882-b9bb-91c03edb25ac
    // pathParts would be ["", "chat", "ef7a41e6-2ba7-4882-b9bb-91c03edb25ac"]
    if (pathParts.length >= 3 && pathParts[1] === 'chat') {
        sessionId = pathParts[2]; // This should be the session_id
        if (!sessionId || sessionId.trim() === "") {
             console.error("Session ID extracted from path is empty.");
             sessionId = null; // Treat empty ID as invalid
        }
    }

    if (!sessionId) {
        console.error("Could not extract valid session ID from URL path:", window.location.pathname);
        // Use your existing addErrorMessage function if available
        if (typeof addErrorMessage === 'function') {
             addErrorMessage("Cannot connect to chat: Invalid session ID in URL.");
        } else {
             alert("Cannot connect to chat: Invalid session ID in URL.");
        }
        // Use your existing setInputDisabledState function if available
        if (typeof setInputDisabledState === 'function') {
             setInputDisabledState(true);
        }
        return; // Stop connection attempt
    }
    // --- END: Added logic to get session ID from URL path ---

    // Use your existing global clientId variable
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    // Construct the URL with the extracted sessionId and existing clientId
    const wsUrl = `${wsProtocol}//${window.location.host}/ws/${sessionId}/${clientId}`; // Corrected URL format

    console.log(`[DEBUG] Attempting to connect to WebSocket: ${wsUrl}`);

    const playIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`; // Keep this if used elsewhere, otherwise remove

    try {
        // Use the corrected wsUrl
        const ws = new WebSocket(wsUrl);
        console.log('connectWebSocket: Creating WebSocket object...');

        ws.onopen = (event) => {
            console.log("[DEBUG] WebSocket connection opened. ws object:", ws);
            websocket = ws; // Assign to your global websocket variable

            // Check for your actual helper functions
            if (typeof addSystemMessage !== 'function' || typeof setupNewAiTurn !== 'function' || typeof appendToAnswer !== 'function' || typeof formatAnswerBubbleFinal !== 'function' || typeof resetStreamingState !== 'function' || typeof setInputDisabledState !== 'function') {
                console.error("CRITICAL ERROR: One or more required helper functions are not defined when ws.onopen is called. Check script order.");
                alert("Chat initialization failed. Please refresh the page. (Error: Helpers undefined)");
                if (typeof setInputDisabledState === 'function') setInputDisabledState(true);
                return;
            }

            if (typeof setInputDisabledState === 'function') setInputDisabledState(false);
            if (typeof addSystemMessage === 'function') addSystemMessage("Connected to the chat server.");

            console.log("[DEBUG ws.onopen] Setting up initial AI turn for welcome message.");
            thinkingRequestedForCurrentTurn = false; // Assuming this is a global/accessible variable
            setupNewAiTurn(); // Your existing function
            const welcomeMessage = "Hello! How can I help you today?";
            appendToAnswer(welcomeMessage); // Your existing function
            formatAnswerBubbleFinal(); // Your existing function
            console.log("[DEBUG ws.onopen] Resetting state after welcome message.");
            resetStreamingState(); // Your existing function

            if(messageInput && messageInput.offsetParent !== null) messageInput.focus();
        };

        ws.onmessage = (event) => {
            // This is the full onmessage logic from your provided script
            let isJsonMessage = false;
            let messageData = null;
            try {
                if (typeof event.data === 'string' && event.data.startsWith('{')) {
                    messageData = JSON.parse(event.data);
                    if (messageData && messageData.type && messageData.payload && messageData.payload.code_block_id) {
                        isJsonMessage = true;
                    }
                }
            } catch (e) {
                isJsonMessage = false;
            }

            if (isJsonMessage) {
                // console.log("%c[ws.onmessage] Code Execution JSON received:", "color: blue;", messageData);
                const { type, payload } = messageData;
                const { code_block_id } = payload;
                const container = document.getElementById(code_block_id);

                if (!container) {
                    console.warn(`Received message for unknown code block ID: ${code_block_id}`, payload);
                    return;
                }

                const outputHeader = container.querySelector('.code-output-header');
                const outputConsoleDiv = container.querySelector('.code-output-console');
                const outputPre = outputConsoleDiv ? outputConsoleDiv.querySelector('pre') : null;
                const runStopBtn = container.querySelector('.run-code-btn');
                const statusSpan = outputHeader ? outputHeader.querySelector('.code-status-span') : null;

                if (!outputHeader || !outputPre || !runStopBtn || !statusSpan) {
                        console.error(`Missing elements for code block ${code_block_id}. Cannot process message.`);
                        return;
                }

                switch (type) {
                    case 'code_output':
                        const { stream, data } = payload;
                        if (outputHeader.style.display === 'none') {
                            // console.log(`Showing output header for ${code_block_id} on first output.`);
                            outputHeader.style.display = 'flex';
                        }
                        if (outputConsoleDiv.style.display === 'none') {
                            // console.log(`Showing output console for ${code_block_id} on first output.`);
                            outputConsoleDiv.style.display = 'block';
                            outputConsoleDiv.classList.remove('hidden');
                                const toggleOutputBtn = outputHeader.querySelector('.toggle-output-btn');
                                if (toggleOutputBtn) toggleOutputBtn.textContent = 'Hide';
                        }
                        if (runStopBtn.dataset.status === 'idle'){
                                const stopIconSvg = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><rect width="100" height="100" rx="15"/></svg>`;
                                console.warn(`Received code output for ${code_block_id} while button was idle. Forcing state to running.`);
                                runStopBtn.dataset.status = 'running';
                                runStopBtn.innerHTML = stopIconSvg;
                                runStopBtn.title = 'Stop Execution';
                                runStopBtn.disabled = false;
                                statusSpan.textContent = 'Running...';
                                statusSpan.className = 'code-status-span running';
                        }
                        addCodeOutput(outputPre, stream, data); // Your existing function
                        break;

                    case 'code_finished':
                        if (outputHeader.style.display === 'none') {
                            // console.log(`Showing output header for ${code_block_id} on finish.`);
                            outputHeader.style.display = 'flex';
                        }
                            if (outputConsoleDiv.style.display === 'none') {
                            // console.log(`Showing output console for ${code_block_id} on finish.`);
                            outputConsoleDiv.style.display = 'block';
                            outputConsoleDiv.classList.remove('hidden');
                                const toggleOutputBtn = outputHeader.querySelector('.toggle-output-btn');
                                if (toggleOutputBtn) toggleOutputBtn.textContent = 'Hide';
                        }

                        const { exit_code, error } = payload;
                        let finishMessage = '';
                        let statusClass = '';

                        if (error) {
                            if (error === "Execution stopped by user.") {
                                finishMessage = 'Stopped'; statusClass = 'stopped';
                            } else if (error.startsWith("Execution timed out")) {
                                    finishMessage = 'Timeout'; statusClass = 'error';
                            } else {
                                    finishMessage = `Error (${exit_code !== undefined ? exit_code : 'N/A'})`; statusClass = 'error';
                                    console.error(`Execution error for ${code_block_id}:`, error);
                            }
                        } else {
                            finishMessage = `Finished (Exit: ${exit_code})`;
                            statusClass = exit_code === 0 ? 'success' : 'error';
                        }

                        statusSpan.textContent = finishMessage;
                        statusSpan.className = `code-status-span ${statusClass}`;

                        runStopBtn.dataset.status = 'idle';
                        // Use the playIconSvg defined earlier or redefine it if needed
                        runStopBtn.innerHTML = `<svg viewBox="0 0 100 100" fill="currentColor" width="1em" height="1em" style="display: block;"><polygon points="0,0 100,50 0,100"/></svg>`;
                        runStopBtn.title = 'Run Code';
                        runStopBtn.disabled = false;
                        break;

                    default:
                        console.warn(`Received unknown code execution message type: ${type}`, payload);
                }

            } else {
                // console.log("%c[ws.onmessage] RAW chat data received:", "color: magenta;", event.data);
                let chunk = event.data;
                const currentTurnIdForMsg = currentTurnId; // Assuming currentTurnId is global/accessible

                if (chunk === "<EOS>") {
                    console.log(`%c[ws.onmessage] Turn ${currentTurnIdForMsg}: Received <EOS>. Finalizing turn.`, 'color: green; font-weight: bold;');
                    if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK) { // Assuming these are global/accessible
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received inside code block. Appending fence buffer and finalizing.`);
                        if (fenceBuffer.length > 0) appendToCodeBlock(fenceBuffer); // Assuming these are global/accessible
                        try { finalizeCodeBlock(true); } catch (e) { console.error("Error finalizing code block on EOS:", e); } // Your existing function
                    } else if (currentProcessingMode === MODE_SEEKING_CODE_END_FENCE) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received while seeking end fence. Treating '${fenceBuffer}' as code.`);
                        appendToCodeBlock(fenceBuffer);
                        finalizeCodeBlock(true);
                    } else if (currentProcessingMode === MODE_SEEKING_CODE_LANGUAGE && langBuffer.length > 0) { // Assuming langBuffer is global/accessible
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received while seeking language. Treating '${FENCE + langBuffer}' as text.`);
                        appendToAnswer(FENCE + langBuffer); // Your existing function
                    } else if (currentProcessingMode === MODE_SEEKING_CODE_START_FENCE && fenceBuffer.length > 0) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received while seeking start fence. Treating '${fenceBuffer}' as text.`);
                        appendToAnswer(fenceBuffer);
                    } else if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE || currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY) {
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received inside KaTeX buffer. Attempting render.`);
                        if (currentKatexMarkerId) { renderAndReplaceKatex(currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY, currentKatexMarkerId); currentKatexMarkerId = null; } // Your existing function, assuming currentKatexMarkerId is global/accessible
                    } else if (currentProcessingMode === MODE_INSIDE_THINK || currentProcessingMode === MODE_MAYBE_END_THINK || currentProcessingMode === MODE_SEEKING_TAG) { // Assuming these modes and variables are global/accessible
                        console.warn(`Turn ${currentTurnIdForMsg}: <EOS> received unexpectedly inside/seeking Think tags. Last mode: ${currentProcessingMode}`);
                        if (thinkingRequestedForCurrentTurn && currentThinkingArea && currentThinkingPreElement) { appendRawTextToThinkingArea("\n--- (EOS received mid-think) ---"); } // Your existing function, assuming variables are global/accessible
                    }

                    formatAnswerBubbleFinal(); // Your existing function
                    resetStreamingState(); // Your existing function
                    if (typeof setInputDisabledState === 'function') setInputDisabledState(false);
                    if (messageInput && messageInput.offsetParent !== null) { messageInput.focus(); }
                    setTimeout(() => scrollToBottom('smooth'), 50); // Your existing function
                    return;
                }
                if (chunk.startsWith("<ERROR>")) {
                    const errorMessage = chunk.substring(7);
                    console.error(`[ws.onmessage] Turn ${currentTurnIdForMsg}: Received <ERROR>:`, errorMessage);
                    if (typeof addErrorMessage === 'function') addErrorMessage(errorMessage);
                    finalizeTurnOnErrorOrClose(); // Your existing function
                    resetAllCodeButtonsOnErrorOrClose(); // Your existing function
                    setTimeout(() => scrollToBottom('smooth'), 50);
                    return;
                }

                if (chunk.length === 0) {
                        return;
                }

                if (!currentAiTurnContainer) { // Assuming global/accessible
                    if (chunk.trim().length > 0) {
                        console.warn(`%c[ws.onmessage] Turn ${currentTurnIdForMsg}: First non-empty chat chunk received, but turn container not set up? Forcing setup.`, 'color: red; font-weight: bold;');
                        setupNewAiTurn(); // Your existing function
                    } else {
                        return;
                    }
                }

                // Your existing complex state machine logic to process the chunk
                let currentPos = 0;
                while (currentPos < chunk.length) {
                    const char = chunk[currentPos];
                    let incrementPos = true;
                    let previousMode = currentProcessingMode; // Assuming global/accessible

                    if (char === '\\' && currentPos + 1 < chunk.length) {
                        const nextChar = chunk[currentPos + 1];
                        const escapableChars = '$`*\\<>';
                        if (escapableChars.includes(nextChar)) {
                            if (currentProcessingMode === MODE_INSIDE_THINK) { appendRawTextToThinkingArea(nextChar); }
                            else if (currentProcessingMode === MODE_KATEX_BUFFERING_INLINE || currentProcessingMode === MODE_KATEX_BUFFERING_DISPLAY) { katexBuffer += nextChar; appendToAnswer(nextChar); } // Assuming katexBuffer is global/accessible
                            else if (currentProcessingMode === MODE_INSIDE_CODE_BLOCK) { appendToCodeBlock(nextChar); } // Your existing function
                            else { appendToAnswer(nextChar); } // Your existing function
                            currentPos += 2;
                            incrementPos = false;
                            continue;
                        }
                    }

                    switch (currentProcessingMode) { // Assuming global/accessible
                        case MODE_ANSWER:
                            if (char === FENCE[0]) {
                                if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                katexBuffer = ''; currentKatexMarkerId = null;
                                fenceBuffer = char; // Assuming fenceBuffer is global/accessible
                                currentProcessingMode = MODE_SEEKING_CODE_START_FENCE;
                            } else if (char === '$') {
                                if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                currentProcessingMode = MODE_MAYBE_START_DISPLAY_KATEX;
                            } else if (char === '<') {
                                    if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                tagBuffer = char; // Assuming tagBuffer is global/accessible
                                currentProcessingMode = MODE_SEEKING_TAG;
                            } else {
                                if (previousMode === MODE_MAYBE_START_DISPLAY_KATEX) { appendToAnswer('$'); }
                                appendToAnswer(char);
                            }
                            break;
                        // ... include all your other cases from the state machine ...
                        case MODE_SEEKING_CODE_START_FENCE:
                            if (char === FENCE[fenceBuffer.length]) {
                                fenceBuffer += char;
                                if (fenceBuffer === FENCE) {
                                    fenceBuffer = ''; langBuffer = ''; // Assuming langBuffer is global/accessible
                                    currentProcessingMode = MODE_SEEKING_CODE_LANGUAGE;
                                }
                            } else {
                                appendToAnswer(fenceBuffer);
                                fenceBuffer = '';
                                currentProcessingMode = MODE_ANSWER;
                                incrementPos = false;
                            }
                            break;
                        case MODE_SEEKING_CODE_LANGUAGE:
                                if (char === '\n') {
                                    currentCodeBlockLang = langBuffer.trim(); // Assuming global/accessible
                                    createCodeBlockStructure(currentCodeBlockLang); // Your existing function
                                    appendCodeReference(); // Your existing function
                                    langBuffer = '';
                                    currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                                } else if (langBuffer.length > 50) {
                                    console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: Code language line too long. Treating as text.`);
                                    appendToAnswer(FENCE + langBuffer + char);
                                    langBuffer = ''; fenceBuffer = '';
                                    currentProcessingMode = MODE_ANSWER;
                                } else {
                                    langBuffer += char;
                                }
                                break;
                        case MODE_INSIDE_CODE_BLOCK:
                            if (char === FENCE[0]) {
                                fenceBuffer = char;
                                currentProcessingMode = MODE_SEEKING_CODE_END_FENCE;
                            } else {
                                appendToCodeBlock(char);
                            }
                            break;
                        case MODE_SEEKING_CODE_END_FENCE:
                            if (char === FENCE[fenceBuffer.length]) {
                                fenceBuffer += char;
                                if (fenceBuffer === FENCE) {
                                    finalizeCodeBlock(); // Your existing function
                                    fenceBuffer = '';
                                    currentProcessingMode = MODE_ANSWER;
                                    lastAppendedNode = null; // Assuming global/accessible
                                    if (currentPos + 1 < chunk.length && chunk[currentPos + 1] === '\n') {
                                        currentPos++;
                                        incrementPos = true;
                                    }
                                }
                            } else {
                                appendToCodeBlock(fenceBuffer);
                                fenceBuffer = '';
                                currentProcessingMode = MODE_INSIDE_CODE_BLOCK;
                                incrementPos = false;
                            }
                            break;
                        case MODE_MAYBE_START_DISPLAY_KATEX:
                            if (char === '$') {
                                currentKatexMarkerId = `katex-marker-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
                                const startMarkerDisp = document.createElement('span');
                                startMarkerDisp.setAttribute('data-katex-start-id', currentKatexMarkerId);
                                startMarkerDisp.style.display = 'none';
                                appendToAnswer(null, startMarkerDisp);
                                appendToAnswer('$$');
                                currentProcessingMode = MODE_KATEX_BUFFERING_DISPLAY;
                                katexBuffer = '';
                            } else {
                                currentKatexMarkerId = `katex-marker-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
                                const startMarkerInline = document.createElement('span');
                                startMarkerInline.setAttribute('data-katex-start-id', currentKatexMarkerId);
                                startMarkerInline.style.display = 'none';
                                appendToAnswer(null, startMarkerInline);
                                appendToAnswer('$');
                                appendToAnswer(char);
                                currentProcessingMode = MODE_KATEX_BUFFERING_INLINE;
                                katexBuffer = char;
                            }
                            break;
                        case MODE_KATEX_BUFFERING_INLINE:
                            if (char === '$') {
                                appendToAnswer('$');
                                if (currentKatexMarkerId) { renderAndReplaceKatex(false, currentKatexMarkerId); currentKatexMarkerId = null; }
                                else { console.error(`Attempted end inline KaTeX Turn ${currentTurnIdForMsg} no marker ID!`); }
                                currentProcessingMode = MODE_ANSWER;
                            } else { katexBuffer += char; appendToAnswer(char); }
                            break;
                        case MODE_KATEX_BUFFERING_DISPLAY:
                                if (char === '$' && currentPos + 1 < chunk.length && chunk[currentPos + 1] === '$') {
                                    appendToAnswer('$$');
                                    if (currentKatexMarkerId) { renderAndReplaceKatex(true, currentKatexMarkerId); currentKatexMarkerId = null; }
                                    else { console.error(`Attempted end display KaTeX Turn ${currentTurnIdForMsg} no marker ID!`); }
                                    currentProcessingMode = MODE_ANSWER; currentPos++;
                                } else { katexBuffer += char; appendToAnswer(char); }
                                break;
                        case MODE_SEEKING_TAG:
                            tagBuffer += char;
                            const lowerTag = tagBuffer.toLowerCase();
                            if (lowerTag === THINK_START_TAG) {
                                thinkBuffer = ''; currentProcessingMode = MODE_INSIDE_THINK; tagBuffer = ''; lastAppendedNode = null; // Assuming thinkBuffer is global/accessible
                            } else if (THINK_START_TAG.startsWith(lowerTag)) { /* Keep buffering */ }
                            else {
                                appendToAnswer(tagBuffer); currentProcessingMode = MODE_ANSWER; tagBuffer = ''; incrementPos = false;
                            }
                            if (tagBuffer.length > 20) {
                                    console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: Tag buffer excessive, treating as text: ${tagBuffer}`);
                                    appendToAnswer(tagBuffer); currentProcessingMode = MODE_ANSWER; tagBuffer = ''; incrementPos = false;
                            }
                            break;
                        case MODE_INSIDE_THINK:
                                if (char === '<') {
                                    tagBuffer = char; currentProcessingMode = MODE_MAYBE_END_THINK;
                                } else { appendRawTextToThinkingArea(char); } // Your existing function
                                break;
                        case MODE_MAYBE_END_THINK:
                                tagBuffer += char;
                                const lowerEndTag = tagBuffer.toLowerCase();
                                if (lowerEndTag === THINK_END_TAG) {
                                    thinkBuffer = ''; tagBuffer = ''; currentProcessingMode = MODE_ANSWER; lastAppendedNode = null;
                                } else if (THINK_END_TAG.startsWith(lowerEndTag)) { /* Keep buffering */ }
                                else {
                                    appendRawTextToThinkingArea(tagBuffer);
                                    currentProcessingMode = MODE_INSIDE_THINK; tagBuffer = ''; incrementPos = false;
                                }
                                if (tagBuffer.length > 20) {
                                        console.warn(`[State Machine] Turn ${currentTurnIdForMsg}: End tag buffer excessive, treating as think text: ${tagBuffer}`);
                                        appendRawTextToThinkingArea(tagBuffer); currentProcessingMode = MODE_INSIDE_THINK; tagBuffer = ''; incrementPos = false;
                                }
                                break;
                        default:
                            console.error(`Unknown processing mode: ${currentProcessingMode} in Turn ${currentTurnIdForMsg}`);
                            appendToAnswer(char);
                            currentProcessingMode = MODE_ANSWER;
                    }

                    if (incrementPos) { currentPos++; }
                }
                scrollToBottom(); // Your existing function
            }
        };

        ws.onerror = (event) => {
            // This is the full onerror logic from your provided script
            console.error("WebSocket error observed:", event);
            if (typeof addErrorMessage === 'function') addErrorMessage("WebSocket connection error. Please check the server or try refreshing. See console for details.");
            if (typeof finalizeTurnOnErrorOrClose === 'function') finalizeTurnOnErrorOrClose();
            if (typeof resetAllCodeButtonsOnErrorOrClose === 'function') resetAllCodeButtonsOnErrorOrClose();
            if (typeof setInputDisabledState === 'function') setInputDisabledState(true);
        };

        ws.onclose = (event) => {
            // This is the full onclose logic from your provided script
            console.log("WebSocket connection closed.", event);
            if (typeof addSystemMessage === 'function') addSystemMessage(`Connection closed: ${event.reason || 'Normal closure'} (Code: ${event.code})`);
            if (typeof finalizeTurnOnErrorOrClose === 'function') finalizeTurnOnErrorOrClose();
            if (typeof resetAllCodeButtonsOnErrorOrClose === 'function') resetAllCodeButtonsOnErrorOrClose();
            if (event.code !== 1000 && event.code !== 1005) {
                console.log("Unexpected WebSocket closure. Attempting to reconnect WebSocket in 3 seconds...");
                if (typeof addSystemMessage === 'function') addSystemMessage("Attempting to reconnect...");
                if (typeof setInputDisabledState === 'function') setInputDisabledState(true);
                setTimeout(() => { websocket = null; if (typeof resetStreamingState === 'function') resetStreamingState(); currentAiTurnContainer = null; connectWebSocket(); }, 3000); // Assuming currentAiTurnContainer is global/accessible
            } else { if (typeof setInputDisabledState === 'function') setInputDisabledState(true); }
        };
        // -----------------------------------------------------------------------------------------

        console.log("[DEBUG] WebSocket object created and handlers assigned.");

    } catch (error) {
        console.error("[DEBUG] CRITICAL Error creating WebSocket object:", error);
        if (typeof addErrorMessage === 'function') { addErrorMessage(`WebSocket Creation Error: ${error.message}. Please check server and refresh.`); }
        else { alert(`WebSocket Creation Error: ${error.message}. Please check server and refresh.`); }
        if (typeof setInputDisabledState === 'function') setInputDisabledState(true);
    }
}

// --- Event Listeners & Initialization ---

if (chatForm) {
    chatForm.addEventListener('submit', (event) => {
        event.preventDefault();
        const userMessage = messageInput.value.trim();
        if (!userMessage) { return; }

        if (!websocket || websocket.readyState !== WebSocket.OPEN) {
            console.warn("[Submit] WebSocket not ready or not defined. State:", websocket?.readyState);
            addErrorMessage("Not connected to the server. Please wait or refresh.");
            return;
        }

        try {
            addUserMessage(userMessage);
            thinkingRequestedForCurrentTurn = thinkCheckbox ? thinkCheckbox.checked : false;
            // console.log(`[Submit] Checkbox checked: ${thinkingRequestedForCurrentTurn}.`);

            let messageToSend = userMessage;
            if (!thinkingRequestedForCurrentTurn) {
                messageToSend = NO_THINK_PREFIX + userMessage;
                // console.log(`[Submit] Prepended '${NO_THINK_PREFIX}'. Prepared message: "${messageToSend.substring(0, 100)}..."`);
            } else {
                // console.log(`[Submit] Prepared raw message (thinking requested): "${messageToSend.substring(0, 100)}..."`);
            }

            setupNewAiTurn();
            // console.log(`[Submit] Sending final message to WebSocket: "${messageToSend.substring(0, 100)}..."`);
            websocket.send(messageToSend);
            // console.log("[Submit] websocket.send() call completed.");

            messageInput.value = '';
            setInputDisabledState(true);
            // console.log("[Submit] Input cleared and disabled.");

        } catch (sendError) {
            console.error("[Submit] !!! ERROR during send attempt or post-send steps:", sendError);
            addErrorMessage(`Failed to send message: ${sendError.message}`);
        }
    });
} else {
    console.error("CRITICAL ERROR: Could not find chat form element with ID 'chat-form'. Messages cannot be sent.");
    if (typeof addErrorMessage === 'function') {
        addErrorMessage("Initialization Error: Chat input form not found.");
    } else {
        alert("Initialization Error: Chat input form not found.");
    }
}

// --- Initial Setup ---

// Wait for the HTML document to be fully loaded and parsed
document.addEventListener('DOMContentLoaded', () => {
    console.log("[DOMContentLoaded] Event fired.");

    // Set initial input state
    // Use your existing function if available, otherwise set directly
    if (typeof setInputDisabledState === 'function') {
        setInputDisabledState(true); // Disable input initially
    } else if (document.getElementById('message-input') && document.getElementById('send-button')) {
         document.getElementById('message-input').disabled = true;
         document.getElementById('send-button').disabled = true;
    }


    marked.setOptions({
        gfm: true, breaks: true, sanitize: false, smartLists: true, smartypants: false,
    });

    // Add a small delay (e.g., 150ms) before fetching sessions
    // This gives the browser a moment to process cookies set during login redirect
    setTimeout(() => {
        console.log("[Initial Setup] setTimeout (150ms) callback executing.");

        const listElementCheck = document.getElementById('session-list');
        if (listElementCheck) {
            console.log("[Initial Setup] Found #session-list element. Calling fetchAndDisplaySessions.");
            fetchAndDisplaySessions(); // Call the function to load the sidebar list
        } else {
            console.error("[Initial Setup] CRITICAL: Could not find #session-list element inside DOMContentLoaded/setTimeout!");
        }

        // Connect WebSocket ONLY if we are on a chat page
        // This check can also happen after the delay
        if (getSessionIdFromPath()) { // Assuming getSessionIdFromPath() is defined and works
            console.log("[Initial Setup] On chat page, attempting WebSocket connection.");
            connectWebSocket(); // Call your existing function to connect
        } else {
            console.log("[Initial Setup] Not on a chat page, WebSocket not initialized.");
            // Input should remain disabled (handled by initial setInputDisabledState)
        }
    }, 150); // Increased delay slightly to 150 milliseconds

    console.log("[DOMContentLoaded] Initial script setup scheduled via setTimeout (150ms).");

}); // End of DOMContentLoaded listener

console.log("[Script] End of script file reached. DOMContentLoaded listener attached.");

=== app/static/session-choice.html ===
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Choose Tesseracs Session</title>
    <link rel="stylesheet" href="/dist/input.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        .sidebar-scrollable { overflow-y: auto; scrollbar-width: thin; scrollbar-color: #a0aec0 #edf2f7; }
        .sidebar-scrollable::-webkit-scrollbar { width: 6px; }
        .sidebar-scrollable::-webkit-scrollbar-track { background: #edf2f7; border-radius: 3px; }
        .sidebar-scrollable::-webkit-scrollbar-thumb { background-color: #a0aec0; border-radius: 3px; border: 1px solid #edf2f7; }
    </style>
</head>
<body class="font-sans bg-gray-100 text-gray-800">

    <div class="flex h-screen overflow-hidden">
        <aside id="sidebar-loader-target" class="w-64 bg-gray-800 text-gray-200 flex flex-col overflow-hidden">
            </aside>

        <main id="session-choice-content" class="flex-1 flex flex-col p-6 overflow-y-auto">
            <header class="mb-6">
                <h1 class="text-2xl font-semibold text-gray-800">Choose or Start a Session</h1>
            </header>
            <div class="bg-white p-6 rounded-lg shadow">
                <p class="text-gray-600 mb-4">Select an existing session from the sidebar, or start a new one below.</p>
                <button id="main-new-chat-button"
                        class="w-full flex items-center justify-center px-6 py-3 bg-blue-600 hover:bg-blue-700 rounded-md text-white font-medium transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
                    Start New Chat Session
                </button>
            </div>
            <div class="mt-8">
                <h2 class="text-xl font-semibold text-gray-700 mb-3">About Tesseracs</h2>
                <p class="text-gray-600">Engage in dynamic chat sessions, powered by advanced AI.</p>
            </div>
        </main>
    </div>

    <script type="module">
        // Ensure '/static/js/app-ui.js' is the correct path from your site root to the JS file.
        import { loadSidebarHTML, populateSessionList } from '/static/js/app-ui.js';

        document.addEventListener('DOMContentLoaded', async () => {
            console.log("Session Choice Page: DOMContentLoaded. Attempting to load UI components.");
            
            // Assuming _sidebar.html is in your static folder as per previous corrections.
            // Adjust '/static/_sidebar.html' if its location is different.
            const sidebarLoaded = await loadSidebarHTML('/static/_sidebar.html', 'sidebar-loader-target');
            
            if (sidebarLoaded) {
                // **MODIFIED API ENDPOINT HERE**
                // Now calling '/api/sessions' to get the ordered list of sessions.
                await populateSessionList('/api/sessions', 'session-list', '/chat-session.html');
            } else {
                console.error("Session Choice Page: Sidebar loading failed, session list will not be populated by app-ui.js.");
            }

            const mainNewChatButton = document.getElementById('main-new-chat-button');
            if (mainNewChatButton) {
                mainNewChatButton.addEventListener('click', () => {
                    window.location.href = 'chat-session.html'; // Or handle new session creation more explicitly
                });
            }
        });
    </script>
</body>
</html>

=== app/static/js/app-ui.js ===
// static/js/app-ui.js

export async function loadSidebarHTML(sidebarHtmlPath = '_sidebar.html', targetElementId = 'sidebar-loader-target') {
    const sidebarTarget = document.getElementById(targetElementId);
    if (!sidebarTarget) {
        console.error(`Sidebar target element with ID '${targetElementId}' not found.`);
        return false;
    }
    try {
        const response = await fetch(sidebarHtmlPath);
        if (!response.ok) {
            console.error(`Failed to fetch sidebar HTML from ${sidebarHtmlPath}. Status: ${response.status}`);
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const sidebarHTML = await response.text();
        sidebarTarget.innerHTML = sidebarHTML;
        console.log(`Sidebar HTML successfully loaded from ${sidebarHtmlPath} into #${targetElementId}`);
        return true;
    } catch (error) {
        console.error('Could not load sidebar:', error);
        sidebarTarget.innerHTML = '<p class="p-4 text-red-400">Error loading sidebar content.</p>';
        return false;
    }
}

async function handleDeleteSession(sessionId, sessionName, apiEndpoint, listElementId, chatPageUrl) {
    if (!window.confirm(`Are you sure you want to delete the session "${sessionName}"? This action cannot be undone.`)) {
        return;
    }

    console.log(`Attempting to delete session: ${sessionId}`);
    try {
        const response = await fetch(`/api/sessions/${sessionId}`, { // Assuming DELETE endpoint structure
            method: 'DELETE',
            headers: {
                // Add any necessary headers like Authorization if your API requires them
                // 'Authorization': 'Bearer YOUR_AUTH_TOKEN',
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ detail: "Failed to delete session. Server error." }));
            console.error(`Failed to delete session ${sessionId}. Status: ${response.status}`, errorData);
            alert(`Error deleting session: ${errorData.detail || response.statusText}`);
            return;
        }

        // If DELETE was successful (e.g., 204 No Content or 200 OK with a message)
        console.log(`Session ${sessionId} successfully deleted from server.`);
        // alert(`Session "${sessionName}" deleted.`); // Optional success message

        // Refresh the session list to reflect the deletion
        // Re-call populateSessionList with the original parameters for the current page
        // We need to pass the original apiEndpoint, listElementId, chatPageUrl
        // These would ideally be stored or passed down appropriately.
        // For now, we'll re-call with the parameters passed to handleDeleteSession,
        // which means populateSessionList might need to be callable with the correct original context.
        // This is a simplification; a more robust app might use a state management solution.
        await populateSessionList(apiEndpoint, listElementId, chatPageUrl);

    } catch (error) {
        console.error('Error during delete session request:', error);
        alert('An error occurred while trying to delete the session. Please check the console.');
    }
}

export async function populateSessionList(apiEndpoint = '/api/sessions', listElementId = 'session-list', chatPageUrl = '/chat-session.html') {
    const sessionListElement = document.getElementById(listElementId);
    if (!sessionListElement) {
        console.error(`Session list element with ID '${listElementId}' not found.`);
        return;
    }
    sessionListElement.innerHTML = '<li class="px-3 py-1 text-gray-400 italic text-sm">Loading sessions...</li>';

    try {
        console.log(`Workspaceing sessions from: ${apiEndpoint}`);
        const response = await fetch(apiEndpoint);

        if (!response.ok) {
            const errorText = await response.text();
            console.error(`Failed to fetch sessions from ${apiEndpoint}. Status: ${response.status}. Response: ${errorText}`);
            throw new Error(`HTTP error! status: ${response.status}. Message: ${errorText}`);
        }
        const sessions = await response.json();
        if (!Array.isArray(sessions)) {
            console.error(`Data from ${apiEndpoint} is not an array:`, sessions);
            throw new Error(`Expected an array of sessions from ${apiEndpoint}, but received other type.`);
        }

        if (sessions.length === 0) {
            sessionListElement.innerHTML = '<li class="px-3 py-1 text-gray-400 text-sm">No active sessions found.</li>';
        } else {
            sessionListElement.innerHTML = '';
            sessions.forEach(session => {
                if (!session.id || !session.name) {
                    console.warn('Session object is missing id or name:', session);
                    return;
                }

                const listItem = document.createElement('li');
                // Apply flex to align link and button
                listItem.className = 'flex items-center justify-between pr-2 group'; // Added group for hover effects if needed

                const link = document.createElement('a');
                link.href = `${chatPageUrl}?session_id=${session.id}`;
                // Adjusted classes for better spacing with a button
                link.className = 'block pl-3 pr-1 py-2 text-gray-300 hover:bg-gray-700 hover:text-white rounded-md text-sm truncate flex-grow';
                link.title = `${session.name}${session.last_active ? ' (Last active: ' + session.last_active + ')' : ''}`;
                link.textContent = session.name;

                const deleteButton = document.createElement('button');
                // Using an "X" symbol (times) for the delete button. You can use an SVG icon too.
                deleteButton.innerHTML = '&#x2715;'; // HTML entity for "X" (multiplication sign)
                // Tailwind CSS classes for styling the delete button
                deleteButton.className = 'ml-2 p-1 text-gray-500 hover:text-red-400 focus:outline-none rounded-full hover:bg-gray-700 transition-colors duration-150 ease-in-out text-xs';
                deleteButton.title = `Delete session: ${session.name}`;
                
                // Storing original API endpoint parameters for re-fetch if needed later in handleDeleteSession
                deleteButton.onclick = () => handleDeleteSession(session.id, session.name, apiEndpoint, listElementId, chatPageUrl);

                listItem.appendChild(link);
                listItem.appendChild(deleteButton);
                sessionListElement.appendChild(listItem);
            });
        }
        console.log(`Session list successfully populated from ${apiEndpoint} with ${sessions.length} sessions.`);

    } catch (error) {
        console.error('Error populating session list:', error);
        sessionListElement.innerHTML = `<li class="px-3 py-1 text-red-400 text-sm">Could not load sessions. Error: ${error.message}</li>`;
    }
}

